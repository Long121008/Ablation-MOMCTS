[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (70% average cost, 30% maximum cost) and applies a hybrid local search that combines path reversal (with probability based on segment distance) and adaptive segment swapping (smaller segments with lower probability). It ensures feasibility through fallback mechanisms (3-opt and random segment shuffles) if uniqueness is violated. The method prioritizes diversity and adaptive exploration to navigate the bi-objective TSP landscape efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_scores = [0.7 * (obj[0] + obj[1]) + 0.3 * max(obj[0], obj[1]) for _, obj in archive]\n    base_solution = archive[np.argmax(weighted_scores)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on distance metrics\n    i1, i2 = np.random.choice(n, 2, replace=False)\n    if i1 > i2:\n        i1, i2 = i2, i1\n\n    # Calculate segment distances in both objective spaces\n    def segment_distance(solution, start, end, matrix1, matrix2):\n        d1 = sum(matrix1[solution[i], solution[i+1]] for i in range(start, end))\n        d2 = sum(matrix2[solution[i], solution[i+1]] for i in range(start, end))\n        return d1 + d2\n\n    current_dist = segment_distance(new_solution, i1, i2, distance_matrix_1, distance_matrix_2)\n\n    # Try path reversal with probability based on segment distance\n    if np.random.random() < 0.7 or current_dist > np.mean([segment_distance(new_solution, i, i+1, distance_matrix_1, distance_matrix_2) for i in range(n-1)]):\n        new_solution[i1:i2+1] = new_solution[i1:i2+1][::-1]\n\n    # Adaptive segment swapping\n    if np.random.random() < 0.4:\n        swap_size = min(3, n // 4)\n        pos1, pos2 = np.random.choice(n - swap_size, 2, replace=False)\n        segment1 = new_solution[pos1:pos1+swap_size]\n        segment2 = new_solution[pos2:pos2+swap_size]\n        new_solution[pos1:pos1+swap_size] = segment2\n        new_solution[pos2:pos2+swap_size] = segment1\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Advanced fallback: 3-opt local search\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1]\n        segment3 = new_solution[j+1:k+1]\n        segment4 = new_solution[k+1:]\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Last resort: random shuffle of a segment\n        segment_size = max(2, n // 5)\n        pos = np.random.randint(0, n - segment_size + 1)\n        new_solution[pos:pos+segment_size] = np.random.permutation(new_solution[pos:pos+segment_size])\n\n    return new_solution\n\n",
        "score": [
            -0.9454238497222858,
            0.3994055390357971
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest sum of normalized objectives from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and falls back to a 3-opt move if the primary operation fails, ensuring feasibility through validation checks. The selection prioritizes solutions with high combined objective values, while the local search explores diverse neighborhood structures to escape local optima. The fallback mechanism maintains solution validity when the primary operation would violate constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -float('inf')\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        norm_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        norm_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        total = norm_cost1 + norm_cost2\n        if total > max_sum:\n            max_sum = total\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal with multiple node reinsertion\n    # Select 3 distinct positions\n    i1, i2, i3 = np.random.choice(n, 3, replace=False)\n    i1, i2, i3 = sorted([i1, i2, i3])\n\n    # Break and reverse segments\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:i3+1]\n    segment4 = new_solution[i3+1:]\n\n    # Reinsert nodes in different orders\n    new_solution = np.concatenate([\n        segment1,\n        segment3[::-1],\n        segment2[::-1],\n        segment4\n    ])\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt move if primary operation fails\n        i, j, k = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([i, j, k])\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.0048094662706575,
            1.2336682081222534
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (60% for the first objective, 40% for the second) and applies a hybrid local search: 70% chance of segment relocation (moving a random segment to a new position) and 30% chance of edge swapping (swapping high-cost nodes identified by their edge contributions to both objectives). The selection prioritizes solutions with better combined objective values, while the local search intelligently explores the solution space by targeting high-cost segments or nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Combine edge swapping and segment relocation\n    if np.random.rand() < 0.7:  # 70% chance for segment relocation\n        # Segment relocation\n        start = np.random.randint(0, n)\n        length = np.random.randint(3, min(7, n // 2))\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        if start < end:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        else:\n            new_solution = np.concatenate([new_solution[end:start], new_solution[start:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:\n        # Edge swapping with high-cost nodes\n        # Calculate node costs based on edge contributions\n        node_costs = np.zeros(n)\n        for i in range(n):\n            prev = i - 1\n            next_node = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[prev], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[next_node]]\n            cost2 = distance_matrix_2[new_solution[prev], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[next_node]]\n            node_costs[i] = cost1 + cost2\n\n        # Select high-cost nodes for swapping\n        high_cost_nodes = np.argsort(node_costs)[-min(3, n//2):]\n        i, j = np.random.choice(high_cost_nodes, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9475014135226745,
            0.476529598236084
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search operator that combines partial path reversal with node reinsertion to generate a neighbor. It ensures feasibility by validating the new solution and falling back to a weighted swap or segment shift if needed. The selection prioritizes solutions with lower weighted objective values, while the local search explores diverse neighborhood structures through random segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective values\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weights /= weights.sum()\n    scores = objectives @ weights\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid operator: partial reversal + reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        reinsert_pos = random.randint(0, n-1)\n        if reinsert_pos >= i and reinsert_pos < j:\n            reinsert_pos = (j + random.randint(1, n-1)) % n\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[j:reinsert_pos],\n            segment[::-1],\n            base_solution[reinsert_pos:]\n        ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: weighted edge swap\n        k, l = random.sample(range(n), 2)\n        if random.random() < 0.7:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            # Partial segment shift\n            shift = random.randint(1, min(3, n//2))\n            new_solution[k:k+shift] = np.roll(new_solution[k:k+shift], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7071533583038947,
            0.23351401090621948
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining node relocation and segment rotation, prioritizing larger segments for potential improvements while ensuring feasibility through validation and fallback mechanisms like the double bridge move. It emphasizes randomness in segment selection and rotation while maintaining tour validity through checks and fallback operations. The approach balances exploration (random selection) with exploitation (focus on larger segments) while ensuring all generated solutions are feasible TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (Pareto dominance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Node relocation with distance-based selection\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: double bridge move\n        p, q, r, s = sorted(random.sample(range(n), 4))\n        new_solution = np.concatenate([\n            new_solution[:p], new_solution[q:r+1], new_solution[p:q],\n            new_solution[r+1:s+1], new_solution[r+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.885361404984967,
            0.24587023258209229
        ]
    },
    {
        "algorithm": "The heuristic selects the highest-scoring solution from the archive (sum of both objectives) and applies a hybrid local search that randomly breaks and reverses segments of the tour to explore diverse neighborhoods while ensuring feasibility through validation checks. It prioritizes solutions with combined higher costs to focus improvement efforts and uses a fallback swap if the reinsertion fails. The algorithm balances exploration and exploitation by combining edge manipulation with node reinsertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + node reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct edges to break\n    i1, i2 = np.random.choice(n, 2, replace=False)\n    if i1 > i2:\n        i1, i2 = i2, i1\n\n    # Break the edges and reinsert nodes\n    segment1 = new_solution[:i1+1]\n    segment2 = new_solution[i1+1:i2+1]\n    segment3 = new_solution[i2+1:]\n\n    # Combine segments with nodes reinserted\n    new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reinsertion fails\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9429277113147808,
            0.4586946964263916
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective cost from the archive and applies a hybrid local search operator that randomly relocates a segment of the tour to a new position, ensuring feasibility by maintaining a valid TSP tour structure. The method prioritizes solutions with higher total cost to focus on promising regions of the search space, while the segment relocation strategy introduces diversity by disrupting and reinserting sub-tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine edge insertion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    # Extract the segment\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Remove the segment\n    if start < end:\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        new_solution = np.concatenate([new_solution[end:start], new_solution[start:]])\n\n    # Insert the segment at a new random position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8550530386352858,
            0.4085387587547302
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge insertion and segment reversal, ensuring feasibility by validating the new solution. It prioritizes larger segments for reversal/insertion to maximize improvement potential, with a fallback to simple swaps if needed. The method balances exploration (random selection) with exploitation (targeted segment operations) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge insertion + segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        segment = base_solution[i:j]\n        new_solution = np.concatenate([base_solution[:i], segment[::-1], base_solution[j:]])\n\n    # Segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    if b - a > 1:\n        segment = base_solution[a:b]\n        new_solution = np.concatenate([base_solution[:a], segment[::-1], base_solution[b:]])\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if above fails\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8760701871960721,
            0.44710928201675415
        ]
    },
    {
        "algorithm": "The algorithm selects a knee-point solution from the Pareto front, then applies a hybrid local search alternating between segment reversal, node reinsertion, and edge breaking, dynamically adjusting operator probabilities based on success rates to prioritize effective improvements while ensuring feasibility through validation. The knee-point selection balances objectives, and the adaptive operators focus on high-potential moves, with fallback mechanisms for trade-off exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify Pareto-efficient solutions\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive.copy()\n\n    # Select knee point solution (balance between objectives)\n    def knee_point(pareto_front):\n        knee_idx = 0\n        max_diff = -1\n        for i, (_, obj) in enumerate(pareto_front):\n            diff = abs(obj[0] - obj[1])\n            if diff > max_diff:\n                max_diff = diff\n                knee_idx = i\n        return pareto_front[knee_idx][0]\n\n    base_solution = knee_point(pareto_front).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Initialize operator probabilities\n    operator_probs = {'segment_reversal': 0.5, 'node_reinsertion': 0.3, 'edge_breaking': 0.2}\n    operator_success = {'segment_reversal': 0, 'node_reinsertion': 0, 'edge_breaking': 0}\n\n    # Apply hybrid local search\n    for _ in range(3):  # Limit iterations\n        operator = random.choices(\n            list(operator_probs.keys()),\n            weights=list(operator_probs.values()),\n            k=1\n        )[0]\n\n        if operator == 'segment_reversal':\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                segment = new_solution[a:b]\n                candidate = np.concatenate([new_solution[:a], segment[::-1], new_solution[b:]])\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n                    operator_success['segment_reversal'] += 1\n\n        elif operator == 'node_reinsertion':\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                candidate = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n                    operator_success['node_reinsertion'] += 1\n\n        elif operator == 'edge_breaking':\n            i, j = sorted(random.sample(range(n), 2))\n            if i != j:\n                candidate = np.concatenate([new_solution[:i], new_solution[i+1:], [new_solution[i]]])\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n                    operator_success['edge_breaking'] += 1\n\n    # Update operator probabilities based on success rate\n    total_success = sum(operator_success.values())\n    if total_success > 0:\n        for op in operator_probs:\n            operator_probs[op] = operator_success[op] / total_success\n\n    return new_solution\n\n",
        "score": [
            -0.4134220732037063,
            0.3287290930747986
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined cost from the archive (prioritizing less optimal solutions for improvement) and applies a hybrid local search combining edge exchange (reversing a segment between two random nodes) and node insertion (relocating a node to the best position based on reduced total distance in both objective spaces). The method ensures feasibility by maintaining a valid TSP tour throughout the operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost = -1\n    selected_solution = None\n    for sol, (cost1, cost2) in archive:\n        total_cost = cost1 + cost2\n        if total_cost > max_cost:\n            max_cost = total_cost\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: apply a combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    if i == j:\n        j = (j + 1) % n\n\n    # Reverse the segment between i and j to explore different paths\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (move a random node to a better position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n\n    # Find the best insertion point for the node in both objective spaces\n    best_pos = k\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == k:\n            continue\n\n        # Remove node from current position and insert at pos\n        temp_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        temp_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n\n        new_cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[(pos+1)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[(pos+1)%n]]\n\n        improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9148601407625312,
            1.1084784865379333
        ]
    }
]