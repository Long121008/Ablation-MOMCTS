[
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining adaptive segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility. It prioritizes edges with high combined distance in both objectives for insertion, balancing exploration and exploitation through adaptive segment sizes and randomness. The selection weights and distance-based edge prioritization are key design choices for driving improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on objective values (lower is better)\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Select segment to reverse\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion based on distance metrics\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d\n            if n > 3:\n                candidates = [i for i in range(n) if i not in (c, d)]\n                if candidates:\n                    e = np.random.choice(candidates)\n                    new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9746621176519483,
            0.5717102885246277
        ]
    },
    {
        "algorithm": "This heuristic selects a promising solution from the archive using tournament selection biased toward lower total costs, then applies a hybrid local search combining adaptive segment rotation (with variable segment size and rotation) and probabilistic edge relocation (prioritizing edges with high normalized distance products from both objectives). The method ensures feasibility by maintaining a valid TSP tour throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection with quality bias\n    tournament_size = min(5, len(archive))\n    selected_idx = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_idx[np.argmin([np.sum(archive[i][1]) for i in selected_idx])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Probabilistic edge relocation\n    if n > 3:\n        normalized_distances = (distance_matrix_1 + distance_matrix_2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2))\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(normalized_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        if n > 3:\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                probs = np.array([normalized_distances[new_solution[c]][new_solution[i]] *\n                                normalized_distances[new_solution[i]][new_solution[d]]\n                                for i in candidates])\n                probs = probs / np.sum(probs)\n                e = np.random.choice(candidates, p=probs)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9310379678551315,
            0.2135852575302124
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Weighted selection of promising solutions using a combination of objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    weights = crowding_dist / np.sum(crowding_dist)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 2: Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Step 3: Hybrid local search combining segment reversal and adaptive edge insertion\n    # First perform segment reversal\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform adaptive edge insertion based on high combined distance\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d with probability based on its distance\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                candidate_distances = [distance_matrix_1[new_solution[c]][new_solution[i]] + distance_matrix_2[new_solution[c]][new_solution[i]] for i in candidates]\n                candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n                e = np.random.choice(candidates, p=candidate_weights)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Step 4: Additional local improvement with edge reversal\n    if n > 3:\n        # Select two edges to reverse based on their combined distance\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if len(edges) >= 2:\n            c1, d1 = edges[0][0], edges[0][1]\n            c2, d2 = edges[1][0], edges[1][1]\n\n            # Reverse the segment between the two selected edges\n            if c1 < d1 and c2 > d2:  # Ensure proper segment selection\n                new_solution[c1:d1+1] = new_solution[c1:d1+1][::-1]\n                new_solution[c2:d2+1] = new_solution[c2:d2+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9596813386903245,
            0.29400932788848877
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using fitness-based probability (prioritizing solutions with lower combined objective costs) and applies a hybrid local search combining node shift and segment rotation to generate a neighbor while ensuring feasibility. The fitness scores are computed as the inverse of the sum of objectives, and the selection is probabilistic. The local search randomly shifts a node to a new position and rotates a segment of the tour to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores (inverse of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    fitness_scores = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Small epsilon to avoid division by zero\n    selection_probs = fitness_scores / np.sum(fitness_scores)\n\n    # Select a solution with probability proportional to fitness\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: node shift and segment rotation\n    # Shift a random node to a new position\n    node_to_shift = np.random.randint(0, n)\n    new_position = np.random.randint(0, n)\n    while new_position == node_to_shift:\n        new_position = np.random.randint(0, n)\n\n    shifted_node = new_solution[node_to_shift]\n    new_solution = np.concatenate([\n        new_solution[:node_to_shift],\n        new_solution[node_to_shift+1:new_position+1],\n        [shifted_node],\n        new_solution[new_position+1:]\n    ])\n\n    # Rotate a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    rotation_amount = np.random.randint(1, b - a + 1)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    return new_solution\n\n",
        "score": [
            -0.8194038682995677,
            0.2810159921646118
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted random selection (prioritizing higher-indexed solutions), then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor. It ensures feasibility by maintaining a valid TSP tour while exploring diverse modifications. The selection bias and randomness in segment/edge choices drive exploration, while the hybrid operator balances structure and perturbation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert\n    if n > 3:\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        while c == d or (c == a and d == b):\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8740335775470593,
            0.49903690814971924
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using weighted random selection (prioritizing lower-cost solutions) and applies a hybrid local search combining segment reversal, edge insertion, and conditional node swapping (only if beneficial for both objectives). It ensures feasibility by validating the solution and falling back to segment reversal if duplicates occur. The method balances exploration (via random operations) and exploitation (via cost-aware swaps) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on combined objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (objectives + 1e-6)  # Inverse of combined cost\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + edge insertion + node swapping\n    if n > 3:\n        # Segment reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge insertion\n        if n > 4:\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            while c == d or (c == a and d == b):\n                c, d = sorted(np.random.choice(n, 2, replace=False))\n            new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n        # Node swapping (if beneficial)\n        if np.random.random() < 0.3:  # Lower probability to balance exploration\n            k, l = np.random.choice(n, 2, replace=False)\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n            # Calculate cost before and after swap\n            def calculate_cost(sol, dist_mat):\n                total = 0\n                for idx in range(len(sol)):\n                    total += dist_mat[sol[idx-1], sol[idx]]\n                return total\n\n            cost_before = calculate_cost(new_solution, distance_matrix_1) + calculate_cost(new_solution, distance_matrix_2)\n            cost_after = calculate_cost(temp_solution, distance_matrix_1) + calculate_cost(temp_solution, distance_matrix_2)\n\n            if cost_after < cost_before:\n                new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if duplicates exist\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8917089614433672,
            0.5027415752410889
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (prioritizing Pareto-optimal candidates) and applies a two-phase local search: first identifying high-quality segments (shortest in both objectives) and then reinserting them at random positions while ensuring feasibility through duplicate removal. If this fails, it defaults to a simple random swap. The method balances exploitation of good structures with controlled diversification while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with non-dominated objectives\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Identify high-quality segments\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+2, min(i+10, n)):  # Limit segment length for efficiency\n            # Calculate segment quality based on both objectives\n            segment_length1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length1 += distance_matrix_1[new_solution[j], new_solution[i]] if j+1 < n else 0\n            segment_length2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length2 += distance_matrix_2[new_solution[j], new_solution[i]] if j+1 < n else 0\n            score = - (segment_length1 + segment_length2)  # Higher score for shorter segments\n            segment_scores.append((score, i, j))\n\n    if segment_scores:\n        segment_scores.sort(reverse=True)\n        _, best_i, best_j = segment_scores[0]\n        best_segment = new_solution[best_i:best_j+1]\n\n        # Phase 2: Reintegrate segment with dynamic boundary adjustment\n        new_pos = random.randint(0, n - len(best_segment))\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            best_segment,\n            new_solution[new_pos:new_pos + len(best_segment)],\n            new_solution[new_pos + len(best_segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = [node for node in range(n) if node not in unique_nodes]\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Final check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if all else fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9494995633810055,
            3.6105303168296814
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-dominance-based weighted selection, then applies a hybrid local search combining adaptive segment rotation and cost-aware edge insertion to generate a neighbor solution while ensuring feasibility through checks and fallback mechanisms. It prioritizes non-dominated solutions with lower combined costs and focuses on improving high-cost edges in both objective spaces. The method balances exploration (via exponential segment size) and exploitation (via cost-aware edge selection) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance-based weighted selection\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n    weights = np.zeros(n_solutions)\n\n    for i in range(n_solutions):\n        dominated = False\n        for j in range(n_solutions):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            weights[i] = 1.0 / (1.0 + np.sum(objectives[i]))\n\n    if np.sum(weights) == 0:\n        weights = np.ones(n_solutions) / n_solutions\n    else:\n        weights /= np.sum(weights)\n\n    selected_idx = np.random.choice(n_solutions, p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: adaptive segment rotation and cost-aware edge insertion\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=3))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation_amount = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a node that improves both objectives\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                best_candidate = None\n                min_cost = float('inf')\n\n                for e in candidates:\n                    temp_solution = np.concatenate([\n                        new_solution[:c+1],\n                        new_solution[e:e+1],\n                        new_solution[c+1:]\n                    ])\n\n                    def calculate_cost(sol, dist_mat):\n                        total = 0\n                        for idx in range(len(sol)):\n                            total += dist_mat[sol[idx-1], sol[idx]]\n                        return total\n\n                    cost1 = calculate_cost(temp_solution, distance_matrix_1)\n                    cost2 = calculate_cost(temp_solution, distance_matrix_2)\n                    total_cost = cost1 + cost2\n\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_candidate = e\n\n                if best_candidate is not None:\n                    new_solution = np.concatenate([\n                        new_solution[:c+1],\n                        new_solution[best_candidate:best_candidate+1],\n                        new_solution[c+1:]\n                    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8997583200364865,
            2.6796183586120605
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection based on objective values (prioritizing better solutions), then applies a hybrid local search combining adaptive segment reversal and edge insertion. The segment size is dynamically determined based on solution quality and instance size, while edge insertion prioritizes high-distance edges in both objectives, ensuring feasibility by maintaining valid TSP tours throughout. The method balances exploration and exploitation through probabilistic operations and distance-based prioritization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on objective values (lower is better)\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on solution quality and instance size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n\n    # Select segment to reverse\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion based on distance metrics with adaptive selection\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d with probability based on edge distance\n            if n > 3 and np.random.random() < 0.7:\n                candidates = [i for i in range(n) if i not in (c, d)]\n                if candidates:\n                    # Select node with highest potential improvement\n                    candidate_scores = []\n                    for e in candidates:\n                        u = new_solution[c]\n                        v = new_solution[e]\n                        w = new_solution[d]\n                        improvement = (distance_matrix_1[u][v] + distance_matrix_1[v][w] - distance_matrix_1[u][w]) + \\\n                                    (distance_matrix_2[u][v] + distance_matrix_2[v][w] - distance_matrix_2[u][w])\n                        candidate_scores.append(improvement)\n\n                    best_candidate = candidates[np.argmax(candidate_scores)]\n                    new_solution = np.concatenate([new_solution[:c+1], new_solution[best_candidate:best_candidate+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7954168051312039,
            0.36960649490356445
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive solution selection with a hybrid local search strategy that alternates between segment-based reinsertion and edge-based reversal, dynamically adjusting perturbation intensity based on solution quality and problem characteristics while ensuring feasibility. It prioritizes solutions with lower combined normalized objectives and applies perturbations with segment sizes and reversal ranges determined by probabilistic distributions, balancing exploration and exploitation. The approach avoids standard 2-opt by using multi-phase perturbations with deterministic adjustments for higher-quality multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1.0 / (1.0 + np.sum(normalized_obj, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 2: Dynamic segment-based reinsertion\n    segment_size = max(2, min(n // 3, int(np.random.normal(loc=n//4, scale=n//6))))\n    a = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[a:a+segment_size]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Edge-based reversal with dynamic range\n    reversal_range = max(2, min(n // 2, int(np.random.exponential(scale=n//3))))\n    c = np.random.randint(0, n - reversal_range + 1)\n    d = c + reversal_range - 1\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.825258031508011,
            0.574952244758606
        ]
    }
]