[
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining adaptive segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility. It prioritizes edges with high combined distance in both objectives for insertion, balancing exploration and exploitation through adaptive segment sizes and randomness. The selection weights and distance-based edge prioritization are key design choices for driving improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on objective values (lower is better)\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Select segment to reverse\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion based on distance metrics\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d\n            if n > 3:\n                candidates = [i for i in range(n) if i not in (c, d)]\n                if candidates:\n                    e = np.random.choice(candidates)\n                    new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9746621176519483,
            0.5717102885246277
        ]
    },
    {
        "algorithm": "This heuristic selects a promising solution from the archive using tournament selection biased toward lower total costs, then applies a hybrid local search combining adaptive segment rotation (with variable segment size and rotation) and probabilistic edge relocation (prioritizing edges with high normalized distance products from both objectives). The method ensures feasibility by maintaining a valid TSP tour throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection with quality bias\n    tournament_size = min(5, len(archive))\n    selected_idx = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_idx[np.argmin([np.sum(archive[i][1]) for i in selected_idx])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Probabilistic edge relocation\n    if n > 3:\n        normalized_distances = (distance_matrix_1 + distance_matrix_2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2))\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(normalized_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        if n > 3:\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                probs = np.array([normalized_distances[new_solution[c]][new_solution[i]] *\n                                normalized_distances[new_solution[i]][new_solution[d]]\n                                for i in candidates])\n                probs = probs / np.sum(probs)\n                e = np.random.choice(candidates, p=probs)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9310379678551315,
            0.2135852575302124
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Weighted selection of promising solutions using a combination of objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    weights = crowding_dist / np.sum(crowding_dist)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 2: Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Step 3: Hybrid local search combining segment reversal and adaptive edge insertion\n    # First perform segment reversal\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform adaptive edge insertion based on high combined distance\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d with probability based on its distance\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                candidate_distances = [distance_matrix_1[new_solution[c]][new_solution[i]] + distance_matrix_2[new_solution[c]][new_solution[i]] for i in candidates]\n                candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n                e = np.random.choice(candidates, p=candidate_weights)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Step 4: Additional local improvement with edge reversal\n    if n > 3:\n        # Select two edges to reverse based on their combined distance\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if len(edges) >= 2:\n            c1, d1 = edges[0][0], edges[0][1]\n            c2, d2 = edges[1][0], edges[1][1]\n\n            # Reverse the segment between the two selected edges\n            if c1 < d1 and c2 > d2:  # Ensure proper segment selection\n                new_solution[c1:d1+1] = new_solution[c1:d1+1][::-1]\n                new_solution[c2:d2+1] = new_solution[c2:d2+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9596813386903245,
            0.29400932788848877
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive using weighted randomness based on normalized objectives and crowding distance, then applies a hybrid local search combining adaptive segment rotation, probabilistic edge insertion, and conditional edge reversal to generate a neighbor solution while ensuring feasibility. The algorithm prioritizes segments with high combined distance in edge reversal and adaptively adjusts segment sizes for rotation, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    weights = crowding_dist / np.sum(crowding_dist)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Probabilistic edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_weights = np.array([combined_distances[new_solution[c]][new_solution[i]] for i in candidates])\n            candidate_weights = candidate_weights / np.sum(candidate_weights)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional edge reversal\n    if n > 3:\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if len(edges) >= 2:\n            c1, d1 = edges[0][0], edges[0][1]\n            c2, d2 = edges[1][0], edges[1][1]\n\n            if c1 < d1 and c2 > d2:\n                # Reverse segments if it improves at least one objective\n                original_cost1 = distance_matrix_1[new_solution[c1]][new_solution[d1]] + distance_matrix_1[new_solution[c2]][new_solution[d2]]\n                original_cost2 = distance_matrix_2[new_solution[c1]][new_solution[d1]] + distance_matrix_2[new_solution[c2]][new_solution[d2]]\n\n                temp_solution = new_solution.copy()\n                temp_solution[c1:d1+1] = temp_solution[c1:d1+1][::-1]\n                temp_solution[c2:d2+1] = temp_solution[c2:d2+1][::-1]\n\n                new_cost1 = distance_matrix_1[temp_solution[c1]][temp_solution[d1]] + distance_matrix_1[temp_solution[c2]][temp_solution[d2]]\n                new_cost2 = distance_matrix_2[temp_solution[c1]][temp_solution[d1]] + distance_matrix_2[temp_solution[c2]][temp_solution[d2]]\n\n                if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n                   (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.911450101760233,
            0.2679750919342041
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (prioritizing Pareto-optimal candidates) and applies a two-phase local search: first identifying high-quality segments (shortest in both objectives) and then reinserting them at random positions while ensuring feasibility through duplicate removal. If this fails, it defaults to a simple random swap. The method balances exploitation of good structures with controlled diversification while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with non-dominated objectives\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Identify high-quality segments\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+2, min(i+10, n)):  # Limit segment length for efficiency\n            # Calculate segment quality based on both objectives\n            segment_length1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length1 += distance_matrix_1[new_solution[j], new_solution[i]] if j+1 < n else 0\n            segment_length2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length2 += distance_matrix_2[new_solution[j], new_solution[i]] if j+1 < n else 0\n            score = - (segment_length1 + segment_length2)  # Higher score for shorter segments\n            segment_scores.append((score, i, j))\n\n    if segment_scores:\n        segment_scores.sort(reverse=True)\n        _, best_i, best_j = segment_scores[0]\n        best_segment = new_solution[best_i:best_j+1]\n\n        # Phase 2: Reintegrate segment with dynamic boundary adjustment\n        new_pos = random.randint(0, n - len(best_segment))\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            best_segment,\n            new_solution[new_pos:new_pos + len(best_segment)],\n            new_solution[new_pos + len(best_segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = [node for node in range(n) if node not in unique_nodes]\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Final check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if all else fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9494995633810055,
            3.6105303168296814
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-dominance-based weighted selection, then applies a hybrid local search combining adaptive segment rotation and cost-aware edge insertion to generate a neighbor solution while ensuring feasibility through checks and fallback mechanisms. It prioritizes non-dominated solutions with lower combined costs and focuses on improving high-cost edges in both objective spaces. The method balances exploration (via exponential segment size) and exploitation (via cost-aware edge selection) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance-based weighted selection\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n    weights = np.zeros(n_solutions)\n\n    for i in range(n_solutions):\n        dominated = False\n        for j in range(n_solutions):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            weights[i] = 1.0 / (1.0 + np.sum(objectives[i]))\n\n    if np.sum(weights) == 0:\n        weights = np.ones(n_solutions) / n_solutions\n    else:\n        weights /= np.sum(weights)\n\n    selected_idx = np.random.choice(n_solutions, p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: adaptive segment rotation and cost-aware edge insertion\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=3))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation_amount = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a node that improves both objectives\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                best_candidate = None\n                min_cost = float('inf')\n\n                for e in candidates:\n                    temp_solution = np.concatenate([\n                        new_solution[:c+1],\n                        new_solution[e:e+1],\n                        new_solution[c+1:]\n                    ])\n\n                    def calculate_cost(sol, dist_mat):\n                        total = 0\n                        for idx in range(len(sol)):\n                            total += dist_mat[sol[idx-1], sol[idx]]\n                        return total\n\n                    cost1 = calculate_cost(temp_solution, distance_matrix_1)\n                    cost2 = calculate_cost(temp_solution, distance_matrix_2)\n                    total_cost = cost1 + cost2\n\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_candidate = e\n\n                if best_candidate is not None:\n                    new_solution = np.concatenate([\n                        new_solution[:c+1],\n                        new_solution[best_candidate:best_candidate+1],\n                        new_solution[c+1:]\n                    ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8997583200364865,
            2.6796183586120605
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using fitness-based probability (prioritizing solutions with lower combined objective costs) and applies a hybrid local search combining node shift and segment rotation to generate a neighbor while ensuring feasibility. The fitness scores are computed as the inverse of the sum of objectives, and the selection is probabilistic. The local search randomly shifts a node to a new position and rotates a segment of the tour to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores (inverse of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    fitness_scores = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Small epsilon to avoid division by zero\n    selection_probs = fitness_scores / np.sum(fitness_scores)\n\n    # Select a solution with probability proportional to fitness\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: node shift and segment rotation\n    # Shift a random node to a new position\n    node_to_shift = np.random.randint(0, n)\n    new_position = np.random.randint(0, n)\n    while new_position == node_to_shift:\n        new_position = np.random.randint(0, n)\n\n    shifted_node = new_solution[node_to_shift]\n    new_solution = np.concatenate([\n        new_solution[:node_to_shift],\n        new_solution[node_to_shift+1:new_position+1],\n        [shifted_node],\n        new_solution[new_position+1:]\n    ])\n\n    # Rotate a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    rotation_amount = np.random.randint(1, b - a + 1)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    return new_solution\n\n",
        "score": [
            -0.8194038682995677,
            0.2810159921646118
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using weighted random selection (prioritizing lower-cost solutions) and applies a hybrid local search combining segment reversal, edge insertion, and conditional node swapping (only if beneficial for both objectives). It ensures feasibility by validating the solution and falling back to segment reversal if duplicates occur. The method balances exploration (via random operations) and exploitation (via cost-aware swaps) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on combined objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (objectives + 1e-6)  # Inverse of combined cost\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + edge insertion + node swapping\n    if n > 3:\n        # Segment reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge insertion\n        if n > 4:\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            while c == d or (c == a and d == b):\n                c, d = sorted(np.random.choice(n, 2, replace=False))\n            new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n        # Node swapping (if beneficial)\n        if np.random.random() < 0.3:  # Lower probability to balance exploration\n            k, l = np.random.choice(n, 2, replace=False)\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n            # Calculate cost before and after swap\n            def calculate_cost(sol, dist_mat):\n                total = 0\n                for idx in range(len(sol)):\n                    total += dist_mat[sol[idx-1], sol[idx]]\n                return total\n\n            cost_before = calculate_cost(new_solution, distance_matrix_1) + calculate_cost(new_solution, distance_matrix_2)\n            cost_after = calculate_cost(temp_solution, distance_matrix_1) + calculate_cost(temp_solution, distance_matrix_2)\n\n            if cost_after < cost_before:\n                new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if duplicates exist\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8917089614433672,
            0.5027415752410889
        ]
    },
    {
        "algorithm": "The algorithm combines cost-sensitive selection with an adaptive hybrid local search that prioritizes high-distance edges in both objectives through dynamic segment rotation and probabilistic edge relocation, while maintaining feasibility through conditional perturbations and segment reversal. It intelligently selects solutions based on Pareto dominance and objective improvement potential, using multi-objective distance prioritization to guide the search. The method balances exploration and exploitation by dynamically adjusting segment sizes and applying conditional operations to refine the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Cost-sensitive selection with Pareto dominance awareness\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    dominance = np.sum(normalized_obj < 0.5, axis=1)  # Count of objectives where solution is better than median\n    weights = dominance / np.sum(dominance)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rotation with cost-aware sizing\n    segment_size = max(2, min(n // 3, int(np.exp(np.random.normal(scale=1.5)))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n\n    # Rotation direction based on objective improvement potential\n    rotation_dir = 1 if np.random.rand() < 0.7 else -1\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, segment_size) * rotation_dir)\n\n    # Probabilistic edge relocation with multi-objective distance prioritization\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_scores = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_scores.append(combined_distances[u][v])\n\n        edge_scores = np.array(edge_scores)\n        edge_probs = edge_scores / np.sum(edge_scores)\n        selected_edge = np.random.choice(n, p=edge_probs)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            # Candidate selection based on both objectives\n            candidate_scores = []\n            for i in candidates:\n                node = new_solution[i]\n                score = (distance_matrix_1[new_solution[c]][node] + distance_matrix_2[new_solution[c]][node]) * \\\n                        (distance_matrix_1[node][new_solution[d]] + distance_matrix_2[node][new_solution[d]])\n                candidate_scores.append(score)\n\n            candidate_probs = np.array(candidate_scores) / np.sum(candidate_scores)\n            e = np.random.choice(candidates, p=candidate_probs)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal for local improvement\n    if n > 4 and np.random.rand() < 0.3:\n        # Select two edges to reverse based on their combined distance\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if len(edges) >= 2:\n            c1, d1 = edges[0][0], edges[0][1]\n            c2, d2 = edges[1][0], edges[1][1]\n\n            # Ensure proper segment selection and improvement potential\n            if c1 < d1 and c2 > d2 and (d1 + 1) % n != c2:\n                new_solution[c1:d1+1] = new_solution[c1:d1+1][::-1]\n                new_solution[c2:d2+1] = new_solution[c2:d2+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8564302310325977,
            0.32124507427215576
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted random selection (prioritizing higher-indexed solutions), then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor. It ensures feasibility by maintaining a valid TSP tour while exploring diverse modifications. The selection bias and randomness in segment/edge choices drive exploration, while the hybrid operator balances structure and perturbation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert\n    if n > 3:\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        while c == d or (c == a and d == b):\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8740335775470593,
            0.49903690814971924
        ]
    }
]