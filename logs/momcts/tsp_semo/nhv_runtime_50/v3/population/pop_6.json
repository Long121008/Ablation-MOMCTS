[
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted random selection (prioritizing higher-indexed solutions), then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor. It ensures feasibility by maintaining a valid TSP tour while exploring diverse modifications. The selection bias and randomness in segment/edge choices drive exploration, while the hybrid operator balances structure and perturbation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert\n    if n > 3:\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        while c == d or (c == a and d == b):\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8740335775470593,
            0.49903690814971924
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining adaptive segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility. It prioritizes edges with high combined distance in both objectives for insertion, balancing exploration and exploitation through adaptive segment sizes and randomness. The selection weights and distance-based edge prioritization are key design choices for driving improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on objective values (lower is better)\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Select segment to reverse\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion based on distance metrics\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d\n            if n > 3:\n                candidates = [i for i in range(n) if i not in (c, d)]\n                if candidates:\n                    e = np.random.choice(candidates)\n                    new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9746621176519483,
            0.5717102885246277
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using fitness-based probability (prioritizing solutions with lower combined objective costs) and applies a hybrid local search combining node shift and segment rotation to generate a neighbor while ensuring feasibility. The fitness scores are computed as the inverse of the sum of objectives, and the selection is probabilistic. The local search randomly shifts a node to a new position and rotates a segment of the tour to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores (inverse of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    fitness_scores = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Small epsilon to avoid division by zero\n    selection_probs = fitness_scores / np.sum(fitness_scores)\n\n    # Select a solution with probability proportional to fitness\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: node shift and segment rotation\n    # Shift a random node to a new position\n    node_to_shift = np.random.randint(0, n)\n    new_position = np.random.randint(0, n)\n    while new_position == node_to_shift:\n        new_position = np.random.randint(0, n)\n\n    shifted_node = new_solution[node_to_shift]\n    new_solution = np.concatenate([\n        new_solution[:node_to_shift],\n        new_solution[node_to_shift+1:new_position+1],\n        [shifted_node],\n        new_solution[new_position+1:]\n    ])\n\n    # Rotate a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    rotation_amount = np.random.randint(1, b - a + 1)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    return new_solution\n\n",
        "score": [
            -0.8194038682995677,
            0.2810159921646118
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using weighted random selection (prioritizing lower-cost solutions) and applies a hybrid local search combining segment reversal, edge insertion, and conditional node swapping (only if beneficial for both objectives). It ensures feasibility by validating the solution and falling back to segment reversal if duplicates occur. The method balances exploration (via random operations) and exploitation (via cost-aware swaps) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on combined objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = 1 / (objectives + 1e-6)  # Inverse of combined cost\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + edge insertion + node swapping\n    if n > 3:\n        # Segment reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge insertion\n        if n > 4:\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            while c == d or (c == a and d == b):\n                c, d = sorted(np.random.choice(n, 2, replace=False))\n            new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n        # Node swapping (if beneficial)\n        if np.random.random() < 0.3:  # Lower probability to balance exploration\n            k, l = np.random.choice(n, 2, replace=False)\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n            # Calculate cost before and after swap\n            def calculate_cost(sol, dist_mat):\n                total = 0\n                for idx in range(len(sol)):\n                    total += dist_mat[sol[idx-1], sol[idx]]\n                return total\n\n            cost_before = calculate_cost(new_solution, distance_matrix_1) + calculate_cost(new_solution, distance_matrix_2)\n            cost_after = calculate_cost(temp_solution, distance_matrix_1) + calculate_cost(temp_solution, distance_matrix_2)\n\n            if cost_after < cost_before:\n                new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if duplicates exist\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8917089614433672,
            0.5027415752410889
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (prioritizing Pareto-optimal candidates) and applies a two-phase local search: first identifying high-quality segments (shortest in both objectives) and then reinserting them at random positions while ensuring feasibility through duplicate removal. If this fails, it defaults to a simple random swap. The method balances exploitation of good structures with controlled diversification while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with non-dominated objectives\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Identify high-quality segments\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+2, min(i+10, n)):  # Limit segment length for efficiency\n            # Calculate segment quality based on both objectives\n            segment_length1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length1 += distance_matrix_1[new_solution[j], new_solution[i]] if j+1 < n else 0\n            segment_length2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length2 += distance_matrix_2[new_solution[j], new_solution[i]] if j+1 < n else 0\n            score = - (segment_length1 + segment_length2)  # Higher score for shorter segments\n            segment_scores.append((score, i, j))\n\n    if segment_scores:\n        segment_scores.sort(reverse=True)\n        _, best_i, best_j = segment_scores[0]\n        best_segment = new_solution[best_i:best_j+1]\n\n        # Phase 2: Reintegrate segment with dynamic boundary adjustment\n        new_pos = random.randint(0, n - len(best_segment))\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            best_segment,\n            new_solution[new_pos:new_pos + len(best_segment)],\n            new_solution[new_pos + len(best_segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = [node for node in range(n) if node not in unique_nodes]\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Final check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if all else fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9494995633810055,
            3.6105303168296814
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive based on the sum of its two objectives, then applies a hybrid local search that reverses a randomly selected segment of the tour (edge-swap) to generate a neighbor solution, ensuring feasibility by falling back to a simple swap if the reversal causes duplicates. This approach prioritizes solutions with lower combined costs while using a constrained perturbation to explore the solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: edge-swap with constrained perturbation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    seg_start = np.random.randint(0, n - 2)\n    seg_length = np.random.randint(2, min(5, n - seg_start))\n    seg_end = seg_start + seg_length\n\n    # Reverse the segment (edge-swap)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure feasibility by checking for duplicates (though reversal should prevent this)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if reversal causes issues\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5449914955289381,
            0.4393578767776489
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge swapping (reversing a random segment) and segment insertion (moving a random segment to another position), ensuring feasibility by reverting to edge swapping if duplicates arise. It prioritizes exploration by randomly sampling segments while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    n = len(selected_solution)\n\n    # Hybrid local search: combine edge swapping with segment insertion\n    new_solution = selected_solution.copy()\n\n    # Edge swapping (similar to 2-opt but with a twist)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Segment insertion (novel mechanism)\n    if n > 4:\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swapping if segment insertion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6955363394749712,
            0.4474228024482727
        ]
    },
    {
        "algorithm": "The heuristic selects a random solution from the archive and applies a hybrid local search combining edge insertion and node swapping, prioritizing improvements that reduce the total tour length in both objective spaces while ensuring feasibility. The edge insertion randomly moves a node to a new position, and node swapping further refines the solution by swapping nodes if it improves the combined cost. The algorithm balances exploration (random selection) and exploitation (cost-based swapping) to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion and node swapping\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Step 1: Edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or abs(j - i) == 1:\n        j = np.random.randint(0, n)\n\n    # Remove node at j and reinsert it after i\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n    insert_pos = (i + 1) % len(new_solution)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Node swapping (if beneficial)\n    if np.random.random() < 0.5:  # 50% chance to apply swapping\n        k = np.random.randint(0, len(new_solution))\n        l = np.random.randint(0, len(new_solution))\n        while k == l:\n            l = np.random.randint(0, len(new_solution))\n\n        # Calculate cost before and after swap\n        def calculate_cost(sol, dist_mat):\n            total = 0\n            for idx in range(len(sol)):\n                total += dist_mat[sol[idx-1], sol[idx]]\n            return total\n\n        cost_before = calculate_cost(new_solution, distance_matrix_1) + calculate_cost(new_solution, distance_matrix_2)\n        temp_sol = new_solution.copy()\n        temp_sol[k], temp_sol[l] = temp_sol[l], temp_sol[k]\n        cost_after = calculate_cost(temp_sol, distance_matrix_1) + calculate_cost(temp_sol, distance_matrix_2)\n\n        if cost_after < cost_before:\n            new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            -0.7671850103342167,
            0.48066627979278564
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining edge swaps (reversing segments) and node relocations (moving single nodes) to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with worse objectives (higher weights) to encourage exploration, while the local search balances exploration and exploitation through randomized segment reversals and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = objectives / objectives.sum(axis=0, keepdims=True)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-6)  # Avoid division by zero\n    weights = weights / weights.sum()  # Normalize weights\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and node relocations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform multiple edge swaps\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node relocation\n    for _ in range(1):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7702270207510664,
            0.5045158863067627
        ]
    }
]