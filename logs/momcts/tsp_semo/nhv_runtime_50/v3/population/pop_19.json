[
    {
        "algorithm": "The algorithm uses Pareto-based tournament selection to choose a promising solution from the archive, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal to generate a neighbor solution while balancing exploration and exploitation across both objectives. The method prioritizes edges with higher combined weights for insertion and only reverses segments if it improves at least one objective, ensuring feasibility and quality improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        # Only reverse if it improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9815906601152675,
            0.2346944808959961
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto-based selection with crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    # Calculate crowding distance for Pareto front\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    # Build Pareto front\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion with probabilistic selection\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9394738245470493,
            0.2026417851448059
        ]
    },
    {
        "algorithm": "This algorithm combines adaptive Pareto selection with a hybrid local search that uses dynamic segment rotations, cost-sensitive edge prioritization, and conditional segment reversals to generate high-quality neighbors while maintaining feasibility across both objectives. It prioritizes solutions with better crowding distances on the Pareto front, applies probabilistic segment operations weighted by edge costs, and conditionally reverses segments only when they improve at least one objective. The approach balances exploration and exploitation by dynamically adjusting segment sizes and operation probabilities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto selection with weighted crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rotation with adaptive size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-sensitive edge prioritization\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v])\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]]\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9643742433955875,
            0.20593953132629395
        ]
    },
    {
        "algorithm": "This algorithm employs adaptive multi-objective selection with probabilistic dominance checks to choose promising solutions from an archive, then applies dynamic segment swaps and cost-sensitive edge insertions to generate improved neighbors while maintaining feasibility. It prioritizes solutions with better objective values but occasionally selects non-dominated ones with a small probability, and uses lognormal-distributed segment sizes for adaptive exploration. The local search combines segment swaps (if they improve at least one objective) with edge insertions weighted by combined distance costs to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive dominance selection with probability-based tournament\n    tournament_size = min(3, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected = None\n\n    for idx in selected_indices:\n        if selected is None:\n            selected = idx\n            continue\n        current = archive[idx]\n        best = archive[selected]\n\n        # Probabilistic dominance check\n        if (current[1][0] < best[1][0] and current[1][1] <= best[1][1]) or \\\n           (current[1][0] <= best[1][0] and current[1][1] < best[1][1]):\n            selected = idx\n        elif np.random.rand() < 0.2:  # Small chance to select non-dominated\n            selected = idx\n\n    base_solution = archive[selected][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment swap with adaptive size\n    segment_size = max(2, min(n // 4, int(np.random.lognormal(mean=0.5, sigma=0.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    c = np.random.randint(0, n - segment_size + 1)\n    while abs(a - c) < segment_size:\n        c = np.random.randint(0, n - segment_size + 1)\n    d = c + segment_size - 1\n\n    # Swap segments if it improves at least one objective\n    original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + \\\n                      distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]] + \\\n                      distance_matrix_1[new_solution[c]][new_solution[(c-1)%n]] + \\\n                      distance_matrix_1[new_solution[d]][new_solution[(d+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + \\\n                      distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]] + \\\n                      distance_matrix_2[new_solution[c]][new_solution[(c-1)%n]] + \\\n                      distance_matrix_2[new_solution[d]][new_solution[(d+1)%n]]\n\n    new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1], new_solution[a:b+1]\n\n    new_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + \\\n                distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]] + \\\n                distance_matrix_1[new_solution[c]][new_solution[(c-1)%n]] + \\\n                distance_matrix_1[new_solution[d]][new_solution[(d+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + \\\n                distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]] + \\\n                distance_matrix_2[new_solution[c]][new_solution[(c-1)%n]] + \\\n                distance_matrix_2[new_solution[d]][new_solution[(d+1)%n]]\n\n    if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n        new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1], new_solution[a:b+1]\n\n    # Cost-sensitive edge insertion\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v])\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]]\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8671557199544548,
            0.18115627765655518
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto selection with weighted crowding distance to prioritize diverse solutions, then applies a hybrid local search that dynamically rotates segments, cost-sensitively prioritizes edges, and conditionally reverses segments when improving at least one objective, ensuring feasibility through strict validation. The approach balances exploration via random segment operations and exploitation via cost-aware prioritization, with dynamic segment sizes and operation probabilities adjusted based on solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto selection with weighted crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search\n    # Dynamic segment rotation with adaptive size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-sensitive edge prioritization\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v])\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]]\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Feasibility check\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.966911917358781,
            0.21160852909088135
        ]
    },
    {
        "algorithm": "This heuristic combines adaptive Pareto selection with a hybrid local search that uses dynamic segment rotations, cost-sensitive edge prioritization, and conditional segment reversals. It prioritizes solutions with better crowding distances on the Pareto front, applies probabilistic operations weighted by edge costs in both objectives, and conditionally reverses segments only when they improve at least one objective, while ensuring feasibility through strict checks. The algorithm balances exploration and exploitation by dynamically adjusting segment sizes and operation probabilities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto selection with weighted crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rotation with adaptive size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-sensitive edge prioritization with multi-objective weighting\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v] * (1 + 0.1 * (distance_matrix_1[u][v] / distance_matrix_2[u][v])))\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]] *\n                             (1 + 0.1 * (distance_matrix_1[new_solution[c]][new_solution[i]] / distance_matrix_2[new_solution[c]][new_solution[i]]))\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Feasibility check\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -1.0211110153860687,
            0.3061484694480896
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto selection with a hybrid local search that prioritizes segment rotation, cost-aware edge insertion, and conditional segment reversal, while ensuring feasibility through probabilistic segment operations and edge weighting. It balances exploration and exploitation by dynamically adjusting segment sizes and using combined distance metrics to guide multi-objective improvements. The method intelligently selects edges and segments based on their potential for reducing tour lengths in both objective spaces, with segment reversal only applied when it improves at least one objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto-based selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion with probabilistic selection\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8547295562960665,
            0.20903760194778442
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection that prioritizes non-dominated solutions with lower combined objective values, then applies a hybrid local search combining adaptive segment rotation (with segment size proportional to solution quality) and conditional edge insertion (only if it improves at least one objective). The rotation prioritizes high-distance segments, while the insertion targets high-distance edges, ensuring feasibility by maintaining valid TSP tours throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on combined objective values and Pareto dominance\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Lower combined objective is better\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n        # Boost weight for non-dominated solutions\n        dominated = False\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            weights[i] *= 1.5\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate segment quality based on combined distance\n    segment_scores = []\n    for a in range(n):\n        segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n        b = min(a + segment_size - 1, n - 1)\n        score = 0\n        for i in range(a, b):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            score += distance_matrix_1[u][v] * distance_matrix_2[u][v]\n        segment_scores.append((a, b, score))\n\n    # Select segment to rotate with highest score\n    segment_scores.sort(key=lambda x: -x[2])\n    if segment_scores:\n        a, b, _ = segment_scores[0]\n        rotation = np.random.randint(1, b - a + 1)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Conditional edge insertion\n    if n > 3:\n        # Find edges with high combined distance\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d if it improves at least one objective\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                for e in candidates:\n                    temp_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n                    temp_obj1 = sum(distance_matrix_1[temp_solution[i]][temp_solution[(i+1)%n]] for i in range(n))\n                    temp_obj2 = sum(distance_matrix_2[temp_solution[i]][temp_solution[(i+1)%n]] for i in range(n))\n                    if temp_obj1 <= sum(distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] for i in range(n)) or \\\n                       temp_obj2 <= sum(distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] for i in range(n)):\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.977285410367772,
            1.0264369249343872
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining adaptive segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility. It prioritizes edges with high combined distance in both objectives for insertion, balancing exploration and exploitation through adaptive segment sizes and randomness. The selection weights and distance-based edge prioritization are key design choices for driving improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on objective values (lower is better)\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Select segment to reverse\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion based on distance metrics\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d\n            if n > 3:\n                candidates = [i for i in range(n) if i not in (c, d)]\n                if candidates:\n                    e = np.random.choice(candidates)\n                    new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9746621176519483,
            0.5717102885246277
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive using Pareto-dominance tournament selection, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal, ensuring feasibility and balanced multi-objective optimization by prioritizing edge weights and improving at least one objective. It intelligently balances exploration and exploitation through probabilistic segment operations and cost-aware selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8948467507881668,
            0.21143871545791626
        ]
    }
]