[
    {
        "algorithm": "This heuristic selects a promising solution from the archive using tournament selection biased toward lower total costs, then applies a hybrid local search combining adaptive segment rotation (with variable segment size and rotation) and probabilistic edge relocation (prioritizing edges with high normalized distance products from both objectives). The method ensures feasibility by maintaining a valid TSP tour throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection with quality bias\n    tournament_size = min(5, len(archive))\n    selected_idx = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_idx[np.argmin([np.sum(archive[i][1]) for i in selected_idx])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Probabilistic edge relocation\n    if n > 3:\n        normalized_distances = (distance_matrix_1 + distance_matrix_2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2))\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(normalized_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        if n > 3:\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                probs = np.array([normalized_distances[new_solution[c]][new_solution[i]] *\n                                normalized_distances[new_solution[i]][new_solution[d]]\n                                for i in candidates])\n                probs = probs / np.sum(probs)\n                e = np.random.choice(candidates, p=probs)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9310379678551315,
            0.2135852575302124
        ]
    },
    {
        "algorithm": "The algorithm uses Pareto-based tournament selection to choose a promising solution from the archive, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal to generate a neighbor solution while balancing exploration and exploitation across both objectives. The method prioritizes edges with higher combined weights for insertion and only reverses segments if it improves at least one objective, ensuring feasibility and quality improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        # Only reverse if it improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9815906601152675,
            0.2346944808959961
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive using Pareto-dominance tournament selection, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal, ensuring feasibility and balanced multi-objective optimization by prioritizing edge weights and improving at least one objective. It intelligently balances exploration and exploitation through probabilistic segment operations and cost-aware selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8948467507881668,
            0.21143871545791626
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining adaptive segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility. It prioritizes edges with high combined distance in both objectives for insertion, balancing exploration and exploitation through adaptive segment sizes and randomness. The selection weights and distance-based edge prioritization are key design choices for driving improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on objective values (lower is better)\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Select segment to reverse\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion based on distance metrics\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d\n            if n > 3:\n                candidates = [i for i in range(n) if i not in (c, d)]\n                if candidates:\n                    e = np.random.choice(candidates)\n                    new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9746621176519483,
            0.5717102885246277
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Weighted selection of promising solutions using a combination of objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    weights = crowding_dist / np.sum(crowding_dist)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 2: Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Step 3: Hybrid local search combining segment reversal and adaptive edge insertion\n    # First perform segment reversal\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform adaptive edge insertion based on high combined distance\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d with probability based on its distance\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                candidate_distances = [distance_matrix_1[new_solution[c]][new_solution[i]] + distance_matrix_2[new_solution[c]][new_solution[i]] for i in candidates]\n                candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n                e = np.random.choice(candidates, p=candidate_weights)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Step 4: Additional local improvement with edge reversal\n    if n > 3:\n        # Select two edges to reverse based on their combined distance\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if len(edges) >= 2:\n            c1, d1 = edges[0][0], edges[0][1]\n            c2, d2 = edges[1][0], edges[1][1]\n\n            # Reverse the segment between the two selected edges\n            if c1 < d1 and c2 > d2:  # Ensure proper segment selection\n                new_solution[c1:d1+1] = new_solution[c1:d1+1][::-1]\n                new_solution[c2:d2+1] = new_solution[c2:d2+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9596813386903245,
            0.29400932788848877
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive using weighted randomness based on normalized objectives and crowding distance, then applies a hybrid local search combining adaptive segment rotation, probabilistic edge insertion, and conditional edge reversal to generate a neighbor solution while ensuring feasibility. The algorithm prioritizes segments with high combined distance in edge reversal and adaptively adjusts segment sizes for rotation, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    weights = crowding_dist / np.sum(crowding_dist)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Probabilistic edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_weights = np.array([combined_distances[new_solution[c]][new_solution[i]] for i in candidates])\n            candidate_weights = candidate_weights / np.sum(candidate_weights)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional edge reversal\n    if n > 3:\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if len(edges) >= 2:\n            c1, d1 = edges[0][0], edges[0][1]\n            c2, d2 = edges[1][0], edges[1][1]\n\n            if c1 < d1 and c2 > d2:\n                # Reverse segments if it improves at least one objective\n                original_cost1 = distance_matrix_1[new_solution[c1]][new_solution[d1]] + distance_matrix_1[new_solution[c2]][new_solution[d2]]\n                original_cost2 = distance_matrix_2[new_solution[c1]][new_solution[d1]] + distance_matrix_2[new_solution[c2]][new_solution[d2]]\n\n                temp_solution = new_solution.copy()\n                temp_solution[c1:d1+1] = temp_solution[c1:d1+1][::-1]\n                temp_solution[c2:d2+1] = temp_solution[c2:d2+1][::-1]\n\n                new_cost1 = distance_matrix_1[temp_solution[c1]][temp_solution[d1]] + distance_matrix_1[temp_solution[c2]][temp_solution[d2]]\n                new_cost2 = distance_matrix_2[temp_solution[c1]][temp_solution[d1]] + distance_matrix_2[temp_solution[c2]][temp_solution[d2]]\n\n                if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n                   (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.911450101760233,
            0.2679750919342041
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-based tournament selection, then applies a hybrid local search that combines adaptive segment rotation with cost-aware edge insertion and node swapping, prioritizing edges with higher combined weights from both objective spaces while ensuring feasibility through verification. It balances exploration through random segment operations and exploitation through cost-aware edge prioritization, with segment reversal and node swapping applied conditionally to improve solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v])\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]]\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Node swapping with cost improvement check\n    if n > 4 and np.random.rand() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while k == l or abs(k - l) == 1:\n            l = np.random.randint(0, n)\n\n        def calculate_cost(sol, dist_mat):\n            total = 0\n            for idx in range(len(sol)):\n                total += dist_mat[sol[idx-1], sol[idx]]\n            return total\n\n        cost_before = calculate_cost(new_solution, distance_matrix_1) + calculate_cost(new_solution, distance_matrix_2)\n        temp_sol = new_solution.copy()\n        temp_sol[k], temp_sol[l] = temp_sol[l], temp_sol[k]\n        cost_after = calculate_cost(temp_sol, distance_matrix_1) + calculate_cost(temp_sol, distance_matrix_2)\n\n        if cost_after < cost_before:\n            new_solution = temp_sol\n\n    # Conditional segment reversal\n    if n > 5 and np.random.rand() < 0.4:\n        segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7373486584161918,
            0.27187418937683105
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (prioritizing Pareto-optimal candidates) and applies a two-phase local search: first identifying high-quality segments (shortest in both objectives) and then reinserting them at random positions while ensuring feasibility through duplicate removal. If this fails, it defaults to a simple random swap. The method balances exploitation of good structures with controlled diversification while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with non-dominated objectives\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Identify high-quality segments\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+2, min(i+10, n)):  # Limit segment length for efficiency\n            # Calculate segment quality based on both objectives\n            segment_length1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length1 += distance_matrix_1[new_solution[j], new_solution[i]] if j+1 < n else 0\n            segment_length2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length2 += distance_matrix_2[new_solution[j], new_solution[i]] if j+1 < n else 0\n            score = - (segment_length1 + segment_length2)  # Higher score for shorter segments\n            segment_scores.append((score, i, j))\n\n    if segment_scores:\n        segment_scores.sort(reverse=True)\n        _, best_i, best_j = segment_scores[0]\n        best_segment = new_solution[best_i:best_j+1]\n\n        # Phase 2: Reintegrate segment with dynamic boundary adjustment\n        new_pos = random.randint(0, n - len(best_segment))\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            best_segment,\n            new_solution[new_pos:new_pos + len(best_segment)],\n            new_solution[new_pos + len(best_segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = [node for node in range(n) if node not in unique_nodes]\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Final check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if all else fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9494995633810055,
            3.6105303168296814
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive segment swapping, objective-aware edge replacement, and conditional path inversion to generate high-quality neighbors from a selected solution. It prioritizes solutions with better combined objective values while considering diversity, and applies hybrid local search operators that balance exploration of both objectives, with segment inversion only when significant improvement is expected. The method ensures feasibility by carefully handling segment boundaries and avoiding node revisits.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Combined objective selection with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n\n    combined_scores = np.sum(objectives, axis=1) - 0.3 * crowding_distances\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment swapping\n    segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    c = np.random.randint(0, n - segment_size + 1)\n    while abs(a - c) < segment_size:\n        c = np.random.randint(0, n - segment_size + 1)\n    d = c + segment_size - 1\n\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution[a:b+1] = segment2\n    new_solution[c:d+1] = segment1\n\n    # Objective-aware edge replacement\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_scores = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_scores.append(combined_distances[u][v])\n\n        edge_scores = np.array(edge_scores)\n        edge_scores = edge_scores / np.sum(edge_scores)\n        selected_edge = np.random.choice(n, p=edge_scores)\n        x = selected_edge\n        y = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (x, y, (x-1)%n, (y+1)%n)]\n        if candidates:\n            candidate_scores = []\n            for i in candidates:\n                score = (distance_matrix_1[new_solution[x]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[y]] -\n                         distance_matrix_1[new_solution[x]][new_solution[y]])\n                score += (distance_matrix_2[new_solution[x]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[y]] -\n                          distance_matrix_2[new_solution[x]][new_solution[y]])\n                candidate_scores.append(score)\n\n            candidate_scores = np.array(candidate_scores)\n            candidate_scores = np.exp(-candidate_scores)\n            candidate_scores = candidate_scores / np.sum(candidate_scores)\n            z = np.random.choice(candidates, p=candidate_scores)\n            new_solution = np.concatenate([new_solution[:x+1], new_solution[z:z+1], new_solution[x+1:]])\n\n    # Conditional path inversion\n    if n > 4 and np.random.rand() < 0.4:\n        segment_size = max(2, min(n // 5, int(np.random.exponential(scale=1.0))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = (distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] +\n                          distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] +\n                          distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]])\n\n        inverted_segment = new_solution[a:b+1][::-1]\n        new_cost1 = (distance_matrix_1[inverted_segment[0]][new_solution[(a-1)%n]] +\n                    distance_matrix_1[inverted_segment[-1]][new_solution[(b+1)%n]])\n        new_cost2 = (distance_matrix_2[inverted_segment[0]][new_solution[(a-1)%n]] +\n                    distance_matrix_2[inverted_segment[-1]][new_solution[(b+1)%n]])\n\n        improvement_factor = 0.7\n        if ((new_cost1 < original_cost1 * improvement_factor) or\n            (new_cost2 < original_cost2 * improvement_factor)):\n            new_solution[a:b+1] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9197315059452067,
            0.6117097735404968
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using fitness-based probability (prioritizing solutions with lower combined objective costs) and applies a hybrid local search combining node shift and segment rotation to generate a neighbor while ensuring feasibility. The fitness scores are computed as the inverse of the sum of objectives, and the selection is probabilistic. The local search randomly shifts a node to a new position and rotates a segment of the tour to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores (inverse of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    fitness_scores = 1 / (objectives[:, 0] + objectives[:, 1] + 1e-6)  # Small epsilon to avoid division by zero\n    selection_probs = fitness_scores / np.sum(fitness_scores)\n\n    # Select a solution with probability proportional to fitness\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: node shift and segment rotation\n    # Shift a random node to a new position\n    node_to_shift = np.random.randint(0, n)\n    new_position = np.random.randint(0, n)\n    while new_position == node_to_shift:\n        new_position = np.random.randint(0, n)\n\n    shifted_node = new_solution[node_to_shift]\n    new_solution = np.concatenate([\n        new_solution[:node_to_shift],\n        new_solution[node_to_shift+1:new_position+1],\n        [shifted_node],\n        new_solution[new_position+1:]\n    ])\n\n    # Rotate a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    rotation_amount = np.random.randint(1, b - a + 1)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    return new_solution\n\n",
        "score": [
            -0.8194038682995677,
            0.2810159921646118
        ]
    }
]