[
    {
        "algorithm": "The algorithm uses Pareto-based tournament selection to choose a promising solution from the archive, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal to generate a neighbor solution while balancing exploration and exploitation across both objectives. The method prioritizes edges with higher combined weights for insertion and only reverses segments if it improves at least one objective, ensuring feasibility and quality improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        # Only reverse if it improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9815906601152675,
            0.2346944808959961
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto-based selection with crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    # Calculate crowding distance for Pareto front\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    # Build Pareto front\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion with probabilistic selection\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9394738245470493,
            0.2026417851448059
        ]
    },
    {
        "algorithm": "This algorithm combines adaptive Pareto selection with a hybrid local search that uses dynamic segment rotations, cost-sensitive edge prioritization, and conditional segment reversals to generate high-quality neighbors while maintaining feasibility across both objectives. It prioritizes solutions with better crowding distances on the Pareto front, applies probabilistic segment operations weighted by edge costs, and conditionally reverses segments only when they improve at least one objective. The approach balances exploration and exploitation by dynamically adjusting segment sizes and operation probabilities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto selection with weighted crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rotation with adaptive size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-sensitive edge prioritization\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v])\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]]\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9643742433955875,
            0.20593953132629395
        ]
    },
    {
        "algorithm": "This algorithm employs adaptive multi-objective selection with probabilistic dominance checks to choose promising solutions from an archive, then applies dynamic segment swaps and cost-sensitive edge insertions to generate improved neighbors while maintaining feasibility. It prioritizes solutions with better objective values but occasionally selects non-dominated ones with a small probability, and uses lognormal-distributed segment sizes for adaptive exploration. The local search combines segment swaps (if they improve at least one objective) with edge insertions weighted by combined distance costs to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive dominance selection with probability-based tournament\n    tournament_size = min(3, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected = None\n\n    for idx in selected_indices:\n        if selected is None:\n            selected = idx\n            continue\n        current = archive[idx]\n        best = archive[selected]\n\n        # Probabilistic dominance check\n        if (current[1][0] < best[1][0] and current[1][1] <= best[1][1]) or \\\n           (current[1][0] <= best[1][0] and current[1][1] < best[1][1]):\n            selected = idx\n        elif np.random.rand() < 0.2:  # Small chance to select non-dominated\n            selected = idx\n\n    base_solution = archive[selected][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment swap with adaptive size\n    segment_size = max(2, min(n // 4, int(np.random.lognormal(mean=0.5, sigma=0.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    c = np.random.randint(0, n - segment_size + 1)\n    while abs(a - c) < segment_size:\n        c = np.random.randint(0, n - segment_size + 1)\n    d = c + segment_size - 1\n\n    # Swap segments if it improves at least one objective\n    original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + \\\n                      distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]] + \\\n                      distance_matrix_1[new_solution[c]][new_solution[(c-1)%n]] + \\\n                      distance_matrix_1[new_solution[d]][new_solution[(d+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + \\\n                      distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]] + \\\n                      distance_matrix_2[new_solution[c]][new_solution[(c-1)%n]] + \\\n                      distance_matrix_2[new_solution[d]][new_solution[(d+1)%n]]\n\n    new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1], new_solution[a:b+1]\n\n    new_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + \\\n                distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]] + \\\n                distance_matrix_1[new_solution[c]][new_solution[(c-1)%n]] + \\\n                distance_matrix_1[new_solution[d]][new_solution[(d+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + \\\n                distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]] + \\\n                distance_matrix_2[new_solution[c]][new_solution[(c-1)%n]] + \\\n                distance_matrix_2[new_solution[d]][new_solution[(d+1)%n]]\n\n    if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n        new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1], new_solution[a:b+1]\n\n    # Cost-sensitive edge insertion\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v])\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]]\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8671557199544548,
            0.18115627765655518
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto selection with weighted crowding distance to prioritize diverse solutions, then applies a hybrid local search that dynamically rotates segments, cost-sensitively prioritizes edges, and conditionally reverses segments when improving at least one objective, ensuring feasibility through strict validation. The approach balances exploration via random segment operations and exploitation via cost-aware prioritization, with dynamic segment sizes and operation probabilities adjusted based on solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto selection with weighted crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search\n    # Dynamic segment rotation with adaptive size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-sensitive edge prioritization\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v])\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]]\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Feasibility check\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.966911917358781,
            0.21160852909088135
        ]
    },
    {
        "algorithm": "This heuristic combines adaptive Pareto selection with a hybrid local search that uses dynamic segment rotations, cost-sensitive edge prioritization, and conditional segment reversals. It prioritizes solutions with better crowding distances on the Pareto front, applies probabilistic operations weighted by edge costs in both objectives, and conditionally reverses segments only when they improve at least one objective, while ensuring feasibility through strict checks. The algorithm balances exploration and exploitation by dynamically adjusting segment sizes and operation probabilities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto selection with weighted crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rotation with adaptive size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-sensitive edge prioritization with multi-objective weighting\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v] * (1 + 0.1 * (distance_matrix_1[u][v] / distance_matrix_2[u][v])))\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]] *\n                             (1 + 0.1 * (distance_matrix_1[new_solution[c]][new_solution[i]] / distance_matrix_2[new_solution[c]][new_solution[i]]))\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Feasibility check\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -1.0211110153860687,
            0.3061484694480896
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive using Pareto-dominance tournament selection, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal, ensuring feasibility and balanced multi-objective optimization by prioritizing edge weights and improving at least one objective. It intelligently balances exploration and exploitation through probabilistic segment operations and cost-aware selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8948467507881668,
            0.21143871545791626
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto selection with a hybrid local search that prioritizes segment rotation, cost-aware edge insertion, and conditional segment reversal, while ensuring feasibility through probabilistic segment operations and edge weighting. It balances exploration and exploitation by dynamically adjusting segment sizes and using combined distance metrics to guide multi-objective improvements. The method intelligently selects edges and segments based on their potential for reducing tour lengths in both objective spaces, with segment reversal only applied when it improves at least one objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto-based selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion with probabilistic selection\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8547295562960665,
            0.20903760194778442
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using weighted random selection based on normalized objectives, then applies adaptive segment-based perturbation, multi-phase edge reversal, and optional node insertion to generate a new neighbor solution while ensuring feasibility. It prioritizes solutions with lower combined normalized objectives and dynamically adjusts perturbation intensity based on solution quality, using probabilistic segment sizes and deterministic reversal phases. The method combines segment-based modifications with edge reversal and selective node insertion to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Weighted selection based on normalized objectives with different weighting scheme\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = np.exp(-0.5 * np.sum(normalized_obj, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 2: Adaptive segment-based perturbation with probabilistic segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=n/5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[a:a+segment_size]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Multi-phase edge reversal with deterministic range adjustment\n    reversal_phases = [max(2, min(n // 4, int(n / (i+1)))) for i in range(3)]\n    for phase in reversal_phases:\n        c = np.random.randint(0, n - phase + 1)\n        d = c + phase - 1\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 4: Optional node insertion with quality-based probability\n    if np.random.rand() < 0.4 * (1 - np.sum(normalized_obj[selected_idx]) / 2):\n        insert_node = np.random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == insert_node)[0][0])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, insert_node)\n\n    return new_solution\n\n",
        "score": [
            -0.993894301084022,
            0.4981873631477356
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto selection with a hybrid local search that prioritizes dynamic segment rotations, cost-sensitive edge prioritization, and conditional segment reversals, ensuring feasibility through strict validation. It intelligently selects solutions from the archive using weighted crowding distance and applies multi-objective-aware operators that balance improvements in both objective spaces while maintaining tour validity. The approach dynamically adjusts segment sizes and operation probabilities to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto selection with weighted crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search\n    # Dynamic segment rotation with adaptive size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-sensitive edge prioritization with multi-objective weighting\n    combined_distances = distance_matrix_1 + distance_matrix_2\n    edge_weights = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        edge_weights.append(combined_distances[u][v] * (1 + 0.1 * (distance_matrix_1[u][v] / distance_matrix_2[u][v])))\n\n    edge_weights = np.array(edge_weights)\n    edge_weights = edge_weights / np.sum(edge_weights)\n    selected_edge = np.random.choice(n, p=edge_weights)\n    c = selected_edge\n    d = (selected_edge + 1) % n\n\n    candidates = [i for i in range(n) if i not in (c, d)]\n    if candidates:\n        candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                             combined_distances[new_solution[i]][new_solution[d]] *\n                             (1 + 0.1 * (distance_matrix_1[new_solution[c]][new_solution[i]] / distance_matrix_2[new_solution[c]][new_solution[i]]))\n                             for i in candidates]\n        candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n        e = np.random.choice(candidates, p=candidate_weights)\n        new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Feasibility check\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9092254104733437,
            0.32239651679992676
        ]
    }
]