[
    {
        "algorithm": "The algorithm uses Pareto-based tournament selection to choose a promising solution from the archive, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal to generate a neighbor solution while balancing exploration and exploitation across both objectives. The method prioritizes edges with higher combined weights for insertion and only reverses segments if it improves at least one objective, ensuring feasibility and quality improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        # Only reverse if it improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9815906601152675,
            0.2346944808959961
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto-based selection with crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    # Calculate crowding distance for Pareto front\n    def calculate_crowding_distance(pop):\n        distances = np.zeros(len(pop))\n        for m in range(2):\n            sorted_idx = np.argsort([sol[1][m] for sol in pop])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(pop)-1):\n                distances[sorted_idx[i]] += (pop[sorted_idx[i+1]][1][m] - pop[sorted_idx[i-1]][1][m]) / (max(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]) - min(pop[sorted_idx[-1]][1][m], pop[sorted_idx[0]][1][m]))\n        return distances\n\n    # Build Pareto front\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(archive[idx])\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        crowding_distances = calculate_crowding_distance(pareto_front)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion with probabilistic selection\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9394738245470493,
            0.2026417851448059
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining adaptive segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility. It prioritizes edges with high combined distance in both objectives for insertion, balancing exploration and exploitation through adaptive segment sizes and randomness. The selection weights and distance-based edge prioritization are key design choices for driving improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on objective values (lower is better)\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Select segment to reverse\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion based on distance metrics\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d\n            if n > 3:\n                candidates = [i for i in range(n) if i not in (c, d)]\n                if candidates:\n                    e = np.random.choice(candidates)\n                    new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9746621176519483,
            0.5717102885246277
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Weighted selection of promising solutions using a combination of objective values and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    crowding_dist = np.sum(normalized_obj, axis=1)\n    weights = crowding_dist / np.sum(crowding_dist)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 2: Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n\n    # Step 3: Hybrid local search combining segment reversal and adaptive edge insertion\n    # First perform segment reversal\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Then perform adaptive edge insertion based on high combined distance\n    if n > 3:\n        # Find edges with high combined distance in both objectives\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d with probability based on its distance\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                candidate_distances = [distance_matrix_1[new_solution[c]][new_solution[i]] + distance_matrix_2[new_solution[c]][new_solution[i]] for i in candidates]\n                candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n                e = np.random.choice(candidates, p=candidate_weights)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Step 4: Additional local improvement with edge reversal\n    if n > 3:\n        # Select two edges to reverse based on their combined distance\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if len(edges) >= 2:\n            c1, d1 = edges[0][0], edges[0][1]\n            c2, d2 = edges[1][0], edges[1][1]\n\n            # Reverse the segment between the two selected edges\n            if c1 < d1 and c2 > d2:  # Ensure proper segment selection\n                new_solution[c1:d1+1] = new_solution[c1:d1+1][::-1]\n                new_solution[c2:d2+1] = new_solution[c2:d2+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9596813386903245,
            0.29400932788848877
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection that prioritizes non-dominated solutions with lower combined objective values, then applies a hybrid local search combining adaptive segment rotation (with segment size proportional to solution quality) and conditional edge insertion (only if it improves at least one objective). The rotation prioritizes high-distance segments, while the insertion targets high-distance edges, ensuring feasibility by maintaining valid TSP tours throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on combined objective values and Pareto dominance\n    weights = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        # Lower combined objective is better\n        weights[i] = 1.0 / (1.0 + np.sum(obj))\n        # Boost weight for non-dominated solutions\n        dominated = False\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            weights[i] *= 1.5\n\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate segment quality based on combined distance\n    segment_scores = []\n    for a in range(n):\n        segment_size = max(2, min(n // 2, int(np.random.exponential(scale=2))))\n        b = min(a + segment_size - 1, n - 1)\n        score = 0\n        for i in range(a, b):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            score += distance_matrix_1[u][v] * distance_matrix_2[u][v]\n        segment_scores.append((a, b, score))\n\n    # Select segment to rotate with highest score\n    segment_scores.sort(key=lambda x: -x[2])\n    if segment_scores:\n        a, b, _ = segment_scores[0]\n        rotation = np.random.randint(1, b - a + 1)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Conditional edge insertion\n    if n > 3:\n        # Find edges with high combined distance\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edges.append((i, (i+1)%n, distance_matrix_1[u][v] + distance_matrix_2[u][v]))\n\n        edges.sort(key=lambda x: -x[2])\n        if edges:\n            best_edge = edges[0]\n            c = best_edge[0]\n            d = best_edge[1]\n\n            # Insert a random node between c and d if it improves at least one objective\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                for e in candidates:\n                    temp_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n                    temp_obj1 = sum(distance_matrix_1[temp_solution[i]][temp_solution[(i+1)%n]] for i in range(n))\n                    temp_obj2 = sum(distance_matrix_2[temp_solution[i]][temp_solution[(i+1)%n]] for i in range(n))\n                    if temp_obj1 <= sum(distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]] for i in range(n)) or \\\n                       temp_obj2 <= sum(distance_matrix_2[new_solution[i]][new_solution[(i+1)%n]] for i in range(n)):\n                        new_solution = temp_solution\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.977285410367772,
            1.0264369249343872
        ]
    },
    {
        "algorithm": "This heuristic selects a promising solution from the archive using tournament selection biased toward lower total costs, then applies a hybrid local search combining adaptive segment rotation (with variable segment size and rotation) and probabilistic edge relocation (prioritizing edges with high normalized distance products from both objectives). The method ensures feasibility by maintaining a valid TSP tour throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection with quality bias\n    tournament_size = min(5, len(archive))\n    selected_idx = np.random.choice(len(archive), size=tournament_size, replace=False)\n    selected_idx = selected_idx[np.argmin([np.sum(archive[i][1]) for i in selected_idx])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Probabilistic edge relocation\n    if n > 3:\n        normalized_distances = (distance_matrix_1 + distance_matrix_2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2))\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(normalized_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        if n > 3:\n            candidates = [i for i in range(n) if i not in (c, d)]\n            if candidates:\n                probs = np.array([normalized_distances[new_solution[c]][new_solution[i]] *\n                                normalized_distances[new_solution[i]][new_solution[d]]\n                                for i in candidates])\n                probs = probs / np.sum(probs)\n                e = np.random.choice(candidates, p=probs)\n                new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9310379678551315,
            0.2135852575302124
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive using Pareto-dominance tournament selection, then applies a hybrid local search combining adaptive segment rotation, cost-aware edge insertion, and conditional segment reversal, ensuring feasibility and balanced multi-objective optimization by prioritizing edge weights and improving at least one objective. It intelligently balances exploration and exploitation through probabilistic segment operations and cost-aware selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance tournament selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8948467507881668,
            0.21143871545791626
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto selection with a hybrid local search that prioritizes segment rotation, cost-aware edge insertion, and conditional segment reversal, while ensuring feasibility through probabilistic segment operations and edge weighting. It balances exploration and exploitation by dynamically adjusting segment sizes and using combined distance metrics to guide multi-objective improvements. The method intelligently selects edges and segments based on their potential for reducing tour lengths in both objective spaces, with segment reversal only applied when it improves at least one objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto-based selection\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment rotation with variable segment size\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation = np.random.randint(1, segment_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion with probabilistic selection\n    if n > 3:\n        combined_distances = distance_matrix_1 + distance_matrix_2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = [combined_distances[new_solution[c]][new_solution[i]] +\n                                 combined_distances[new_solution[i]][new_solution[d]]\n                                 for i in candidates]\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.3:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8547295562960665,
            0.20903760194778442
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto-based selection with a hybrid local search that dynamically balances segment rotation, cost-aware edge insertion, and conditional segment reversal, prioritizing solutions with high crowding distance in the Pareto front and using multi-objective improvement criteria to ensure feasible, high-quality solutions. It employs probabilistic segment operations with adaptive sizes and directions, favoring cost-aware edge insertions and conditional reversals when they improve at least one objective without worsening the other. The selection process prioritizes non-dominated solutions, while the local search focuses on improving both objectives through segment manipulation and edge operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive Pareto-based selection with crowding distance\n    tournament_size = min(5, len(archive))\n    selected_indices = np.random.choice(len(archive), size=tournament_size, replace=False)\n    pareto_front = []\n\n    for idx in selected_indices:\n        dominated = False\n        for other_idx in selected_indices:\n            if idx == other_idx:\n                continue\n            if (archive[other_idx][1][0] <= archive[idx][1][0] and archive[other_idx][1][1] <= archive[idx][1][1]) and \\\n               (archive[other_idx][1][0] < archive[idx][1][0] or archive[other_idx][1][1] < archive[idx][1][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(idx)\n\n    if not pareto_front:\n        selected_idx = selected_indices[np.argmin([np.sum(archive[i][1]) for i in selected_indices])]\n    else:\n        # Select solution with highest crowding distance in Pareto front\n        crowding_distances = []\n        for idx in pareto_front:\n            left, right = None, None\n            sorted_solutions = sorted(pareto_front, key=lambda x: archive[x][1][0])\n            pos = sorted_solutions.index(idx)\n            if pos > 0:\n                left = archive[sorted_solutions[pos-1]][1][0]\n            if pos < len(sorted_solutions)-1:\n                right = archive[sorted_solutions[pos+1]][1][0]\n            if left is None:\n                left = archive[sorted_solutions[pos]][1][0]\n            if right is None:\n                right = archive[sorted_solutions[pos]][1][0]\n            cd1 = right - left\n\n            sorted_solutions = sorted(pareto_front, key=lambda x: archive[x][1][1])\n            pos = sorted_solutions.index(idx)\n            if pos > 0:\n                left = archive[sorted_solutions[pos-1]][1][1]\n            if pos < len(sorted_solutions)-1:\n                right = archive[sorted_solutions[pos+1]][1][1]\n            if left is None:\n                left = archive[sorted_solutions[pos]][1][1]\n            if right is None:\n                right = archive[sorted_solutions[pos]][1][1]\n            cd2 = right - left\n\n            crowding_distances.append(cd1 + cd2)\n\n        selected_idx = pareto_front[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rotation with adaptive size and direction\n    segment_size = max(2, min(n // 3, int(np.random.exponential(scale=1.5))))\n    a = np.random.randint(0, n - segment_size + 1)\n    b = a + segment_size - 1\n    rotation_direction = np.random.choice([-1, 1])\n    rotation = np.random.randint(1, segment_size)\n    if rotation_direction == -1:\n        rotation = -rotation\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Cost-aware edge insertion with multi-objective weighting\n    if n > 3:\n        combined_distances = (distance_matrix_1 + distance_matrix_2) / 2\n        edge_weights = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i+1)%n]\n            edge_weights.append(combined_distances[u][v])\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n        selected_edge = np.random.choice(n, p=edge_weights)\n        c = selected_edge\n        d = (selected_edge + 1) % n\n\n        candidates = [i for i in range(n) if i not in (c, d)]\n        if candidates:\n            candidate_distances = []\n            for i in candidates:\n                dist1 = distance_matrix_1[new_solution[c]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[d]]\n                dist2 = distance_matrix_2[new_solution[c]][new_solution[i]] + distance_matrix_2[new_solution[i]][new_solution[d]]\n                candidate_distances.append((dist1 + dist2) / 2)\n\n            candidate_weights = np.array(candidate_distances) / np.sum(candidate_distances)\n            e = np.random.choice(candidates, p=candidate_weights)\n            new_solution = np.concatenate([new_solution[:c+1], new_solution[e:e+1], new_solution[c+1:]])\n\n    # Conditional segment reversal with multi-objective improvement check\n    if n > 4 and np.random.rand() < 0.4:\n        segment_size = max(2, min(n // 4, int(np.random.exponential(scale=1.2))))\n        a = np.random.randint(0, n - segment_size + 1)\n        b = a + segment_size - 1\n\n        original_cost1 = distance_matrix_1[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b]][new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a]][new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b]][new_solution[(b+1)%n]]\n\n        reversed_segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_1[reversed_segment[-1]][new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[reversed_segment[0]][new_solution[(a-1)%n]] + distance_matrix_2[reversed_segment[-1]][new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9351328302931913,
            0.2623704671859741
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive (prioritizing non-dominated ones), then applies a hybrid local search combining segment reversal and dynamic reinsertion of high-scoring segments (based on normalized distance products), while conditionally reversing edges to improve at least one objective. It ensures feasibility by removing duplicates and falls back to random swaps if needed. The algorithm balances exploration (random segment selection) and exploitation (cost-aware edge prioritization) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize non-dominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal + cost-aware edge prioritization\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+2, min(i+10, n)):  # Limit segment length for efficiency\n            segment_length1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length1 += distance_matrix_1[new_solution[j], new_solution[i]] if j+1 < n else 0\n            segment_length2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            segment_length2 += distance_matrix_2[new_solution[j], new_solution[i]] if j+1 < n else 0\n            normalized_score = - (segment_length1 * segment_length2)  # Higher score for shorter segments in both objectives\n            segment_scores.append((normalized_score, i, j))\n\n    if segment_scores:\n        segment_scores.sort(reverse=True)\n        _, best_i, best_j = segment_scores[0]\n        best_segment = new_solution[best_i:best_j+1]\n\n        # Dynamic reinsertion with feasibility check\n        new_pos = random.randint(0, n - len(best_segment))\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            best_segment,\n            new_solution[new_pos:new_pos + len(best_segment)],\n            new_solution[new_pos + len(best_segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = [node for node in range(n) if node not in unique_nodes]\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Conditional edge reversal based on cost improvement\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_length1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_length1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        old_length2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_length2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_length1 < old_length1 or new_length2 < old_length2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Final check and fallback\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9532634060346503,
            3.9698342084884644
        ]
    }
]