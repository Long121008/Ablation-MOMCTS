[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with better objective trade-offs, then applies a hybrid local search combining segment rotation and inversion to generate a neighbor solution while ensuring feasibility. The method intelligently balances exploration and exploitation by randomly selecting segments and rotating them to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select based on objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select based on objective trade-off (better balance between objectives)\n        selected = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search: edge exchange with segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Segment rotation instead of inversion\n        if random.random() < 0.5:\n            new_segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n        else:\n            new_segment = np.concatenate([new_solution[c:d], new_solution[a:b]])\n\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Segment rotation with random rotation amount\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    rotation = random.randint(1, seg_length-1)\n    new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8255608592425827,
            0.4006079435348511
        ]
    },
    {
        "algorithm": "The algorithm prioritizes dominated solutions for exploration, applies a hybrid local search combining segment reversal with node insertion, and uses adaptive segment sizes based on solution quality to generate diverse neighbors while ensuring feasibility. It selects solutions with lower combined objective values more often and adaptively adjusts the segment size for reversal, balancing exploration and exploitation. The hybrid approach ensures both structural changes (reversal) and fine-grained adjustments (insertion) for effective neighborhood exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a dominated solution if possible, otherwise select randomly\n    dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if is_dominated:\n            dominated.append((sol, obj))\n\n    if dominated:\n        selected = random.choice(dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    avg_obj = np.mean([obj[0] + obj[1] for _, obj in archive])\n    current_obj = sum(archive[[sol.tolist() for sol, _ in archive].index(new_solution.tolist())][1])\n    seg_length = max(2, min(5, int(n / (1 + np.exp(-(current_obj - avg_obj))))))\n\n    # Segment reversal\n    seg_start = random.randint(0, n - seg_length)\n    seg_end = seg_start + seg_length\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Node insertion (more disruptive than standard operators)\n    if n > 3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:new_pos],\n                [node],\n                new_solution[new_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6833780356639678,
            0.27279770374298096
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    max_obj = np.max(objectives)\n    if max_obj == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_obj = objectives / max_obj\n        selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dominance status\n    is_dominated = False\n    current_obj = archive[selected_idx][1]\n    for _, other_obj in archive:\n        if other_obj[0] < current_obj[0] and other_obj[1] < current_obj[1]:\n            is_dominated = True\n            break\n\n    # Adaptive multi-segment rotation with objective-aware edge swaps\n    if is_dominated or np.random.random() < 0.3:\n        # Multi-segment rotation for dominated solutions or with probability\n        num_segments = max(2, min(4, int(np.sqrt(n))))\n        segment_length = max(3, n // num_segments)\n        segments = []\n        for i in range(num_segments):\n            start = i * segment_length\n            end = start + segment_length if i < num_segments - 1 else n\n            segments.append(new_solution[start:end])\n\n        # Rotate segments\n        rotation = np.random.randint(1, len(segments))\n        segments = segments[rotation:] + segments[:rotation]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n    else:\n        # Objective-aware edge swaps for non-dominated solutions\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if i + 1 != j:\n                # Check if swap improves both objectives\n                old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or np.random.random() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9895202361095508,
            0.44411444664001465
        ]
    },
    {
        "algorithm": "The algorithm selects a balanced solution from the archive based on objective trade-offs, then applies adaptive segment fusion and node relocation to improve both objectives while maintaining feasibility through dominance checks and validation. It prioritizes solutions with balanced dominance counts and dynamically adjusts segment sizes for effective local search, ensuring only improving and valid solutions are retained.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on balanced dominance counts and objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    tradeoff = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n    selected_idx = np.argmin(tradeoff)  # Prioritize balanced solutions\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment fusion and objective-aware node relocation\n    segment_size = max(2, min(5, int(n * 0.2)))  # Dynamic segment size based on problem size\n    a = np.random.randint(0, n - segment_size)\n    b = a + segment_size\n\n    # Segment fusion\n    fused_segment = new_solution[a:b]\n    if np.random.rand() < 0.5:\n        fused_segment = np.concatenate([fused_segment[:len(fused_segment)//2][::-1], fused_segment[len(fused_segment)//2:][::-1]])\n    else:\n        fused_segment = np.roll(fused_segment, shift=np.random.randint(1, len(fused_segment)))\n\n    # Node relocation to improve both objectives\n    for i in range(len(fused_segment)):\n        node = fused_segment[i]\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue\n            temp_sol = np.concatenate([new_solution[:a], fused_segment[:i], fused_segment[i+1:], new_solution[a:]])\n            temp_sol = np.concatenate([temp_sol[:pos], [node], temp_sol[pos:]])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            improvement = (current_obj[0] - cost1) + (current_obj[1] - cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:a], fused_segment[:i], fused_segment[i+1:], new_solution[a:]])\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Feasibility check\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    # Dominance-aware acceptance\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if not dominates(new_obj, current_obj):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9933009349029832,
            11.680901050567627
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest combined objective values, applies a dynamic segment rotation strategy based on angles derived from node positions in both objective spaces, and then performs a guided edge swap operation to improve both objectives while ensuring feasibility. The rotation prioritizes segments with larger angular differences between objective spaces, while the edge swap considers both objectives to find the most beneficial swap.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment rotation\n    num_segments = max(2, min(5, n // 2))\n    segment_size = n // num_segments\n    for i in range(num_segments):\n        start = i * segment_size\n        end = (i + 1) * segment_size if i < num_segments - 1 else n\n\n        # Calculate rotation angle based on segment positions in both spaces\n        center1 = instance[new_solution[start:end], :2].mean(axis=0)\n        center2 = instance[new_solution[start:end], 2:].mean(axis=0)\n        angle = np.arctan2(center2[1] - center1[1], center2[0] - center1[0])\n\n        # Rotate segment\n        segment = new_solution[start:end]\n        rotated = np.roll(segment, int(len(segment) * (angle / (2 * np.pi))))\n        new_solution[start:end] = rotated\n\n    # Guided edge swap\n    best_swap = None\n    min_cost = float('inf')\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate cost before swap\n            old_cost1 = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            old_cost2 = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            # Calculate cost after swap\n            new_cost1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            # Combined cost improvement\n            cost_diff = (new_cost1 + new_cost2) - (old_cost1 + old_cost2)\n\n            if cost_diff < min_cost:\n                min_cost = cost_diff\n                best_swap = (i, j)\n\n    if best_swap:\n        i, j = best_swap\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.989914612130629,
            4.664077937602997
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive by maximizing the variance of normalized objective values, then applies a clustered segment reversal strategy to break the tour into non-overlapping segments and reverses each segment independently. Finally, it identifies the worst edge based on combined costs from both objective spaces, removes it, and reinserts it at the optimal position to improve both objectives while maintaining feasibility. The algorithm prioritizes diversity in selection and uses a hybrid of structural perturbation (reversal) and edge-based optimization (reinsertion) to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most diverse solution based on objective variance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    variances = np.var(normalized_obj, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Clustered segment reversal\n    num_clusters = max(2, min(5, n // 3))\n    cluster_size = n // num_clusters\n    for i in range(num_clusters):\n        start = i * cluster_size\n        end = (i + 1) * cluster_size if i < num_clusters - 1 else n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Find the worst edge based on combined costs\n    worst_edge = -1\n    max_cost = -1\n    for i in range(n):\n        edge_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        if edge_cost > max_cost:\n            max_cost = edge_cost\n            worst_edge = i\n\n    # Remove and reinsert the worst edge\n    if worst_edge != -1:\n        node1 = new_solution[worst_edge]\n        node2 = new_solution[(worst_edge + 1) % n]\n\n        # Remove the edge\n        new_solution = np.delete(new_solution, worst_edge)\n        new_solution = np.delete(new_solution, (worst_edge + 1) % len(new_solution))\n\n        # Find the best insertion position\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(len(new_solution)):\n            # Insert node1 after position i\n            temp_sol = np.insert(new_solution, i, node1)\n            temp_sol = np.insert(temp_sol, (i + 1) % len(temp_sol), node2)\n\n            # Calculate costs\n            cost1 = 0\n            cost2 = 0\n            for j in range(len(temp_sol)):\n                cost1 += distance_matrix_1[temp_sol[j], temp_sol[(j+1)%len(temp_sol)]]\n                cost2 += distance_matrix_2[temp_sol[j], temp_sol[(j+1)%len(temp_sol)]]\n\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, node1)\n        new_solution = np.insert(new_solution, (best_pos + 1) % len(new_solution), node2)\n\n    return new_solution\n\n",
        "score": [
            -0.983379763777567,
            3.2441552877426147
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward lower individual objective values (weighted by inverse costs) and applies a hybrid local search combining segment reversal, edge exchange, and insertion operations to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with better objective values, while the local search introduces diversity through random segment reversals, edge swaps, and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives (separate weights for each objective)\n    weights = [(1 / (obj1 + 1)) * (1 / (obj2 + 1)) for (_, (obj1, obj2)) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange, segment reversal, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8399713793675228,
            0.44551795721054077
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted sum (70% for the second objective, 30% for the first) and applies a hybrid local search combining segment reversal (with variable-length segments) and node insertion (with adaptive positions). It ensures feasibility by validating node coverage and uses Pareto dominance to accept improvements, prioritizing the second objective while employing a dynamic acceptance criterion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.3, 0.7])\n    weighted_sums = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        segment_length = min(3, n // 4)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        positions = np.random.choice(n, size=3, replace=False)\n        best_pos = positions[0]\n        best_cost = float('inf')\n\n        for pos in positions:\n            if pos == i:\n                continue\n            temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = 0.3 * cost1 + 0.7 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    current_obj = archive[selected_idx][1]\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if not dominates(new_obj, current_obj):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.977043928416031,
            0.6142610311508179
        ]
    },
    {
        "algorithm": "This algorithm selects the most promising solution from the archive by normalizing and summing its objectives, then applies a hybrid local search combining segment reversal (70% chance) or node insertion (30% chance) with dynamic segment lengths and multiple insertion positions. It ensures feasibility by validating node coverage and uses Pareto dominance to accept only improving solutions, reverting to the original if no improvement is found. The algorithm prioritizes high-potential solutions while maintaining tour validity through novel mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    sums = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with novel mechanisms\n    if np.random.rand() < 0.7:\n        # Segment reversal with dynamic segment length\n        segment_length = min(3, n // 2)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Node insertion with multiple positions\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        positions = np.random.choice(n, size=3, replace=False)\n        best_pos = positions[0]\n        best_cost = float('inf')\n\n        for pos in positions:\n            if pos == i:\n                continue\n            temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    # Novel acceptance criterion: Pareto dominance check\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    current_obj = archive[selected_idx][1]\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if not dominates(new_obj, current_obj):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9267586408443391,
            0.5547756552696228
        ]
    }
]