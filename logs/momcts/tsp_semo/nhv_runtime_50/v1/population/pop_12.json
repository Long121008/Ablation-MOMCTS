[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid metric combining objective diversity and dominance count, then applies a multi-segment inversion strategy with dynamic segment sizes and adaptive edge swaps to generate a neighbor solution while ensuring feasibility through validation checks. It prioritizes solutions with high diversity and low dominance, and focuses on segments that show significant potential for improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine diversity and dominance count\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n\n    # Calculate dominance count (number of solutions dominated by each solution)\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance[i] += 1\n\n    # Combine metrics with adaptive weights\n    combined_score = 0.7 * diversity + 0.3 * (1 / (1 + dominance))\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with dynamic segment size\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_sizes = np.random.randint(2, n//2, size=num_segments)\n    segment_starts = np.random.choice(range(n), size=num_segments, replace=False)\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = (start + size) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate segment's contribution to both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Calculate potential improvement\n        if len(segment) >= 3:\n            potential_cost1 = distance_matrix_1[segment[0], segment[-1]] + \\\n                             sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            potential_cost2 = distance_matrix_2[segment[0], segment[-1]] + \\\n                             sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert segment if it improves both objectives with margin\n            if (potential_cost1 < 0.95 * segment_cost1) and (potential_cost2 < 0.95 * segment_cost2):\n                if start < end:\n                    new_solution[start:end] = segment[::-1]\n                else:\n                    inverted = segment[::-1]\n                    new_solution[start:] = inverted[:n-start]\n                    new_solution[:end] = inverted[n-start:]\n\n    # Adaptive edge swap with objective-aware selection\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Accept swap if it improves both objectives with margin\n            if (new_cost1 < 0.98 * old_cost1) and (new_cost2 < 0.98 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Final validation check\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9630460548280968,
            11.859996676445007
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution (preferring non-dominated ones) from the archive, then applies a hybrid local search combining edge exchange (randomly swapping and inverting segments) and random segment inversion to generate a neighbor solution while ensuring feasibility. The method prioritizes non-dominated solutions for exploration and uses a mix of standard and novel operators to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select randomly\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected = random.choice(non_dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine edge exchange and random segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (similar to 2-opt but more general)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are valid and don't overlap in a way that breaks the tour\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Create new segments\n        new_segment = np.concatenate([new_solution[a:b], new_solution[c:d][::-1]])\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Random segment inversion (local improvement)\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8669746667714558,
            0.4785269498825073
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with higher normalized costs (sum of normalized objectives), then applies a hybrid local search combining random segment reversal to generate a neighbor solution while ensuring feasibility. It selects two random non-overlapping segments, reverses them, and checks if the solution remains valid. The selection criterion and segment-based local search are the key design choices.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    sums = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Ensure segments don't overlap\n    if a < c < b:\n        c = b\n    if a < d < b:\n        d = b\n\n    # Reverse the selected segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9152994955339191,
            0.4816514253616333
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward lower individual objective values (weighted by inverse costs) and applies a hybrid local search combining segment reversal, edge exchange, and insertion operations to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with better objective values, while the local search introduces diversity through random segment reversals, edge swaps, and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives (separate weights for each objective)\n    weights = [(1 / (obj1 + 1)) * (1 / (obj2 + 1)) for (_, (obj1, obj2)) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange, segment reversal, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8399713793675228,
            0.44551795721054077
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on objective diversity, then applies a hybrid local search combining segment reversal and adaptive edge swaps to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with diverse objectives and uses distance matrices to evaluate improvements in both objective spaces. The segment reversal and limited adaptive swaps balance exploration and exploitation to improve the tour's quality across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by objective diversity (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        diversity_scores = normalized_obj.sum(axis=1)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with adaptive edge swaps\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution  # Too small to improve\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, min(start + 8, n))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swaps based on distance reduction\n    for _ in range(3):  # Limit the number of swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Swap if both objectives improve or one improves significantly\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2) or \\\n           (potential_cost1 * 0.9 < current_cost1 and potential_cost2 * 0.9 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.901249805272273,
            0.5561956167221069
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with high objective diversity (product of normalized costs) to explore less-explored regions of the Pareto front, then applies a hybrid local search combining adaptive segment inversion (reversing segments that improve both objectives) and context-aware edge insertion (swapping edges that reduce both costs), ensuring feasibility through validation. The selection strategy focuses on diversity, while the local search dynamically balances exploitation of promising segments with exploration of edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity (product of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive segment inversion + context-aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n\n    # Calculate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert segment if it improves both objectives\n    if segment_cost1 > distance_matrix_1[segment[0], segment[-1]] and segment_cost2 > distance_matrix_2[segment[0], segment[-1]]:\n        new_solution[a:b+1] = segment[::-1]\n\n    # Context-aware edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j and abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n        # Calculate potential edge costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Insert edge if it improves both objectives\n        if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8619623024943197,
            0.5111284255981445
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of normalized objective values (prioritizing the first objective with 0.7 weight), then applies a hybrid local search combining segment rotation (reversing segments if both objectives improve) and context-aware node relocation (moving nodes if both objectives improve). It ensures feasibility by validating the solution and reverting to the original if invalid. The design prioritizes balanced improvement across objectives while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective diversity (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    weighted_diversity = np.sum(normalized_obj * np.array([0.7, 0.3]), axis=1)\n    selected_idx = np.argmax(weighted_diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive segment rotation + context-aware node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n\n    # Calculate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Rotate segment if it improves both objectives\n    rotation_cost1 = sum(distance_matrix_1[segment[(i+1)%len(segment)], segment[i]] for i in range(len(segment)))\n    rotation_cost2 = sum(distance_matrix_2[segment[(i+1)%len(segment)], segment[i]] for i in range(len(segment)))\n\n    if rotation_cost1 < segment_cost1 and rotation_cost2 < segment_cost2:\n        new_solution[a:b+1] = segment[::-1]\n\n    # Context-aware node relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        # Calculate potential relocation costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Relocate node if it improves both objectives\n        if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8733554199113087,
            0.5279737114906311
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward better objectives (weighted by normalized objective values), then applies a hybrid local search combining edge insertion, partial route reversal, and edge swaps, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with lower combined objectives, while the local search introduces diversity through probabilistic segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives\n    objectives = np.array([(obj1 + obj2) for (_, (obj1, obj2)) in archive])\n    min_obj, max_obj = np.min(objectives), np.max(objectives)\n    if max_obj == min_obj:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized = (max_obj - objectives) / (max_obj - min_obj)\n        weights = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(range(len(archive)), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and partial route reversal\n    if n > 3:\n        # Randomly select a segment and insert it at a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Randomly reverse a segment with probability 0.3\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly swap two non-adjacent edges with probability 0.5\n        if random.random() < 0.5 and n > 3:\n            i, j = sorted(random.sample(range(n), 2))\n            if abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7078935027097926,
            0.4606529474258423
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on high objective diversity and low combined objectives, then applies a hybrid local search combining adaptive segment inversion and context-aware edge insertion, prioritizing moves that improve both objectives while maintaining feasibility through segment reversals and edge swaps. The selection strategy balances exploration and exploitation, and the local search ensures valid TSP tours by validating all changes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity and low combined objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n    combined_obj = np.sum(objectives, axis=1)\n    weights = diversity / (combined_obj + 1)\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    for _ in range(2):  # Try multiple segment inversions\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Calculate segment's contribution to both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Invert segment if it improves both objectives\n        if segment_cost1 > distance_matrix_1[segment[0], segment[-1]] and segment_cost2 > distance_matrix_2[segment[0], segment[-1]]:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Context-aware edge insertion\n    for _ in range(3):  # Try multiple edge insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n            # Calculate potential edge costs\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Insert edge if it improves both objectives\n            if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Or if it improves one objective but not the other, with some probability\n            elif (new_cost1 < old_cost1 or new_cost2 < old_cost2) and np.random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Random segment reversal for diversity\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Random edge swap for diversity\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8411066836688412,
            0.5418779850006104
        ]
    }
]