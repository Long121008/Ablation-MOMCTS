[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution (preferring non-dominated ones) from the archive, then applies a hybrid local search combining edge exchange (randomly swapping and inverting segments) and random segment inversion to generate a neighbor solution while ensuring feasibility. The method prioritizes non-dominated solutions for exploration and uses a mix of standard and novel operators to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select randomly\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected = random.choice(non_dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine edge exchange and random segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (similar to 2-opt but more general)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are valid and don't overlap in a way that breaks the tour\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Create new segments\n        new_segment = np.concatenate([new_solution[a:b], new_solution[c:d][::-1]])\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Random segment inversion (local improvement)\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8669746667714558,
            0.4785269498825073
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with higher normalized costs (sum of normalized objectives), then applies a hybrid local search combining random segment reversal to generate a neighbor solution while ensuring feasibility. It selects two random non-overlapping segments, reverses them, and checks if the solution remains valid. The selection criterion and segment-based local search are the key design choices.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    sums = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Ensure segments don't overlap\n    if a < c < b:\n        c = b\n    if a < d < b:\n        d = b\n\n    # Reverse the selected segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9152994955339191,
            0.4816514253616333
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward lower individual objective values (weighted by inverse costs) and applies a hybrid local search combining segment reversal, edge exchange, and insertion operations to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with better objective values, while the local search introduces diversity through random segment reversals, edge swaps, and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives (separate weights for each objective)\n    weights = [(1 / (obj1 + 1)) * (1 / (obj2 + 1)) for (_, (obj1, obj2)) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange, segment reversal, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8399713793675228,
            0.44551795721054077
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on objective diversity, then applies a hybrid local search combining segment reversal and adaptive edge swaps to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with diverse objectives and uses distance matrices to evaluate improvements in both objective spaces. The segment reversal and limited adaptive swaps balance exploration and exploitation to improve the tour's quality across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by objective diversity (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        diversity_scores = normalized_obj.sum(axis=1)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with adaptive edge swaps\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution  # Too small to improve\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, min(start + 8, n))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive edge swaps based on distance reduction\n    for _ in range(3):  # Limit the number of swaps\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Swap if both objectives improve or one improves significantly\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2) or \\\n           (potential_cost1 * 0.9 < current_cost1 and potential_cost2 * 0.9 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.901249805272273,
            0.5561956167221069
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with high objective diversity (product of normalized costs) to explore less-explored regions of the Pareto front, then applies a hybrid local search combining adaptive segment inversion (reversing segments that improve both objectives) and context-aware edge insertion (swapping edges that reduce both costs), ensuring feasibility through validation. The selection strategy focuses on diversity, while the local search dynamically balances exploitation of promising segments with exploration of edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity (product of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive segment inversion + context-aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n\n    # Calculate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert segment if it improves both objectives\n    if segment_cost1 > distance_matrix_1[segment[0], segment[-1]] and segment_cost2 > distance_matrix_2[segment[0], segment[-1]]:\n        new_solution[a:b+1] = segment[::-1]\n\n    # Context-aware edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j and abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n        # Calculate potential edge costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Insert edge if it improves both objectives\n        if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8619623024943197,
            0.5111284255981445
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward better objectives (weighted by normalized objective values), then applies a hybrid local search combining edge insertion, partial route reversal, and edge swaps, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with lower combined objectives, while the local search introduces diversity through probabilistic segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives\n    objectives = np.array([(obj1 + obj2) for (_, (obj1, obj2)) in archive])\n    min_obj, max_obj = np.min(objectives), np.max(objectives)\n    if max_obj == min_obj:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized = (max_obj - objectives) / (max_obj - min_obj)\n        weights = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(range(len(archive)), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and partial route reversal\n    if n > 3:\n        # Randomly select a segment and insert it at a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Randomly reverse a segment with probability 0.3\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly swap two non-adjacent edges with probability 0.5\n        if random.random() < 0.5 and n > 3:\n            i, j = sorted(random.sample(range(n), 2))\n            if abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7078935027097926,
            0.4606529474258423
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (weighted by equal costs in both objectives) and applies a hybrid local search: first performing a random 2-opt move, then identifying and reinserting the worst edge (based on combined costs) into the most promising position to improve both objectives. The method ensures feasibility by maintaining a valid tour structure throughout.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]\n    for i, (sol, obj) in enumerate(archive[1:]):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i + 1\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a random 2-opt move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Novel edge insertion: identify the worst edge in both spaces and reinsert it\n    def compute_tour_cost(sol, matrix):\n        cost = 0\n        for i in range(n):\n            cost += matrix[sol[i], sol[(i+1)%n]]\n        return cost\n\n    cost1 = compute_tour_cost(new_solution, distance_matrix_1)\n    cost2 = compute_tour_cost(new_solution, distance_matrix_2)\n\n    worst_edge = -1\n    max_cost = -1\n    for i in range(n):\n        edge_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        if edge_cost > max_cost:\n            max_cost = edge_cost\n            worst_edge = i\n\n    # Remove the worst edge and reinsert it in a better position\n    if worst_edge != -1:\n        node1 = new_solution[worst_edge]\n        node2 = new_solution[(worst_edge + 1) % n]\n\n        # Remove the edge\n        new_solution = np.delete(new_solution, worst_edge)\n        new_solution = np.delete(new_solution, (worst_edge + 1) % len(new_solution))\n\n        # Find the best insertion position\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(len(new_solution)):\n            # Insert node1 after position i\n            temp_sol = np.insert(new_solution, i, node1)\n            temp_sol = np.insert(temp_sol, (i + 1) % len(temp_sol), node2)\n            temp_cost1 = compute_tour_cost(temp_sol, distance_matrix_1)\n            temp_cost2 = compute_tour_cost(temp_sol, distance_matrix_2)\n            total_cost = weights[0] * temp_cost1 + weights[1] * temp_cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, node1)\n        new_solution = np.insert(new_solution, (best_pos + 1) % len(new_solution), node2)\n\n    return new_solution\n\n",
        "score": [
            -0.8366191206722238,
            3.1239725947380066
        ]
    }
]