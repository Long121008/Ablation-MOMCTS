[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with better objective trade-offs, then applies a hybrid local search combining segment rotation and inversion to generate a neighbor solution while ensuring feasibility. The method intelligently balances exploration and exploitation by randomly selecting segments and rotating them to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select based on objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select based on objective trade-off (better balance between objectives)\n        selected = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search: edge exchange with segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Segment rotation instead of inversion\n        if random.random() < 0.5:\n            new_segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n        else:\n            new_segment = np.concatenate([new_solution[c:d], new_solution[a:b]])\n\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Segment rotation with random rotation amount\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    rotation = random.randint(1, seg_length-1)\n    new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8255608592425827,
            0.4006079435348511
        ]
    },
    {
        "algorithm": "The algorithm prioritizes dominated solutions for exploration, applies a hybrid local search combining segment reversal with node insertion, and uses adaptive segment sizes based on solution quality to generate diverse neighbors while ensuring feasibility. It selects solutions with lower combined objective values more often and adaptively adjusts the segment size for reversal, balancing exploration and exploitation. The hybrid approach ensures both structural changes (reversal) and fine-grained adjustments (insertion) for effective neighborhood exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a dominated solution if possible, otherwise select randomly\n    dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if is_dominated:\n            dominated.append((sol, obj))\n\n    if dominated:\n        selected = random.choice(dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    avg_obj = np.mean([obj[0] + obj[1] for _, obj in archive])\n    current_obj = sum(archive[[sol.tolist() for sol, _ in archive].index(new_solution.tolist())][1])\n    seg_length = max(2, min(5, int(n / (1 + np.exp(-(current_obj - avg_obj))))))\n\n    # Segment reversal\n    seg_start = random.randint(0, n - seg_length)\n    seg_end = seg_start + seg_length\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Node insertion (more disruptive than standard operators)\n    if n > 3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:new_pos],\n                [node],\n                new_solution[new_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6833780356639678,
            0.27279770374298096
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    max_obj = np.max(objectives)\n    if max_obj == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_obj = objectives / max_obj\n        selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dominance status\n    is_dominated = False\n    current_obj = archive[selected_idx][1]\n    for _, other_obj in archive:\n        if other_obj[0] < current_obj[0] and other_obj[1] < current_obj[1]:\n            is_dominated = True\n            break\n\n    # Adaptive multi-segment rotation with objective-aware edge swaps\n    if is_dominated or np.random.random() < 0.3:\n        # Multi-segment rotation for dominated solutions or with probability\n        num_segments = max(2, min(4, int(np.sqrt(n))))\n        segment_length = max(3, n // num_segments)\n        segments = []\n        for i in range(num_segments):\n            start = i * segment_length\n            end = start + segment_length if i < num_segments - 1 else n\n            segments.append(new_solution[start:end])\n\n        # Rotate segments\n        rotation = np.random.randint(1, len(segments))\n        segments = segments[rotation:] + segments[:rotation]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n    else:\n        # Objective-aware edge swaps for non-dominated solutions\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if i + 1 != j:\n                # Check if swap improves both objectives\n                old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or np.random.random() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9895202361095508,
            0.44411444664001465
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum of objectives (60% first objective, 40% second), then applies a hybrid local search combining segment reversal (with dynamic length) and node insertion (with multiple positions). It ensures feasibility by validating node coverage and uses Pareto dominance to accept improvements. The approach prioritizes the first objective while maintaining diversity through weighted selection and novel acceptance criteria.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest weighted sum of objectives (different weights)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])  # Different weights for objectives\n    weighted_sums = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with different probabilities and mechanisms\n    if np.random.rand() < 0.6:  # Different probability\n        # Segment reversal with dynamic segment length (different range)\n        segment_length = min(4, n // 3)  # Different length calculation\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Node insertion with different number of positions\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        positions = np.random.choice(n, size=5, replace=False)  # Different number of positions\n        best_pos = positions[0]\n        best_cost = float('inf')\n\n        for pos in positions:\n            if pos == i:\n                continue\n            temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2  # Different cost calculation (weighted sum)\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    # Novel acceptance criterion: Pareto dominance check with different condition\n    def dominates(a, b):\n        return (a[0] < b[0] and a[1] < b[1])  # Strictly better in both objectives\n\n    current_obj = archive[selected_idx][1]\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if not dominates(new_obj, current_obj):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9761289683205986,
            0.6018286943435669
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward lower individual objective values (weighted by inverse costs) and applies a hybrid local search combining segment reversal, edge exchange, and insertion operations to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with better objective values, while the local search introduces diversity through random segment reversals, edge swaps, and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives (separate weights for each objective)\n    weights = [(1 / (obj1 + 1)) * (1 / (obj2 + 1)) for (_, (obj1, obj2)) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange, segment reversal, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8399713793675228,
            0.44551795721054077
        ]
    },
    {
        "algorithm": "This algorithm selects the most promising solution from the archive by normalizing and summing its objectives, then applies a hybrid local search combining segment reversal (70% chance) or node insertion (30% chance) with dynamic segment lengths and multiple insertion positions. It ensures feasibility by validating node coverage and uses Pareto dominance to accept only improving solutions, reverting to the original if no improvement is found. The algorithm prioritizes high-potential solutions while maintaining tour validity through novel mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    sums = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with novel mechanisms\n    if np.random.rand() < 0.7:\n        # Segment reversal with dynamic segment length\n        segment_length = min(3, n // 2)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Node insertion with multiple positions\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        positions = np.random.choice(n, size=3, replace=False)\n        best_pos = positions[0]\n        best_cost = float('inf')\n\n        for pos in positions:\n            if pos == i:\n                continue\n            temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    # Novel acceptance criterion: Pareto dominance check\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    current_obj = archive[selected_idx][1]\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if not dominates(new_obj, current_obj):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9267586408443391,
            0.5547756552696228
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high normalized costs in the first objective, then applies a hybrid local search (edge exchange or segment reversal) to generate a neighbor while ensuring feasibility by checking for duplicate nodes. The method balances exploration and exploitation by randomly choosing between edge exchange and segment reversal, and reverts to the original solution if invalidity is detected.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest normalized cost in the first objective\n    objectives = np.array([obj[0] for _, obj in archive])\n    max_obj = np.max(objectives)\n    if max_obj == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_obj = objectives / max_obj\n        selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange and segment reversal\n    if np.random.random() < 0.5:\n        # Edge exchange\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i + 1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8828759611804771,
            0.45358389616012573
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective values from the archive, then applies a hybrid local search (60% 3-exchange, 40% edge swap) to generate a neighbor while ensuring the solution remains valid. It prioritizes solutions with larger objective sums and uses a randomized yet structured neighborhood exploration to balance diversity and improvement potential.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    objectives = np.array([obj for _, obj in archive])\n    sums = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-exchange and edge swap\n    if np.random.rand() < 0.6:\n        # 3-exchange\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n    else:\n        # Edge swap\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9190864967431429,
            0.47098636627197266
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by balancing objective diversity and performance, then applies a hybrid local search combining adaptive edge swapping (60% chance) and limited-length segment reversal with probabilistic node relinking (40% chance), ensuring feasibility through strict validation. It prioritizes diversity in selection and uses controlled randomization in local search to explore the solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-10)\n    diversity = np.std(normalized_obj, axis=0)\n    weights = np.random.dirichlet([1, 1] + diversity.tolist())\n    scores = np.dot(normalized_obj, weights[:-2]) + weights[-2] * diversity[0] + weights[-1] * diversity[1]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if np.random.random() < 0.6:\n        # Adaptive edge swapping\n        i, j = np.random.choice(n, size=2, replace=False)\n        a, b = np.random.choice(n, size=2, replace=False)\n        if i != a and j != b:\n            new_solution[[i, j, a, b]] = new_solution[[a, b, i, j]]\n    else:\n        # Limited-length segment reversal with probabilistic node relinking\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        reversal_length = min(b - a, 3)\n        new_solution[a:a+reversal_length] = new_solution[a:a+reversal_length][::-1]\n        if np.random.random() < 0.3:\n            # Relink with another node\n            k = np.random.randint(0, n)\n            if k not in new_solution[a:a+reversal_length]:\n                new_solution = np.insert(np.delete(new_solution, k), a, new_solution[k])\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6824421194051018,
            0.4996347427368164
        ]
    }
]