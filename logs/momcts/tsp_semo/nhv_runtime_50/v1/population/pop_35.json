[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with better objective trade-offs, then applies a hybrid local search combining segment rotation and inversion to generate a neighbor solution while ensuring feasibility. The method intelligently balances exploration and exploitation by randomly selecting segments and rotating them to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select based on objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select based on objective trade-off (better balance between objectives)\n        selected = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search: edge exchange with segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Segment rotation instead of inversion\n        if random.random() < 0.5:\n            new_segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n        else:\n            new_segment = np.concatenate([new_solution[c:d], new_solution[a:b]])\n\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Segment rotation with random rotation amount\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    rotation = random.randint(1, seg_length-1)\n    new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8255608592425827,
            0.4006079435348511
        ]
    },
    {
        "algorithm": "The algorithm prioritizes dominated solutions for exploration, applies a hybrid local search combining segment reversal with node insertion, and uses adaptive segment sizes based on solution quality to generate diverse neighbors while ensuring feasibility. It selects solutions with lower combined objective values more often and adaptively adjusts the segment size for reversal, balancing exploration and exploitation. The hybrid approach ensures both structural changes (reversal) and fine-grained adjustments (insertion) for effective neighborhood exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a dominated solution if possible, otherwise select randomly\n    dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if is_dominated:\n            dominated.append((sol, obj))\n\n    if dominated:\n        selected = random.choice(dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    avg_obj = np.mean([obj[0] + obj[1] for _, obj in archive])\n    current_obj = sum(archive[[sol.tolist() for sol, _ in archive].index(new_solution.tolist())][1])\n    seg_length = max(2, min(5, int(n / (1 + np.exp(-(current_obj - avg_obj))))))\n\n    # Segment reversal\n    seg_start = random.randint(0, n - seg_length)\n    seg_end = seg_start + seg_length\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Node insertion (more disruptive than standard operators)\n    if n > 3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:new_pos],\n                [node],\n                new_solution[new_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6833780356639678,
            0.27279770374298096
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    max_obj = np.max(objectives)\n    if max_obj == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_obj = objectives / max_obj\n        selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dominance status\n    is_dominated = False\n    current_obj = archive[selected_idx][1]\n    for _, other_obj in archive:\n        if other_obj[0] < current_obj[0] and other_obj[1] < current_obj[1]:\n            is_dominated = True\n            break\n\n    # Adaptive multi-segment rotation with objective-aware edge swaps\n    if is_dominated or np.random.random() < 0.3:\n        # Multi-segment rotation for dominated solutions or with probability\n        num_segments = max(2, min(4, int(np.sqrt(n))))\n        segment_length = max(3, n // num_segments)\n        segments = []\n        for i in range(num_segments):\n            start = i * segment_length\n            end = start + segment_length if i < num_segments - 1 else n\n            segments.append(new_solution[start:end])\n\n        # Rotate segments\n        rotation = np.random.randint(1, len(segments))\n        segments = segments[rotation:] + segments[:rotation]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n    else:\n        # Objective-aware edge swaps for non-dominated solutions\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if i + 1 != j:\n                # Check if swap improves both objectives\n                old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or np.random.random() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9895202361095508,
            0.44411444664001465
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on balanced dominance and diversity, then applies an adaptive multi-segment perturbation followed by objective-aware edge swaps to generate a neighbor solution while ensuring feasibility. It prioritizes segments of the tour for transformation based on the trade-off between objectives, and uses randomized edge swaps that favor improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced dominance and diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.std(normalized_obj, axis=0)\n    selected_idx = np.argmax(np.sum(normalized_obj * diversity, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive multi-segment perturbation\n    num_segments = max(2, min(5, int(np.sqrt(n))))\n    segment_size = max(3, n // num_segments)\n    for i in range(num_segments):\n        start = i * segment_size\n        end = min(start + segment_size, n)\n        segment = new_solution[start:end]\n\n        # Adaptive transformation based on objective trade-off\n        obj1_trade = objectives[selected_idx][0] / (objectives[selected_idx][0] + objectives[selected_idx][1])\n        if np.random.rand() < obj1_trade:\n            segment = segment[::-1]\n        else:\n            shift = np.random.randint(1, len(segment))\n            segment = np.roll(segment, shift)\n\n        new_solution[start:end] = segment\n\n    # Objective-aware edge swaps\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i + 1 != j:\n            # Check if swap improves both objectives\n            old_dist1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n            old_dist2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n            if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or np.random.random() < 0.1:\n                new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0297552063095865,
            0.579038143157959
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid of Pareto dominance and objective diversity, then applies a multi-segment perturbation and adaptive node insertion strategy to generate neighbors that improve both objectives while ensuring feasibility through geometric validation and constraint-aware acceptance criteria. It prioritizes solutions with higher diversity in normalized objectives and uses segment-based transformations followed by adaptive node insertions to explore the solution space efficiently. The algorithm strictly enforces feasibility by reverting to the original solution if any changes violate constraints or excessively degrade performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.std(normalized_obj, axis=0)\n    selected_idx = np.argmax(np.sum(normalized_obj * diversity, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment perturbation\n    num_segments = max(2, min(4, int(np.sqrt(n))))\n    segment_size = n // num_segments\n    for i in range(num_segments):\n        start = i * segment_size\n        end = (i + 1) * segment_size if i < num_segments - 1 else n\n        segment = new_solution[start:end]\n\n        # Adaptive segment transformation\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        else:\n            shift = np.random.randint(1, len(segment))\n            segment = np.roll(segment, shift)\n\n        new_solution[start:end] = segment\n\n    # Adaptive node insertion\n    for _ in range(min(3, n // 5)):\n        node = np.random.choice(new_solution)\n        temp_sol = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        best_pos = -1\n        best_score = -np.inf\n\n        for pos in range(len(temp_sol)):\n            candidate = np.insert(temp_sol, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            score = - (cost1 + cost2)\n\n            if score > best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Geometric validation\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    # Constraint-aware acceptance\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if new_obj1 > current_obj[0] * 1.05 or new_obj2 > current_obj[1] * 1.05:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9949181247777155,
            8.27187031507492
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on the minimum sum of normalized objectives, then applies a hybrid local search combining segment reversal (80% probability) and node insertion (50% probability) to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with better combined performance, while the local search explores the solution space by modifying segments and nodes intelligently. The algorithm ensures feasibility by validating all operations and maintaining the TSP tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimum sum of normalized objectives\n    if len(archive) > 1:\n        max_obj1 = max(x[1][0] for x in archive)\n        max_obj2 = max(x[1][1] for x in archive)\n        selected = min(archive, key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node insertion\n    a, b = sorted(random.sample(range(n), 2))\n    seg_length = b - a\n\n    if seg_length > 1:\n        # Reverse segment with 80% probability\n        if random.random() < 0.8:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Insert a node from segment to another position with 50% probability\n        if seg_length > 2 and random.random() < 0.5:\n            node_pos = random.randint(a, b-1)\n            new_pos = random.randint(0, n-1)\n            if new_pos < a or new_pos >= b:\n                node = new_solution[node_pos]\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6688392028984823,
            0.4337157607078552
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with balanced objectives) and applies a novel local search combining segment reversal and node displacement to generate a neighbor solution while ensuring feasibility. It reverses segments with a 70% probability and displaces nodes within segments with a 60% probability, while carefully handling edge cases to maintain valid TSP tours. The selection criteria and local search operators are designed to balance exploration and exploitation for multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off or random if no clear trade-off\n    if len(archive) > 1:\n        selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Novel local search: segment reversal with node displacement\n    a, b = sorted(random.sample(range(n), 2))\n    seg_length = b - a\n\n    if seg_length > 1:\n        # Reverse segment with probability\n        if random.random() < 0.7:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Displace a node from segment to another position\n        if seg_length > 2 and random.random() < 0.6:\n            node_pos = random.randint(a, b-1)\n            new_pos = random.randint(0, n-1)\n            if new_pos < a or new_pos >= b:\n                node = new_solution[node_pos]\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9607896867938261,
            0.4578489065170288
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest combined objective values, applies a dynamic segment rotation strategy based on angles derived from node positions in both objective spaces, and then performs a guided edge swap operation to improve both objectives while ensuring feasibility. The rotation prioritizes segments with larger angular differences between objective spaces, while the edge swap considers both objectives to find the most beneficial swap.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective values\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment rotation\n    num_segments = max(2, min(5, n // 2))\n    segment_size = n // num_segments\n    for i in range(num_segments):\n        start = i * segment_size\n        end = (i + 1) * segment_size if i < num_segments - 1 else n\n\n        # Calculate rotation angle based on segment positions in both spaces\n        center1 = instance[new_solution[start:end], :2].mean(axis=0)\n        center2 = instance[new_solution[start:end], 2:].mean(axis=0)\n        angle = np.arctan2(center2[1] - center1[1], center2[0] - center1[0])\n\n        # Rotate segment\n        segment = new_solution[start:end]\n        rotated = np.roll(segment, int(len(segment) * (angle / (2 * np.pi))))\n        new_solution[start:end] = rotated\n\n    # Guided edge swap\n    best_swap = None\n    min_cost = float('inf')\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate cost before swap\n            old_cost1 = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            old_cost2 = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            # Calculate cost after swap\n            new_cost1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n            # Combined cost improvement\n            cost_diff = (new_cost1 + new_cost2) - (old_cost1 + old_cost2)\n\n            if cost_diff < min_cost:\n                min_cost = cost_diff\n                best_swap = (i, j)\n\n    if best_swap:\n        i, j = best_swap\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.989914612130629,
            4.664077937602997
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive by maximizing the variance of normalized objective values, then applies a clustered segment reversal strategy to break the tour into non-overlapping segments and reverses each segment independently. Finally, it identifies the worst edge based on combined costs from both objective spaces, removes it, and reinserts it at the optimal position to improve both objectives while maintaining feasibility. The algorithm prioritizes diversity in selection and uses a hybrid of structural perturbation (reversal) and edge-based optimization (reinsertion) to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most diverse solution based on objective variance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    variances = np.var(normalized_obj, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Clustered segment reversal\n    num_clusters = max(2, min(5, n // 3))\n    cluster_size = n // num_clusters\n    for i in range(num_clusters):\n        start = i * cluster_size\n        end = (i + 1) * cluster_size if i < num_clusters - 1 else n\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Find the worst edge based on combined costs\n    worst_edge = -1\n    max_cost = -1\n    for i in range(n):\n        edge_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        if edge_cost > max_cost:\n            max_cost = edge_cost\n            worst_edge = i\n\n    # Remove and reinsert the worst edge\n    if worst_edge != -1:\n        node1 = new_solution[worst_edge]\n        node2 = new_solution[(worst_edge + 1) % n]\n\n        # Remove the edge\n        new_solution = np.delete(new_solution, worst_edge)\n        new_solution = np.delete(new_solution, (worst_edge + 1) % len(new_solution))\n\n        # Find the best insertion position\n        best_pos = 0\n        min_cost = float('inf')\n        for i in range(len(new_solution)):\n            # Insert node1 after position i\n            temp_sol = np.insert(new_solution, i, node1)\n            temp_sol = np.insert(temp_sol, (i + 1) % len(temp_sol), node2)\n\n            # Calculate costs\n            cost1 = 0\n            cost2 = 0\n            for j in range(len(temp_sol)):\n                cost1 += distance_matrix_1[temp_sol[j], temp_sol[(j+1)%len(temp_sol)]]\n                cost2 += distance_matrix_2[temp_sol[j], temp_sol[(j+1)%len(temp_sol)]]\n\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, node1)\n        new_solution = np.insert(new_solution, (best_pos + 1) % len(new_solution), node2)\n\n    return new_solution\n\n",
        "score": [
            -0.983379763777567,
            3.2441552877426147
        ]
    }
]