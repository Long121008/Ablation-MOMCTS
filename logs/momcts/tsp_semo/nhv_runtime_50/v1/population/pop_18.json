[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with better objective trade-offs, then applies a hybrid local search combining segment rotation and inversion to generate a neighbor solution while ensuring feasibility. The method intelligently balances exploration and exploitation by randomly selecting segments and rotating them to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select based on objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select based on objective trade-off (better balance between objectives)\n        selected = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search: edge exchange with segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Segment rotation instead of inversion\n        if random.random() < 0.5:\n            new_segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n        else:\n            new_segment = np.concatenate([new_solution[c:d], new_solution[a:b]])\n\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Segment rotation with random rotation amount\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    rotation = random.randint(1, seg_length-1)\n    new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8255608592425827,
            0.4006079435348511
        ]
    },
    {
        "algorithm": "The algorithm prioritizes dominated solutions for exploration, applies a hybrid local search combining segment reversal with node insertion, and uses adaptive segment sizes based on solution quality to generate diverse neighbors while ensuring feasibility. It selects solutions with lower combined objective values more often and adaptively adjusts the segment size for reversal, balancing exploration and exploitation. The hybrid approach ensures both structural changes (reversal) and fine-grained adjustments (insertion) for effective neighborhood exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a dominated solution if possible, otherwise select randomly\n    dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if is_dominated:\n            dominated.append((sol, obj))\n\n    if dominated:\n        selected = random.choice(dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    avg_obj = np.mean([obj[0] + obj[1] for _, obj in archive])\n    current_obj = sum(archive[[sol.tolist() for sol, _ in archive].index(new_solution.tolist())][1])\n    seg_length = max(2, min(5, int(n / (1 + np.exp(-(current_obj - avg_obj))))))\n\n    # Segment reversal\n    seg_start = random.randint(0, n - seg_length)\n    seg_end = seg_start + seg_length\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Node insertion (more disruptive than standard operators)\n    if n > 3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:new_pos],\n                [node],\n                new_solution[new_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6833780356639678,
            0.27279770374298096
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted sum of objectives (60% first objective, 40% second), then applies a hybrid local search combining segment reversal (with dynamic length) and node insertion (with multiple positions). It ensures feasibility by validating node coverage and uses Pareto dominance to accept improvements. The approach prioritizes the first objective while maintaining diversity through weighted selection and novel acceptance criteria.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest weighted sum of objectives (different weights)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])  # Different weights for objectives\n    weighted_sums = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with different probabilities and mechanisms\n    if np.random.rand() < 0.6:  # Different probability\n        # Segment reversal with dynamic segment length (different range)\n        segment_length = min(4, n // 3)  # Different length calculation\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Node insertion with different number of positions\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        positions = np.random.choice(n, size=5, replace=False)  # Different number of positions\n        best_pos = positions[0]\n        best_cost = float('inf')\n\n        for pos in positions:\n            if pos == i:\n                continue\n            temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2  # Different cost calculation (weighted sum)\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    # Novel acceptance criterion: Pareto dominance check with different condition\n    def dominates(a, b):\n        return (a[0] < b[0] and a[1] < b[1])  # Strictly better in both objectives\n\n    current_obj = archive[selected_idx][1]\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if not dominates(new_obj, current_obj):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9761289683205986,
            0.6018286943435669
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward lower individual objective values (weighted by inverse costs) and applies a hybrid local search combining segment reversal, edge exchange, and insertion operations to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with better objective values, while the local search introduces diversity through random segment reversals, edge swaps, and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives (separate weights for each objective)\n    weights = [(1 / (obj1 + 1)) * (1 / (obj2 + 1)) for (_, (obj1, obj2)) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange, segment reversal, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8399713793675228,
            0.44551795721054077
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on the highest sum of normalized objectives, then applies a hybrid local search combining segment reversal (50% chance) or node insertion (50% chance) to generate a neighbor solution, ensuring feasibility by validating the tour structure. The selection prioritizes solutions with higher objective values, while the local search explores two distinct neighborhood structures to escape local optima. The algorithm maintains feasibility by checking node uniqueness and tour completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    sums = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and node insertion\n    if np.random.rand() < 0.5:\n        # Segment reversal\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Node insertion\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9236913792132955,
            0.48340296745300293
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high normalized costs in the first objective, then applies a hybrid local search (edge exchange or segment reversal) to generate a neighbor while ensuring feasibility by checking for duplicate nodes. The method balances exploration and exploitation by randomly choosing between edge exchange and segment reversal, and reverts to the original solution if invalidity is detected.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest normalized cost in the first objective\n    objectives = np.array([obj[0] for _, obj in archive])\n    max_obj = np.max(objectives)\n    if max_obj == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_obj = objectives / max_obj\n        selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange and segment reversal\n    if np.random.random() < 0.5:\n        # Edge exchange\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i + 1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8828759611804771,
            0.45358389616012573
        ]
    },
    {
        "algorithm": "This algorithm selects the most promising solution from the archive by normalizing and summing its objectives, then applies a hybrid local search combining segment reversal (70% chance) or node insertion (30% chance) with dynamic segment lengths and multiple insertion positions. It ensures feasibility by validating node coverage and uses Pareto dominance to accept only improving solutions, reverting to the original if no improvement is found. The algorithm prioritizes high-potential solutions while maintaining tour validity through novel mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    sums = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with novel mechanisms\n    if np.random.rand() < 0.7:\n        # Segment reversal with dynamic segment length\n        segment_length = min(3, n // 2)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Node insertion with multiple positions\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        positions = np.random.choice(n, size=3, replace=False)\n        best_pos = positions[0]\n        best_cost = float('inf')\n\n        for pos in positions:\n            if pos == i:\n                continue\n            temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    # Novel acceptance criterion: Pareto dominance check\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    current_obj = archive[selected_idx][1]\n    new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_obj = (new_obj1, new_obj2)\n\n    if not dominates(new_obj, current_obj):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9267586408443391,
            0.5547756552696228
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective values from the archive, then applies a hybrid local search (60% 3-exchange, 40% edge swap) to generate a neighbor while ensuring the solution remains valid. It prioritizes solutions with larger objective sums and uses a randomized yet structured neighborhood exploration to balance diversity and improvement potential.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives\n    objectives = np.array([obj for _, obj in archive])\n    sums = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-exchange and edge swap\n    if np.random.rand() < 0.6:\n        # 3-exchange\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n    else:\n        # Edge swap\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9190864967431429,
            0.47098636627197266
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid metric combining objective diversity and dominance count, then applies a multi-segment inversion strategy with dynamic segment sizes and adaptive edge swaps to generate a neighbor solution while ensuring feasibility through validation checks. It prioritizes solutions with high diversity and low dominance, and focuses on segments that show significant potential for improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine diversity and dominance count\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n\n    # Calculate dominance count (number of solutions dominated by each solution)\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance[i] += 1\n\n    # Combine metrics with adaptive weights\n    combined_score = 0.7 * diversity + 0.3 * (1 / (1 + dominance))\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with dynamic segment size\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_sizes = np.random.randint(2, n//2, size=num_segments)\n    segment_starts = np.random.choice(range(n), size=num_segments, replace=False)\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = (start + size) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate segment's contribution to both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Calculate potential improvement\n        if len(segment) >= 3:\n            potential_cost1 = distance_matrix_1[segment[0], segment[-1]] + \\\n                             sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            potential_cost2 = distance_matrix_2[segment[0], segment[-1]] + \\\n                             sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert segment if it improves both objectives with margin\n            if (potential_cost1 < 0.95 * segment_cost1) and (potential_cost2 < 0.95 * segment_cost2):\n                if start < end:\n                    new_solution[start:end] = segment[::-1]\n                else:\n                    inverted = segment[::-1]\n                    new_solution[start:] = inverted[:n-start]\n                    new_solution[:end] = inverted[n-start:]\n\n    # Adaptive edge swap with objective-aware selection\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Accept swap if it improves both objectives with margin\n            if (new_cost1 < 0.98 * old_cost1) and (new_cost2 < 0.98 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Final validation check\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9630460548280968,
            11.859996676445007
        ]
    }
]