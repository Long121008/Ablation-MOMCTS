[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    max_obj = np.max(objectives)\n    if max_obj == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_obj = objectives / max_obj\n        selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate dominance status\n    is_dominated = False\n    current_obj = archive[selected_idx][1]\n    for _, other_obj in archive:\n        if other_obj[0] < current_obj[0] and other_obj[1] < current_obj[1]:\n            is_dominated = True\n            break\n\n    # Adaptive multi-segment rotation with objective-aware edge swaps\n    if is_dominated or np.random.random() < 0.3:\n        # Multi-segment rotation for dominated solutions or with probability\n        num_segments = max(2, min(4, int(np.sqrt(n))))\n        segment_length = max(3, n // num_segments)\n        segments = []\n        for i in range(num_segments):\n            start = i * segment_length\n            end = start + segment_length if i < num_segments - 1 else n\n            segments.append(new_solution[start:end])\n\n        # Rotate segments\n        rotation = np.random.randint(1, len(segments))\n        segments = segments[rotation:] + segments[:rotation]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(segments)\n    else:\n        # Objective-aware edge swaps for non-dominated solutions\n        for _ in range(3):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if i + 1 != j:\n                # Check if swap improves both objectives\n                old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or np.random.random() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9895202361095508,
            0.44411444664001465
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on balanced dominance and diversity, then applies an adaptive multi-segment perturbation followed by objective-aware edge swaps to generate a neighbor solution while ensuring feasibility. It prioritizes segments of the tour for transformation based on the trade-off between objectives, and uses randomized edge swaps that favor improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced dominance and diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.std(normalized_obj, axis=0)\n    selected_idx = np.argmax(np.sum(normalized_obj * diversity, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive multi-segment perturbation\n    num_segments = max(2, min(5, int(np.sqrt(n))))\n    segment_size = max(3, n // num_segments)\n    for i in range(num_segments):\n        start = i * segment_size\n        end = min(start + segment_size, n)\n        segment = new_solution[start:end]\n\n        # Adaptive transformation based on objective trade-off\n        obj1_trade = objectives[selected_idx][0] / (objectives[selected_idx][0] + objectives[selected_idx][1])\n        if np.random.rand() < obj1_trade:\n            segment = segment[::-1]\n        else:\n            shift = np.random.randint(1, len(segment))\n            segment = np.roll(segment, shift)\n\n        new_solution[start:end] = segment\n\n    # Objective-aware edge swaps\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i + 1 != j:\n            # Check if swap improves both objectives\n            old_dist1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_dist1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n            old_dist2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_dist2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n            if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or np.random.random() < 0.1:\n                new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0297552063095865,
            0.579038143157959
        ]
    },
    {
        "algorithm": "The algorithm selects a high-crowding-distance solution from the archive, adaptively fuses 2-4 non-overlapping segments using objective-aware path relinking (prioritizing either objective based on their relative trade-off), and ensures feasibility by validating node visits and falling back to a simple edge swap if needed. The key design ideas are the crowding-distance-based selection, adaptive segment fusion with objective-aware relinking, and strict feasibility validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(normalized_obj[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += normalized_obj[sorted_idx[j+1], i] - normalized_obj[sorted_idx[j-1], i]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment fusion (2-4 segments)\n    num_segments = np.random.randint(2, min(5, n//3))\n    segment_size = n // num_segments\n    segments = []\n    for i in range(num_segments):\n        start = i * segment_size\n        end = start + segment_size if i < num_segments - 1 else n\n        segments.append(new_solution[start:end])\n\n    # Objective-aware path relinking\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            # Check if segments can be fused without overlapping\n            if segments[i][-1] != segments[j][0] and segments[j][-1] != segments[i][0]:\n                # Relink based on objective trade-off\n                obj1_trade = current_obj[0] / (current_obj[0] + current_obj[1])\n                if np.random.rand() < obj1_trade:\n                    # Fuse with better path in first objective\n                    if distance_matrix_1[segments[i][-1], segments[j][0]] < distance_matrix_1[segments[j][-1], segments[i][0]]:\n                        segments[i] = np.concatenate([segments[i], segments[j]])\n                    else:\n                        segments[i] = np.concatenate([segments[j], segments[i]])\n                else:\n                    # Fuse with better path in second objective\n                    if distance_matrix_2[segments[i][-1], segments[j][0]] < distance_matrix_2[segments[j][-1], segments[i][0]]:\n                        segments[i] = np.concatenate([segments[i], segments[j]])\n                    else:\n                        segments[i] = np.concatenate([segments[j], segments[i]])\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge swap if fusion fails\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i + 1 != j:\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8756732743489246,
            0.2587517499923706
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with balanced objectives) and applies a novel local search combining segment reversal and node displacement to generate a neighbor solution while ensuring feasibility. It reverses segments with a 70% probability and displaces nodes within segments with a 60% probability, while carefully handling edge cases to maintain valid TSP tours. The selection criteria and local search operators are designed to balance exploration and exploitation for multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off or random if no clear trade-off\n    if len(archive) > 1:\n        selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Novel local search: segment reversal with node displacement\n    a, b = sorted(random.sample(range(n), 2))\n    seg_length = b - a\n\n    if seg_length > 1:\n        # Reverse segment with probability\n        if random.random() < 0.7:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Displace a node from segment to another position\n        if seg_length > 2 and random.random() < 0.6:\n            node_pos = random.randint(a, b-1)\n            new_pos = random.randint(0, n-1)\n            if new_pos < a or new_pos >= b:\n                node = new_solution[node_pos]\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9607896867938261,
            0.4578489065170288
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid scoring metric that balances Pareto dominance and objective diversity, then applies adaptive segment merging and dynamic objective-aware node insertion to generate high-quality neighbors, prioritizing improvements in both objectives while ensuring tour feasibility through careful validation. The method dynamically balances improvements between objectives (weighted 60% for the first objective) and maintains solution validity by verifying node count and node set equality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on Pareto dominance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.std(normalized_obj, axis=0)\n    dominance = np.sum(normalized_obj * diversity, axis=1)\n    balance = 1 / (1 + np.abs(normalized_obj[:, 0] - normalized_obj[:, 1]))\n    score = dominance * balance\n    selected_idx = np.argmax(score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment merging\n    num_merges = np.random.randint(1, min(3, n // 4))\n    for _ in range(num_merges):\n        if len(new_solution) <= 4:\n            break\n\n        # Select two adjacent segments to merge\n        split_point = np.random.randint(1, len(new_solution)-1)\n        merged_segment = np.concatenate([new_solution[:split_point], new_solution[split_point:]])\n\n        # Evaluate merged segment\n        cost1 = sum(distance_matrix_1[merged_segment[i], merged_segment[(i+1)%len(merged_segment)]] for i in range(len(merged_segment)))\n        cost2 = sum(distance_matrix_2[merged_segment[i], merged_segment[(i+1)%len(merged_segment)]] for i in range(len(merged_segment)))\n\n        # Accept merge if it shows potential improvement\n        if cost1 < sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution))) or \\\n           cost2 < sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution))):\n            new_solution = merged_segment\n\n    # Dynamic objective-aware node insertion\n    for _ in range(min(3, n // 3)):\n        # Select a node to relocate\n        node_idx = np.random.randint(1, len(new_solution)-1)\n        node = new_solution[node_idx]\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for pos in range(len(new_solution)):\n            if pos == node_idx or pos == (node_idx - 1) % len(new_solution):\n                continue\n\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] + \\\n                        distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%len(new_solution)]]\n            new_cost1 = distance_matrix_1[new_solution[node_idx-1], node] + \\\n                        distance_matrix_1[node, new_solution[(node_idx+1)%len(new_solution)]]\n\n            old_cost2 = distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] + \\\n                        distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%len(new_solution)]]\n            new_cost2 = distance_matrix_2[new_solution[node_idx-1], node] + \\\n                        distance_matrix_2[node, new_solution[(node_idx+1)%len(new_solution)]]\n\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            # Consider both objectives with weighted balance\n            weighted_improvement = improvement1 * 0.6 + improvement2 * 0.4\n\n            if weighted_improvement > best_improvement[0] + best_improvement[1]:\n                best_pos = pos\n                best_improvement = (improvement1, improvement2)\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:],\n                np.array([node])\n            ])\n            new_solution = np.roll(new_solution, -best_pos)\n\n    # Ensure solution remains valid\n    if len(new_solution) != n or not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -1.0039270925261317,
            1.121850311756134
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and cross-segment edge insertion, prioritizing segments with potential improvement in both objectives while ensuring feasibility. It weights objectives randomly between 0.3-0.7, emphasizes diversity with 0.3 multiplier, and performs segment reversal or node insertion only when both objectives improve or with 20%/30% probability when one improves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = objectives @ weights\n    diversity = np.std(objectives, axis=0)\n    selection_score = weighted_scores + 0.3 * diversity.sum()\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective awareness\n    segment_size = max(3, n // 4)\n    for start in range(0, n, segment_size):\n        end = min(start + segment_size, n)\n        segment = new_solution[start:end]\n\n        # Evaluate segment cost\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Only reverse if potential improvement exists\n        if len(segment) > 2:\n            reversed_cost1 = sum(distance_matrix_1[segment[(i+1)%len(segment)], segment[i]] for i in range(len(segment)))\n            reversed_cost2 = sum(distance_matrix_2[segment[(i+1)%len(segment)], segment[i]] for i in range(len(segment)))\n\n            if (reversed_cost1 < cost1 and reversed_cost2 < cost2) or \\\n               (np.random.random() < 0.2 and (reversed_cost1 <= cost1 or reversed_cost2 <= cost2)):\n                new_solution[start:end] = segment[::-1]\n\n    # Cross-segment edge insertion with objective priority\n    for _ in range(min(2, n // 5)):\n        # Select two different segments\n        seg1_start = np.random.randint(0, n - 2)\n        seg1_end = np.random.randint(seg1_start + 2, min(seg1_start + 5, n))\n        seg2_start = np.random.randint(0, n - 2)\n        seg2_end = np.random.randint(seg2_start + 2, min(seg2_start + 5, n))\n\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        # Evaluate potential insertion\n        if len(seg1) > 1 and len(seg2) > 1:\n            # Try inserting a node from seg1 into seg2\n            node = seg1[np.random.randint(0, len(seg1))]\n            pos = np.random.randint(0, len(seg2))\n\n            old_cost1 = distance_matrix_1[seg2[pos-1], seg2[pos]] + distance_matrix_1[seg2[pos], seg2[(pos+1)%len(seg2)]]\n            new_cost1 = distance_matrix_1[seg2[pos-1], node] + distance_matrix_1[node, seg2[(pos+1)%len(seg2)]]\n\n            old_cost2 = distance_matrix_2[seg2[pos-1], seg2[pos]] + distance_matrix_2[seg2[pos], seg2[(pos+1)%len(seg2)]]\n            new_cost2 = distance_matrix_2[seg2[pos-1], node] + distance_matrix_2[node, seg2[(pos+1)%len(seg2)]]\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (np.random.random() < 0.3 and (new_cost1 <= old_cost1 or new_cost2 <= old_cost2)):\n                # Perform insertion\n                new_solution = np.concatenate([\n                    new_solution[:seg2_start],\n                    np.array([node]),\n                    np.delete(new_solution[seg1_start:seg1_end], np.where(new_solution[seg1_start:seg1_end] == node)[0][0]),\n                    new_solution[seg2_end:]\n                ])\n\n    # Ensure solution remains valid\n    if len(new_solution) != n or not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9636093946557969,
            0.6310885548591614
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with better objective trade-offs, then applies a hybrid local search combining segment rotation and inversion to generate a neighbor solution while ensuring feasibility. The method intelligently balances exploration and exploitation by randomly selecting segments and rotating them to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select based on objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select based on objective trade-off (better balance between objectives)\n        selected = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search: edge exchange with segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Segment rotation instead of inversion\n        if random.random() < 0.5:\n            new_segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n        else:\n            new_segment = np.concatenate([new_solution[c:d], new_solution[a:b]])\n\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Segment rotation with random rotation amount\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    rotation = random.randint(1, seg_length-1)\n    new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8255608592425827,
            0.4006079435348511
        ]
    },
    {
        "algorithm": "The algorithm prioritizes dominated solutions for exploration, applies a hybrid local search combining segment reversal with node insertion, and uses adaptive segment sizes based on solution quality to generate diverse neighbors while ensuring feasibility. It selects solutions with lower combined objective values more often and adaptively adjusts the segment size for reversal, balancing exploration and exploitation. The hybrid approach ensures both structural changes (reversal) and fine-grained adjustments (insertion) for effective neighborhood exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a dominated solution if possible, otherwise select randomly\n    dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if is_dominated:\n            dominated.append((sol, obj))\n\n    if dominated:\n        selected = random.choice(dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    avg_obj = np.mean([obj[0] + obj[1] for _, obj in archive])\n    current_obj = sum(archive[[sol.tolist() for sol, _ in archive].index(new_solution.tolist())][1])\n    seg_length = max(2, min(5, int(n / (1 + np.exp(-(current_obj - avg_obj))))))\n\n    # Segment reversal\n    seg_start = random.randint(0, n - seg_length)\n    seg_end = seg_start + seg_length\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Node insertion (more disruptive than standard operators)\n    if n > 3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:new_pos],\n                [node],\n                new_solution[new_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6833780356639678,
            0.27279770374298096
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on the minimum sum of normalized objectives, then applies a hybrid local search combining segment reversal (80% probability) and node insertion (50% probability) to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with better combined performance, while the local search explores the solution space by modifying segments and nodes intelligently. The algorithm ensures feasibility by validating all operations and maintaining the TSP tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with minimum sum of normalized objectives\n    if len(archive) > 1:\n        max_obj1 = max(x[1][0] for x in archive)\n        max_obj2 = max(x[1][1] for x in archive)\n        selected = min(archive, key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))[0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node insertion\n    a, b = sorted(random.sample(range(n), 2))\n    seg_length = b - a\n\n    if seg_length > 1:\n        # Reverse segment with 80% probability\n        if random.random() < 0.8:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Insert a node from segment to another position with 50% probability\n        if seg_length > 2 and random.random() < 0.5:\n            node_pos = random.randint(a, b-1)\n            new_pos = random.randint(0, n-1)\n            if new_pos < a or new_pos >= b:\n                node = new_solution[node_pos]\n                new_solution = np.delete(new_solution, node_pos)\n                new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6688392028984823,
            0.4337157607078552
        ]
    }
]