[
    {
        "algorithm": "The heuristic selects a solution from the archive with a bias toward lower combined objective values (prioritizing better solutions) and applies a hybrid local search that combines segment reversal and edge exchange to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection is weighted by inverse objective values, and the local search introduces diversity through random segment reversals and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives and diversity\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj1 + obj2 + 1) for (_, (obj1, obj2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9272577568532457,
            0.41235780715942383
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid metric combining objective diversity and dominance count, then applies a multi-segment inversion strategy with dynamic segment sizes and adaptive edge swaps to generate a neighbor solution while ensuring feasibility through validation checks. It prioritizes solutions with high diversity and low dominance, and focuses on segments that show significant potential for improvement in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine diversity and dominance count\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n\n    # Calculate dominance count (number of solutions dominated by each solution)\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance[i] += 1\n\n    # Combine metrics with adaptive weights\n    combined_score = 0.7 * diversity + 0.3 * (1 / (1 + dominance))\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with dynamic segment size\n    num_segments = np.random.randint(1, min(4, n//2))\n    segment_sizes = np.random.randint(2, n//2, size=num_segments)\n    segment_starts = np.random.choice(range(n), size=num_segments, replace=False)\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = (start + size) % n\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate segment's contribution to both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Calculate potential improvement\n        if len(segment) >= 3:\n            potential_cost1 = distance_matrix_1[segment[0], segment[-1]] + \\\n                             sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            potential_cost2 = distance_matrix_2[segment[0], segment[-1]] + \\\n                             sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert segment if it improves both objectives with margin\n            if (potential_cost1 < 0.95 * segment_cost1) and (potential_cost2 < 0.95 * segment_cost2):\n                if start < end:\n                    new_solution[start:end] = segment[::-1]\n                else:\n                    inverted = segment[::-1]\n                    new_solution[start:] = inverted[:n-start]\n                    new_solution[:end] = inverted[n-start:]\n\n    # Adaptive edge swap with objective-aware selection\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Accept swap if it improves both objectives with margin\n            if (new_cost1 < 0.98 * old_cost1) and (new_cost2 < 0.98 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Final validation check\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9630460548280968,
            11.859996676445007
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from the archive by prioritizing non-dominated solutions with better objective trade-offs, then applies a hybrid local search combining segment rotation and inversion to generate a neighbor solution while ensuring feasibility. The method intelligently balances exploration and exploitation by randomly selecting segments and rotating them to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select based on objective trade-off\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select based on objective trade-off (better balance between objectives)\n        selected = min(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1]))[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search: edge exchange with segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Segment rotation instead of inversion\n        if random.random() < 0.5:\n            new_segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n        else:\n            new_segment = np.concatenate([new_solution[c:d], new_solution[a:b]])\n\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Segment rotation with random rotation amount\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    rotation = random.randint(1, seg_length-1)\n    new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8255608592425827,
            0.4006079435348511
        ]
    },
    {
        "algorithm": "The algorithm prioritizes dominated solutions for exploration, applies a hybrid local search combining segment reversal with node insertion, and uses adaptive segment sizes based on solution quality to generate diverse neighbors while ensuring feasibility. It selects solutions with lower combined objective values more often and adaptively adjusts the segment size for reversal, balancing exploration and exploitation. The hybrid approach ensures both structural changes (reversal) and fine-grained adjustments (insertion) for effective neighborhood exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a dominated solution if possible, otherwise select randomly\n    dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if is_dominated:\n            dominated.append((sol, obj))\n\n    if dominated:\n        selected = random.choice(dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    avg_obj = np.mean([obj[0] + obj[1] for _, obj in archive])\n    current_obj = sum(archive[[sol.tolist() for sol, _ in archive].index(new_solution.tolist())][1])\n    seg_length = max(2, min(5, int(n / (1 + np.exp(-(current_obj - avg_obj))))))\n\n    # Segment reversal\n    seg_start = random.randint(0, n - seg_length)\n    seg_end = seg_start + seg_length\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Node insertion (more disruptive than standard operators)\n    if n > 3:\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:new_pos],\n                [node],\n                new_solution[new_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6833780356639678,
            0.27279770374298096
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution (preferring non-dominated ones) from the archive, then applies a hybrid local search combining edge exchange (randomly swapping and inverting segments) and random segment inversion to generate a neighbor solution while ensuring feasibility. The method prioritizes non-dominated solutions for exploration and uses a mix of standard and novel operators to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if possible, otherwise select randomly\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        selected = random.choice(non_dominated)[0].copy()\n    else:\n        selected = random.choice(archive)[0].copy()\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine edge exchange and random segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (similar to 2-opt but more general)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are valid and don't overlap in a way that breaks the tour\n    if a != c and b != d and not (a < c < b < d or c < a < d < b):\n        # Create new segments\n        new_segment = np.concatenate([new_solution[a:b], new_solution[c:d][::-1]])\n        if len(new_segment) == b - a + d - c:\n            new_solution[a:b] = new_segment[:b-a]\n            new_solution[c:d] = new_segment[b-a:]\n\n    # Random segment inversion (local improvement)\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n-1))\n    seg_end = min(seg_start + seg_length, n)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8669746667714558,
            0.4785269498825073
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with higher normalized costs (sum of normalized objectives), then applies a hybrid local search combining random segment reversal to generate a neighbor solution while ensuring feasibility. It selects two random non-overlapping segments, reverses them, and checks if the solution remains valid. The selection criterion and segment-based local search are the key design choices.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized costs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    sums = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Ensure segments don't overlap\n    if a < c < b:\n        c = b\n    if a < d < b:\n        d = b\n\n    # Reverse the selected segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9152994955339191,
            0.4816514253616333
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward lower individual objective values (weighted by inverse costs) and applies a hybrid local search combining segment reversal, edge exchange, and insertion operations to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with better objective values, while the local search introduces diversity through random segment reversals, edge swaps, and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives (separate weights for each objective)\n    weights = [(1 / (obj1 + 1)) * (1 / (obj2 + 1)) for (_, (obj1, obj2)) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange, segment reversal, and insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Randomly exchange two edges\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j and (i + 1) % n != j and (j + 1) % n != i:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8399713793675228,
            0.44551795721054077
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a bias toward better objectives (weighted by normalized objective values), then applies a hybrid local search combining edge insertion, partial route reversal, and edge swaps, ensuring feasibility by maintaining a valid TSP tour structure. The selection prioritizes solutions with lower combined objectives, while the local search introduces diversity through probabilistic segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards better objectives\n    objectives = np.array([(obj1 + obj2) for (_, (obj1, obj2)) in archive])\n    min_obj, max_obj = np.min(objectives), np.max(objectives)\n    if max_obj == min_obj:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized = (max_obj - objectives) / (max_obj - min_obj)\n        weights = normalized / np.sum(normalized)\n\n    selected_idx = np.random.choice(range(len(archive)), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and partial route reversal\n    if n > 3:\n        # Randomly select a segment and insert it at a different position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Randomly reverse a segment with probability 0.3\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Randomly swap two non-adjacent edges with probability 0.5\n        if random.random() < 0.5 and n > 3:\n            i, j = sorted(random.sample(range(n), 2))\n            if abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7078935027097926,
            0.4606529474258423
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity and balance to explore less-explored regions while maintaining Pareto front proximity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n    balance = 1 / (1 + np.abs(normalized_obj[:, 0] - normalized_obj[:, 1]))\n    score = diversity * balance\n    selected_idx = np.argmax(score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment relocation with adaptive segment size and position\n    seg_length = np.random.randint(2, min(6, n//2))\n    seg_start = np.random.randint(0, n - seg_length)\n    segment = new_solution[seg_start:seg_start+seg_length]\n\n    # Calculate segment's contribution to both objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find optimal insertion point that improves both objectives\n    best_pos = -1\n    best_improvement = (0, 0)\n\n    for pos in range(n - seg_length + 1):\n        if pos == seg_start:\n            continue\n\n        # Calculate potential insertion costs\n        old_edges1 = distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_start+seg_length-1], new_solution[seg_start+seg_length]]\n        new_edges1 = distance_matrix_1[new_solution[pos-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_start+seg_length-1], new_solution[pos]]\n\n        old_edges2 = distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_2[new_solution[seg_start+seg_length-1], new_solution[seg_start+seg_length]]\n        new_edges2 = distance_matrix_2[new_solution[pos-1], new_solution[seg_start]] + distance_matrix_2[new_solution[seg_start+seg_length-1], new_solution[pos]]\n\n        improvement1 = old_edges1 - new_edges1\n        improvement2 = old_edges2 - new_edges2\n\n        if improvement1 > 0 and improvement2 > 0:\n            if (improvement1 + improvement2) > (best_improvement[0] + best_improvement[1]):\n                best_pos = pos\n                best_improvement = (improvement1, improvement2)\n\n    if best_pos != -1:\n        # Remove segment from current position\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains valid\n    if len(new_solution) != n or not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.909036363662305,
            0.6182532906532288
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with high objective diversity (product of normalized costs) to explore less-explored regions of the Pareto front, then applies a hybrid local search combining adaptive segment inversion (reversing segments that improve both objectives) and context-aware edge insertion (swapping edges that reduce both costs), ensuring feasibility through validation. The selection strategy focuses on diversity, while the local search dynamically balances exploitation of promising segments with exploration of edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity (product of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0, keepdims=True)\n    diversity = np.prod(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive segment inversion + context-aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n\n    # Calculate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert segment if it improves both objectives\n    if segment_cost1 > distance_matrix_1[segment[0], segment[-1]] and segment_cost2 > distance_matrix_2[segment[0], segment[-1]]:\n        new_solution[a:b+1] = segment[::-1]\n\n    # Context-aware edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j and abs(i - j) > 1 and (i + 1) % n != j and (j + 1) % n != i:\n        # Calculate potential edge costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Insert edge if it improves both objectives\n        if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8619623024943197,
            0.5111284255981445
        ]
    }
]