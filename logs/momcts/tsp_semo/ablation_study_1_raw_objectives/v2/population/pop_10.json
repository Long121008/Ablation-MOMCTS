[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the highest sum of normalized objectives) and applies a hybrid local search: either a random edge swap or node reinsertion to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with higher combined costs, while the local search explores neighborhoods through randomized edge swaps or node reinsertions. The approach balances exploration and exploitation by combining simple but effective perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -1\n    selected_solution = None\n    for sol, obj in archive:\n        normalized_obj = (obj[0] + obj[1]) / 2  # Simple normalization\n        if normalized_obj > max_sum:\n            max_sum = normalized_obj\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random edge swap or node reinsertion\n    n = len(new_solution)\n    if np.random.rand() < 0.5:  # Edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Node reinsertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9263534306788621,
            0.2028200626373291
        ],
        "raw_score": [
            10.527134484715972,
            10.564929956806642
        ]
    },
    {
        "algorithm": "The algorithm selects a Pareto-dominated solution from the archive (prioritizing non-dominated or randomly choosing from dominated solutions) and applies a hybrid local search: it first attempts a segment reversal (2-opt-like) if it improves either objective, otherwise performs a random node reinsertion to maintain feasibility. The method ensures solution validity by checking node uniqueness and preserves the tour structure while exploring multi-objective improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a Pareto-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal if beneficial, else node reinsertion\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, l, node)\n    else:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0259954099517012,
            0.38352054357528687
        ],
        "raw_score": [
            5.699175348104417,
            7.028717067597253
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining 3-opt edge exchanges with adaptive node reinsertion to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with better combined objective performance and intelligently balances exploration (random selection) and exploitation (targeted improvements) through weighted edge exchanges and adaptive insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.random.permutation(len(instance))\n\n    # Calculate normalized objective scores for selection\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    if max_obj1 == 0 or max_obj2 == 0:\n        weights = [0.5, 0.5]\n    else:\n        weights = [1/max_obj1, 1/max_obj2]\n    scores = [weights[0]*obj[0] + weights[1]*obj[1] for _, obj in archive]\n\n    # Select solution with highest combined score (higher score = better potential)\n    selected_index = np.argmax(scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        # For small instances, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search: 3-opt edge exchange with adaptive insertion\n        # Step 1: Select three edges to exchange (3-opt)\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Step 2: Calculate potential improvement\n        a, b, c, d, e, f = base_solution[i], base_solution[(i+1)%n], base_solution[j], base_solution[(j+1)%n], base_solution[k], base_solution[(k+1)%n]\n\n        # Calculate changes for both objectives\n        delta1 = (distance_matrix_1[a,d] + distance_matrix_1[b,e] + distance_matrix_1[c,f]) - \\\n                 (distance_matrix_1[a,b] + distance_matrix_1[c,d] + distance_matrix_1[e,f])\n        delta2 = (distance_matrix_2[a,d] + distance_matrix_2[b,e] + distance_matrix_2[c,f]) - \\\n                 (distance_matrix_2[a,b] + distance_matrix_2[c,d] + distance_matrix_2[e,f])\n\n        if delta1 < 0 or delta2 < 0:\n            # If 3-opt improves at least one objective, perform it\n            new_solution[(i+1):(j+1)] = np.flip(new_solution[(i+1):(j+1)])\n            new_solution[(j+1):(k+1)] = np.flip(new_solution[(j+1):(k+1)])\n        else:\n            # Adaptive node reinsertion\n            # Select a node to remove and reinsert\n            remove_pos = random.randint(0, n-1)\n            node = new_solution[remove_pos]\n\n            # Calculate insertion positions based on both objectives\n            obj1_costs = [distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%n]] for i in range(n-1)]\n            obj2_costs = [distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%n]] for i in range(n-1)]\n\n            # Weighted insertion score\n            insertion_scores = [weights[0]*obj1_costs[i] + weights[1]*obj2_costs[i] for i in range(n-1)]\n            insert_pos = np.argmin(insertion_scores)\n\n            # Perform insertion\n            new_solution = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:]])\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0082527092395177,
            0.22302573919296265
        ],
        "raw_score": [
            10.40473316868271,
            10.656387013563487
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution from the archive (based on the maximum objective value) and applies a hybrid local search combining random segment reversal and 2-opt moves to generate a neighbor solution. It prioritizes exploration of less-explored regions by focusing on the worst-performing solution and ensures feasibility by maintaining valid TSP tours. The approach balances diversity and local improvement while avoiding standard 2-opt-only strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: combine random 2-opt with a novel segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (novel segment reversal)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a random 2-opt move to ensure diversity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7627709071663467,
            0.20366013050079346
        ],
        "raw_score": [
            9.049800417335923,
            10.417538166894719
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objective values and random diversity, then applies a hybrid local search combining 2.5-opt (a segment reversal) and node insertion to generate a neighbor, ensuring feasibility by validating no duplicates or missing nodes. The selection prioritizes lower objectives with added randomness, while the local search focuses on segment reversal and node repositioning for potential multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    def selection_score(solution, objective):\n        # Prefer solutions with lower objectives but also consider diversity\n        return (objective[0] + objective[1]) * (1 + np.random.uniform(0.5, 1.5))\n\n    scored_solutions = [(solution, objective, selection_score(solution, objective))\n                       for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2])\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: 2.5-opt + node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt (generalized 2-opt)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion (move a random node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure solution remains feasible (no duplicates and all nodes visited)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(selected_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9672586246322147,
            0.250504732131958
        ],
        "raw_score": [
            6.691336365610633,
            6.575647727482992
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (prioritizing Pareto fronts) and applies a hybrid local search strategy: segment reversal for Pareto-improving moves in larger instances, or node swaps for smaller instances, while always ensuring feasibility. The method intelligently balances exploration (random selection) and exploitation (Pareto-aware improvements) to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto selection: choose a non-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal if Pareto-improving, else node reinsertion\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, l, node)\n    else:\n        # For small instances, swap nodes if Pareto-improving\n        i, j = random.sample(range(n), 2)\n        a, b = base_solution[i], base_solution[j]\n        delta1 = (distance_matrix_1[a, base_solution[i-1]] + distance_matrix_1[a, base_solution[(i+1)%n]] +\n                  distance_matrix_1[b, base_solution[j-1]] + distance_matrix_1[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[b, base_solution[i-1]] + distance_matrix_1[b, base_solution[(i+1)%n]] +\n                  distance_matrix_1[a, base_solution[j-1]] + distance_matrix_1[a, base_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[a, base_solution[i-1]] + distance_matrix_2[a, base_solution[(i+1)%n]] +\n                  distance_matrix_2[b, base_solution[j-1]] + distance_matrix_2[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[b, base_solution[i-1]] + distance_matrix_2[b, base_solution[(i+1)%n]] +\n                  distance_matrix_2[a, base_solution[j-1]] + distance_matrix_2[a, base_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9752425011617248,
            0.35219669342041016
        ],
        "raw_score": [
            5.9635449044178905,
            6.735768041691197
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated solutions) and applies a hybrid local search combining edge exchange and node insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. It intelligently balances exploration (random selection) and exploitation (local improvement) while considering both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        return np.random.permutation(len(instance))\n\n    # Calculate the Pareto dominance rank for each solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    # Select non-dominated solutions (rank 0)\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if non_dominated_indices:\n        selected_index = random.choice(non_dominated_indices)\n    else:\n        # If no non-dominated solutions, select randomly\n        selected_index = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a full swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more sophisticated local search\n        # Step 1: Select two edges to exchange (similar to 2-opt but with additional checks)\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Step 2: Check if exchanging these edges improves both objectives\n        # Calculate the change in cost for both objectives\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            # If the exchange improves at least one objective, perform it\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            # If not, try a node insertion move\n            k = random.randint(0, n - 1)\n            l = random.randint(0, n - 1)\n            if k != l:\n                # Remove node at position k and insert it after position l\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = (l + 1) % (n - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9793278915524335,
            0.41966134309768677
        ],
        "raw_score": [
            6.099593653768952,
            6.610992634938869
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on dominance and diversity, then applies a hybrid local search combining a swap-insert operator and segment reversal, ensuring feasibility through validation and a repair mechanism. It prioritizes non-dominated solutions and uses randomness to explore the solution space while maintaining tour validity. The repair mechanism rebuilds the solution if invalid, guaranteeing feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on dominance and diversity\n    def dominance_score(solution, objective):\n        # Prefer solutions that are not dominated by others\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= objective[0] and other_obj[1] < objective[1]) or (other_obj[0] < objective[0] and other_obj[1] <= objective[1]):\n                dominated = True\n                break\n        if dominated:\n            return float('inf')\n        return objective[0] + objective[1] + np.random.uniform(0, 0.5)\n\n    scored_solutions = [(solution, objective, dominance_score(solution, objective))\n                       for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2])\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: swap-insert + segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply swap-insert: select two random nodes and swap them, then insert one at a new position\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Repair mechanism: ensure all nodes are visited exactly once\n    missing = set(range(n)) - set(new_solution)\n    extra = set(new_solution) - set(range(n))\n\n    if missing or extra:\n        # Rebuild the solution if invalid\n        new_solution = np.array(list(range(n)))\n        np.random.shuffle(new_solution)\n\n    # Ensure solution remains feasible\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(range(n))\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7597170458285994,
            0.2715601325035095
        ],
        "raw_score": [
            6.612906357748611,
            6.813776734116832
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive using Pareto dominance, then applies a hybrid local search combining segment reversal (if beneficial) and node reinsertion (otherwise), ensuring feasibility by validating node uniqueness and tour completeness. It prioritizes solutions that improve at least one objective while maintaining feasibility, with special handling for small instances via simple swaps. The method intelligently balances exploration and exploitation by leveraging both structural changes (segment reversal) and fine-grained adjustments (node reinsertion).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto selection: choose a non-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal if beneficial, else node reinsertion\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, l, node)\n    else:\n        # For small instances, perform a simple swap if beneficial\n        i, j = random.sample(range(n), 2)\n        a, b = base_solution[i], base_solution[j]\n        delta1 = (distance_matrix_1[a, base_solution[i-1]] + distance_matrix_1[a, base_solution[(i+1)%n]] +\n                  distance_matrix_1[b, base_solution[j-1]] + distance_matrix_1[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[b, base_solution[i-1]] + distance_matrix_1[b, base_solution[(i+1)%n]] +\n                  distance_matrix_1[a, base_solution[j-1]] + distance_matrix_1[a, base_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[a, base_solution[i-1]] + distance_matrix_2[a, base_solution[(i+1)%n]] +\n                  distance_matrix_2[b, base_solution[j-1]] + distance_matrix_2[b, base_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[b, base_solution[i-1]] + distance_matrix_2[b, base_solution[(j+1)%n]] +\n                  distance_matrix_2[a, base_solution[j-1]] + distance_matrix_2[a, base_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9305258598815458,
            0.3310345411300659
        ],
        "raw_score": [
            6.750994222682744,
            6.196014517473082
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted randomness favoring lower-cost solutions, then applies a hybrid local search combining 3-opt with a novel segment inversion strategy to generate a neighbor while ensuring feasibility. It prioritizes solutions with better combined objective values and explores local improvements through both standard and specialized operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring lower-cost solutions\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 - (normalized_costs[:, 0] + normalized_costs[:, 1]) / 2\n    weights = np.maximum(weights, 0.1)  # Ensure minimum probability\n    weights /= weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion\n    n = len(new_solution)\n    for _ in range(5):  # Number of attempts\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try 3-opt\n        candidates = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:][::-1]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n        ]\n\n        # Try segment inversion\n        segment_length = min(5, (k - j) // 2)\n        if segment_length > 1:\n            mid = j + (k - j) // 2\n            candidates.append(np.concatenate([\n                new_solution[:j], new_solution[j:mid][::-1], new_solution[mid:k], new_solution[k:]\n            ]))\n\n        # Evaluate candidates\n        best_candidate = new_solution.copy()\n        best_cost = np.inf\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate.copy()\n\n        if not np.array_equal(best_candidate, new_solution):\n            new_solution = best_candidate\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8952181140724547,
            0.3488140106201172
        ],
        "raw_score": [
            5.715211745334367,
            6.7316106930825
        ]
    }
]