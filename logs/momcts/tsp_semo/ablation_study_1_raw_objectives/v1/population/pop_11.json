[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on combined objective scores) and applies a hybrid local search combining random edge swaps and segment reversals, ensuring feasibility by validating the tour's uniqueness and completeness. It prioritizes exploration of non-standard neighborhoods while maintaining validity through fallback mechanisms. The selection and modification process balances diversification (randomness) with intensification (focus on promising solutions).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    # Step 1: Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler edge swap\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7878765038582443,
            0.2220955491065979
        ],
        "raw_score": [
            6.372103462906185,
            6.53457595745146
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective scores) and applies a multi-segment shuffle strategy: it randomly selects non-overlapping segments of the tour, reverses their order, and optimizes their internal structure through edge swaps and reversals, ensuring feasibility by validating uniqueness of nodes. The number of segments and their lengths are dynamically determined based on the tour size.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment shuffle strategy\n    num_segments = min(3, max(1, n // 5))  # Determine number of segments to shuffle\n    segment_length = max(2, n // (2 * num_segments))  # Ensure segments are substantial\n\n    # Randomly select non-overlapping segments\n    segments = []\n    used_indices = set()\n    for _ in range(num_segments):\n        while True:\n            start = np.random.randint(n)\n            end = (start + segment_length) % n\n            if start < end:\n                if not any(s <= end and e >= start for s, e in segments):\n                    segments.append((start, end))\n                    used_indices.update(range(start, end))\n                    break\n            else:\n                if not any((s <= n-1 and e >= start) or (s <= end and e >= 0) for s, e in segments):\n                    segments.append((start, end))\n                    used_indices.update(range(start, n))\n                    used_indices.update(range(0, end))\n                    break\n\n    # Reverse the order of segments in the solution\n    segment_order = sorted(segments, key=lambda x: x[0])\n    shuffled_order = segment_order.copy()\n    np.random.shuffle(shuffled_order)\n\n    # Reconstruct the solution with segments in new order\n    temp_solution = []\n    last_pos = 0\n    for (s, e), (new_s, new_e) in zip(segment_order, shuffled_order):\n        if last_pos < s:\n            temp_solution.extend(new_solution[last_pos:s])\n        temp_solution.extend(new_solution[new_s:new_e])\n        last_pos = e\n    if last_pos < n:\n        temp_solution.extend(new_solution[last_pos:])\n\n    # Optimize internal structure of segments\n    for s, e in segment_order:\n        segment = new_solution[s:e]\n        # Random edge swaps within segment\n        for _ in range(min(3, len(segment)//2)):\n            i, j = np.random.choice(len(segment), size=2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n        # Segment reversal\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        # Reinsert optimized segment\n        temp_solution[s:e] = segment\n\n    # Validate solution\n    if len(np.unique(temp_solution)) == n:\n        new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.775134537552052,
            0.1574108600616455
        ],
        "raw_score": [
            7.53251816198539,
            7.067323953454627
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing combined objective scores) and applies a hybrid local search combining random node insertions and segment shifts, ensuring feasibility by validating tour uniqueness and completeness. It adaptively adjusts parameters to explore diverse neighborhoods while falling back to simpler operations if needed. The method prioritizes exploration by randomly perturbing segments and nodes, balancing exploration with feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: combine node insertions and segment shifts\n    # Step 1: Randomly select a node to insert elsewhere\n    node = np.random.choice(new_solution)\n    idx = np.where(new_solution == node)[0][0]\n    new_solution = np.delete(new_solution, idx)\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Randomly select a segment to shift\n    segment_size = np.random.randint(2, min(5, n))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.delete(new_solution, np.s_[start:start+segment_size])\n    insert_pos = np.random.randint(0, n - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler node insertion\n        new_solution = base_solution.copy()\n        node = np.random.choice(new_solution)\n        idx = np.where(new_solution == node)[0][0]\n        new_solution = np.delete(new_solution, idx)\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590416592200175,
            0.22849512100219727
        ],
        "raw_score": [
            6.281348843659081,
            7.059226482841522
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from an archive based on normalized objective scores and structural diversity, then applies a hybrid local search combining segment relocations and dynamic edge swaps, adaptively choosing operators based on solution quality and local topology to generate improved neighbors while ensuring feasibility. It prioritizes segment moves for higher-quality solutions and uses topology-aware edge swaps for others, with fallback to the original solution if invalidity occurs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic solution selection: prioritize solutions with high normalized objectives and low structural redundancy\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    structural_diversity = np.array([len(set(sol)) for (sol, _) in archive])  # Simple measure of structural diversity\n\n    # Combine normalized objectives and structural diversity for selection\n    scores = normalized.sum(axis=1) * (1 + 1 / (structural_diversity + 1e-8))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search with adaptive operator selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine operator selection probabilities based on solution quality\n    sol_quality = (normalized[selected_idx][0] + normalized[selected_idx][1]) / 2\n    segment_prob = max(0.1, sol_quality * 0.8)  # Higher quality solutions favor segment moves\n    swap_prob = 1 - segment_prob\n\n    if np.random.random() < segment_prob:\n        # Adaptive segment relocation\n        segment_length = min(3, max(1, int(np.random.random() * n // 3)))\n        start_pos = np.random.randint(n)\n        end_pos = (start_pos + segment_length) % n\n\n        if start_pos < end_pos:\n            segment = new_solution[start_pos:end_pos]\n            remaining = np.concatenate([new_solution[:start_pos], new_solution[end_pos:]])\n        else:\n            segment = np.concatenate([new_solution[start_pos:], new_solution[:end_pos]])\n            remaining = new_solution[end_pos:start_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(remaining)):\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n    else:\n        # Dynamic edge swap with topology-aware selection\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Determine swap type based on local topology\n        dist1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[(a-1)%n]]\n        dist2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[(a-1)%n]]\n\n        if dist1 + dist2 > distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + \\\n           distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[(a-1)%n]]:\n            # Perform the swap if it improves both objectives\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9874616550993895,
            0.7441497445106506
        ],
        "raw_score": [
            10.517218484537604,
            10.642625561096308
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if all are dominated) and applies a hybrid local search combining segment reversal, edge swaps, and distance-aware node insertion to generate a neighbor solution, ensuring feasibility by validating node uniqueness. The method prioritizes solutions with high potential for improvement by considering both objective values, with edge swaps and insertions guided by combined distance metrics from both spaces. The solution is validated to ensure no duplicates before returning.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine segment reversal, edge swaps, and distance-aware node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply segment reversal\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Apply distance-aware edge swap\n    if a != 0 and c != n-1:\n        node_a, node_b, node_c = new_solution[a], new_solution[b], new_solution[c]\n        # Calculate combined distance improvement potential\n        dist1_before = distance_matrix_1[node_a, node_b] + distance_matrix_1[node_c, node_a]\n        dist1_after = distance_matrix_1[node_c, node_b] + distance_matrix_1[node_a, node_c]\n        dist2_before = distance_matrix_2[node_a, node_b] + distance_matrix_2[node_c, node_a]\n        dist2_after = distance_matrix_2[node_c, node_b] + distance_matrix_2[node_a, node_c]\n\n        if (dist1_after < dist1_before and dist2_after < dist2_before) or random.random() < 0.3:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    # Distance-aware node insertion\n    if n > 3:\n        # Select a random node to reinsert\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n\n        # Find the best insertion position based on combined distance\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == i or pos == i-1 or pos == i+1:\n                continue\n\n            # Calculate insertion cost\n            prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            score = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] -\n                    distance_matrix_1[prev, next_node]) + \\\n                    (distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] -\n                    distance_matrix_2[prev, next_node])\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1 and best_pos != i:\n            # Remove the node and reinsert at best position\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8440192805511035,
            0.2234652042388916
        ],
        "raw_score": [
            6.378475966616593,
            6.8813829811676985
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if all are dominated), then applies a hybrid 3-opt local search with a customized edge swap to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The selection prioritizes solutions with potential for improvement, while the local search combines segment reversal and edge swaps to explore diverse neighborhoods.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with a customized edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Apply customized edge swap: swap edges between non-adjacent segments\n    if a != 0 and c != n-1:\n        if random.random() < 0.5:\n            # Swap edges between (a, b) and (c, a)\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n        else:\n            # Swap edges between (b, c) and (a, b)\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7218428340875651,
            0.19054001569747925
        ],
        "raw_score": [
            7.06795468379313,
            6.662980597418125
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution. It ensures feasibility by implicitly maintaining a valid tour through these operations, though explicit validation could be added. The approach prioritizes randomness in edge selection and operation choice, with 10 iterations of modifications per solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations can be adjusted\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion: move a segment between two random positions\n        if random.random() < 0.5:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        # Segment reversal: reverse a segment\n        else:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour (visits each node exactly once)\n    # This is implicitly handled by the operations above\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7621023578191657,
            0.20801621675491333
        ],
        "raw_score": [
            7.852275087762327,
            8.791772746869768
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective scores) and applies a hybrid local search combining random node insertions and segment relocations, while ensuring feasibility by validating uniqueness and completeness, with a fallback to node swaps for invalid cases. It prioritizes exploration of non-standard neighborhoods through adaptive segment selection and maintains validity through checks. The solution is selected based on the sum of objectives, and the local search dynamically adjusts by relocating segments and inserting nodes, reverting to simpler swaps if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: combine node insertion and segment relocation\n    # Step 1: Randomly select a node to insert elsewhere\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert the node at a random position\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Randomly select a segment to relocate\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.delete(new_solution, np.arange(a, b+1))\n\n    # Insert the segment at a random position\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to a simpler node swap\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9349723795388156,
            0.24263978004455566
        ],
        "raw_score": [
            6.556954003030747,
            6.544141442077507
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive using probabilistic selection based on normalized objective scores and diversity, then applies a hybrid local search that dynamically manipulates segments of the tour with adaptive reversals and edge swaps, ensuring feasibility by validating uniqueness of nodes. The segment size and number are determined adaptively based on solution quality, with higher-quality solutions undergoing more extensive manipulations. The neighbor solution is constructed by shuffling and modifying segments while respecting the tour's circular structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Probabilistic selection based on normalized objective scores and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores[:, 0] + normalized_scores[:, 1]\n    selection_probs = np.exp(-combined_scores) / np.sum(np.exp(-combined_scores))\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment determination based on solution quality\n    current_obj = archive[selected_idx][1]\n    quality_factor = (current_obj[0] + current_obj[1]) / (np.sum(objectives) + 1e-8)\n    num_segments = min(4, max(1, int(n * (0.3 + 0.7 * quality_factor))))\n    segment_length = max(2, int(n / (3 + num_segments)))\n\n    # Randomly select segments with adaptive size\n    segments = []\n    used_indices = set()\n    for _ in range(num_segments):\n        while True:\n            start = np.random.randint(n)\n            end = (start + np.random.randint(segment_length // 2, segment_length + 1)) % n\n            if start < end:\n                if not any(s <= end and e >= start for s, e in segments):\n                    segments.append((start, end))\n                    used_indices.update(range(start, end))\n                    break\n            else:\n                if not any((s <= n-1 and e >= start) or (s <= end and e >= 0) for s, e in segments):\n                    segments.append((start, end))\n                    used_indices.update(range(start, n))\n                    used_indices.update(range(0, end))\n                    break\n\n    # Hybrid segment manipulation with adaptive edge swaps\n    segment_order = sorted(segments, key=lambda x: x[0])\n    shuffled_order = segment_order.copy()\n    np.random.shuffle(shuffled_order)\n\n    temp_solution = []\n    last_pos = 0\n    for (s, e), (new_s, new_e) in zip(segment_order, shuffled_order):\n        if last_pos < s:\n            temp_solution.extend(new_solution[last_pos:s])\n        segment = new_solution[new_s:new_e]\n\n        # Adaptive manipulation based on distance matrices\n        if np.random.rand() < 0.7:\n            segment = segment[::-1]\n        else:\n            # Dynamic edge swaps based on distance improvement\n            for _ in range(min(2, len(segment)//2)):\n                i, j = np.random.choice(len(segment), size=2, replace=False)\n                original_cost = (distance_matrix_1[segment[i-1], segment[i]] + distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] +\n                                distance_matrix_2[segment[i-1], segment[i]] + distance_matrix_2[segment[j], segment[(j+1)%len(segment)]])\n                swapped_cost = (distance_matrix_1[segment[i-1], segment[j]] + distance_matrix_1[segment[i], segment[(j+1)%len(segment)]] +\n                               distance_matrix_2[segment[i-1], segment[j]] + distance_matrix_2[segment[i], segment[(j+1)%len(segment)]])\n                if swapped_cost < original_cost:\n                    segment[i], segment[j] = segment[j], segment[i]\n\n        temp_solution.extend(segment)\n        last_pos = e\n    if last_pos < n:\n        temp_solution.extend(new_solution[last_pos:])\n\n    # Validate solution\n    if len(np.unique(temp_solution)) == n:\n        new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8329484787814836,
            0.23632097244262695
        ],
        "raw_score": [
            7.021636492450765,
            7.757914384019743
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive based on the sum of normalized objective values, then applies a hybrid local search combining segment relocation and edge insertion to generate a neighbor while ensuring feasibility. The algorithm prioritizes solutions with better combined performance across objectives and uses a randomized segment relocation strategy to explore the solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_start = np.random.randint(n)\n    segment_length = np.random.randint(1, min(5, n // 2))\n    segment_end = (segment_start + segment_length) % n\n\n    if segment_start < segment_end:\n        segment = new_solution[segment_start:segment_end]\n        remaining = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n    else:\n        segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n        remaining = new_solution[segment_end:segment_start]\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n\n    for i in range(len(remaining)):\n        candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply the best insertion\n    if segment_start < segment_end:\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n    else:\n        new_solution = np.concatenate([segment, remaining[:best_pos], remaining[best_pos:]])\n\n    # Ensure the solution is valid (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8884464889790682,
            0.6300314664840698
        ],
        "raw_score": [
            10.449699670611317,
            10.541362995032294
        ]
    }
]