[
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing combined objective scores) and applies a hybrid local search combining random node insertions and segment shifts, ensuring feasibility by validating tour uniqueness and completeness. It adaptively adjusts parameters to explore diverse neighborhoods while falling back to simpler operations if needed. The method prioritizes exploration by randomly perturbing segments and nodes, balancing exploration with feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: combine node insertions and segment shifts\n    # Step 1: Randomly select a node to insert elsewhere\n    node = np.random.choice(new_solution)\n    idx = np.where(new_solution == node)[0][0]\n    new_solution = np.delete(new_solution, idx)\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Randomly select a segment to shift\n    segment_size = np.random.randint(2, min(5, n))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.delete(new_solution, np.s_[start:start+segment_size])\n    insert_pos = np.random.randint(0, n - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler node insertion\n        new_solution = base_solution.copy()\n        node = np.random.choice(new_solution)\n        idx = np.where(new_solution == node)[0][0]\n        new_solution = np.delete(new_solution, idx)\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590416592200175,
            0.22849512100219727
        ],
        "raw_score": [
            6.281348843659081,
            7.059226482841522
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects promising solutions from an archive based on normalized objective scores and structural diversity, then applies a hybrid local search combining segment relocations and dynamic edge swaps, adaptively choosing operators based on solution quality and local topology to generate improved neighbors while ensuring feasibility. It prioritizes segment moves for higher-quality solutions and uses topology-aware edge swaps for others, with fallback to the original solution if invalidity occurs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic solution selection: prioritize solutions with high normalized objectives and low structural redundancy\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    structural_diversity = np.array([len(set(sol)) for (sol, _) in archive])  # Simple measure of structural diversity\n\n    # Combine normalized objectives and structural diversity for selection\n    scores = normalized.sum(axis=1) * (1 + 1 / (structural_diversity + 1e-8))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search with adaptive operator selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine operator selection probabilities based on solution quality\n    sol_quality = (normalized[selected_idx][0] + normalized[selected_idx][1]) / 2\n    segment_prob = max(0.1, sol_quality * 0.8)  # Higher quality solutions favor segment moves\n    swap_prob = 1 - segment_prob\n\n    if np.random.random() < segment_prob:\n        # Adaptive segment relocation\n        segment_length = min(3, max(1, int(np.random.random() * n // 3)))\n        start_pos = np.random.randint(n)\n        end_pos = (start_pos + segment_length) % n\n\n        if start_pos < end_pos:\n            segment = new_solution[start_pos:end_pos]\n            remaining = np.concatenate([new_solution[:start_pos], new_solution[end_pos:]])\n        else:\n            segment = np.concatenate([new_solution[start_pos:], new_solution[:end_pos]])\n            remaining = new_solution[end_pos:start_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(remaining)):\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n    else:\n        # Dynamic edge swap with topology-aware selection\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Determine swap type based on local topology\n        dist1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[(a-1)%n]]\n        dist2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[(a-1)%n]]\n\n        if dist1 + dist2 > distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + \\\n           distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[(a-1)%n]]:\n            # Perform the swap if it improves both objectives\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9874616550993895,
            0.7441497445106506
        ],
        "raw_score": [
            10.517218484537604,
            10.642625561096308
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring better objectives, then applies a hybrid local search combining node swapping (40% chance) and segment insertion (60% chance) for 15 iterations, ensuring feasibility by validating and repairing the tour if nodes are missing. The selection prioritizes solutions with lower objective values, while the local search explores diverse modifications to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(o[0] for o in objectives)\n    min_obj2 = min(o[1] for o in objectives)\n    weights = [(min_obj1 / o[0] + min_obj2 / o[1]) for o in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine node swapping and segment insertion\n    n = len(new_solution)\n    for _ in range(15):  # Increased iterations\n        # Randomly select two distinct edges to modify\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Node swapping: swap two nodes\n        if random.random() < 0.4:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment insertion: move a segment between two random positions\n        else:\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[b:c], new_solution[b:]])\n\n    # Ensure the solution remains a valid tour (visits each node exactly once)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Recover feasibility by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9138960752940551,
            0.14283901453018188
        ],
        "raw_score": [
            10.419760007142234,
            10.631350875391004
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with better balanced objectives (weighted 60% for the first and 40% for the second objective) and applies a hybrid local search combining edge swaps (70% probability) and segment reversals (50% probability) to generate a neighbor solution. If the generated solution is invalid, it reverts to a simpler edge swap to ensure feasibility. The approach balances exploration and exploitation by dynamically adjusting the search based on objective weights and prioritizing edge swaps for higher-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with weighted objective score (prioritize better balance)\n    weights = np.array([0.6, 0.4])  # Weight for objectives\n    archive.sort(key=lambda x: np.dot(weights, x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: edge swap + segment reversal\n    # Step 1: Edge swap with probability 0.7\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to single edge swap\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.962628363971866,
            0.3214622139930725
        ],
        "raw_score": [
            5.518734347771969,
            6.873537403646718
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive solution selection based on crowding distance with a hybrid local search that alternates between region-based node swaps (focused on high-diversity areas) and objective-biased segment reversals (targeting the worse-performing objective), while ensuring feasibility through validation and fallback to the original solution. The selection prioritizes solutions with high crowding distance (indicating Pareto-front potential), and the local search dynamically adapts its strategy to balance multi-objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Adaptive selection using crowding distance\n    objectives = np.array([obj for (sol, obj) in archive])\n    fronts = np.zeros(len(archive), dtype=int)\n    crowding_distances = np.zeros(len(archive))\n\n    # Non-dominated sorting\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                dominates = (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and \\\n                             (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1])\n                if dominates:\n                    fronts[j] += 1\n\n    # Assign crowding distances\n    for front in np.unique(fronts):\n        front_indices = np.where(fronts == front)[0]\n        if len(front_indices) == 0:\n            continue\n\n        front_objectives = objectives[front_indices]\n        for obj_idx in range(2):\n            sorted_indices = np.argsort(front_objectives[:, obj_idx])\n            crowding_distances[front_indices[sorted_indices[0]]] = float('inf')\n            crowding_distances[front_indices[sorted_indices[-1]]] = float('inf')\n            if len(sorted_indices) > 2:\n                max_obj = front_objectives[sorted_indices[-1], obj_idx]\n                min_obj = front_objectives[sorted_indices[0], obj_idx]\n                for i in range(1, len(sorted_indices) - 1):\n                    if max_obj == min_obj:\n                        crowding_distances[front_indices[sorted_indices[i]]] += 0\n                    else:\n                        crowding_distances[front_indices[sorted_indices[i]]] += (front_objectives[sorted_indices[i+1], obj_idx] - front_objectives[sorted_indices[i-1], obj_idx]) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search\n    if np.random.random() < 0.5:  # Region-based node swap\n        # Identify high-diversity regions\n        region_size = max(3, n // 5)\n        region_costs = []\n        for i in range(n):\n            segment = new_solution[i:i+region_size]\n            cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            region_costs.append(cost1 + cost2)\n\n        # Select high-diversity region\n        high_div_regions = np.argsort(region_costs)[-2:]  # Top 2 regions\n        region_idx = np.random.choice(high_div_regions)\n        region_start = region_idx\n        region_end = (region_idx + region_size) % n\n\n        # Perform node swap within region\n        if region_start < region_end:\n            i, j = np.random.choice(range(region_start, region_end), size=2, replace=False)\n        else:\n            i = np.random.randint(region_start, n)\n            j = np.random.randint(0, region_end)\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Objective-biased segment reversal\n        # Identify worse-performing objective\n        cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        if cost1 > cost2:  # Improve first objective\n            # Find segment to reverse\n            best_improvement = 0\n            best_segment = None\n            for length in range(3, min(7, n)):\n                for start in range(n):\n                    end = (start + length) % n\n                    if start < end:\n                        segment = new_solution[start:end]\n                    else:\n                        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n                    reversed_segment = segment[::-1]\n                    if start < end:\n                        candidate = np.concatenate([new_solution[:start], reversed_segment, new_solution[end:]])\n                    else:\n                        candidate = np.concatenate([reversed_segment, new_solution[end:start]])\n\n                    new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n                    improvement = cost1 - new_cost1\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_segment = (start, end)\n\n            if best_segment:\n                start, end = best_segment\n                if start < end:\n                    segment = new_solution[start:end]\n                    new_solution[start:end] = segment[::-1]\n                else:\n                    segment = np.concatenate([new_solution[start:], new_solution[:end]])\n                    reversed_segment = segment[::-1]\n                    new_solution = np.concatenate([reversed_segment[:n-end], new_solution[end:start], reversed_segment[n-end:]])\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9694891266233484,
            9.322016298770905
        ],
        "raw_score": [
            10.485636376399547,
            10.5680771605325
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective scores) and applies a multi-segment shuffle strategy: it randomly selects non-overlapping segments of the tour, reverses their order, and optimizes their internal structure through edge swaps and reversals, ensuring feasibility by validating uniqueness of nodes. The number of segments and their lengths are dynamically determined based on the tour size.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-segment shuffle strategy\n    num_segments = min(3, max(1, n // 5))  # Determine number of segments to shuffle\n    segment_length = max(2, n // (2 * num_segments))  # Ensure segments are substantial\n\n    # Randomly select non-overlapping segments\n    segments = []\n    used_indices = set()\n    for _ in range(num_segments):\n        while True:\n            start = np.random.randint(n)\n            end = (start + segment_length) % n\n            if start < end:\n                if not any(s <= end and e >= start for s, e in segments):\n                    segments.append((start, end))\n                    used_indices.update(range(start, end))\n                    break\n            else:\n                if not any((s <= n-1 and e >= start) or (s <= end and e >= 0) for s, e in segments):\n                    segments.append((start, end))\n                    used_indices.update(range(start, n))\n                    used_indices.update(range(0, end))\n                    break\n\n    # Reverse the order of segments in the solution\n    segment_order = sorted(segments, key=lambda x: x[0])\n    shuffled_order = segment_order.copy()\n    np.random.shuffle(shuffled_order)\n\n    # Reconstruct the solution with segments in new order\n    temp_solution = []\n    last_pos = 0\n    for (s, e), (new_s, new_e) in zip(segment_order, shuffled_order):\n        if last_pos < s:\n            temp_solution.extend(new_solution[last_pos:s])\n        temp_solution.extend(new_solution[new_s:new_e])\n        last_pos = e\n    if last_pos < n:\n        temp_solution.extend(new_solution[last_pos:])\n\n    # Optimize internal structure of segments\n    for s, e in segment_order:\n        segment = new_solution[s:e]\n        # Random edge swaps within segment\n        for _ in range(min(3, len(segment)//2)):\n            i, j = np.random.choice(len(segment), size=2, replace=False)\n            segment[i], segment[j] = segment[j], segment[i]\n        # Segment reversal\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        # Reinsert optimized segment\n        temp_solution[s:e] = segment\n\n    # Validate solution\n    if len(np.unique(temp_solution)) == n:\n        new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.775134537552052,
            0.1574108600616455
        ],
        "raw_score": [
            7.53251816198539,
            7.067323953454627
        ]
    },
    {
        "algorithm": "The algorithm selects high-crowding-distance solutions from the Pareto front and applies a hybrid operator combining dynamic segment shuffling (randomly reshuffling segments of varying sizes) and edge swaps biased toward high-crowding regions to generate feasible neighbors, prioritizing regions with potential for improvement. The method ensures feasibility by validating uniqueness and length of the new tour, reverting to the original if invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Crowding-distance-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    crowding = np.zeros(len(archive))\n\n    # Calculate crowding distance for each objective\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        range_obj = objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i]\n\n        if range_obj == 0:\n            continue\n\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / range_obj\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 2: Hybrid operator - dynamic segment shuffling + edge swaps\n    # Dynamic segment shuffling\n    segment_size = min(5, max(2, int(np.random.normal(n/4, n/8))))\n    segment_size = max(2, min(n-1, segment_size))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n    np.random.shuffle(segment)\n    new_solution = np.concatenate([new_solution[:start], segment, new_solution[start+segment_size:]])\n\n    # Edge swaps biased toward high-crowding regions\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        # Higher probability for nodes in high-crowding regions\n        if np.random.random() < 0.7 * (crowding[selected_idx] / (np.max(crowding) + 1e-8)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9482469597193108,
            0.4730827212333679
        ],
        "raw_score": [
            10.430837534151927,
            10.603526536712986
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted random selection (prioritizing lower objective scores) and applies a hybrid local search combining path reversal and segment swapping with adaptive segment sizes, ensuring feasibility through checks and fallback to simple swaps if invalid. The method emphasizes exploration via probabilistic segment operations while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted random selection based on objective scores (lower is better)\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.max(objectives) - objectives + 1e-6  # Invert scores for selection\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: path reversal with adaptive segment size\n    segment_size = min(max(2, int(np.random.normal(n/4, n/8))), n-1)\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Reverse a segment (path reversal)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive segment swapping\n    if np.random.rand() < 0.3:  # 30% chance to swap segments\n        swap_size = min(max(2, int(np.random.normal(n/6, n/12))), n//2)\n        pos1 = np.random.randint(0, n - swap_size + 1)\n        pos2 = np.random.randint(0, n - swap_size + 1)\n        if pos1 != pos2:\n            segment1 = new_solution[pos1:pos1+swap_size]\n            segment2 = new_solution[pos2:pos2+swap_size]\n            new_solution[pos1:pos1+swap_size] = segment2\n            new_solution[pos2:pos2+swap_size] = segment1\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8390505238189782,
            0.1826220154762268
        ],
        "raw_score": [
            6.4135098774140795,
            6.383777095329164
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on combined objective scores) and applies a hybrid local search combining random node insertions and segment relocations, while ensuring feasibility by validating uniqueness and completeness, with a fallback to node swaps for invalid cases. It prioritizes exploration of non-standard neighborhoods through adaptive segment selection and maintains validity through checks. The solution is selected based on the sum of objectives, and the local search dynamically adjusts by relocating segments and inserting nodes, reverting to simpler swaps if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: combine node insertion and segment relocation\n    # Step 1: Randomly select a node to insert elsewhere\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Insert the node at a random position\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Randomly select a segment to relocate\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.delete(new_solution, np.arange(a, b+1))\n\n    # Insert the segment at a random position\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to a simpler node swap\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9349723795388156,
            0.24263978004455566
        ],
        "raw_score": [
            6.556954003030747,
            6.544141442077507
        ]
    },
    {
        "algorithm": "The algorithm randomly selects a solution from the archive, applies a hybrid local search combining large-scale segment reversals and adaptive node swaps, and ensures feasibility by validating and reverting to simpler operations if needed. It prioritizes segment size and swap count adaptively, balancing exploration and exploitation while maintaining tour validity. The design emphasizes dynamic neighborhood exploration through segment-based operations and probabilistic swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Randomly select a solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: large-scale segment reversal and adaptive node swaps\n    # Step 1: Randomly select a large segment to reverse\n    segment_size = np.random.randint(3, min(7, n))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n    new_solution[start:start+segment_size] = segment[::-1]\n\n    # Step 2: Adaptive node swaps based on segment size\n    swap_count = min(3, segment_size // 2)\n    for _ in range(swap_count):\n        i, j = np.random.choice(segment_size, 2, replace=False)\n        new_solution[start+i], new_solution[start+j] = new_solution[start+j], new_solution[start+i]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        new_solution = base_solution.copy()\n        segment_size = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[start:start+segment_size]\n        new_solution[start:start+segment_size] = segment[::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8769073360674927,
            0.22339999675750732
        ],
        "raw_score": [
            6.91705443144627,
            7.299967671043923
        ]
    }
]