[
    {
        "algorithm": "The algorithm selects the highest-cost solution from the archive (sorted by descending total cost) and applies a hybrid local search combining segment inversion and segment swapping, ensuring the neighbor remains a valid TSP tour. The selection prioritizes solutions with higher total cost, while the local search randomly inverts or swaps segments to explore the solution space. The approach balances exploration (via random segment selection) and exploitation (by targeting high-cost solutions for improvement).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8212540227787393,
            0.17821145057678223
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8622967880281742,
            0.20535552501678467
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower average cost) and applies a hybrid local search combining segment inversion and edge insertion to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes. The method intelligently explores neighborhoods while balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to invert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Choose a random edge to insert elsewhere\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        edge = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], edge])\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8253635069716272,
            0.20474779605865479
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.940814033356052,
            0.2891772389411926
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive using a tournament-based approach with dynamic weights (prioritizing solutions near the Pareto front) and applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge swaps (optimizing both objectives simultaneously) while ensuring feasibility. The dynamic weighting scheme (e.g., weight1 = 0.7 if cost1 dominates) and quality-based segment sizing (e.g., segment_size = int(n * (0.4 + 0.6 * quality))) are key design choices.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Nondominated selection with dynamic weighting\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    # Dynamic weight vector (changes based on solution quality)\n    weight1 = 0.7 if max_cost1 > max_cost2 else 0.3\n    weight2 = 1 - weight1\n\n    # Tournament selection (size 2)\n    candidates = random.sample(range(len(archive)), min(2, len(archive)))\n    selected_idx = candidates[0]\n    for idx in candidates[1:]:\n        cost1_a, cost2_a = costs[selected_idx]\n        cost1_b, cost2_b = costs[idx]\n        score_a = (cost1_a / max_cost1) * weight1 + (cost2_a / max_cost2) * weight2\n        score_b = (cost1_b / max_cost1) * weight1 + (cost2_b / max_cost2) * weight2\n        if score_b < score_a:\n            selected_idx = idx\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal (larger segments for better solutions)\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.4 + 0.6 * quality)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge swapping (optimize both objectives)\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate improvement for both objectives\n            prev_node_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node_i = new_solution[(i+1)%n]\n            prev_node_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node_j = new_solution[(j+1)%n]\n\n            # Original cost\n            orig_cost1 = (distance_matrix_1[prev_node_i, node_i] + distance_matrix_1[node_i, next_node_i] +\n                          distance_matrix_1[prev_node_j, node_j] + distance_matrix_1[node_j, next_node_j])\n            orig_cost2 = (distance_matrix_2[prev_node_i, node_i] + distance_matrix_2[node_i, next_node_i] +\n                          distance_matrix_2[prev_node_j, node_j] + distance_matrix_2[node_j, next_node_j])\n\n            # Swapped cost\n            new_cost1 = (distance_matrix_1[prev_node_i, node_j] + distance_matrix_1[node_j, next_node_i] +\n                         distance_matrix_1[prev_node_j, node_i] + distance_matrix_1[node_i, next_node_j])\n            new_cost2 = (distance_matrix_2[prev_node_i, node_j] + distance_matrix_2[node_j, next_node_i] +\n                         distance_matrix_2[prev_node_j, node_i] + distance_matrix_2[node_i, next_node_j])\n\n            # Accept if improves weighted sum\n            if (new_cost1 * weight1 + new_cost2 * weight2) < (orig_cost1 * weight1 + orig_cost2 * weight2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7766006463554873,
            0.23874443769454956
        ]
    },
    {
        "algorithm": "The heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9104672619156713,
            0.32973289489746094
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from an archive based on its dominance in the Pareto front, using inverse dominance weights to prioritize non-dominated solutions, and applies a hybrid local search combining node relocation with segment rotation to generate feasible neighbor solutions while maintaining tour validity. The selection strategy balances exploration and exploitation by favoring solutions with fewer dominating neighbors, while the local search operator introduces diversity through randomized node movement and segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weight adjustment based on dominance in Pareto front\n    dominated_count = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                cost_i = archive[i][1]\n                cost_j = archive[j][1]\n                if (cost_i[0] <= cost_j[0] and cost_i[1] < cost_j[1]) or (cost_i[0] < cost_j[0] and cost_i[1] <= cost_j[1]):\n                    dominated_count[j] += 1\n\n    # Select solution with probability inversely proportional to its dominance\n    weights = [1.0 / (1 + count) for count in dominated_count]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relocation with segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n\n    # Create new solution by removing the node and inserting it into the rotated segment\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9254894964269617,
            0.3887676000595093
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from an archive using a weighted mechanism that prioritizes lower costs in one objective and higher costs in another, then applies a hybrid local search combining adaptive segment reversal (with larger segments for better solutions) and guided edge insertion (optimizing both distance matrices simultaneously) to generate improved, feasible neighbors. The weights balance exploration and exploitation, while the local search adaptively refines solutions based on their quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objectives and compute weights\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Combine inverse and direct weighting for balanced selection\n        weight = (0.4 * (1 - norm_cost1) + 0.6 * norm_cost2)  # Prioritize lower cost1 and higher cost2\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on both distance matrices\n    for _ in range(3):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8216530583581655,
            0.3038076162338257
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive using weighted tournament selection, then applies a hybrid local search combining adaptive segment reversal (with segment size adjusted based on solution quality) and guided edge swapping (accepting swaps only if they improve both objectives), ensuring feasibility through dynamic repair. The selection weights balance the two objectives equally, while the local search adaptively balances exploration and exploitation based on solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted tournament selection for nondominated solutions\n    nondominated = []\n    for i, (sol, cost) in enumerate(archive):\n        dominated = False\n        for j, (_, other_cost) in enumerate(archive):\n            if i != j and (other_cost[0] <= cost[0] and other_cost[1] <= cost[1]) and (other_cost[0] < cost[0] or other_cost[1] < cost[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, cost))\n\n    if not nondominated:\n        nondominated = archive.copy()\n\n    weights = []\n    max_cost1 = max(c[0] for _, c in nondominated) if max(c[0] for _, c in nondominated) > 0 else 1\n    max_cost2 = max(c[1] for _, c in nondominated) if max(c[1] for _, c in nondominated) > 0 else 1\n\n    for _, cost in nondominated:\n        norm_cost1 = cost[0] / max_cost1\n        norm_cost2 = cost[1] / max_cost2\n        weights.append(0.5 * norm_cost1 + 0.5 * norm_cost2)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(nondominated)] * len(nondominated)\n\n    selected_idx = random.choices(range(len(nondominated)), weights=weights, k=1)[0]\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal with guided edge swapping\n    if n >= 4:\n        # Adaptive segment reversal\n        quality = (nondominated[selected_idx][1][0] + nondominated[selected_idx][1][1]) / (max_cost1 + max_cost2)\n        segment_size = max(2, int(n * (0.5 - 0.4 * quality)))\n        a = random.randint(0, n - segment_size)\n        b = a + segment_size - 1\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided edge swapping\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                # Calculate improvement in both objectives\n                delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                         (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                         (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                # Accept if improves both objectives\n                if delta1 <= 0 and delta2 <= 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # Repair by adding missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8245285542232021,
            0.3500186800956726
        ]
    },
    {
        "algorithm": "The algorithm combines multi-objective aware selection with dynamic local search: it selects solutions based on weighted improvement potential (equal weighting for both objectives) and applies either fine-grained or aggressive perturbations (segment reversal or edge insertion) based on solution quality, ensuring feasibility through validation checks. The selection prioritizes solutions with lower normalized costs, while the local search adapts its intensity based on the solution's proximity to optimality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective aware selection with dynamic weighting\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Dynamic weighting based on relative improvement potential\n        norm_cost1 = cost1 / max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        norm_cost2 = cost2 / max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        weight = 1 - (0.5 * norm_cost1 + 0.5 * norm_cost2)  # Equal weighting for both objectives\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive perturbation based on solution quality\n    cost1, cost2 = archive[selected_idx][1]\n    max_cost1 = max(c[0] for _, c in archive)\n    max_cost2 = max(c[1] for _, c in archive)\n\n    # If solution is close to optimal in both objectives, use fine-grained perturbation\n    if (cost1 / max_cost1 < 0.3 and cost2 / max_cost2 < 0.3):\n        # Fine-grained edge swap with validation\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        if len(set(temp_solution)) == n:\n            new_solution = temp_solution\n    else:\n        # More aggressive perturbation for solutions with room for improvement\n        operation = random.choice(['segment_reversal', 'edge_insertion'])\n\n        if operation == 'segment_reversal':\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final validation check\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9212690369465448,
            0.6433501243591309
        ]
    }
]