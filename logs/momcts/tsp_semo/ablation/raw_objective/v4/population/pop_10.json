[
    {
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objective scores) and applies a hybrid local search combining 3-opt moves with greedy edge insertion to generate a neighbor while ensuring feasibility. The algorithm prioritizes solutions with better combined performance and uses a mix of random and greedy operations to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined normalized objective score\n    def normalize_objectives(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return norm1 + norm2\n\n    best_solution = min(archive, key=lambda x: normalize_objectives(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search operator\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 3-opt move (randomly select 3 edges and reconnect them)\n        if n >= 4:\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[:i]\n            segment2 = new_solution[i:j+1]\n            segment3 = new_solution[j+1:k+1]\n            segment4 = new_solution[k+1:]\n\n            # Try all possible reconnections\n            possible_solutions = [\n                np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n                np.concatenate([segment1, segment3, segment2, segment4]),\n                np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n                np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n                np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n                np.concatenate([segment1, segment3, segment2[::-1], segment4])\n            ]\n\n            # Select the best solution based on both objectives\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return cost1 + cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Greedy edge insertion (try to improve by inserting nodes in a better position)\n        for _ in range(3):  # Limit iterations to avoid excessive computation\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n\n            # Remove the node\n            temp_solution = np.delete(new_solution, i)\n\n            # Find the best insertion position\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(best_solution)\n    return neighbor\n\n",
        "score": [
            5.426902453633912,
            6.119995236995279
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of normalized objectives (prioritizing the first objective with a 0.7 weight), then applies a hybrid local search combining 4-opt moves with adaptive edge swapping. The 4-opt operator reconnects randomly selected segments in all possible ways and evaluates them using adaptive weighting (0.6 for the first objective), while the edge swapping focuses on high-improvement regions to refine the solution. The method ensures feasibility by maintaining valid TSP tours throughout all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    def weighted_score(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return 0.7 * norm1 + 0.3 * norm2  # Weighted toward first objective\n\n    selected_solution = min(archive, key=lambda x: weighted_score(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid 4-opt with adaptive edge swapping\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move (randomly select 4 edges and reconnect)\n        if n >= 6:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Generate all possible 4-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n            ]\n\n            # Evaluate with adaptive weighting\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return 0.6 * cost1 + 0.4 * cost2  # Adaptive weighting\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Adaptive edge swapping\n        for _ in range(2):\n            # Select high-improvement region\n            region_size = max(3, n // 5)\n            region_start = np.random.randint(0, n - region_size)\n            region = new_solution[region_start:region_start+region_size]\n\n            # Try swapping edges within the region\n            for i in range(len(region)-1):\n                for j in range(i+1, len(region)):\n                    temp = new_solution.copy()\n                    temp[region_start+i], temp[region_start+j] = temp[region_start+j], temp[region_start+i]\n\n                    # Check if improvement\n                    current_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                                  sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                    new_cost = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n)) + \\\n                               sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n\n                    if new_cost < current_cost:\n                        new_solution = temp\n                        break\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            4.676603931493985,
            7.643328294004073
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best Pareto front position\n    def pareto_dominance(obj1, obj2):\n        min1 = min(o[1][0] for o in archive)\n        max1 = max(o[1][0] for o in archive)\n        min2 = min(o[1][1] for o in archive)\n        max2 = max(o[1][1] for o in archive)\n\n        norm1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0.5\n        norm2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0.5\n        return (norm1, norm2)\n\n    # Sort by Pareto dominance (lexicographic order)\n    archive_sorted = sorted(archive, key=lambda x: pareto_dominance(x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search combining adaptive 5-opt and dynamic edge insertion\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Adaptive 5-opt move\n        if n >= 7:\n            # Select 5 distinct positions\n            points = sorted(np.random.choice(n, 5, replace=False))\n            segments = [\n                new_solution[:points[0]],\n                new_solution[points[0]:points[1]+1],\n                new_solution[points[1]+1:points[2]+1],\n                new_solution[points[2]+1:points[3]+1],\n                new_solution[points[3]+1:points[4]+1],\n                new_solution[points[4]+1:]\n            ]\n\n            # Generate all possible 5-opt reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[1][::-1], segments[3], segments[2][::-1], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4], segments[5]]),\n                np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4], segments[5]])\n            ]\n\n            # Evaluate with dynamic weighting based on current solution quality\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                # Dynamic weighting: favor objective with higher current cost\n                if cost1 > cost2:\n                    return 0.7 * cost1 + 0.3 * cost2\n                else:\n                    return 0.3 * cost1 + 0.7 * cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Dynamic edge insertion\n        for _ in range(3):\n            # Select a random node to reinsert\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n\n            # Remove the node\n            temp_solution = np.delete(new_solution, node_idx)\n\n            # Find best insertion position with dynamic evaluation\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n-1):\n                candidate = np.insert(temp_solution, pos, node)\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%(n-1)]] for i in range(n-1))\n\n                # Dynamic evaluation based on current solution quality\n                current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n                current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n                if current_cost1 > current_cost2:\n                    total_cost = 0.7 * cost1 + 0.3 * cost2\n                else:\n                    total_cost = 0.3 * cost1 + 0.7 * cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n        return new_solution\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            5.1956880402110865,
            7.488018690703704
        ]
    },
    {
        "algorithm": "The heuristic function selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility through validation checks. The algorithm focuses on improving solutions by strategically breaking and rearranging segments of the tour, with randomness in edge selection to explore diverse neighborhoods, though it reverts to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimizing both objectives)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Step 1: Randomly select two non-adjacent edges to break\n    a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(a - b) == 1:  # Ensure not adjacent\n        a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    # Step 2: Remove the edges and reverse the segment between them\n    segment = new_solution[a+1:b+1]\n    new_solution[a+1:b+1] = segment[::-1]\n\n    # Step 3: Randomly insert a segment between two other edges\n    c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(c - d) == 1:  # Ensure not adjacent\n        c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    segment = new_solution[c+1:d+1]\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.1486496758090725,
            6.291455144403966
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of normalized objective values (60% weight on the first objective), then applies a hybrid local search combining random segment rotation and edge swapping to generate a neighbor, ensuring feasibility by validating node uniqueness and reverting to the original if invalid. It prioritizes the first objective while maintaining diversity through random operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (np.max(objectives, axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: segment rotation and edge swapping\n    # Step 1: Random segment rotation\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    rotation = np.random.randint(1, min(3, n))\n    segment = new_solution[a:b]\n    rotated = np.roll(segment, rotation)\n    new_solution[a:b] = rotated\n\n    # Step 2: Random edge swap\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validation\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.961079468668251,
            7.339298399089364
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on combined objective costs) and applies a novel multi-objective segment relocation strategy, prioritizing edges with high combined importance from both objectives. It probabilistically relocates segments to better positions, balancing both objectives while ensuring feasibility through validation. The method dynamically adapts segment selection and insertion based on edge importance across both spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (minimizing both objectives)\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment relocation strategy\n    def calculate_edge_importance(solution, matrix):\n        importance = []\n        for i in range(n):\n            j = (i + 1) % n\n            importance.append(matrix[solution[i], solution[j]])\n        return np.array(importance)\n\n    # Calculate edge importance for both objectives\n    imp1 = calculate_edge_importance(base_solution, distance_matrix_1)\n    imp2 = calculate_edge_importance(base_solution, distance_matrix_2)\n    combined_importance = imp1 + imp2\n\n    # Select segments based on importance\n    sorted_edges = np.argsort(combined_importance)[::-1]\n    selected_edges = sorted_edges[:max(2, n//4)]\n\n    # Relocate segments probabilistically\n    for edge in selected_edges:\n        if np.random.rand() < 0.7:  # 70% chance to relocate\n            segment_start = edge\n            segment_end = (edge + 1) % n\n\n            # Remove segment\n            segment = new_solution[segment_start:segment_end+1]\n            remaining = np.delete(new_solution, slice(segment_start, segment_end+1))\n\n            # Find insertion points based on both objectives\n            insertion_scores = []\n            for i in range(len(remaining)):\n                candidate = np.insert(remaining, i, segment)\n                cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%len(candidate)]] for j in range(len(candidate)))\n                insertion_scores.append(cost1 + cost2)\n\n            best_insertion = np.argmin(insertion_scores)\n            new_solution = np.insert(remaining, best_insertion, segment)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.748072244320239,
            7.36351065315697
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with lower individual objective values, then applies a hybrid local search combining segment rotation and edge swapping to generate a neighbor solution while ensuring feasibility through validation checks. It focuses on improving solutions by strategically rotating segments and swapping edges, with randomness in segment selection to explore diverse neighborhoods, reverting to the original solution if feasibility is violated. The selection prioritizes solutions with lower individual objective values, and the hybrid local search combines segment rotation and edge swapping to explore the neighborhood space while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimizing either objective)\n    selected_idx = np.argmin([min(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful changes\n\n    # Hybrid local search: combine segment rotation and edge swapping\n    a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(a - b) == 1:  # Ensure not adjacent\n        a, b = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    # Step 1: Rotate the segment between a and b\n    segment = new_solution[a+1:b+1]\n    if len(segment) > 1:\n        rotation = np.random.randint(1, len(segment))\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a+1:b+1] = segment\n\n    # Step 2: Randomly swap two edges\n    c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n    while abs(c - d) == 1:  # Ensure not adjacent\n        c, d = sorted(np.random.choice(range(n-1), 2, replace=False))\n\n    # Swap edges (c, c+1) and (d, d+1)\n    if c + 1 != d and d + 1 != c:\n        new_solution[c+1], new_solution[d+1] = new_solution[d+1], new_solution[c+1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.736581277940244,
            7.653234220300595
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive with high objective variance (indicating potential for improvement), then applies a hybrid local search combining node insertion and edge exchange to generate a neighbor solution while ensuring feasibility through validation checks. The selection prioritizes solutions with diverse objectives, while the local search strategically modifies the tour by moving nodes and reversing segments to explore the solution space. The algorithm maintains feasibility by validating the solution length and node uniqueness after each operation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Select a solution with high potential (e.g., high variance in objectives)\n    if len(non_dominated) > 1:\n        # Sort by objective variance (higher variance indicates more potential)\n        non_dominated.sort(key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n        selected = non_dominated[0][0].copy()\n    else:\n        selected = non_dominated[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: node insertion + edge exchange\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Node insertion: move node at position j to position i+1\n        node = new_solution[j]\n        new_pos = (i + 1) % n\n        new_solution = np.insert(new_solution, new_pos, node)\n        if j < new_pos:\n            new_solution = np.delete(new_solution, j)\n        else:\n            new_solution = np.delete(new_solution, j + 1)\n\n        # Edge exchange: swap edges between i and j\n        if i + 1 < j:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility (though the operations above should maintain it)\n    assert len(new_solution) == len(selected), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected), \"Duplicate nodes introduced\"\n\n    return new_solution\n\n",
        "score": [
            8.064875610090384,
            7.627547120134032
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on a weighted combination of objectives (60% first objective, 40% second objective) and applies a hybrid local search combining 4-opt moves with simulated annealing-inspired edge swaps to generate a neighbor solution while ensuring feasibility. The 4-opt move reconnects four randomly selected edges in all possible ways, while the simulated annealing approach probabilistically accepts edge swaps to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective combination\n    def weighted_objective(obj1, obj2):\n        return 0.6 * obj1 + 0.4 * obj2\n\n    selected_solution = min(archive, key=lambda x: weighted_objective(x[1][0], x[1][1]))[0].copy()\n\n    # Hybrid local search combining 4-opt and simulated annealing edge swaps\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # 4-opt move (randomly select 4 edges and reconnect them)\n        if n >= 5:\n            i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n            segments = [\n                new_solution[:i],\n                new_solution[i:j+1],\n                new_solution[j+1:k+1],\n                new_solution[k+1:l+1],\n                new_solution[l+1:]\n            ]\n\n            # Try all possible reconnections\n            possible_solutions = [\n                np.concatenate([segments[0], segments[1][::-1], segments[2], segments[3][::-1], segments[4]]),\n                np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n                np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n                np.concatenate([segments[0], segments[3], segments[1], segments[2], segments[4]])\n            ]\n\n            # Select best solution based on both objectives\n            def evaluate(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return cost1 + cost2\n\n            best_new = min(possible_solutions, key=evaluate)\n            new_solution = best_new\n\n        # Simulated annealing-inspired edge swaps\n        temp = 100.0\n        cooling_rate = 0.99\n        current = new_solution.copy()\n\n        for _ in range(10):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Create candidate solution with swapped edges\n            candidate = current.copy()\n            candidate[i:j+1] = candidate[i:j+1][::-1]\n\n            # Evaluate costs\n            current_cost1 = sum(distance_matrix_1[current[k], current[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[current[k], current[(k+1)%n]] for k in range(n))\n            candidate_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            candidate_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Acceptance criteria\n            delta_cost = (candidate_cost1 + candidate_cost2) - (current_cost1 + current_cost2)\n            if delta_cost < 0 or np.random.random() < np.exp(-delta_cost / temp):\n                current = candidate\n\n            temp *= cooling_rate\n\n        return current\n\n    neighbor = hybrid_local_search(selected_solution)\n    return neighbor\n\n",
        "score": [
            8.091014852562742,
            8.094147814058651
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective values) and applies a hybrid local search combining 3-opt moves with randomized edge swaps to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The 3-opt moves explore different segment reversals, while the randomized edge swaps introduce diversity, with both strategies prioritizing solutions that improve the combined cost across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 3-opt with randomized edge swaps\n    for _ in range(10):  # Number of iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Generate three possible 3-opt moves\n        moves = [\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n        ]\n\n        # Evaluate all moves based on both objectives\n        best_move = None\n        best_score = float('inf')\n\n        for move in moves:\n            cost1 = sum(distance_matrix_1[move[i], move[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[move[i], move[(i+1)%n]] for i in range(n))\n            score = cost1 + cost2  # Combined score for selection\n\n            if score < best_score:\n                best_score = score\n                best_move = move\n\n        if best_move is not None:\n            new_solution = best_move\n\n        # Randomized edge swap for diversification\n        if random.random() < 0.3:  # 30% chance\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.180994436644973,
            8.169521320452091
        ]
    }
]