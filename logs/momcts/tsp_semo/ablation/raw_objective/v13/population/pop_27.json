[
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n\n    # Hybrid local search: edge swap + segment reversal\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge swap (2-opt-like)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Segment reversal (novel operator)\n        if b - a > 2:\n            c = np.random.randint(a+1, b)\n            new_solution[a:c] = new_solution[a:c][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            5.692783799934242,
            6.250821588805908
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower combined objectives) and applies a dynamic, objective-aware local search combining segment inversions and edge swaps, evaluating improvements in both objectives to ensure feasibility while balancing exploration and exploitation. It adaptively selects segment sizes and accepts inversions or swaps that show significant improvements in either objective, ensuring valid TSP tours through permutation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Objective-aware segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement\n        if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.1 * abs(best_improvement[0]) or delta2 < -0.1 * abs(best_improvement[1])):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Edge swap with objective awareness\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    # Evaluate swap\n    pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n    pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n    orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n    new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n    new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.80145785411436,
            5.7754796233164205
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted random choice favoring lower objectives\n    weights = np.array([1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with multi-objective segment inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for trivial cases\n\n    # Step 1: Random edge swap (2-opt-like but with objective-aware selection)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1  # Ensure we don't create a degenerate tour\n\n    # Evaluate the swap in both objectives\n    def evaluate_swap(sol, i, j):\n        pre_i = sol[i-1] if i > 0 else sol[-1]\n        post_i = sol[i+1] if i < n-1 else sol[0]\n        pre_j = sol[j-1] if j > 0 else sol[-1]\n        post_j = sol[j+1] if j < n-1 else sol[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n        # New edges after swap\n        new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n        return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n    delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n    # Accept the swap if it improves at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse the segment\n    else:\n        # Step 2: Multi-objective segment inversion (novel operator)\n        # Select a segment based on objective diversity\n        segment_size = min(3, n // 2)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            # Original edges\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            # New edges after inversion\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        inv_delta1, inv_delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        # Accept inversion if it improves both objectives or one significantly\n        if (inv_delta1 < 0 and inv_delta2 < 0) or (inv_delta1 < -0.1 * delta1 or inv_delta2 < -0.1 * delta2):\n            new_solution[start:start+segment_size] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.350686397753774,
            6.472525333812347
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive segment selection with multi-objective-aware insertion heuristics, dynamically adjusting segment sizes based on improvement potential and strategically placing segments to simultaneously improve both objectives by analyzing trade-offs between distance matrices, while ensuring feasibility through permutation checks. It prioritizes solutions near the Pareto front and uses a weighted acceptance criterion to balance improvements in both objectives, with segment sizes adjusted based on recent performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with adaptive weighting favoring solutions near the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        pareto_front = []\n        for i, obj in enumerate(objectives):\n            dominated = False\n            for other in objectives:\n                if np.all(other <= obj) and np.any(other < obj):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n        if pareto_front:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment size based on recent improvements\n    segment_size = min(3, max(2, n // 5))\n    max_attempts = 5\n    best_delta1, best_delta2 = 0, 0\n    best_solution = new_solution.copy()\n\n    for attempt in range(max_attempts):\n        # Select random segment\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate segment removal\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # Find best insertion point for objective-balanced placement\n        best_pos = -1\n        best_value = float('inf')\n\n        for pos in range(n - segment_size + 1):\n            if pos >= start and pos <= start + segment_size - 1:\n                continue  # Skip current position\n\n            pre_new = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            post_new = new_solution[pos] if pos < n else new_solution[0]\n\n            # Calculate new costs\n            new_cost1 = distance_matrix_1[pre_new, segment[0]] + distance_matrix_1[segment[-1], post_new]\n            new_cost2 = distance_matrix_2[pre_new, segment[0]] + distance_matrix_2[segment[-1], post_new]\n\n            # Objective-balanced insertion evaluation\n            delta1 = new_cost1 - orig_cost1\n            delta2 = new_cost2 - orig_cost2\n            value = delta1 + delta2  # Simple sum for balanced improvement\n\n            if value < best_value:\n                best_value = value\n                best_pos = pos\n\n        if best_pos != -1 and best_value < -0.1 * (best_delta1 + best_delta2):\n            # Apply the insertion\n            temp_solution = np.delete(new_solution, slice(start, start+segment_size))\n            temp_solution = np.insert(temp_solution, best_pos, segment)\n\n            # Verify validity\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution.copy()\n                best_delta1, best_delta2 = best_value, best_value\n                best_solution = new_solution.copy()\n\n        # Adjust segment size based on recent improvements\n        if attempt > 0 and best_value >= 0:\n            segment_size = max(2, segment_size - 1)\n\n    return best_solution\n\n",
        "score": [
            6.541822262107865,
            6.0985840420962125
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighted selection based on normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1.0 / (1 + norm_obj[:, 0] + norm_obj[:, 1])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and improvement history\n    segment_size = max(2, min(5, n // 4))\n\n    # Hybrid local search: edge swap with objective-aware selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    def evaluate_swap(sol, i, j):\n        pre_i = sol[i-1] if i > 0 else sol[-1]\n        post_i = sol[i+1] if i < n-1 else sol[0]\n        pre_j = sol[j-1] if j > 0 else sol[-1]\n        post_j = sol[j+1] if j < n-1 else sol[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n        return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n    delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Multi-objective segment inversion with dynamic size adjustment\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        inv_delta1, inv_delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (inv_delta1 < 0 and inv_delta2 < 0) or (inv_delta1 < -0.2 * delta1 or inv_delta2 < -0.2 * delta2):\n            new_solution[start:start+segment_size] = segment[::-1]\n            segment_size = min(segment_size + 1, n // 2)  # Increase segment size if successful\n        else:\n            segment_size = max(2, segment_size - 1)  # Decrease segment size if unsuccessful\n\n    return new_solution\n\n",
        "score": [
            6.2773713446520905,
            6.484180850022769
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection based on normalized objective values, favoring solutions with balanced objectives, then applies a multi-segment inversion operator with adaptive segment sizes determined by the potential improvement in both objective spaces. The operator iteratively inverts segments of the tour to reduce costs in both spaces while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = 1 / (1 + np.sum(normalized, axis=1))  # Prefer solutions with balanced objectives\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Multi-segment inversion with adaptive segment sizes\n    for _ in range(5):  # Reduced iterations for computational efficiency\n        # Determine segment sizes based on objective improvement potential\n        segments = []\n        for _ in range(3):  # Generate 3 candidate segments\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[a:b]\n            # Calculate objective improvement if inverted\n            original_cost = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))) + \\\n                           sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n            inverted_cost = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + \\\n                           sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segments.append((a, b, original_cost - inverted_cost))\n\n        # Select segment with highest improvement potential\n        segments.sort(key=lambda x: x[2], reverse=True)\n        a, b, _ = segments[0]\n\n        # Apply inversion\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Feasibility check\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            6.617105714349662,
            6.555918881687816
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive by prioritizing those with lower objective values, then applies a hybrid local search combining 3-opt and edge insertion to explore diverse neighborhoods while ensuring feasibility. The algorithm favors solutions with better combined objectives and uses weighted random selection to balance exploration and exploitation. The local search modifies the tour by reversing segments and reinserting nodes, promoting diversity in the neighborhood.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select 3 distinct edges to modify\n    edges = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(edges)\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Edge insertion: randomly remove a node and reinsert it\n    remove_pos = np.random.randint(0, n)\n    node_to_insert = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n    insert_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.898571945341784,
            6.675233968408497
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random selection based on the inverse of the sum of objectives (prioritizing solutions with lower total cost), then applies a modified 3-opt local search by randomly selecting three edges, rearranging segments in a non-standard way (either keeping or reversing one segment), and ensuring the solution remains valid (no duplicates). This hybrid approach combines probabilistic selection with a creative edge-recombination strategy to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Randomly select a solution with probability proportional to its Pareto dominance\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Simple heuristic\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (modified 3-opt with adaptive edge selection)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    edges = np.random.choice(n, size=3, replace=False)\n    edges.sort()\n\n    # Extract the three segments\n    a, b, c = edges\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:]\n\n    # Recombine segments in a new order (modified 3-opt)\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([seg1, seg3, seg2, seg4])\n    else:\n        new_order = np.concatenate([seg1, seg3[::-1], seg2, seg4])\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    return new_solution\n\n",
        "score": [
            6.737422017237954,
            6.81557627061559
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high objective diversity, then applies a hybrid local search combining adaptive segment inversions guided by objective gradients, ensuring feasibility through permutation checks and dynamic segment size adjustments. It prioritizes segments with higher cumulative cost for inversion and occasionally expands segment sizes to explore larger neighborhoods, with a 30% chance of expanding segments to balance exploration and exploitation. The solution remains feasible by verifying unique node visits after each operation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.std(norm_objectives, axis=1)\n    weights = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 2: Hybrid local search with adaptive segment inversion\n    for _ in range(10):\n        # Randomly select segments\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Compute objective gradients for segments\n        def compute_segment_cost(sol, start, end):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            return cost1, cost2\n\n        seg1_cost = compute_segment_cost(new_solution, a, b)\n        seg2_cost = compute_segment_cost(new_solution, c, d)\n\n        # Invert the segment with higher cost\n        if sum(seg1_cost) > sum(seg2_cost):\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Adaptive segment size adjustment\n        if np.random.rand() < 0.3:  # 30% chance to expand segments\n            new_a = max(0, a - np.random.randint(1, 3))\n            new_b = min(n, b + np.random.randint(1, 3))\n            new_solution[new_a:new_b] = new_solution[new_a:new_b][::-1]\n\n        # Feasibility check\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            6.723299197151084,
            7.199738638153561
        ]
    },
    {
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower objective values preferred)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt + segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments are distinct\n    if a == c and b == d:\n        return new_solution\n\n    # Apply 2-opt between segments\n    if a < c and b < d:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Apply segment inversion\n    elif a < c and c < b and b < d:\n        new_solution[a:c] = new_solution[a:c][::-1]\n        new_solution[b:d] = new_solution[b:d][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if inversion causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.174185419602587,
            7.513302776359469
        ]
    }
]