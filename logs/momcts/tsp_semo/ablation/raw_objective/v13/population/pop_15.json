[
    {
        "algorithm": "The algorithm selects the solution with the lowest combined cost from the archive, then applies a hybrid local search combining segment reversal and edge swaps to generate a new neighbor solution while ensuring feasibility. It prioritizes solutions with higher potential improvement and uses novel segment reversal to explore the solution space beyond standard edge swaps. The selection and operators ensure valid tours by maintaining node uniqueness and completeness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement (simplified for this example)\n    potential = [sum(obj) for obj in objectives]\n    selected_idx = np.argmin(potential)  # Select the solution with the lowest combined cost\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random segment reversal (novel operator)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform a random edge swap (standard operator)\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9453093012944958,
            0.1820637583732605
        ],
        "raw_score": [
            6.180186675512935,
            6.63654462139858
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (favoring lower-cost solutions but allowing some diversity) and applies a cross-segment swap operator, randomly exchanging two non-overlapping segments of the tour to generate a neighbor solution while ensuring feasibility. The selection prioritizes exploitation of good solutions but balances it with exploration by occasionally choosing from the middle of the archive. The cross-segment swap is a novel local search operator that disrupts larger tour structures compared to standard edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selection_threshold = min(2 * len(sorted_archive) // 3, len(sorted_archive) - 1)\n    selected_solution = random.choice(sorted_archive[:selection_threshold])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-segment swap: select two non-overlapping segments and swap them\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        seg2,\n        new_solution[seg1_end+1:seg2_start],\n        seg1,\n        new_solution[seg2_end+1:]\n    ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(selected_solution):\n        return selected_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.837455409186324,
            0.1816069483757019
        ],
        "raw_score": [
            6.500691332763455,
            6.600301261577352
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects balanced solutions from the archive based on normalized objective scores, then applies a probabilistic hybrid local search combining segment merging and dynamic k-opt (k=2-4), ensuring feasibility through uniqueness checks and missing node repair. It prioritizes solutions with balanced objectives (lower balance score) and uses randomized segment recombination to explore the solution space while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: prioritize solutions with balanced objective improvements\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize and calculate balance score (lower is better)\n    max_obj1 = max(obj[0] for obj in objectives) if any(obj[0] for obj in objectives) else 1\n    max_obj2 = max(obj[1] for obj in objectives) if any(obj[1] for obj in objectives) else 1\n    normalized = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n    balance_scores = [abs(obj1 - obj2) for obj1, obj2 in normalized]  # Prefer balanced solutions\n\n    # Select based on balance score with some randomness\n    weights = [1/(1 + score) for score in balance_scores]\n    total_weight = sum(weights)\n    probabilities = [w/total_weight for w in weights]\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Sophisticated local search: probabilistic segment merging and dynamic k-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine k for k-opt (between 2 and 4)\n    k = random.choice([2, 3, 4])\n\n    if n > k + 1:\n        # Select k random segments to modify\n        points = sorted(random.sample(range(n), k))\n        segments = []\n        for i in range(k):\n            start = points[i]\n            end = points[(i+1)%k] if (i+1)%k != 0 else n\n            if start > end:\n                segments.append(new_solution[start:] + new_solution[:end])\n            else:\n                segments.append(new_solution[start:end])\n\n        # Recombine segments in a new order\n        random.shuffle(segments)\n        new_order = []\n        for seg in segments:\n            new_order.extend(seg)\n\n        # Ensure uniqueness and fix duplicates if any\n        unique_order = []\n        seen = set()\n        for node in new_order:\n            if node not in seen:\n                seen.add(node)\n                unique_order.append(node)\n\n        # Fill missing nodes\n        missing = [node for node in base_solution if node not in seen]\n        unique_order.extend(missing)\n\n        new_solution = np.array(unique_order)\n\n    # Validate the solution remains feasible\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9672992767713314,
            0.24489057064056396
        ],
        "raw_score": [
            7.261666706830336,
            6.767282304986544
        ]
    },
    {
        "algorithm": "The algorithm prioritizes non-dominated solutions (or explores less dominant ones with 30% probability) and applies a \"guided segment inversion\" heuristic, where high-cost edges in both objectives are probabilistically inverted to improve both tour lengths. It ensures feasibility by maintaining node uniqueness and tour continuity while adaptively balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify non-dominated solutions in the archive\n    dominated = set()\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and (obj2[0] <= obj1[0] and obj2[1] <= obj1[1]) and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                dominated.add(i)\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if i not in dominated]\n    if not non_dominated_indices:\n        non_dominated_indices = list(range(len(archive)))\n\n    # Select a solution with adaptive pressure (favor non-dominated but allow some exploration)\n    if len(non_dominated_indices) > 0 and random.random() < 0.7:\n        selected_idx = random.choice(non_dominated_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate segment costs in both objectives\n    segment_costs = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        segment_costs.append((cost1 + cost2, i, j))\n\n    # Sort segments by total cost (descending)\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n\n    # Probabilistically select high-cost segments for inversion\n    for cost, i, j in segment_costs:\n        if random.random() < 0.3:  # 30% chance to invert a high-cost segment\n            if i < j:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # Handle circular segment\n                segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n                inverted = segment[::-1]\n                new_solution[i:] = inverted[:len(new_solution)-i]\n                new_solution[:j+1] = inverted[len(new_solution)-i:]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        return base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9302908512574285,
            0.2250475287437439
        ],
        "raw_score": [
            7.680710408189633,
            7.440240376945426
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive using weighted random sampling (higher weights for better solutions) and applies a hybrid local search: 50% probability of cross-segment swaps (swapping two non-overlapping segments) or segment reversal followed by edge insertion (reversing a segment and reinserting a node), ensuring feasibility by maintaining a valid TSP tour. The selection prioritizes lower-cost solutions, while the local search diversifies improvements through novel segment-based operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    weights = [1.0 / (i + 1) for i in range(len(sorted_archive))]  # Higher weights for better solutions\n    selected_idx = random.choices(range(len(sorted_archive)), weights=weights, k=1)[0]\n    selected_solution = sorted_archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    if random.random() < 0.5:\n        # Cross-segment swap\n        if n >= 4:\n            seg1_start = random.randint(0, n - 4)\n            seg1_end = random.randint(seg1_start + 1, n - 3)\n            seg2_start = random.randint(seg1_end + 1, n - 2)\n            seg2_end = random.randint(seg2_start + 1, n - 1)\n\n            seg1 = new_solution[seg1_start:seg1_end+1]\n            seg2 = new_solution[seg2_start:seg2_end+1]\n\n            new_solution = np.concatenate([\n                new_solution[:seg1_start],\n                seg2,\n                new_solution[seg1_end+1:seg2_start],\n                seg1,\n                new_solution[seg2_end+1:]\n            ])\n\n            # Verify feasibility\n            if len(np.unique(new_solution)) != len(selected_solution):\n                new_solution = selected_solution.copy()\n    else:\n        # Segment reversal + edge insertion\n        if n >= 3:\n            # Segment reversal\n            i = random.randint(0, n - 2)\n            j = random.randint(i + 1, n - 1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n            # Edge insertion\n            k = random.randint(0, n - 1)\n            l = random.randint(0, n - 1)\n            if k != l:\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = random.randint(0, len(new_solution) - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9124371403836096,
            0.1892402172088623
        ],
        "raw_score": [
            6.754771267509838,
            6.376899343384708
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-based solution selection with a dynamic hybrid local search that adaptively applies segment inversion, edge reinsertion, and node swapping, adjusting operator probabilities based on solution quality and archive diversity while ensuring feasibility through cost validation checks. High-quality solutions favor node swaps, while low-quality solutions emphasize segment inversions to escape local optima. The selection prioritizes non-dominated solutions with weighted randomness to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-based adaptive selection\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Weighted selection from Pareto front\n    weights = [1.0 / (1 + np.sqrt(obj[0]**2 + obj[1]**2)) for _, obj in pareto_front]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(pareto_front), p=normalized_weights)\n    selected_solution = pareto_front[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic operator probabilities\n    operator_probs = [0.3, 0.4, 0.3]  # Segment inversion, edge reinsertion, node swap\n\n    # Adjust based on solution quality\n    sol_quality = np.sqrt(pareto_front[selected_idx][1][0]**2 + pareto_front[selected_idx][1][1]**2)\n    avg_quality = np.mean([np.sqrt(obj[0]**2 + obj[1]**2) for _, obj in archive])\n\n    if sol_quality < avg_quality * 0.8:  # High-quality solution\n        operator_probs = [0.2, 0.3, 0.5]\n    elif sol_quality > avg_quality * 1.2:  # Low-quality solution\n        operator_probs = [0.5, 0.4, 0.1]\n\n    operator_choice = np.random.choice(3, p=operator_probs)\n\n    if operator_choice == 0:  # Segment inversion with cost validation\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        old_cost1 = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]\n\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]\n\n        if (new_cost1 > old_cost1 * 1.2 and new_cost2 > old_cost2 * 1.2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice == 1:  # Edge reinsertion with feasibility check\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    else:  # Node swap with quality threshold\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a != b:\n            old_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            old_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            new_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            new_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            if (new_cost1 > old_cost1 * 1.1 or new_cost2 > old_cost2 * 1.1):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9551613107197618,
            2.188393294811249
        ],
        "raw_score": [
            6.882278076825621,
            6.616779004737815
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive using adaptive weighted sampling based on normalized objective balance, then applies a hybrid local search combining probabilistic segment reversal, cross-segment swaps, and dynamic k-opt (k=2-3) to generate neighbors while ensuring feasibility through uniqueness checks and missing node repair. The selection prioritizes balanced objective improvements, while the local search intelligently explores the solution space with varying probabilities for each operator.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize solutions with balanced objective improvements\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives and calculate balance score\n    max_obj1 = max(obj[0] for obj in objectives) if any(obj[0] for obj in objectives) else 1\n    max_obj2 = max(obj[1] for obj in objectives) if any(obj[1] for obj in objectives) else 1\n    normalized = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n    balance_scores = [abs(obj1 - obj2) for obj1, obj2 in normalized]\n\n    # Weighted random selection based on balance score\n    weights = [1/(1 + score) for score in balance_scores]\n    total_weight = sum(weights)\n    probabilities = [w/total_weight for w in weights]\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: probabilistic segment reversal + cross-segment swap + dynamic k-opt\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Probabilistic segment reversal (local refinement)\n    if n > 3 and random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Cross-segment swap (global exploration)\n    if n > 4 and random.random() < 0.5:\n        seg1_start = random.randint(0, n - 4)\n        seg1_end = random.randint(seg1_start + 1, n - 3)\n        seg2_start = random.randint(seg1_end + 1, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Dynamic k-opt (k=2-3)\n    if n > 4:\n        k = random.choice([2, 3])\n        if random.random() < 0.3:  # Probabilistic application\n            points = sorted(random.sample(range(n), k))\n            segments = []\n            for i in range(k):\n                start = points[i]\n                end = points[(i+1)%k] if (i+1)%k != 0 else n\n                if start > end:\n                    segments.append(new_solution[start:] + new_solution[:end])\n                else:\n                    segments.append(new_solution[start:end])\n\n            random.shuffle(segments)\n            new_order = []\n            for seg in segments:\n                new_order.extend(seg)\n\n            # Repair duplicates and missing nodes\n            unique_order = []\n            seen = set()\n            for node in new_order:\n                if node not in seen:\n                    seen.add(node)\n                    unique_order.append(node)\n\n            missing = [node for node in base_solution if node not in seen]\n            unique_order.extend(missing)\n            new_solution = np.array(unique_order)\n\n    # Validate feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9347460253506599,
            0.26749444007873535
        ],
        "raw_score": [
            7.276414816781417,
            6.599740122132938
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive solution selection based on objective diversity and improvement potential with a hybrid local search that dynamically applies segment inversion, cross-segment transposition, edge flipping, and adaptive k-opt operators, adjusting operator probabilities based on objective balance while ensuring tour feasibility through multi-stage validation. Solutions are weighted by their cost, diversity, and improvement potential, and operators are selected probabilistically to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive solution selection based on objective diversity and historical improvement trends\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate objective diversity and improvement potential\n    obj1_mean = np.mean([obj[0] for obj in objectives])\n    obj2_mean = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0] - obj1_mean) + abs(obj[1] - obj2_mean)) for obj in objectives]\n\n    # Calculate historical improvement potential\n    improvement_scores = []\n    for i in range(len(solutions)):\n        current_obj = objectives[i]\n        better_count = sum(1 for obj in objectives if (obj[0] < current_obj[0] and obj[1] <= current_obj[1]) or (obj[0] <= current_obj[0] and obj[1] < current_obj[1]))\n        improvement_scores.append(better_count)\n\n    # Combine diversity, cost, and improvement into selection weights\n    weights = [1/(1 + obj[0] + obj[1] + div + imp) for obj, div, imp in zip(objectives, diversity_scores, improvement_scores)]\n    total_weight = sum(weights)\n    probabilities = [w/total_weight for w in weights]\n\n    # Select a solution using weighted random choice\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current objective balance\n    obj1_total = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj2_total = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    obj_balance = abs(obj1_total - obj2_total) / (obj1_total + obj2_total)\n\n    # Dynamic operator selection based on objective balance and historical trends\n    operator_weights = {\n        'segment_inversion': max(0.4, 0.7 - 0.5 * obj_balance),\n        'cross_segment_transposition': min(0.6, 0.4 + 0.3 * obj_balance),\n        'edge_flipping': 0.3 + 0.4 * obj_balance,\n        'adaptive_k_opt': 0.2 + 0.3 * obj_balance\n    }\n\n    # Normalize operator weights\n    total_op_weight = sum(operator_weights.values())\n    op_probs = {k: v/total_op_weight for k, v in operator_weights.items()}\n\n    # Select operator to apply\n    operator = np.random.choice(list(op_probs.keys()), p=list(op_probs.values()))\n\n    # Apply selected operator\n    if operator == 'segment_inversion' and n > 3:\n        # Probabilistic segment inversion with objective-aware selection\n        segment_length = random.randint(2, min(10, n//2))\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # Calculate potential improvement\n        old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(start, end+1))\n        old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(start, end+1))\n\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n\n        # Revert if both objectives worsen significantly\n        if (new_cost1 > old_cost1 and new_cost2 > old_cost2) and (new_cost1 > 1.2 * old_cost1 or new_cost2 > 1.2 * old_cost2):\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    elif operator == 'cross_segment_transposition' and n > 4:\n        # Cross-segment transposition with objective-aware selection\n        seg1_start = random.randint(0, n - 4)\n        seg1_end = random.randint(seg1_start + 1, n - 3)\n        seg2_start = random.randint(seg1_end + 1, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    elif operator == 'edge_flipping' and n > 3:\n        # Objective-aware edge flipping\n        node1 = random.randint(0, n-1)\n        node2 = random.randint(0, n-1)\n        if node1 != node2:\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[node1-1], new_solution[node1]] + \\\n                       distance_matrix_1[new_solution[node1], new_solution[(node1+1)%n]] + \\\n                       distance_matrix_1[new_solution[node2-1], new_solution[node2]] + \\\n                       distance_matrix_1[new_solution[node2], new_solution[(node2+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[node1-1], new_solution[node1]] + \\\n                       distance_matrix_2[new_solution[node1], new_solution[(node1+1)%n]] + \\\n                       distance_matrix_2[new_solution[node2-1], new_solution[node2]] + \\\n                       distance_matrix_2[new_solution[node2], new_solution[(node2+1)%n]]\n\n            # Flip edges\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n            new_cost1 = distance_matrix_1[new_solution[node1-1], new_solution[node1]] + \\\n                       distance_matrix_1[new_solution[node1], new_solution[(node1+1)%n]] + \\\n                       distance_matrix_1[new_solution[node2-1], new_solution[node2]] + \\\n                       distance_matrix_1[new_solution[node2], new_solution[(node2+1)%n]]\n\n            new_cost2 = distance_matrix_2[new_solution[node1-1], new_solution[node1]] + \\\n                       distance_matrix_2[new_solution[node1], new_solution[(node1+1)%n]] + \\\n                       distance_matrix_2[new_solution[node2-1], new_solution[node2]] + \\\n                       distance_matrix_2[new_solution[node2], new_solution[(node2+1)%n]]\n\n            # Revert if both objectives worsen significantly\n            if (new_cost1 > old_cost1 and new_cost2 > old_cost2) and (new_cost1 > 1.2 * old_cost1 or new_cost2 > 1.2 * old_cost2):\n                new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    elif operator == 'adaptive_k_opt' and n > 4:\n        # Adaptive k-opt with dynamic k selection\n        k = random.choice([2, 3, 4])\n        points = sorted(random.sample(range(n), k))\n        segments = []\n        for i in range(k):\n            start = points[i]\n            end = points[(i+1)%k] if (i+1)%k != 0 else n\n            if start > end:\n                segments.append(new_solution[start:] + new_solution[:end])\n            else:\n                segments.append(new_solution[start:end])\n\n        random.shuffle(segments)\n        new_order = []\n        for seg in segments:\n            new_order.extend(seg)\n\n        # Repair duplicates and missing nodes\n        unique_order = []\n        seen = set()\n        for node in new_order:\n            if node not in seen:\n                seen.add(node)\n                unique_order.append(node)\n\n        missing = [node for node in base_solution if node not in seen]\n        unique_order.extend(missing)\n        new_solution = np.array(unique_order)\n\n    # Multi-stage feasibility validation\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    # Verify segment connectivity\n    for i in range(n):\n        assert new_solution[i] in base_solution\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9440546353812282,
            2.9833160638809204
        ],
        "raw_score": [
            6.412260346438823,
            6.963737189916172
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects a solution from the archive with weighted sampling, prioritizing lower-cost solutions, and applies a hybrid local search operator (segment reversal, node insertion, or edge swap) to generate a neighbor while ensuring feasibility. The selection balances exploration and exploitation, while the hybrid operator introduces diversity beyond standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: weighted sampling based on inverse of combined cost\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    combined_costs = [sum(obj) for obj in objectives]\n    min_cost = min(combined_costs)\n    weights = [1.0 / (cost - min_cost + 1e-6) for cost in combined_costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(solutions)), weights=weights, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine segment reversal, node insertion, and edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three operators\n    operator = random.choice(['segment_reversal', 'node_insertion', 'edge_swap'])\n\n    if operator == 'segment_reversal' and n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    elif operator == 'node_insertion' and n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n    elif operator == 'edge_swap' and n > 1:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7972943019164536,
            0.19001930952072144
        ],
        "raw_score": [
            6.273739444916374,
            5.597086427916787
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects promising solutions from the top 20% of the archive (weighted by objective cost) and applies a hybrid local search with dynamic operator selection (40% segment reversal, 30% cross-segment swap, 30% edge insertion). The operator probabilities adjust based on archive diversity (exploration when homogeneous, exploitation when diverse), ensuring feasibility through cost checks and validation. The solution always maintains a valid TSP tour by validating all operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: weighted random selection from top 20% solutions\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_n = max(1, len(sorted_archive) // 5)\n    top_solutions = sorted_archive[:top_n]\n\n    # Calculate weights based on solution quality (better solutions have higher probability)\n    weights = [1.0 / (rank + 1) for rank in range(len(top_solutions))]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(top_solutions), p=normalized_weights)\n    selected_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with dynamic operator selection\n    operator_probs = [0.4, 0.3, 0.3]  # Initial probabilities for segment reversal, cross-segment swap, edge insertion\n\n    # Adjust probabilities based on archive diversity\n    archive_diversity = len(set(tuple(sol[0]) for sol in archive)) / len(archive)\n    if archive_diversity < 0.3:  # If archive is too homogeneous, increase exploration\n        operator_probs = [0.2, 0.4, 0.4]\n    elif archive_diversity > 0.7:  # If archive is diverse, increase exploitation\n        operator_probs = [0.5, 0.3, 0.2]\n\n    operator_choice = np.random.choice(3, p=operator_probs)\n\n    if operator_choice == 0:  # Segment reversal with objective improvement check\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate cost before reversal\n        old_cost1 = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]\n\n        # Perform reversal\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1]][new_solution[i]] + distance_matrix_2[new_solution[j]][new_solution[(j+1)%n]]\n\n        # Revert if both objectives worsen significantly\n        if (new_cost1 > old_cost1 and new_cost2 > old_cost2) and (new_cost1 > 1.1 * old_cost1 or new_cost2 > 1.1 * old_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator_choice == 1:  # Cross-segment swap with objective improvement\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n\n        if a != b:\n            # Calculate cost before swap\n            old_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            old_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            # Perform swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # Calculate cost after swap\n            new_cost1 = distance_matrix_1[new_solution[a-1]][new_solution[a]] + distance_matrix_1[new_solution[b-1]][new_solution[b]]\n            new_cost2 = distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]]\n\n            # Revert if both objectives worsen\n            if new_cost1 > old_cost1 and new_cost2 > old_cost2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:  # Edge insertion with feasibility validation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.918464087169262,
            0.9424006938934326
        ],
        "raw_score": [
            6.143863087123614,
            5.662502722746077
        ]
    }
]