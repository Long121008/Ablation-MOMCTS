[
    {
        "algorithm": "This algorithm selects promising solutions from an archive using a modified knee-point approach to balance objective improvements, then applies a hybrid local search combining adaptive 3-opt moves and objective-weighted segment inversions, dynamically adjusting move sizes based on historical improvement patterns while ensuring feasibility through validation. The selection prioritizes solutions with better knee-point scores, and the local search prioritizes moves that improve both objectives based on their historical improvement rates, with segment inversions dynamically sized to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Modified knee point selection\n    def calculate_knee_scores(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        knee_scores = np.max(normalized, axis=1) - np.sum(normalized, axis=1)\n        return knee_scores\n\n    knee_scores = calculate_knee_scores(archive)\n    selected_idx = np.argmax(knee_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 2: Historical improvement tracking\n    improvement_rates = [1.0, 1.0]\n    if len(archive) > 2:\n        obj1_prev = archive[-3][1][0]\n        obj1_curr = archive[-1][1][0]\n        obj2_prev = archive[-3][1][1]\n        obj2_curr = archive[-1][1][1]\n        improvement_rates = [\n            max(0.1, min(2.0, (obj1_prev - obj1_curr) / (obj1_prev + 1e-10))),\n            max(0.1, min(2.0, (obj2_prev - obj2_curr) / (obj2_prev + 1e-10)))\n        ]\n\n    # Step 3: Hybrid local search with adaptive 3-opt and weighted inversions\n    def evaluate_3opt(a, b, c):\n        pre_a = new_solution[a-1] if a > 0 else new_solution[-1]\n        post_c = new_solution[c+1] if c < n-1 else new_solution[0]\n\n        orig_cost1 = (distance_matrix_1[pre_a, new_solution[a]] +\n                      distance_matrix_1[new_solution[b], new_solution[c]] +\n                      distance_matrix_1[new_solution[c], post_c])\n        orig_cost2 = (distance_matrix_2[pre_a, new_solution[a]] +\n                      distance_matrix_2[new_solution[b], new_solution[c]] +\n                      distance_matrix_2[new_solution[c], post_c])\n\n        new_cost1 = (distance_matrix_1[pre_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[c], new_solution[a]] +\n                     distance_matrix_1[new_solution[a], post_c])\n        new_cost2 = (distance_matrix_2[pre_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[c], new_solution[a]] +\n                     distance_matrix_2[new_solution[a], post_c])\n\n        return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n    # Adaptive 3-opt moves\n    best_3opt = None\n    best_3opt_improvement = (0, 0)\n\n    for _ in range(5):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        delta1, delta2 = evaluate_3opt(a, b, c)\n        weighted_improvement = (delta1 * improvement_rates[0] + delta2 * improvement_rates[1])\n\n        if weighted_improvement < 0 and (delta1 < best_3opt_improvement[0] and delta2 < best_3opt_improvement[1]):\n            best_3opt_improvement = (delta1, delta2)\n            best_3opt = (a, b, c)\n\n    if best_3opt is not None:\n        a, b, c = best_3opt\n        new_solution[a:c+1] = np.concatenate([new_solution[b:c+1], new_solution[a:b][::-1]])\n\n    # Objective-weighted segment inversion\n    segment_size = max(3, min(7, int(n * (1.0 / (1.0 + np.sum(improvement_rates))))))\n    best_inversion = None\n    best_inversion_improvement = (0, 0)\n\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n        weighted_improvement = (delta1 * improvement_rates[0] + delta2 * improvement_rates[1])\n\n        if weighted_improvement < 0 and (delta1 < best_inversion_improvement[0] and delta2 < best_inversion_improvement[1]):\n            best_inversion_improvement = (delta1, delta2)\n            best_inversion = (start, segment_size)\n\n    if best_inversion is not None:\n        start, size = best_inversion\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.475659976277734,
            4.885485815997759
        ]
    },
    {
        "algorithm": "This algorithm combines crowding-distance-aware selection with a multi-phase hybrid operator that first performs objective-aware edge inversions, then dynamically relocates segments based on historical improvement rates, and finally adaptively reinserts nodes prioritizing positions that minimize combined objective costs while ensuring feasibility through permutation validation. The selection prioritizes solutions with higher crowding distances, and the local search operators progressively refine the tour by considering both objectives, with edge inversions and segment relocations guided by improvement rates, while node reinsertions optimize for combined costs. The algorithm maintains feasibility by validating permutations and falls back to random swaps if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (np.max(objectives[:, i]) - np.min(objectives[:, i]) + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate historical improvement rates\n    objective_history = np.array([obj for _, obj in archive])\n    improvement_rates = np.std(objective_history, axis=0)\n\n    # Objective-aware edge inversions\n    for _ in range(max(3, n // 3)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n\n        orig_cost1 = distance_matrix_1[new_solution[i-1] if i > 0 else new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n        orig_cost2 = distance_matrix_2[new_solution[i-1] if i > 0 else new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1] if i > 0 else new_solution[-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n        new_cost2 = distance_matrix_2[new_solution[i-1] if i > 0 else new_solution[-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[j+1] if j < n-1 else new_solution[0]]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.2 * improvement_rates[0] and delta2 < -0.2 * improvement_rates[1]):\n            new_solution[i:j+1] = inverted_segment\n\n    # Dynamic segment relocation with adaptive size\n    segment_size = max(4, min(8, n // 2))\n    segment_size = max(2, int(segment_size * (1 / (1 + improvement_rates[0] + improvement_rates[1]))))\n\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    pre_orig = new_solution[start-1] if start > 0 else new_solution[-1]\n    post_orig = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_orig, segment[0]] + distance_matrix_1[segment[-1], post_orig]\n    orig_cost2 = distance_matrix_2[pre_orig, segment[0]] + distance_matrix_2[segment[-1], post_orig]\n\n    new_pos = np.random.randint(0, n - segment_size)\n    if new_pos == start:\n        new_pos = (new_pos + segment_size) % (n - segment_size)\n\n    pre_new = new_solution[new_pos-1] if new_pos > 0 else new_solution[-1]\n    post_new = new_solution[new_pos] if new_pos < n-segment_size else new_solution[0]\n\n    new_cost1 = distance_matrix_1[pre_new, segment[0]] + distance_matrix_1[segment[-1], post_new]\n    new_cost2 = distance_matrix_2[pre_new, segment[0]] + distance_matrix_2[segment[-1], post_new]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if (delta1 < 0 and delta2 < 0) or (delta1 < -0.15 * improvement_rates[0] and delta2 < -0.15 * improvement_rates[1]):\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Adaptive node reinsertion with edge inversion\n    node_pos = np.random.randint(0, n)\n    node = new_solution[node_pos]\n\n    if node_pos == 0:\n        new_solution = np.concatenate([new_solution[1:], [node]])\n    else:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(n-1):\n        pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        post = new_solution[pos]\n\n        cost1 = distance_matrix_1[pre, node] + distance_matrix_1[node, post] - distance_matrix_1[pre, post]\n        cost2 = distance_matrix_2[pre, node] + distance_matrix_2[node, post] - distance_matrix_2[pre, post]\n\n        combined_cost = cost1 + cost2\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.179368986816559,
            7.296290065636853
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive using crowding distance, then applies a hybrid local search combining objective-aware edge swaps (with adaptive selection based on historical improvements) and dynamic segment inversion (with segment sizes adjusted based on improvement rates), ensuring feasibility through validation checks. The method prioritizes solutions with high crowding distance, performs edge swaps to improve both objectives, and uses segment inversions to further refine the tour, with adaptive parameters balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Crowding-distance-aware selection\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        front = objectives.copy()\n        distances = np.zeros(len(front))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(front[:, m])\n            front = front[sorted_idx]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(front)-1):\n                distances[sorted_idx[i]] += (front[sorted_idx[i+1], m] - front[sorted_idx[i-1], m]) / (front[-1, m] - front[0, m] + 1e-6)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    improvement_history = {1: [], 2: []}\n\n    # Phase 2: Objective-aware edge swaps with adaptive selection\n    for _ in range(max(2, n // 5)):\n        best_improvement = (0, 0)\n        best_swap = None\n\n        for i in range(n):\n            for j in range(i+2, n):\n                if j == (i+1) % n:\n                    continue\n\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or \\\n                   (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n                    best_improvement = (delta1, delta2)\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n            improvement_history[1].append(best_improvement[0])\n            improvement_history[2].append(best_improvement[1])\n\n    # Phase 3: Dynamic segment inversion with adaptive size\n    if improvement_history[1] and improvement_history[2]:\n        avg_improvement1 = np.mean(improvement_history[1])\n        avg_improvement2 = np.mean(improvement_history[2])\n        segment_size = max(2, min(n//3, int(1 / (0.1 + avg_improvement1 + avg_improvement2))))\n\n        for _ in range(2):\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            def evaluate_inversion(sol, start, size):\n                pre = sol[start-1] if start > 0 else sol[-1]\n                post = sol[start+size] if start+size < n else sol[0]\n\n                orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n                orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n                new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n                new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n                return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n            delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n            if (delta1 < 0 and delta2 < 0) or \\\n               (delta1 < -0.15 * avg_improvement1 or delta2 < -0.15 * avg_improvement2):\n                new_solution[start:start+segment_size] = segment[::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.644627787759498,
            6.0747009109710755
        ]
    },
    {
        "algorithm": "The algorithm selects diverse solutions from the archive (high crowding distance) and applies a hybrid local search combining large-scale segment inversions, multi-objective edge swaps, and adaptive node reinsertions, dynamically adjusting segment sizes and move acceptance criteria to balance bi-objective improvements. It prioritizes solutions with better crowding distance and uses a three-phase approach (segment inversion, edge swaps, and node reinsertion) with adaptive segment sizes and multi-objective acceptance criteria to explore high-quality neighbors while ensuring feasibility. The method emphasizes exploration of diverse regions while maintaining solution quality through careful move selection and dynamic adjustments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_indices[0]] = float('inf')\n    crowding_dist[sorted_indices[-1]] = float('inf')\n\n    for i in range(1, len(archive)-1):\n        crowding_dist[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem scale and recent improvements\n    segment_size = max(3, min(8, n // 3))\n\n    # Hybrid local search with three phases\n    for phase in range(3):\n        # Phase 1: Large-scale segment inversion\n        best_improvement = (0, 0)\n        best_segment = None\n\n        for _ in range(5):  # More attempts for larger segments\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n            orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n            orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n            new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n            new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n            delta1 = new_cost1 - orig_cost1\n            delta2 = new_cost2 - orig_cost2\n\n            if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.2 * abs(best_improvement[0]) or delta2 < -0.2 * abs(best_improvement[1])):\n                best_improvement = (delta1, delta2)\n                best_segment = (start, segment_size)\n\n        if best_segment is not None and (best_improvement[0] < 0 or best_improvement[1] < 0):\n            start, size = best_segment\n            new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n        # Phase 2: Multi-objective edge swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n        orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n        new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n        new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * abs(delta2) and delta2 < -0.1 * abs(delta1)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Phase 3: Adaptive node reinsertion\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        if node_pos == 0:\n            new_solution = np.concatenate([new_solution[1:], [node]])\n        else:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            pre = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            post = new_solution[pos]\n\n            cost1 = distance_matrix_1[pre, node] + distance_matrix_1[node, post] - distance_matrix_1[pre, post]\n            cost2 = distance_matrix_2[pre, node] + distance_matrix_2[node, post] - distance_matrix_2[pre, post]\n\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.360144564634852,
            5.537172679117202
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Crowding-distance-aware selection\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        front = objectives.copy()\n        distances = np.zeros(len(front))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(front[:, m])\n            front = front[sorted_idx]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(front)-1):\n                distances[sorted_idx[i]] += (front[sorted_idx[i+1], m] - front[sorted_idx[i-1], m]) / (front[-1, m] - front[0, m] + 1e-6)\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Phase 2: Objective-aware edge swaps with dynamic selection\n    for _ in range(3):\n        best_improvement = (0, 0)\n        best_swap = None\n\n        for i in range(n):\n            for j in range(i+2, n):\n                if j == (i+1) % n:\n                    continue\n\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or \\\n                   (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n                    best_improvement = (delta1, delta2)\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Phase 3: Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or \\\n           (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.06054686155467,
            5.75938619182241
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower objectives) and applies a hybrid local search combining adaptive segment inversions (with dynamic segment sizes) and edge swaps, evaluating improvements in both objective spaces while ensuring feasibility. It balances exploration/exploitation through adaptive segment sizing and operator selection based on recent performance, favoring operators that improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size and recent improvements\n    segment_size = max(2, min(5, n // 4))\n    improvement_memory = [0, 0]\n\n    # Hybrid local search with adaptive operator selection\n    for _ in range(2):\n        # Adaptive segment inversion\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        def evaluate_inversion(sol, start, size):\n            pre = sol[start-1] if start > 0 else sol[-1]\n            post = sol[start+size] if start+size < n else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre, sol[start]] + distance_matrix_1[sol[start+size-1], post]\n            orig_cost2 = distance_matrix_2[pre, sol[start]] + distance_matrix_2[sol[start+size-1], post]\n\n            new_cost1 = distance_matrix_1[pre, sol[start+size-1]] + distance_matrix_1[sol[start], post]\n            new_cost2 = distance_matrix_2[pre, sol[start+size-1]] + distance_matrix_2[sol[start], post]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_inversion(new_solution, start, segment_size)\n\n        if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * improvement_memory[0] or delta2 < -0.1 * improvement_memory[1]):\n            new_solution[start:start+segment_size] = segment[::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n            segment_size = max(2, min(5, segment_size + np.random.randint(-1, 2)))\n            continue\n\n        # Edge swap if inversion didn't help\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            j -= 1\n\n        def evaluate_swap(sol, i, j):\n            pre_i = sol[i-1] if i > 0 else sol[-1]\n            post_i = sol[i+1] if i < n-1 else sol[0]\n            pre_j = sol[j-1] if j > 0 else sol[-1]\n            post_j = sol[j+1] if j < n-1 else sol[0]\n\n            orig_cost1 = distance_matrix_1[pre_i, sol[i]] + distance_matrix_1[sol[j], post_j]\n            orig_cost2 = distance_matrix_2[pre_i, sol[i]] + distance_matrix_2[sol[j], post_j]\n\n            new_cost1 = distance_matrix_1[pre_i, sol[j]] + distance_matrix_1[sol[i], post_j]\n            new_cost2 = distance_matrix_2[pre_i, sol[j]] + distance_matrix_2[sol[i], post_j]\n\n            return (new_cost1 - orig_cost1, new_cost2 - orig_cost2)\n\n        delta1, delta2 = evaluate_swap(new_solution, i, j)\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            improvement_memory[0] = delta1\n            improvement_memory[1] = delta2\n\n    return new_solution\n\n",
        "score": [
            5.650655791934891,
            5.828830062644275
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding-distance-aware selection, then applies a hybrid local search combining objective-aware edge swaps and dynamic segment inversions to generate improved neighbors while ensuring feasibility. It prioritizes solutions with better crowding distances and dynamically adjusts segment sizes based on past improvement patterns to balance exploration and exploitation across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Crowding-distance-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 2: Objective-aware edge swaps with dynamic selection\n    improvement_memory = {1: [], 2: []}\n    for _ in range(3):\n        best_improvement = (0, 0)\n        best_swap = None\n\n        for i in range(n):\n            for j in range(i+2, n):\n                if j == (i+1) % n:\n                    continue\n\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                delta1 = new_cost1 - orig_cost1\n                delta2 = new_cost2 - orig_cost2\n\n                if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 + delta2 < best_improvement[0] + best_improvement[1]):\n                    best_improvement = (delta1, delta2)\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n            improvement_memory[1].append(best_improvement[0])\n            improvement_memory[2].append(best_improvement[1])\n\n    # Step 3: Dynamic segment inversion with adaptive size\n    if improvement_memory[1] and improvement_memory[2]:\n        avg_improvement1 = np.mean(improvement_memory[1])\n        avg_improvement2 = np.mean(improvement_memory[2])\n        segment_size = max(2, min(n//3, int(1 / (0.1 + avg_improvement1 + avg_improvement2))))\n\n        for _ in range(2):\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n\n            pre = new_solution[start-1] if start > 0 else new_solution[-1]\n            post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n            orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n            orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n            new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n            new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n            delta1 = new_cost1 - orig_cost1\n            delta2 = new_cost2 - orig_cost2\n\n            if (delta1 < 0 and delta2 < 0) or (delta1 < -0.15 * avg_improvement1 or delta2 < -0.15 * avg_improvement2):\n                new_solution[start:start+segment_size] = segment[::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.204911318012591,
            5.614727665551342
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing lower combined objectives) and applies a dynamic, objective-aware local search combining segment inversions and edge swaps, evaluating improvements in both objectives to ensure feasibility while balancing exploration and exploitation. It adaptively selects segment sizes and accepts inversions or swaps that show significant improvements in either objective, ensuring valid TSP tours through permutation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), p=[0.7, 0.2, 0.1] if len(archive_sorted) >= 3 else None)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment size based on problem size\n    segment_size = max(2, min(5, n // 4))\n\n    # Objective-aware segment inversion\n    best_improvement = (0, 0)\n    best_segment = None\n\n    for _ in range(3):  # Try multiple random segments\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Evaluate inversion in both objectives\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        # Original edges\n        orig_cost1 = distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post]\n        orig_cost2 = distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post]\n\n        # New edges after inversion\n        new_cost1 = distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post]\n        new_cost2 = distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post]\n\n        delta1 = new_cost1 - orig_cost1\n        delta2 = new_cost2 - orig_cost2\n\n        # Track best improvement\n        if (delta1 < best_improvement[0] and delta2 < best_improvement[1]) or (delta1 < -0.1 * abs(best_improvement[0]) or delta2 < -0.1 * abs(best_improvement[1])):\n            best_improvement = (delta1, delta2)\n            best_segment = (start, segment_size)\n\n    # Apply the best found inversion\n    if best_segment is not None:\n        start, size = best_segment\n        new_solution[start:start+size] = new_solution[start:start+size][::-1]\n\n    # Edge swap with objective awareness\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i == 0 and j == n-1:\n        j -= 1\n\n    # Evaluate swap\n    pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n    post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n    pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n    post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n    orig_cost1 = distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j]\n    orig_cost2 = distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j]\n\n    new_cost1 = distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j]\n    new_cost2 = distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j]\n\n    delta1 = new_cost1 - orig_cost1\n    delta2 = new_cost2 - orig_cost2\n\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.80145785411436,
            5.7754796233164205
        ]
    },
    {
        "algorithm": "The algorithm combines dominance-aware selection with a four-phase hybrid local search: (1) it prioritizes solutions with high crowding distance for selection, (2) performs dynamic weighted edge flips with objective-space momentum, (3) uses adaptive segment-wise inversions based on historical improvement patterns, and (4) ensures feasibility through spatial-aware validation while maintaining TSP tour validity. The method balances exploration and exploitation by dynamically adjusting segment sizes and weights based on recent improvements, while always validating spatial coherence to preserve solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Dominance-aware selection with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n    crowding_distances = np.zeros(n_solutions)\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, n_solutions-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n_nodes = len(base_solution)\n    improvement_history = {1: [], 2: []}\n\n    # Phase 2: Dynamic weighted edge flips with momentum\n    momentum = 0.3\n    for _ in range(5):\n        best_improvement = 0\n        best_flip = None\n\n        for i in range(n_nodes):\n            for j in range(i+2, n_nodes):\n                if j == (i+1) % n_nodes:\n                    continue\n\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n_nodes]\n\n                orig_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n                orig_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n                new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n                # Weighted improvement with momentum\n                if improvement_history[1] and improvement_history[2]:\n                    weight1 = np.mean(improvement_history[1]) / (np.mean(improvement_history[1]) + np.mean(improvement_history[2]))\n                    weight2 = 1 - weight1\n                    improvement = (orig_cost1 - new_cost1) * weight1 + (orig_cost2 - new_cost2) * weight2\n                else:\n                    improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n                improvement *= (1 + momentum * np.random.randn())\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_flip = (i, j)\n\n        if best_flip:\n            i, j = best_flip\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n            improvement_history[1].append(orig_cost1 - new_cost1)\n            improvement_history[2].append(orig_cost2 - new_cost2)\n\n    # Phase 3: Segment-wise inversion with adaptive sizes\n    if improvement_history[1] and improvement_history[2]:\n        avg_improvement1 = np.mean(improvement_history[1])\n        avg_improvement2 = np.mean(improvement_history[2])\n\n        # Adaptive segment size calculation\n        segment_size = max(2, min(n_nodes//3, int(1 / (0.1 + 0.5 * (avg_improvement1 + avg_improvement2)))))\n\n        for _ in range(2):\n            a = np.random.randint(0, n_nodes - segment_size)\n            b = a + segment_size\n\n            # Evaluate inversion\n            pre = new_solution[a-1] if a > 0 else new_solution[-1]\n            post = new_solution[b] if b < n_nodes else new_solution[0]\n\n            orig_cost1 = distance_matrix_1[pre, new_solution[a]] + distance_matrix_1[new_solution[b-1], post]\n            orig_cost2 = distance_matrix_2[pre, new_solution[a]] + distance_matrix_2[new_solution[b-1], post]\n\n            new_cost1 = distance_matrix_1[pre, new_solution[b-1]] + distance_matrix_1[new_solution[a], post]\n            new_cost2 = distance_matrix_2[pre, new_solution[b-1]] + distance_matrix_2[new_solution[a], post]\n\n            if (new_cost1 - orig_cost1) + (new_cost2 - orig_cost2) < 0:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Phase 4: Feasibility-preserving inversion with spatial validation\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n\n        # Check spatial coherence before inversion\n        segment_nodes = new_solution[a:b]\n        segment_coords1 = instance[segment_nodes, :2]\n        segment_coords2 = instance[segment_nodes, 2:]\n\n        # Calculate centroids\n        centroid1 = np.mean(segment_coords1, axis=0)\n        centroid2 = np.mean(segment_coords2, axis=0)\n\n        # Check if inversion maintains spatial coherence\n        inverted_segment1 = segment_coords1[::-1]\n        inverted_segment2 = segment_coords2[::-1]\n\n        orig_dist1 = np.sum(np.linalg.norm(segment_coords1[1:] - segment_coords1[:-1], axis=1))\n        new_dist1 = np.sum(np.linalg.norm(inverted_segment1[1:] - inverted_segment1[:-1], axis=1))\n\n        orig_dist2 = np.sum(np.linalg.norm(segment_coords2[1:] - segment_coords2[:-1], axis=1))\n        new_dist2 = np.sum(np.linalg.norm(inverted_segment2[1:] - inverted_segment2[:-1], axis=1))\n\n        if (new_dist1 - orig_dist1) + (new_dist2 - orig_dist2) < 0:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n_nodes:\n        a, b = sorted(np.random.choice(n_nodes, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.739216282901545,
            5.334613577960395
        ]
    },
    {
        "algorithm": "The algorithm selects a crowded solution from the archive using crowding distance, then applies a three-phase hybrid operator combining objective-aware edge swaps, dynamic segment inversions with adaptive sizes, and a feasibility check with a greedy fallback to ensure valid TSP tours. The method prioritizes solutions in less-explored regions of the objective space while employing novel local search strategies to improve both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[-1, 0] - objectives[0, 0] + 1e-8)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Phase 1: Objective-aware edge swaps\n    for _ in range(n // 2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        orig_cost = (distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j] +\n                     distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j])\n        new_cost = (distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j] +\n                     distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j])\n\n        if new_cost < orig_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 2: Dynamic segment inversion with adaptive sizes\n    max_segment = min(5, n // 3)\n    for _ in range(3):\n        segment_size = np.random.randint(2, max_segment + 1)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        pre = new_solution[start-1] if start > 0 else new_solution[-1]\n        post = new_solution[start+segment_size] if start+segment_size < n else new_solution[0]\n\n        orig_cost = (distance_matrix_1[pre, segment[0]] + distance_matrix_1[segment[-1], post] +\n                     distance_matrix_2[pre, segment[0]] + distance_matrix_2[segment[-1], post])\n        new_cost = (distance_matrix_1[pre, segment[-1]] + distance_matrix_1[segment[0], post] +\n                     distance_matrix_2[pre, segment[-1]] + distance_matrix_2[segment[0], post])\n\n        if new_cost < orig_cost:\n            new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Phase 3: Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        best_swap = None\n        best_improvement = -float('inf')\n\n        for _ in range(10):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            if i == j:\n                continue\n\n            pre_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            post_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            pre_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            post_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            orig_cost = (distance_matrix_1[pre_i, new_solution[i]] + distance_matrix_1[new_solution[j], post_j] +\n                         distance_matrix_2[pre_i, new_solution[i]] + distance_matrix_2[new_solution[j], post_j])\n            new_cost = (distance_matrix_1[pre_i, new_solution[j]] + distance_matrix_1[new_solution[i], post_j] +\n                         distance_matrix_2[pre_i, new_solution[j]] + distance_matrix_2[new_solution[i], post_j])\n\n            improvement = orig_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.346708299173532,
            5.367440493722215
        ]
    }
]