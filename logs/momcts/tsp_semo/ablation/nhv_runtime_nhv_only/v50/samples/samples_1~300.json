[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. It prioritizes exploration for larger instances while using simple swaps for small instances, and intelligently modifies the solution while preserving node uniqueness. The method balances exploration and exploitation by combining structural changes (segment reversal) with fine-grained adjustments (edge insertion).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8286690861599322,
            0.19991153478622437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. It prioritizes exploration for larger instances while using simple swaps for small instances, and intelligently modifies the solution while preserving node uniqueness. The method balances exploration and exploitation by combining structural changes (segment reversal) with fine-grained adjustments (edge insertion).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8286690861599322,
            0.19991153478622437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic function selects a random solution from the archive and applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. It prioritizes exploration for larger instances while using simple swaps for small instances, and intelligently modifies the solution while preserving node uniqueness. The method balances exploration and exploitation by combining structural changes (segment reversal) with fine-grained adjustments (edge insertion).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8286690861599322,
            0.19991153478622437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform segment reversal\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects the highest-priority solution from the archive (based on the sum of its two objectives) and applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher combined objective values and uses random segment manipulation and node repositioning to explore the solution space, avoiding the standard 2-opt approach. The method ensures feasibility by maintaining a valid tour structure throughout the operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high combined objective values (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply hybrid local search (edge insertion + node relocation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Randomly insert the segment back\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Apply node relocation: move a random node to a new position\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9207833859329001,
            0.22673547267913818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high combined objective values (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply hybrid local search (edge insertion + node relocation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Randomly insert the segment back\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Apply node relocation: move a random node to a new position\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects the highest-priority solution from the archive (based on the sum of its two objectives) and applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher combined objective values and uses random segment manipulation and node repositioning to explore the solution space, avoiding the standard 2-opt approach. The method ensures feasibility by maintaining a valid tour structure throughout the operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high combined objective values (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply hybrid local search (edge insertion + node relocation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Randomly insert the segment back\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Apply node relocation: move a random node to a new position\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9207833859329001,
            0.22673547267913818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high combined objective values (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply hybrid local search (edge insertion + node relocation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Randomly insert the segment back\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Apply node relocation: move a random node to a new position\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The `select_neighbor` function selects a promising TSP solution from an archive, prioritizing those with moderate improvement potential, and applies a hybrid local search operator that combines segment relocation with edge insertion bias, balancing both objectives while ensuring feasibility. It falls back to random swaps for small instances or when no improvement is found. The algorithm dynamically adjusts objective weighting to avoid local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[:max(2, len(archive) // 3)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: segment relocation with edge insertion bias\n    if n > 3:\n        # Randomly select a segment to relocate\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + n // 4, n - 1))\n        segment = new_solution[seg_start:seg_end + 1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end + 1:]])\n\n        # Find the best insertion point for the segment (considering both objectives)\n        best_pos = 0\n        min_total_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting the segment at position i\n            candidate = np.insert(new_solution, i, segment)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Combine objectives with a bias towards the less explored objective\n            total_cost = cost1 + cost2 * (1.0 + 0.2 * random.random())  # Add some randomness to avoid local optima\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # If no improvement or small instance, apply a simple swap\n    if np.array_equal(new_solution, selected_solution) or n <= 3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8551287712459142,
            0.6201212406158447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[:max(2, len(archive) // 3)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: segment relocation with edge insertion bias\n    if n > 3:\n        # Randomly select a segment to relocate\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + n // 4, n - 1))\n        segment = new_solution[seg_start:seg_end + 1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end + 1:]])\n\n        # Find the best insertion point for the segment (considering both objectives)\n        best_pos = 0\n        min_total_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting the segment at position i\n            candidate = np.insert(new_solution, i, segment)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Combine objectives with a bias towards the less explored objective\n            total_cost = cost1 + cost2 * (1.0 + 0.2 * random.random())  # Add some randomness to avoid local optima\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # If no improvement or small instance, apply a simple swap\n    if np.array_equal(new_solution, selected_solution) or n <= 3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining edge swaps and node insertions to generate a neighbor solution while ensuring feasibility. It limits iterations for efficiency and evaluates insertion points based on the sum of costs from both distance matrices. The selected solution is randomly chosen from the top 3 solutions in the archive, and the local search alternates between edge swaps and node reinsertions to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower objective values for exploration\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge swaps and node insertions\n    for _ in range(5):  # Limit iterations for efficiency\n        # Randomly select two distinct edges to swap\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform edge swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly select a node to reinsert\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find best insertion point\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n-1):\n            # Temporarily insert and calculate cost\n            temp_sol = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8160721789739123,
            2.8436782360076904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower objective values for exploration\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge swaps and node insertions\n    for _ in range(5):  # Limit iterations for efficiency\n        # Randomly select two distinct edges to swap\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Perform edge swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly select a node to reinsert\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find best insertion point\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n-1):\n            # Temporarily insert and calculate cost\n            temp_sol = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search by reversing two non-overlapping segments of the tour, ensuring feasibility by checking for duplicates. The method prioritizes exploration over exploitation by randomly choosing segments, balancing diversity in the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7044155029974566,
            0.4953097105026245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the highest-priority solution from the archive (based on the sum of its two objectives) and applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher combined objective values and uses random segment manipulation and node repositioning to explore the solution space, avoiding the standard 2-opt approach. The method ensures feasibility by maintaining a valid tour structure throughout the operations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high combined objective values (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Step 2: Apply hybrid local search (edge insertion + node relocation)\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 2, n)\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Randomly insert the segment back\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Apply node relocation: move a random node to a new position\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        new_pos = np.random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search by reversing two non-overlapping segments of the tour, ensuring feasibility by checking for duplicates. The method prioritizes exploration over exploitation by randomly choosing segments, balancing diversity in the search process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm dynamically selects a promising solution from the archive by combining objective dominance and structural diversity, then applies a novel multi-segment crossover operator that probabilistically combines partial tours from other solutions while ensuring feasibility and balancing exploration/exploitation. It prioritizes solutions with higher combined objective values (top 3) but also allows random selection to maintain diversity, and accepts new solutions based on cost improvement or a 30% probability. The multi-segment crossover randomly selects 2-3 segments from other solutions, validates uniqueness, and inserts them into the base solution, with acceptance guided by cost comparison.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Combine objective dominance and structural diversity\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive) - 1) if np.random.random() < 0.7 else np.random.randint(0, len(archive))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply multi-segment crossover with probabilistic acceptance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select multiple segments from other solutions\n    num_segments = np.random.randint(2, min(4, n//2))\n    segment_indices = []\n\n    for _ in range(num_segments):\n        other_idx = np.random.randint(0, len(archive))\n        other_solution = archive[other_idx][0]\n        if len(other_solution) != n:\n            continue\n\n        # Find a random segment in the other solution\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n        segment = other_solution[start:end]\n\n        # Find a position in the current solution to insert\n        insert_pos = np.random.randint(0, n - len(segment) + 1)\n\n        # Create a candidate solution\n        candidate = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Check feasibility\n        if len(np.unique(candidate)) == n:\n            # Accept with probability based on objective improvement\n            original_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n)) + \\\n                       sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            if new_cost < original_cost or np.random.random() < 0.3:\n                new_solution = candidate.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8681409448619544,
            2.6966092586517334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Combine objective dominance and structural diversity\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_idx = min(3, len(archive) - 1) if np.random.random() < 0.7 else np.random.randint(0, len(archive))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply multi-segment crossover with probabilistic acceptance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select multiple segments from other solutions\n    num_segments = np.random.randint(2, min(4, n//2))\n    segment_indices = []\n\n    for _ in range(num_segments):\n        other_idx = np.random.randint(0, len(archive))\n        other_solution = archive[other_idx][0]\n        if len(other_solution) != n:\n            continue\n\n        # Find a random segment in the other solution\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n        segment = other_solution[start:end]\n\n        # Find a position in the current solution to insert\n        insert_pos = np.random.randint(0, n - len(segment) + 1)\n\n        # Create a candidate solution\n        candidate = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Check feasibility\n        if len(np.unique(candidate)) == n:\n            # Accept with probability based on objective improvement\n            original_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)) + \\\n                            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n)) + \\\n                       sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            if new_cost < original_cost or np.random.random() < 0.3:\n                new_solution = candidate.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe `select_neighbor` function selects a promising TSP solution from an archive, prioritizing those with moderate improvement potential, and applies a hybrid local search operator that combines segment relocation with edge insertion bias, balancing both objectives while ensuring feasibility. It falls back to random swaps for small instances or when no improvement is found. The algorithm dynamically adjusts objective weighting to avoid local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[:max(2, len(archive) // 3)]\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: segment relocation with edge insertion bias\n    if n > 3:\n        # Randomly select a segment to relocate\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + n // 4, n - 1))\n        segment = new_solution[seg_start:seg_end + 1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end + 1:]])\n\n        # Find the best insertion point for the segment (considering both objectives)\n        best_pos = 0\n        min_total_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting the segment at position i\n            candidate = np.insert(new_solution, i, segment)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Combine objectives with a bias towards the less explored objective\n            total_cost = cost1 + cost2 * (1.0 + 0.2 * random.random())  # Add some randomness to avoid local optima\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # If no improvement or small instance, apply a simple swap\n    if np.array_equal(new_solution, selected_solution) or n <= 3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive and applies a hybrid local search by reversing two non-overlapping segments of the tour, ensuring feasibility by checking for duplicates. The method prioritizes exploration over exploitation by randomly choosing segments, balancing diversity in the search process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 7,
        "algorithm": "The algorithm combines adaptive segment merging with biased edge insertion, where segment sizes are dynamically determined based on objective dominance (smaller segments for objective 1, larger for objective 2), and segments are inserted at positions optimized for a weighted combination of both objectives. It ensures feasibility by maintaining node uniqueness and tour completeness while falling back to probabilistic edge swaps when no improvement is found.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with moderate potential (not the best, not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(archive)//4 : len(archive)//2]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment merging with biased edge insertion\n        # Determine segment size based on objective dominance\n        obj1, obj2 = archive[0][1]\n        if obj1 > obj2:\n            seg_size = max(2, min(n//4, 3))  # Smaller segments for objective 1\n        else:\n            seg_size = max(2, min(n//3, 4))  # Larger segments for objective 2\n\n        # Randomly select a segment\n        seg_start = random.randint(0, n - seg_size - 1)\n        segment = new_solution[seg_start:seg_start + seg_size]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_size:]])\n\n        # Find the best insertion point considering both objectives\n        best_pos = 0\n        min_total_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting the segment at position i\n            candidate = np.insert(new_solution, i, segment)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Weighted combination with adaptive bias\n            weight = 0.5 + 0.3 * (obj1 / (obj1 + obj2 + 1e-6))  # More weight to objective 1 if it dominates\n            total_cost = weight * cost1 + (1 - weight) * cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # If no improvement or small instance, apply a probabilistic edge swap\n    if np.array_equal(new_solution, selected_solution) or n <= 3:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.7:  # Higher probability for beneficial swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7183140429969044,
            0.8423869609832764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with moderate potential (not the best, not the worst)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    candidate_solutions = sorted_archive[len(archive)//4 : len(archive)//2]\n    if not candidate_solutions:\n        candidate_solutions = archive\n    selected_solution = random.choice(candidate_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment merging with biased edge insertion\n        # Determine segment size based on objective dominance\n        obj1, obj2 = archive[0][1]\n        if obj1 > obj2:\n            seg_size = max(2, min(n//4, 3))  # Smaller segments for objective 1\n        else:\n            seg_size = max(2, min(n//3, 4))  # Larger segments for objective 2\n\n        # Randomly select a segment\n        seg_start = random.randint(0, n - seg_size - 1)\n        segment = new_solution[seg_start:seg_start + seg_size]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_size:]])\n\n        # Find the best insertion point considering both objectives\n        best_pos = 0\n        min_total_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting the segment at position i\n            candidate = np.insert(new_solution, i, segment)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Weighted combination with adaptive bias\n            weight = 0.5 + 0.3 * (obj1 / (obj1 + obj2 + 1e-6))  # More weight to objective 1 if it dominates\n            total_cost = weight * cost1 + (1 - weight) * cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # If no improvement or small instance, apply a probabilistic edge swap\n    if np.array_equal(new_solution, selected_solution) or n <= 3:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.7:  # Higher probability for beneficial swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from the archive and applies a hybrid local search by reversing two non-overlapping segments of the tour, ensuring feasibility by checking for duplicates. The method prioritizes exploration over exploitation by randomly choosing segments, balancing diversity in the search process.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge swapping and dynamic segment reversal, prioritizing moves that improve both objectives while ensuring feasibility through node uniqueness checks. It evaluates candidate solutions based on cost differences in both objective spaces and accepts improvements in either or both objectives. The approach balances exploration (random selection) with exploitation (targeted local search), though it lacks explicit dominance-based selection or more sophisticated diversity mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Calculate current costs for both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(N):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Hybrid local search: edge swapping with dynamic segment reversal\n    # Step 1: Random edge swap\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Dynamic segment reversal based on cost difference\n    for _ in range(2):  # Try twice to find an improving move\n        k, l = sorted(np.random.choice(N, size=2, replace=False))\n        if k >= l:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n\n        # Check feasibility\n        if len(np.unique(candidate)) != N:\n            continue\n\n        # Calculate new costs\n        new_cost1 = calculate_cost(candidate, distance_matrix_1)\n        new_cost2 = calculate_cost(candidate, distance_matrix_2)\n\n        # Accept if both objectives are improved or at least one is improved\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution = candidate\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.9009973710689997,
            0.27538591623306274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Calculate current costs for both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(N):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Hybrid local search: edge swapping with dynamic segment reversal\n    # Step 1: Random edge swap\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Dynamic segment reversal based on cost difference\n    for _ in range(2):  # Try twice to find an improving move\n        k, l = sorted(np.random.choice(N, size=2, replace=False))\n        if k >= l:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[k:l+1] = candidate[k:l+1][::-1]\n\n        # Check feasibility\n        if len(np.unique(candidate)) != N:\n            continue\n\n        # Calculate new costs\n        new_cost1 = calculate_cost(candidate, distance_matrix_1)\n        new_cost2 = calculate_cost(candidate, distance_matrix_2)\n\n        # Accept if both objectives are improved or at least one is improved\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution = candidate\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from the archive and applies a hybrid local search by reversing two non-overlapping segments of the tour, ensuring feasibility by checking for duplicates. The method prioritizes exploration over exploitation by randomly choosing segments, balancing diversity in the search process.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    if (i < k < j < l) or (k < i < l < j):\n        # Reverse the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 9,
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining segment reversal and insertion-based operations to generate a neighbor solution. It prioritizes feasibility by ensuring no nodes are skipped or revisited, and uses random segment selection and conditional insertion to explore the solution space. The method balances exploration (random selection) with exploitation (local search) while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: segment reversal with insertion-based operator\n    # Step 1: Randomly select two non-overlapping segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    if (i < k < j < l) or (k < i < l < j):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Step 2: Apply insertion-based operator to further improve\n    if np.random.rand() < 0.5:  # 50% chance to apply insertion\n        m = np.random.randint(0, N)\n        n = np.random.randint(0, N)\n        if m != n:\n            node = new_solution[m]\n            new_solution = np.delete(new_solution, m)\n            new_solution = np.insert(new_solution, n, node)\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8181276485142189,
            0.3190404176712036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(base_solution)\n    if N < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: segment reversal with insertion-based operator\n    # Step 1: Randomly select two non-overlapping segments and reverse them\n    i, j = sorted(np.random.choice(N, size=2, replace=False))\n    k, l = sorted(np.random.choice(N, size=2, replace=False))\n\n    if (i < k < j < l) or (k < i < l < j):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Step 2: Apply insertion-based operator to further improve\n    if np.random.rand() < 0.5:  # 50% chance to apply insertion\n        m = np.random.randint(0, N)\n        n = np.random.randint(0, N)\n        if m != n:\n            node = new_solution[m]\n            new_solution = np.delete(new_solution, m)\n            new_solution = np.insert(new_solution, n, node)\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != N:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the highest-cost solution from the archive (sorted by descending total cost) and applies a hybrid local search combining segment inversion and segment swapping, ensuring the neighbor remains a valid TSP tour. The selection prioritizes solutions with higher total cost, while the local search randomly inverts or swaps segments to explore the solution space. The approach balances exploration (via random segment selection) and exploitation (by targeting high-cost solutions for improvement).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8212540227787393,
            0.17821145057678223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the highest-cost solution from the archive (sorted by descending total cost) and applies a hybrid local search combining segment inversion and segment swapping, ensuring the neighbor remains a valid TSP tour. The selection prioritizes solutions with higher total cost, while the local search randomly inverts or swaps segments to explore the solution space. The approach balances exploration (via random segment selection) and exploitation (by targeting high-cost solutions for improvement).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8212540227787393,
            0.17821145057678223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The algorithm selects the highest-cost solution from the archive (sorted by descending total cost) and applies a hybrid local search combining segment inversion and segment swapping, ensuring the neighbor remains a valid TSP tour. The selection prioritizes solutions with higher total cost, while the local search randomly inverts or swaps segments to explore the solution space. The approach balances exploration (via random segment selection) and exploitation (by targeting high-cost solutions for improvement).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8212540227787393,
            0.17821145057678223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9104672619156713,
            0.32973289489746094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9104672619156713,
            0.32973289489746094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8622967880281742,
            0.20535552501678467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm first selects a promising solution from the archive by prioritizing non-dominated solutions and using crowding distance to balance exploration and exploitation. It then applies a hybrid edge-insertion local search that intelligently recombines tour segments by evaluating insertion points based on minimizing both objectives, ensuring feasible solutions while improving tour quality across both coordinate spaces. The selection process gives higher priority to non-dominated solutions, while the local search focuses on optimizing both objectives simultaneously through segment-based modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (non-dominated + crowding distance)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    # Select based on crowding distance (simplified)\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid edge-insertion local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Remove the segment\n    remaining_nodes = np.setdiff1d(np.arange(n), segment)\n\n    # Find insertion points that minimize both objectives\n    best_pos = -1\n    best_cost = (float('inf'), float('inf'))\n\n    for i in range(len(remaining_nodes)):\n        for j in range(i + 1, len(remaining_nodes)):\n            # Create candidate solution by inserting segment between i and j\n            candidate = np.concatenate([\n                remaining_nodes[:i],\n                segment,\n                remaining_nodes[i:j],\n                remaining_nodes[j:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%len(candidate)]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%len(candidate)]] for k in range(len(candidate)))\n\n            if (cost1, cost2) < best_cost:\n                best_cost = (cost1, cost2)\n                best_pos = (i, j)\n\n    if best_pos != -1:\n        i, j = best_pos\n        new_solution = np.concatenate([\n            remaining_nodes[:i],\n            segment,\n            remaining_nodes[i:j],\n            remaining_nodes[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8718233259377204,
            3.7077744603157043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (non-dominated + crowding distance)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    # Select based on crowding distance (simplified)\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid edge-insertion local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Remove the segment\n    remaining_nodes = np.setdiff1d(np.arange(n), segment)\n\n    # Find insertion points that minimize both objectives\n    best_pos = -1\n    best_cost = (float('inf'), float('inf'))\n\n    for i in range(len(remaining_nodes)):\n        for j in range(i + 1, len(remaining_nodes)):\n            # Create candidate solution by inserting segment between i and j\n            candidate = np.concatenate([\n                remaining_nodes[:i],\n                segment,\n                remaining_nodes[i:j],\n                remaining_nodes[j:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%len(candidate)]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%len(candidate)]] for k in range(len(candidate)))\n\n            if (cost1, cost2) < best_cost:\n                best_cost = (cost1, cost2)\n                best_pos = (i, j)\n\n    if best_pos != -1:\n        i, j = best_pos\n        new_solution = np.concatenate([\n            remaining_nodes[:i],\n            segment,\n            remaining_nodes[i:j],\n            remaining_nodes[j:]\n        ])\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower average cost) and applies a hybrid local search combining segment inversion and edge insertion to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes. The method intelligently explores neighborhoods while balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to invert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Choose a random edge to insert elsewhere\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        edge = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], edge])\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8253635069716272,
            0.20474779605865479
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to invert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Choose a random edge to insert elsewhere\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        edge = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], edge])\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm dynamically selects a solution from an archive based on its dominance in the Pareto front, using inverse dominance weights to prioritize non-dominated solutions, and applies a hybrid local search combining node relocation with segment rotation to generate feasible neighbor solutions while maintaining tour validity. The selection strategy balances exploration and exploitation by favoring solutions with fewer dominating neighbors, while the local search operator introduces diversity through randomized node movement and segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weight adjustment based on dominance in Pareto front\n    dominated_count = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                cost_i = archive[i][1]\n                cost_j = archive[j][1]\n                if (cost_i[0] <= cost_j[0] and cost_i[1] < cost_j[1]) or (cost_i[0] < cost_j[0] and cost_i[1] <= cost_j[1]):\n                    dominated_count[j] += 1\n\n    # Select solution with probability inversely proportional to its dominance\n    weights = [1.0 / (1 + count) for count in dominated_count]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relocation with segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n\n    # Create new solution by removing the node and inserting it into the rotated segment\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9254894964269617,
            0.3887676000595093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weight adjustment based on dominance in Pareto front\n    dominated_count = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                cost_i = archive[i][1]\n                cost_j = archive[j][1]\n                if (cost_i[0] <= cost_j[0] and cost_i[1] < cost_j[1]) or (cost_i[0] < cost_j[0] and cost_i[1] <= cost_j[1]):\n                    dominated_count[j] += 1\n\n    # Select solution with probability inversely proportional to its dominance\n    weights = [1.0 / (1 + count) for count in dominated_count]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relocation with segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n\n    # Create new solution by removing the node and inserting it into the rotated segment\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm dynamically selects a solution from an archive based on its dominance in the Pareto front, using inverse dominance weights to prioritize non-dominated solutions, and applies a hybrid local search combining node relocation with segment rotation to generate feasible neighbor solutions while maintaining tour validity. The selection strategy balances exploration and exploitation by favoring solutions with fewer dominating neighbors, while the local search operator introduces diversity through randomized node movement and segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weight adjustment based on dominance in Pareto front\n    dominated_count = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                cost_i = archive[i][1]\n                cost_j = archive[j][1]\n                if (cost_i[0] <= cost_j[0] and cost_i[1] < cost_j[1]) or (cost_i[0] < cost_j[0] and cost_i[1] <= cost_j[1]):\n                    dominated_count[j] += 1\n\n    # Select solution with probability inversely proportional to its dominance\n    weights = [1.0 / (1 + count) for count in dominated_count]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relocation with segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n\n    # Create new solution by removing the node and inserting it into the rotated segment\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9254894964269617,
            0.3887676000595093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weight adjustment based on dominance in Pareto front\n    dominated_count = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                cost_i = archive[i][1]\n                cost_j = archive[j][1]\n                if (cost_i[0] <= cost_j[0] and cost_i[1] < cost_j[1]) or (cost_i[0] < cost_j[0] and cost_i[1] <= cost_j[1]):\n                    dominated_count[j] += 1\n\n    # Select solution with probability inversely proportional to its dominance\n    weights = [1.0 / (1 + count) for count in dominated_count]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relocation with segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n\n    # Create new solution by removing the node and inserting it into the rotated segment\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 7,
        "algorithm": "The algorithm combines multi-objective aware selection with dynamic local search: it selects solutions based on weighted improvement potential (equal weighting for both objectives) and applies either fine-grained or aggressive perturbations (segment reversal or edge insertion) based on solution quality, ensuring feasibility through validation checks. The selection prioritizes solutions with lower normalized costs, while the local search adapts its intensity based on the solution's proximity to optimality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective aware selection with dynamic weighting\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Dynamic weighting based on relative improvement potential\n        norm_cost1 = cost1 / max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        norm_cost2 = cost2 / max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        weight = 1 - (0.5 * norm_cost1 + 0.5 * norm_cost2)  # Equal weighting for both objectives\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive perturbation based on solution quality\n    cost1, cost2 = archive[selected_idx][1]\n    max_cost1 = max(c[0] for _, c in archive)\n    max_cost2 = max(c[1] for _, c in archive)\n\n    # If solution is close to optimal in both objectives, use fine-grained perturbation\n    if (cost1 / max_cost1 < 0.3 and cost2 / max_cost2 < 0.3):\n        # Fine-grained edge swap with validation\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        if len(set(temp_solution)) == n:\n            new_solution = temp_solution\n    else:\n        # More aggressive perturbation for solutions with room for improvement\n        operation = random.choice(['segment_reversal', 'edge_insertion'])\n\n        if operation == 'segment_reversal':\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final validation check\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9212690369465448,
            0.6433501243591309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective aware selection with dynamic weighting\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Dynamic weighting based on relative improvement potential\n        norm_cost1 = cost1 / max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        norm_cost2 = cost2 / max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        weight = 1 - (0.5 * norm_cost1 + 0.5 * norm_cost2)  # Equal weighting for both objectives\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive perturbation based on solution quality\n    cost1, cost2 = archive[selected_idx][1]\n    max_cost1 = max(c[0] for _, c in archive)\n    max_cost2 = max(c[1] for _, c in archive)\n\n    # If solution is close to optimal in both objectives, use fine-grained perturbation\n    if (cost1 / max_cost1 < 0.3 and cost2 / max_cost2 < 0.3):\n        # Fine-grained edge swap with validation\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        if len(set(temp_solution)) == n:\n            new_solution = temp_solution\n    else:\n        # More aggressive perturbation for solutions with room for improvement\n        operation = random.choice(['segment_reversal', 'edge_insertion'])\n\n        if operation == 'segment_reversal':\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final validation check\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.940814033356052,
            0.2891772389411926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.940814033356052,
            0.2891772389411926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 9,
        "algorithm": "The algorithm selects solutions from the archive with a probability inversely proportional to their normalized costs (prioritizing higher-cost solutions for improvement) and applies a hybrid local search combining edge reversal and segment insertion, with adaptive segment lengths based on solution quality. The weighting scheme (60-40) gives higher priority to the first objective, and the segment length is dynamically adjusted between 2 and 5 nodes. The method ensures feasibility by maintaining a valid TSP tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized costs\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = (0.6 * norm_cost1 + 0.4 * norm_cost2)  # Higher weight for solutions with higher costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment length based on solution quality\n    segment_length = max(2, min(5, int(n * (0.6 * weights[selected_idx] + 0.4))))\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert a segment between two non-consecutive nodes\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) > segment_length:\n        segment = new_solution[i:i+segment_length]\n        new_solution = np.delete(new_solution, slice(i, i+segment_length))\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8442779461361483,
            0.48172855377197266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized costs\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = (0.6 * norm_cost1 + 0.4 * norm_cost2)  # Higher weight for solutions with higher costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment length based on solution quality\n    segment_length = max(2, min(5, int(n * (0.6 * weights[selected_idx] + 0.4))))\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert a segment between two non-consecutive nodes\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) > segment_length:\n        segment = new_solution[i:i+segment_length]\n        new_solution = np.delete(new_solution, slice(i, i+segment_length))\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 4 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the highest-cost solution from the archive (sorted by descending total cost) and applies a hybrid local search combining segment inversion and segment swapping, ensuring the neighbor remains a valid TSP tour. The selection prioritizes solutions with higher total cost, while the local search randomly inverts or swaps segments to explore the solution space. The approach balances exploration (via random segment selection) and exploitation (by targeting high-cost solutions for improvement).\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with lower average cost) and applies a hybrid local search combining segment inversion and edge insertion to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes. The method intelligently explores neighborhoods while balancing exploration and exploitation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to invert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Choose a random edge to insert elsewhere\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        edge = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], edge])\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s a concise, actionable reflection to guide heuristic design:\n\n- **Keywords**: Nondominated, weighted selection, hybrid local search, dynamic weighting, segment operations.\n- **Advice**: Prioritize nondominated heuristics, use weighted selection to balance objectives, and innovate with hybrid local search (e.g., adaptive segment reversal/swapping).\n- **Avoid**: Simple top-N selection, rigid repair mechanisms, or static weighting; focus on dynamic exploration.\n- **Explanation**: Nondominated heuristics ensure robustness by balancing objectives and maintaining feasibility. Hybrid local search (e.g., combining inversion with weighted swaps) can outperform standard methods like 2-opt. Dynamic weighting avoids premature convergence, while intelligent segment operations (e.g., reversing high-cost segments) enhance Pareto front quality.\n\n**Next step**: Implement a weighted selection mechanism (e.g., tournament or roulette wheel) combined with a novel hybrid local search operator (e.g., adaptive segment reversal/swapping) to generate high-quality neighbors.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 10,
        "algorithm": "The algorithm selects a nondominated solution from the archive using weighted roulette wheel selection based on normalized objective values, prioritizing solutions with balanced improvement potential (60% weight on first objective, 40% on second). It then applies a hybrid local search combining adaptive segment reversal (reversing segments with high cost in either objective) and weighted edge swaps (prioritizing swaps that improve at least one objective), ensuring feasibility by reverting invalid moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection of nondominated solutions\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Dynamic weighting: prioritize solutions with balanced improvement potential\n        weight = 1 - (0.6 * norm_cost1 + 0.4 * norm_cost2)\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal + weighted edge swaps\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal: reverse segments with high cost in either objective\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    if segment_cost1 > 0.7 * sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)) or \\\n       segment_cost2 > 0.7 * sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)):\n        new_solution[i:j+1] = segment[::-1]\n\n    # Weighted edge swaps: prioritize swapping edges with high cost in either objective\n    k, l = random.sample(range(n), 2)\n    if k != l:\n        cost1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        cost1_after = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost2_after = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n        # Revert if no improvement in either objective\n        if (cost1_after >= cost1_before and cost2_after >= cost2_before) or \\\n           (random.random() < 0.3 and (cost1_after > cost1_before or cost2_after > cost2_before)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8880416690009134,
            9.611193776130676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection of nondominated solutions\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Dynamic weighting: prioritize solutions with balanced improvement potential\n        weight = 1 - (0.6 * norm_cost1 + 0.4 * norm_cost2)\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal + weighted edge swaps\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal: reverse segments with high cost in either objective\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    if segment_cost1 > 0.7 * sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)) or \\\n       segment_cost2 > 0.7 * sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)):\n        new_solution[i:j+1] = segment[::-1]\n\n    # Weighted edge swaps: prioritize swapping edges with high cost in either objective\n    k, l = random.sample(range(n), 2)\n    if k != l:\n        cost1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        cost1_after = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost2_after = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n        # Revert if no improvement in either objective\n        if (cost1_after >= cost1_before and cost2_after >= cost2_before) or \\\n           (random.random() < 0.3 and (cost1_after > cost1_before or cost2_after > cost2_before)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm combines multi-objective aware selection with dynamic local search: it selects solutions based on weighted improvement potential (equal weighting for both objectives) and applies either fine-grained or aggressive perturbations (segment reversal or edge insertion) based on solution quality, ensuring feasibility through validation checks. The selection prioritizes solutions with lower normalized costs, while the local search adapts its intensity based on the solution's proximity to optimality.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective aware selection with dynamic weighting\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Dynamic weighting based on relative improvement potential\n        norm_cost1 = cost1 / max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        norm_cost2 = cost2 / max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        weight = 1 - (0.5 * norm_cost1 + 0.5 * norm_cost2)  # Equal weighting for both objectives\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive perturbation based on solution quality\n    cost1, cost2 = archive[selected_idx][1]\n    max_cost1 = max(c[0] for _, c in archive)\n    max_cost2 = max(c[1] for _, c in archive)\n\n    # If solution is close to optimal in both objectives, use fine-grained perturbation\n    if (cost1 / max_cost1 < 0.3 and cost2 / max_cost2 < 0.3):\n        # Fine-grained edge swap with validation\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        if len(set(temp_solution)) == n:\n            new_solution = temp_solution\n    else:\n        # More aggressive perturbation for solutions with room for improvement\n        operation = random.choice(['segment_reversal', 'edge_insertion'])\n\n        if operation == 'segment_reversal':\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final validation check\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a concise, actionable reflection to guide heuristic design:\n\n- **Keywords**: Nondominated, weighted selection, hybrid local search, dynamic weighting, segment operations.\n- **Advice**: Prioritize nondominated heuristics, use weighted selection to balance objectives, and innovate with hybrid local search (e.g., adaptive segment reversal/swapping).\n- **Avoid**: Simple top-N selection, rigid repair mechanisms, or static weighting; focus on dynamic exploration.\n- **Explanation**: Nondominated heuristics ensure robustness by balancing objectives and maintaining feasibility. Hybrid local search (e.g., combining inversion with weighted swaps) can outperform standard methods like 2-opt. Dynamic weighting avoids premature convergence, while intelligent segment operations (e.g., reversing high-cost segments) enhance Pareto front quality.\n\n**Next step**: Implement a weighted selection mechanism (e.g., tournament or roulette wheel) combined with a novel hybrid local search operator (e.g., adaptive segment reversal/swapping) to generate high-quality neighbors.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm selects promising solutions from the archive using nondominated sorting and crowding distance, then applies a hybrid local search combining adaptive segment reversal and guided edge insertion with Pareto-aware scoring to generate neighbors while maintaining feasibility. It dynamically adjusts search intensity based on solution quality and prioritizes balanced objective improvements. Key variables like segment size and insertion scores are weighted based on solution quality and Pareto dominance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Nondominated sorting and weighted selection\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                dominating_sets[i].append(j)\n            elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                  (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first front with probability inversely proportional to crowding distance\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=[1.0/len(archive)]*len(archive), k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: adaptive segment reversal with guided edge insertion\n    quality = (archive[selected_idx][1][0] + archive[selected_idx][1][1]) / (sum(c[0] for _, c in archive) + sum(c[1] for _, c in archive))\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))\n\n    # Adaptive segment reversal\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion with Pareto-aware scoring\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                # Pareto dominance adjustment\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8071741038575967,
            0.35951459407806396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Nondominated sorting and weighted selection\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                dominating_sets[i].append(j)\n            elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                  (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first front with probability inversely proportional to crowding distance\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n    else:\n        selected_idx = random.choices(range(len(archive)), weights=[1.0/len(archive)]*len(archive), k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: adaptive segment reversal with guided edge insertion\n    quality = (archive[selected_idx][1][0] + archive[selected_idx][1][1]) / (sum(c[0] for _, c in archive) + sum(c[1] for _, c in archive))\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))\n\n    # Adaptive segment reversal\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion with Pareto-aware scoring\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                # Pareto dominance adjustment\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Final validation\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a concise, actionable reflection to guide heuristic design:\n\n- **Keywords**: Nondominated, weighted selection, hybrid local search, dynamic weighting, segment operations.\n- **Advice**: Prioritize nondominated heuristics, use weighted selection to balance objectives, and innovate with hybrid local search (e.g., adaptive segment reversal/swapping).\n- **Avoid**: Simple top-N selection, rigid repair mechanisms, or static weighting; focus on dynamic exploration.\n- **Explanation**: Nondominated heuristics ensure robustness by balancing objectives and maintaining feasibility. Hybrid local search (e.g., combining inversion with weighted swaps) can outperform standard methods like 2-opt. Dynamic weighting avoids premature convergence, while intelligent segment operations (e.g., reversing high-cost segments) enhance Pareto front quality.\n\n**Next step**: Implement a weighted selection mechanism (e.g., tournament or roulette wheel) combined with a novel hybrid local search operator (e.g., adaptive segment reversal/swapping) to generate high-quality neighbors.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 12,
        "algorithm": "The algorithm selects a promising solution from an archive using a tournament-based approach with dynamic weights (prioritizing solutions near the Pareto front) and applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge swaps (optimizing both objectives simultaneously) while ensuring feasibility. The dynamic weighting scheme (e.g., weight1 = 0.7 if cost1 dominates) and quality-based segment sizing (e.g., segment_size = int(n * (0.4 + 0.6 * quality))) are key design choices.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Nondominated selection with dynamic weighting\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    # Dynamic weight vector (changes based on solution quality)\n    weight1 = 0.7 if max_cost1 > max_cost2 else 0.3\n    weight2 = 1 - weight1\n\n    # Tournament selection (size 2)\n    candidates = random.sample(range(len(archive)), min(2, len(archive)))\n    selected_idx = candidates[0]\n    for idx in candidates[1:]:\n        cost1_a, cost2_a = costs[selected_idx]\n        cost1_b, cost2_b = costs[idx]\n        score_a = (cost1_a / max_cost1) * weight1 + (cost2_a / max_cost2) * weight2\n        score_b = (cost1_b / max_cost1) * weight1 + (cost2_b / max_cost2) * weight2\n        if score_b < score_a:\n            selected_idx = idx\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal (larger segments for better solutions)\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.4 + 0.6 * quality)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge swapping (optimize both objectives)\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate improvement for both objectives\n            prev_node_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node_i = new_solution[(i+1)%n]\n            prev_node_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node_j = new_solution[(j+1)%n]\n\n            # Original cost\n            orig_cost1 = (distance_matrix_1[prev_node_i, node_i] + distance_matrix_1[node_i, next_node_i] +\n                          distance_matrix_1[prev_node_j, node_j] + distance_matrix_1[node_j, next_node_j])\n            orig_cost2 = (distance_matrix_2[prev_node_i, node_i] + distance_matrix_2[node_i, next_node_i] +\n                          distance_matrix_2[prev_node_j, node_j] + distance_matrix_2[node_j, next_node_j])\n\n            # Swapped cost\n            new_cost1 = (distance_matrix_1[prev_node_i, node_j] + distance_matrix_1[node_j, next_node_i] +\n                         distance_matrix_1[prev_node_j, node_i] + distance_matrix_1[node_i, next_node_j])\n            new_cost2 = (distance_matrix_2[prev_node_i, node_j] + distance_matrix_2[node_j, next_node_i] +\n                         distance_matrix_2[prev_node_j, node_i] + distance_matrix_2[node_i, next_node_j])\n\n            # Accept if improves weighted sum\n            if (new_cost1 * weight1 + new_cost2 * weight2) < (orig_cost1 * weight1 + orig_cost2 * weight2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7766006463554873,
            0.23874443769454956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Nondominated selection with dynamic weighting\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    # Dynamic weight vector (changes based on solution quality)\n    weight1 = 0.7 if max_cost1 > max_cost2 else 0.3\n    weight2 = 1 - weight1\n\n    # Tournament selection (size 2)\n    candidates = random.sample(range(len(archive)), min(2, len(archive)))\n    selected_idx = candidates[0]\n    for idx in candidates[1:]:\n        cost1_a, cost2_a = costs[selected_idx]\n        cost1_b, cost2_b = costs[idx]\n        score_a = (cost1_a / max_cost1) * weight1 + (cost2_a / max_cost2) * weight2\n        score_b = (cost1_b / max_cost1) * weight1 + (cost2_b / max_cost2) * weight2\n        if score_b < score_a:\n            selected_idx = idx\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal (larger segments for better solutions)\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.4 + 0.6 * quality)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge swapping (optimize both objectives)\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate improvement for both objectives\n            prev_node_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node_i = new_solution[(i+1)%n]\n            prev_node_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node_j = new_solution[(j+1)%n]\n\n            # Original cost\n            orig_cost1 = (distance_matrix_1[prev_node_i, node_i] + distance_matrix_1[node_i, next_node_i] +\n                          distance_matrix_1[prev_node_j, node_j] + distance_matrix_1[node_j, next_node_j])\n            orig_cost2 = (distance_matrix_2[prev_node_i, node_i] + distance_matrix_2[node_i, next_node_i] +\n                          distance_matrix_2[prev_node_j, node_j] + distance_matrix_2[node_j, next_node_j])\n\n            # Swapped cost\n            new_cost1 = (distance_matrix_1[prev_node_i, node_j] + distance_matrix_1[node_j, next_node_i] +\n                         distance_matrix_1[prev_node_j, node_i] + distance_matrix_1[node_i, next_node_j])\n            new_cost2 = (distance_matrix_2[prev_node_i, node_j] + distance_matrix_2[node_j, next_node_i] +\n                         distance_matrix_2[prev_node_j, node_i] + distance_matrix_2[node_i, next_node_j])\n\n            # Accept if improves weighted sum\n            if (new_cost1 * weight1 + new_cost2 * weight2) < (orig_cost1 * weight1 + orig_cost2 * weight2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 13,
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining dynamic path swapping and guided node relocation, where the relocation prioritizes moves that improve both objectives (60% weight to first objective, 40% to second) while ensuring feasibility through careful validation. The swap size and relocation frequency adapt to solution quality, with more aggressive changes for worse solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with lower normalized costs (prioritize better solutions)\n        weight = 1.0 / (0.5 * norm_cost1 + 0.5 * norm_cost2 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic path swapping based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    swap_size = max(2, int(n * (0.3 + 0.4 * quality)))  # More aggressive swaps for worse solutions\n\n    a = random.randint(0, n - swap_size)\n    b = random.randint(a + 1, n - 1)\n    segment1 = new_solution[a:a+swap_size]\n    segment2 = new_solution[b:b+swap_size]\n\n    # Ensure segments don't overlap and are of same size\n    if len(segment1) == len(segment2) and a + swap_size <= b:\n        new_solution[a:a+swap_size] = segment2\n        new_solution[b:b+swap_size] = segment1\n\n    # Guided node relocation based on weighted distance matrices\n    for _ in range(3):  # Perform multiple relocations\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Calculate weighted distances for all possible insertion positions\n        best_pos = 0\n        best_score = float('inf')\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                score = (0.6 * distance_matrix_1[new_solution[-1], node] + 0.4 * distance_matrix_2[new_solution[-1], node] +\n                         0.6 * distance_matrix_1[node, new_solution[pos]] + 0.4 * distance_matrix_2[node, new_solution[pos]])\n            elif pos == len(new_solution) - 1:\n                score = (0.6 * distance_matrix_1[new_solution[pos], node] + 0.4 * distance_matrix_2[new_solution[pos], node] +\n                         0.6 * distance_matrix_1[node, new_solution[0]] + 0.4 * distance_matrix_2[node, new_solution[0]])\n            else:\n                score = (0.6 * distance_matrix_1[new_solution[pos-1], node] + 0.4 * distance_matrix_2[new_solution[pos-1], node] +\n                         0.6 * distance_matrix_1[node, new_solution[pos]] + 0.4 * distance_matrix_2[node, new_solution[pos]])\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6955014037199929,
            0.46020597219467163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with lower normalized costs (prioritize better solutions)\n        weight = 1.0 / (0.5 * norm_cost1 + 0.5 * norm_cost2 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic path swapping based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    swap_size = max(2, int(n * (0.3 + 0.4 * quality)))  # More aggressive swaps for worse solutions\n\n    a = random.randint(0, n - swap_size)\n    b = random.randint(a + 1, n - 1)\n    segment1 = new_solution[a:a+swap_size]\n    segment2 = new_solution[b:b+swap_size]\n\n    # Ensure segments don't overlap and are of same size\n    if len(segment1) == len(segment2) and a + swap_size <= b:\n        new_solution[a:a+swap_size] = segment2\n        new_solution[b:b+swap_size] = segment1\n\n    # Guided node relocation based on weighted distance matrices\n    for _ in range(3):  # Perform multiple relocations\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Calculate weighted distances for all possible insertion positions\n        best_pos = 0\n        best_score = float('inf')\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                score = (0.6 * distance_matrix_1[new_solution[-1], node] + 0.4 * distance_matrix_2[new_solution[-1], node] +\n                         0.6 * distance_matrix_1[node, new_solution[pos]] + 0.4 * distance_matrix_2[node, new_solution[pos]])\n            elif pos == len(new_solution) - 1:\n                score = (0.6 * distance_matrix_1[new_solution[pos], node] + 0.4 * distance_matrix_2[new_solution[pos], node] +\n                         0.6 * distance_matrix_1[node, new_solution[0]] + 0.4 * distance_matrix_2[node, new_solution[0]])\n            else:\n                score = (0.6 * distance_matrix_1[new_solution[pos-1], node] + 0.4 * distance_matrix_2[new_solution[pos-1], node] +\n                         0.6 * distance_matrix_1[node, new_solution[pos]] + 0.4 * distance_matrix_2[node, new_solution[pos]])\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 14,
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive block swapping (with block size determined by solution quality) and guided node relocation (based on combined distance matrices) to generate a feasible neighbor solution. It prioritizes solutions with lower combined costs and dynamically adjusts block sizes and relocation strategies to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with lower normalized costs (direct selection)\n        weight = 1.0 / (0.5 * norm_cost1 + 0.5 * norm_cost2 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive block swapping based on solution quality\n    quality = 1.0 - (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    block_size = max(2, int(n * (0.3 + 0.4 * quality)))  # Variable block size\n\n    a = random.randint(0, n - block_size)\n    b = a + block_size - 1\n    c = random.randint(0, n - block_size)\n    d = c + block_size - 1\n\n    # Swap blocks if they don't overlap\n    if not (a <= d and b >= c):\n        temp = new_solution[a:b+1].copy()\n        new_solution[a:b+1] = new_solution[c:d+1]\n        new_solution[c:d+1] = temp\n\n    # Guided node relocation based on combined distance matrices\n    for _ in range(3):  # Perform multiple relocations\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Find best relocation position based on combined distance\n        best_pos = 0\n        best_score = float('inf')\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                         distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n            elif pos == len(new_solution) - 1:\n                score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                         distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n            else:\n                score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                         distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8999348504445216,
            0.4520612955093384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with lower normalized costs (direct selection)\n        weight = 1.0 / (0.5 * norm_cost1 + 0.5 * norm_cost2 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive block swapping based on solution quality\n    quality = 1.0 - (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    block_size = max(2, int(n * (0.3 + 0.4 * quality)))  # Variable block size\n\n    a = random.randint(0, n - block_size)\n    b = a + block_size - 1\n    c = random.randint(0, n - block_size)\n    d = c + block_size - 1\n\n    # Swap blocks if they don't overlap\n    if not (a <= d and b >= c):\n        temp = new_solution[a:b+1].copy()\n        new_solution[a:b+1] = new_solution[c:d+1]\n        new_solution[c:d+1] = temp\n\n    # Guided node relocation based on combined distance matrices\n    for _ in range(3):  # Perform multiple relocations\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Find best relocation position based on combined distance\n        best_pos = 0\n        best_score = float('inf')\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                         distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n            elif pos == len(new_solution) - 1:\n                score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                         distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n            else:\n                score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                         distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a concise, actionable reflection to guide heuristic design:\n\n- **Keywords**: Nondominated, weighted selection, hybrid local search, dynamic weighting, segment operations.\n- **Advice**: Prioritize nondominated heuristics, use weighted selection to balance objectives, and innovate with hybrid local search (e.g., adaptive segment reversal/swapping).\n- **Avoid**: Simple top-N selection, rigid repair mechanisms, or static weighting; focus on dynamic exploration.\n- **Explanation**: Nondominated heuristics ensure robustness by balancing objectives and maintaining feasibility. Hybrid local search (e.g., combining inversion with weighted swaps) can outperform standard methods like 2-opt. Dynamic weighting avoids premature convergence, while intelligent segment operations (e.g., reversing high-cost segments) enhance Pareto front quality.\n\n**Next step**: Implement a weighted selection mechanism (e.g., tournament or roulette wheel) combined with a novel hybrid local search operator (e.g., adaptive segment reversal/swapping) to generate high-quality neighbors.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 15,
        "algorithm": "The algorithm selects promising solutions from an archive using a weighted mechanism that prioritizes lower costs in one objective and higher costs in another, then applies a hybrid local search combining adaptive segment reversal (with larger segments for better solutions) and guided edge insertion (optimizing both distance matrices simultaneously) to generate improved, feasible neighbors. The weights balance exploration and exploitation, while the local search adaptively refines solutions based on their quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objectives and compute weights\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Combine inverse and direct weighting for balanced selection\n        weight = (0.4 * (1 - norm_cost1) + 0.6 * norm_cost2)  # Prioritize lower cost1 and higher cost2\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on both distance matrices\n    for _ in range(3):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8216530583581655,
            0.3038076162338257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objectives and compute weights\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Combine inverse and direct weighting for balanced selection\n        weight = (0.4 * (1 - norm_cost1) + 0.6 * norm_cost2)  # Prioritize lower cost1 and higher cost2\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on both distance matrices\n    for _ in range(3):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 4 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the highest-cost solution from the archive (sorted by descending total cost) and applies a hybrid local search combining segment inversion and segment swapping, ensuring the neighbor remains a valid TSP tour. The selection prioritizes solutions with higher total cost, while the local search randomly inverts or swaps segments to explore the solution space. The approach balances exploration (via random segment selection) and exploitation (by targeting high-cost solutions for improvement).\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with lower average cost) and applies a hybrid local search combining segment inversion and edge insertion to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes. The method intelligently explores neighborhoods while balancing exploration and exploitation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to invert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Choose a random edge to insert elsewhere\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        edge = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], edge])\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: Nondominated, weighted selection, hybrid local search, dynamic weighting, segment operations, feasibility validation.\n- **Advice**: Use a weighted tournament selection to prioritize high-quality nondominated solutions, then apply a hybrid local search combining adaptive segment reversal with guided edge swapping to balance objectives.\n- **Avoid**: Static selection (e.g., random or top-N), rigid repair mechanisms, or 2-opt-like operators; focus on dynamic, multi-objective-aware operations.\n- **Explanation**: Weighted selection ensures diverse exploration, while hybrid local search exploits high-potential neighborhoods. Feasibility is maintained via dynamic validation (e.g., segment checks), and adaptive operators refine solutions dynamically.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 16,
        "algorithm": "The algorithm selects a non-dominated solution from the archive using weighted tournament selection, then applies a hybrid local search combining adaptive segment reversal (with segment size adjusted based on solution quality) and guided edge swapping (accepting swaps only if they improve both objectives), ensuring feasibility through dynamic repair. The selection weights balance the two objectives equally, while the local search adaptively balances exploration and exploitation based on solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted tournament selection for nondominated solutions\n    nondominated = []\n    for i, (sol, cost) in enumerate(archive):\n        dominated = False\n        for j, (_, other_cost) in enumerate(archive):\n            if i != j and (other_cost[0] <= cost[0] and other_cost[1] <= cost[1]) and (other_cost[0] < cost[0] or other_cost[1] < cost[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, cost))\n\n    if not nondominated:\n        nondominated = archive.copy()\n\n    weights = []\n    max_cost1 = max(c[0] for _, c in nondominated) if max(c[0] for _, c in nondominated) > 0 else 1\n    max_cost2 = max(c[1] for _, c in nondominated) if max(c[1] for _, c in nondominated) > 0 else 1\n\n    for _, cost in nondominated:\n        norm_cost1 = cost[0] / max_cost1\n        norm_cost2 = cost[1] / max_cost2\n        weights.append(0.5 * norm_cost1 + 0.5 * norm_cost2)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(nondominated)] * len(nondominated)\n\n    selected_idx = random.choices(range(len(nondominated)), weights=weights, k=1)[0]\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal with guided edge swapping\n    if n >= 4:\n        # Adaptive segment reversal\n        quality = (nondominated[selected_idx][1][0] + nondominated[selected_idx][1][1]) / (max_cost1 + max_cost2)\n        segment_size = max(2, int(n * (0.5 - 0.4 * quality)))\n        a = random.randint(0, n - segment_size)\n        b = a + segment_size - 1\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided edge swapping\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                # Calculate improvement in both objectives\n                delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                         (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                         (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                # Accept if improves both objectives\n                if delta1 <= 0 and delta2 <= 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # Repair by adding missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8245285542232021,
            0.3500186800956726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted tournament selection for nondominated solutions\n    nondominated = []\n    for i, (sol, cost) in enumerate(archive):\n        dominated = False\n        for j, (_, other_cost) in enumerate(archive):\n            if i != j and (other_cost[0] <= cost[0] and other_cost[1] <= cost[1]) and (other_cost[0] < cost[0] or other_cost[1] < cost[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, cost))\n\n    if not nondominated:\n        nondominated = archive.copy()\n\n    weights = []\n    max_cost1 = max(c[0] for _, c in nondominated) if max(c[0] for _, c in nondominated) > 0 else 1\n    max_cost2 = max(c[1] for _, c in nondominated) if max(c[1] for _, c in nondominated) > 0 else 1\n\n    for _, cost in nondominated:\n        norm_cost1 = cost[0] / max_cost1\n        norm_cost2 = cost[1] / max_cost2\n        weights.append(0.5 * norm_cost1 + 0.5 * norm_cost2)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(nondominated)] * len(nondominated)\n\n    selected_idx = random.choices(range(len(nondominated)), weights=weights, k=1)[0]\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal with guided edge swapping\n    if n >= 4:\n        # Adaptive segment reversal\n        quality = (nondominated[selected_idx][1][0] + nondominated[selected_idx][1][1]) / (max_cost1 + max_cost2)\n        segment_size = max(2, int(n * (0.5 - 0.4 * quality)))\n        a = random.randint(0, n - segment_size)\n        b = a + segment_size - 1\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided edge swapping\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                # Calculate improvement in both objectives\n                delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                         (distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                         (distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                # Accept if improves both objectives\n                if delta1 <= 0 and delta2 <= 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # Repair by adding missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with lower average cost) and applies a hybrid local search combining segment inversion and edge insertion to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes. The method intelligently explores neighborhoods while balancing exploration and exploitation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to invert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Choose a random edge to insert elsewhere\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        edge = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], edge])\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive block swapping (with block size determined by solution quality) and guided node relocation (based on combined distance matrices) to generate a feasible neighbor solution. It prioritizes solutions with lower combined costs and dynamically adjusts block sizes and relocation strategies to balance exploration and exploitation.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with lower normalized costs (direct selection)\n        weight = 1.0 / (0.5 * norm_cost1 + 0.5 * norm_cost2 + 1e-6)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive block swapping based on solution quality\n    quality = 1.0 - (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    block_size = max(2, int(n * (0.3 + 0.4 * quality)))  # Variable block size\n\n    a = random.randint(0, n - block_size)\n    b = a + block_size - 1\n    c = random.randint(0, n - block_size)\n    d = c + block_size - 1\n\n    # Swap blocks if they don't overlap\n    if not (a <= d and b >= c):\n        temp = new_solution[a:b+1].copy()\n        new_solution[a:b+1] = new_solution[c:d+1]\n        new_solution[c:d+1] = temp\n\n    # Guided node relocation based on combined distance matrices\n    for _ in range(3):  # Perform multiple relocations\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Find best relocation position based on combined distance\n        best_pos = 0\n        best_score = float('inf')\n        for pos in range(len(new_solution)):\n            if pos == 0:\n                score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                         distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n            elif pos == len(new_solution) - 1:\n                score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                         distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n            else:\n                score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                         distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Nondominated, weighted selection, hybrid local search, dynamic weighting, segment operations, feasibility validation.\n- **Advice**: Use a weighted tournament selection to prioritize high-quality nondominated solutions, then apply a hybrid local search combining adaptive segment reversal with guided edge swapping to balance objectives.\n- **Avoid**: Static selection (e.g., random or top-N), rigid repair mechanisms, or 2-opt-like operators; focus on dynamic, multi-objective-aware operations.\n- **Explanation**: Weighted selection ensures diverse exploration, while hybrid local search exploits high-potential neighborhoods. Feasibility is maintained via dynamic validation (e.g., segment checks), and adaptive operators refine solutions dynamically.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 17,
        "algorithm": "The heuristic algorithm employs a weighted tournament selection mechanism to prioritize solutions based on their normalized objective values, then applies a hybrid local search combining adaptive segment reversal and guided edge swapping, ensuring feasibility through dynamic repair mechanisms. The segment size and swap operations are dynamically adjusted based on solution quality and distance matrices, with higher-quality solutions receiving larger segments and more aggressive modifications. The algorithm balances exploration and exploitation by leveraging both segment-based and edge-based improvements while maintaining tour validity through dynamic checks and repairs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted tournament selection for nondominated solutions\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    # Dynamic weighting based on archive diversity\n    weights = []\n    for cost1, cost2 in costs:\n        weight = (1.0 - cost1 / max_cost1) * 0.5 + (1.0 - cost2 / max_cost2) * 0.5\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal guided by combined distance\n    quality = weights[selected_idx]\n    segment_size = max(2, int(n * (0.2 + 0.5 * quality)))\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    # Reverse segment and check feasibility\n    segment = new_solution[a:b+1].copy()\n    new_solution[a:b+1] = segment[::-1]\n\n    # Guided edge swapping based on objective values\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Swap edges if it improves combined distance\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_dist < current_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8238667824310062,
            0.2344149947166443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted tournament selection for nondominated solutions\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    # Dynamic weighting based on archive diversity\n    weights = []\n    for cost1, cost2 in costs:\n        weight = (1.0 - cost1 / max_cost1) * 0.5 + (1.0 - cost2 / max_cost2) * 0.5\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal guided by combined distance\n    quality = weights[selected_idx]\n    segment_size = max(2, int(n * (0.2 + 0.5 * quality)))\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    # Reverse segment and check feasibility\n    segment = new_solution[a:b+1].copy()\n    new_solution[a:b+1] = segment[::-1]\n\n    # Guided edge swapping based on objective values\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Swap edges if it improves combined distance\n            current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_dist < current_dist:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic repair for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "operation": "e2"
    }
]