[
    {
        "algorithm": "The algorithm selects the highest-cost solution from the archive (sorted by descending total cost) and applies a hybrid local search combining segment inversion and segment swapping, ensuring the neighbor remains a valid TSP tour. The selection prioritizes solutions with higher total cost, while the local search randomly inverts or swaps segments to explore the solution space. The approach balances exploration (via random segment selection) and exploitation (by targeting high-cost solutions for improvement).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: -sum(x[1]))  # Sort by total cost descending\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to invert or swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Apply segment inversion or swap based on a coin flip\n    if random.random() < 0.5:\n        # Invert segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap segments between i and j with segment starting at k\n        segment_length = j - i + 1\n        if k + segment_length <= n:\n            temp = new_solution[k:k+segment_length].copy()\n            new_solution[k:k+segment_length] = new_solution[i:i+segment_length]\n            new_solution[i:i+segment_length] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8212540227787393,
            0.17821145057678223
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing lower-cost solutions (using a weighted sum of objectives) and applies a hybrid local search combining random edge swaps and segment reversals to generate neighbors, ensuring feasibility through validation checks. It balances exploration and exploitation by randomly choosing between these operations and reverting to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[np.random.randint(0, min(5, len(archive_sorted)))][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if np.random.rand() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = np.random.choice(n, size=2, replace=False)\n        if start > end:\n            start, end = end, start\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8622967880281742,
            0.20535552501678467
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower average cost) and applies a hybrid local search combining segment inversion and edge insertion to generate a neighbor solution, ensuring feasibility by repairing any duplicate nodes. The method intelligently explores neighborhoods while balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to invert\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Choose a random edge to insert elsewhere\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != d:\n        edge = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], edge])\n\n    # Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by adding missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8253635069716272,
            0.20474779605865479
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objective values, then applies a hybrid local search combining adaptive segment reversal (larger segments for better solutions) and guided edge insertion (based on both distance matrices) to generate a neighbor solution while maintaining feasibility. The selection prioritizes solutions with higher normalized costs, and the search intensity adapts dynamically based on the solution's quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objectives\n    costs = [c for _, c in archive]\n    max_cost1 = max(c[0] for c in costs) if max(c[0] for c in costs) > 0 else 1\n    max_cost2 = max(c[1] for c in costs) if max(c[1] for c in costs) > 0 else 1\n\n    weights = []\n    for cost1, cost2 in costs:\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Higher weight for solutions with higher normalized costs (inverse selection)\n        weight = (0.5 * norm_cost1 + 0.5 * norm_cost2)\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights] if total_weight > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal based on solution quality\n    quality = (costs[selected_idx][0] + costs[selected_idx][1]) / (max_cost1 + max_cost2)\n    segment_size = max(2, int(n * (0.5 - 0.4 * quality)))  # Larger segments for better solutions\n\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Guided edge insertion based on distance matrices\n    for _ in range(2):  # Perform multiple insertions\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if abs(i - j) > 1:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n\n            # Find best insertion position based on both distance matrices\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    score = (distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[pos]])\n                elif pos == len(new_solution) - 1:\n                    score = (distance_matrix_1[new_solution[pos], node] + distance_matrix_1[node, new_solution[0]] +\n                             distance_matrix_2[new_solution[pos], node] + distance_matrix_2[node, new_solution[0]])\n                else:\n                    score = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.940814033356052,
            0.2891772389411926
        ]
    },
    {
        "algorithm": "The heuristic selects solutions from the archive with a probability weighted by their normalized objective values (prioritizing lower costs) and applies a hybrid local search combining segment reversal and edge insertion to generate neighbor solutions while maintaining feasibility. The algorithm biases selection toward solutions with better overall performance (70% weight on the first objective, 30% on the second) and uses random segment reversal and edge insertion to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives and compute a weighted sum\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = 1 - (0.7 * norm_cost1 + 0.3 * norm_cost2)  # Higher weight for solutions with lower costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert an edge between two non-consecutive nodes\n    i, j = random.sample(range(n), 2)\n    if abs(i - j) > 1:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9104672619156713,
            0.32973289489746094
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from an archive based on its dominance in the Pareto front, using inverse dominance weights to prioritize non-dominated solutions, and applies a hybrid local search combining node relocation with segment rotation to generate feasible neighbor solutions while maintaining tour validity. The selection strategy balances exploration and exploitation by favoring solutions with fewer dominating neighbors, while the local search operator introduces diversity through randomized node movement and segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weight adjustment based on dominance in Pareto front\n    dominated_count = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                cost_i = archive[i][1]\n                cost_j = archive[j][1]\n                if (cost_i[0] <= cost_j[0] and cost_i[1] < cost_j[1]) or (cost_i[0] < cost_j[0] and cost_i[1] <= cost_j[1]):\n                    dominated_count[j] += 1\n\n    # Select solution with probability inversely proportional to its dominance\n    weights = [1.0 / (1 + count) for count in dominated_count]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: node relocation with segment rotation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n\n    # Create new solution by removing the node and inserting it into the rotated segment\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9254894964269617,
            0.3887676000595093
        ]
    },
    {
        "algorithm": "The algorithm combines multi-objective aware selection with dynamic local search: it selects solutions based on weighted improvement potential (equal weighting for both objectives) and applies either fine-grained or aggressive perturbations (segment reversal or edge insertion) based on solution quality, ensuring feasibility through validation checks. The selection prioritizes solutions with lower normalized costs, while the local search adapts its intensity based on the solution's proximity to optimality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective aware selection with dynamic weighting\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Dynamic weighting based on relative improvement potential\n        norm_cost1 = cost1 / max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        norm_cost2 = cost2 / max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        weight = 1 - (0.5 * norm_cost1 + 0.5 * norm_cost2)  # Equal weighting for both objectives\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive perturbation based on solution quality\n    cost1, cost2 = archive[selected_idx][1]\n    max_cost1 = max(c[0] for _, c in archive)\n    max_cost2 = max(c[1] for _, c in archive)\n\n    # If solution is close to optimal in both objectives, use fine-grained perturbation\n    if (cost1 / max_cost1 < 0.3 and cost2 / max_cost2 < 0.3):\n        # Fine-grained edge swap with validation\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        if len(set(temp_solution)) == n:\n            new_solution = temp_solution\n    else:\n        # More aggressive perturbation for solutions with room for improvement\n        operation = random.choice(['segment_reversal', 'edge_insertion'])\n\n        if operation == 'segment_reversal':\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final validation check\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9212690369465448,
            0.6433501243591309
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive with a probability inversely proportional to their normalized costs (prioritizing higher-cost solutions for improvement) and applies a hybrid local search combining edge reversal and segment insertion, with adaptive segment lengths based on solution quality. The weighting scheme (60-40) gives higher priority to the first objective, and the segment length is dynamically adjusted between 2 and 5 nodes. The method ensures feasibility by maintaining a valid TSP tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized costs\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        weight = (0.6 * norm_cost1 + 0.4 * norm_cost2)  # Higher weight for solutions with higher costs\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment length based on solution quality\n    segment_length = max(2, min(5, int(n * (0.6 * weights[selected_idx] + 0.4))))\n\n    # Randomly choose a segment to reverse\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly insert a segment between two non-consecutive nodes\n    i, j = sorted(random.sample(range(n), 2))\n    if abs(i - j) > segment_length:\n        segment = new_solution[i:i+segment_length]\n        new_solution = np.delete(new_solution, slice(i, i+segment_length))\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8442779461361483,
            0.48172855377197266
        ]
    },
    {
        "algorithm": "The algorithm first selects a promising solution from the archive by prioritizing non-dominated solutions and using crowding distance to balance exploration and exploitation. It then applies a hybrid edge-insertion local search that intelligently recombines tour segments by evaluating insertion points based on minimizing both objectives, ensuring feasible solutions while improving tour quality across both coordinate spaces. The selection process gives higher priority to non-dominated solutions, while the local search focuses on optimizing both objectives simultaneously through segment-based modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (non-dominated + crowding distance)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Non-dominated sorting\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    # Select based on crowding distance (simplified)\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid edge-insertion local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(5, n // 2))\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n    # Remove the segment\n    remaining_nodes = np.setdiff1d(np.arange(n), segment)\n\n    # Find insertion points that minimize both objectives\n    best_pos = -1\n    best_cost = (float('inf'), float('inf'))\n\n    for i in range(len(remaining_nodes)):\n        for j in range(i + 1, len(remaining_nodes)):\n            # Create candidate solution by inserting segment between i and j\n            candidate = np.concatenate([\n                remaining_nodes[:i],\n                segment,\n                remaining_nodes[i:j],\n                remaining_nodes[j:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%len(candidate)]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%len(candidate)]] for k in range(len(candidate)))\n\n            if (cost1, cost2) < best_cost:\n                best_cost = (cost1, cost2)\n                best_pos = (i, j)\n\n    if best_pos != -1:\n        i, j = best_pos\n        new_solution = np.concatenate([\n            remaining_nodes[:i],\n            segment,\n            remaining_nodes[i:j],\n            remaining_nodes[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8718233259377204,
            3.7077744603157043
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution from the archive using weighted roulette wheel selection based on normalized objective values, prioritizing solutions with balanced improvement potential (60% weight on first objective, 40% on second). It then applies a hybrid local search combining adaptive segment reversal (reversing segments with high cost in either objective) and weighted edge swaps (prioritizing swaps that improve at least one objective), ensuring feasibility by reverting invalid moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection of nondominated solutions\n    weights = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives\n        max_cost1 = max(c[0] for _, c in archive) if max(c[0] for _, c in archive) > 0 else 1\n        max_cost2 = max(c[1] for _, c in archive) if max(c[1] for _, c in archive) > 0 else 1\n        norm_cost1 = cost1 / max_cost1\n        norm_cost2 = cost2 / max_cost2\n        # Dynamic weighting: prioritize solutions with balanced improvement potential\n        weight = 1 - (0.6 * norm_cost1 + 0.4 * norm_cost2)\n        weights.append(weight)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal + weighted edge swaps\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal: reverse segments with high cost in either objective\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    if segment_cost1 > 0.7 * sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)) or \\\n       segment_cost2 > 0.7 * sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)):\n        new_solution[i:j+1] = segment[::-1]\n\n    # Weighted edge swaps: prioritize swapping edges with high cost in either objective\n    k, l = random.sample(range(n), 2)\n    if k != l:\n        cost1_before = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost2_before = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        cost1_after = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        cost2_after = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n        # Revert if no improvement in either objective\n        if (cost1_after >= cost1_before and cost2_after >= cost2_before) or \\\n           (random.random() < 0.3 and (cost1_after > cost1_before or cost2_after > cost2_before)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8880416690009134,
            9.611193776130676
        ]
    }
]