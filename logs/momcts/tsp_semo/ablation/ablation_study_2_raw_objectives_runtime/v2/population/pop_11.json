[
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objectives (30% for the first objective, 70% for the second), then applies a hybrid local search combining edge reversal and a novel node reordering strategy to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The weighted selection prioritizes solutions with better performance in the second objective, while the local search explores new configurations by reversing segments and shuffling sub-sequences.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective (0.3*obj1 + 0.7*obj2)\n    selected = max(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal with node reordering\n    if n >= 3:\n        # Step 1: Reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Step 2: Novel node reordering in a sub-sequence\n        sub_start = np.random.randint(0, n - 2)\n        sub_end = np.random.randint(sub_start + 2, min(sub_start + 6, n))\n        sub_seq = new_solution[sub_start:sub_end]\n        np.random.shuffle(sub_seq)\n        new_solution[sub_start:sub_end] = sub_seq\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9955506201873332,
            0.5729128122329712
        ],
        "raw_score": [
            10.473809131272606,
            10.692212489823685
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated or high-cost solutions) and applies a hybrid local search combining edge insertion with a novel edge-swapping move, ensuring feasibility by maintaining a valid TSP tour. It evaluates potential improvements by reinserting edges and swaps non-adjacent edges to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify edges with high potential for improvement\n    # Calculate the improvement if we remove an edge and reinsert it elsewhere\n    improvements = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Cost before removal\n        cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b]\n        # Try inserting between other edges\n        for j in range(n):\n            if j == i or j == (i+1)%n:\n                continue\n            c, d = new_solution[j], new_solution[(j+1)%n]\n            # Cost after insertion\n            cost_after = distance_matrix_1[a, c] + distance_matrix_1[b, d] + distance_matrix_2[a, c] + distance_matrix_2[b, d]\n            improvement = cost_before - cost_after\n            if improvement > 0:\n                improvements.append((improvement, i, j))\n\n    if improvements:\n        # Select the best improvement\n        improvements.sort(reverse=True, key=lambda x: x[0])\n        best_improvement, i, j = improvements[0]\n        # Perform the move\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        # Remove edge (a,b)\n        if i < (i+1)%n:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[(i+2)%n:]])\n        else:\n            new_solution = np.concatenate([new_solution[:(i+1)%n], new_solution[i+1:]])\n        # Insert between j and (j+1)%n\n        new_solution = np.insert(new_solution, (j+1)%(n-1), [a, b])\n\n    # Step 2: Apply a novel move (swap of two non-adjacent edges)\n    if n >= 4:\n        # Select two non-adjacent edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        # Swap the edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9064382800779567,
            1.1508705615997314
        ],
        "raw_score": [
            10.533537607490505,
            10.598789083613973
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive and applies a hybrid 4-opt local search with conditional edge swaps, prioritizing solutions with lower costs in both objectives while ensuring feasibility through dynamic segment validation. It evaluates all possible 4-opt reconnections and selects the best one, then occasionally applies a random edge swap for exploration, with a fallback to the original solution if validity is compromised. The approach balances exploitation (via 4-opt) and exploration (via random swaps) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high potential for improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] < selected[1][0] and obj[1] < selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid 4-opt with conditional edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Select four distinct edges\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Step 2: Generate all possible 4-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[c:d], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[a:b], new_solution[b:c], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[c:d], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[b:c], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[a:b], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[c:d], new_solution[a:b]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[a:b], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[b:c], new_solution[a:b]])\n    ]\n\n    # Step 3: Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Step 4: Conditional edge swap for exploration\n    if np.random.random() < 0.3:  # 30% chance to apply edge swap\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9000109701044243,
            0.995768666267395
        ],
        "raw_score": [
            6.723056389385884,
            6.099974218831657
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted sum of objectives (70% first objective, 30% second objective), then applies a hybrid local search combining random node swapping and segment rotation to generate a neighbor solution while ensuring feasibility by validating node uniqueness. If the neighbor violates feasibility, it reverts to the original solution. The approach prioritizes the first objective (70%) while still considering the second objective (30%) for selection, and uses creative local search operators beyond standard 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best weighted combination of objectives\n    def weighted_score(obj):\n        return 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n\n    selected = min(archive, key=lambda x: weighted_score(x[1]))[0].copy()\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: node swapping and segment rotation\n    if n > 2:\n        # Randomly select two distinct nodes to swap\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment and rotate it\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8677281002252125,
            0.5868901014328003
        ],
        "raw_score": [
            6.0516388475897465,
            7.951022179966049
        ]
    },
    {
        "algorithm": "The algorithm selects a promising TSP solution from an archive by prioritizing those with higher objective values, then applies a hybrid local search combining a novel path reversal and a guided edge swap. It ensures feasibility by validating all moves and prioritizes improvements based on both objectives, with path reversal acting as a diversification step and edge swaps focusing on cost reduction.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with high diversity and potential improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] > selected[1][0] and obj[1] > selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel path reversal operator\n    if n >= 4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Guided edge swap with objective-aware selection\n    if n >= 4:\n        improvements = []\n        for i in range(n):\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            for j in range(n):\n                if j == i or j == (i+1)%n:\n                    continue\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                cost_before = distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_1[c, d] + distance_matrix_2[c, d]\n                cost_after = distance_matrix_1[a, c] + distance_matrix_2[a, c] + distance_matrix_1[b, d] + distance_matrix_2[b, d]\n                improvement = cost_before - cost_after\n                if improvement > 0:\n                    improvements.append((improvement, i, j))\n\n        if improvements:\n            improvements.sort(reverse=True, key=lambda x: x[0])\n            best_improvement, i, j = improvements[0]\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9666645385568962,
            2.3527796864509583
        ],
        "raw_score": [
            10.441985295776638,
            10.72303720980633
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive, applies a hybrid 4-opt local search with adaptive edge swaps to generate neighbors, and ensures feasibility by validating node uniqueness before returning the improved solution. It prioritizes solutions with better objective values and uses a dynamic probability for edge swaps to balance exploration and exploitation. The method emphasizes multi-objective improvement while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high potential for improvement\n    selected = None\n    for sol, obj in archive:\n        if selected is None or (obj[0] < selected[1][0] and obj[1] < selected[1][1]):\n            selected = (sol, obj)\n    if selected is None:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 4-opt with adaptive edge swaps\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Generate all possible 4-opt reconnections\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[c:d], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[b:c], new_solution[a:b], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[a:b], new_solution[b:c], new_solution[d:]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[c:d], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[a:b], new_solution[d:], new_solution[b:c], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[a:b], new_solution[c:d]]),\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[d:], new_solution[c:d], new_solution[a:b]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[a:b], new_solution[b:c]]),\n        np.concatenate([new_solution[:a], new_solution[c:d], new_solution[d:], new_solution[b:c], new_solution[a:b]])\n    ]\n\n    # Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Adaptive edge swap for exploration\n    swap_prob = 0.4 if n > 10 else 0.6\n    if np.random.random() < swap_prob:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        while abs(i - j) <= 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8923644272645856,
            1.0413649678230286
        ],
        "raw_score": [
            6.885641840737755,
            6.194193988497842
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective value from the archive and applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution, ensuring feasibility by validating node uniqueness. It prioritizes solutions with better overall performance and uses random segment selection and insertion to explore the search space creatively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine segment reversal and edge insertion\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Reverse segment [a, b] if it improves the tour\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Insert segment [c, d] at a random position\n    segment_to_insert = new_solution[c:d+1]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment_to_insert)\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7187510415670595,
            0.6468862891197205
        ],
        "raw_score": [
            6.571400756723691,
            6.321706330194692
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by dynamically weighting objectives, then applies adaptive segment relocation followed by probabilistic edge swapping to generate a neighbor solution, ensuring feasibility through validation. The selection prioritizes solutions with lower combined normalized objectives, while the local search balances segment relocation and edge swaps to explore the solution space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a dynamic trade-off between objectives\n    objectives = np.array([(obj1, obj2) for _, (obj1, obj2) in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weights /= np.sum(weights)\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment relocation\n    segment_size = min(3, n // 3)\n    a = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[a:a+segment_size]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Probabilistic edge swapping\n    swap_prob = 0.3 if n > 10 else 0.5\n    for i in range(len(new_solution)):\n        if np.random.random() < swap_prob:\n            j = np.random.randint(0, len(new_solution))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8366329921997576,
            0.7220543622970581
        ],
        "raw_score": [
            8.158220724422227,
            7.652125449267405
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects promising solutions from the archive by balancing normalized objective costs and diversity, then generates neighbors through adaptive segment swapping prioritizing node clusters close in both objective spaces, with a probabilistic bias toward improving the higher-cost objective. It uses weighted cost evaluation to guide segment insertion and occasionally applies segment inversion for diversity, ensuring feasible TSP tours while exploring the solution space more effectively than standard 2-opt methods.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a dynamic combination of normalized objectives and diversity\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj1 = obj[0] / (np.sum(distance_matrix_1) + 1e-10)\n        norm_obj2 = obj[1] / (np.sum(distance_matrix_2) + 1e-10)\n        diversity = np.sum(np.abs(np.diff(sol))) / len(sol)\n        scores.append(weights[i] * (norm_obj1 + norm_obj2) + (1 - weights[i]) * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment swapping with node clustering\n    if n >= 4:\n        # Identify clusters of nodes that are close in both objective spaces\n        cluster_size = np.random.randint(2, min(5, n//2))\n        start_pos = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[start_pos:start_pos + cluster_size]\n\n        # Find a position to insert the cluster that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n - cluster_size + 1):\n            if pos in range(start_pos, start_pos + cluster_size):\n                continue\n\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                cluster,\n                new_solution[pos:start_pos],\n                new_solution[start_pos + cluster_size:]\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n            # Bias towards improving the objective with higher current cost\n            current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n            if current_cost1 > current_cost2:\n                total_cost = cost1 * 0.6 + cost2 * 0.4\n            else:\n                total_cost = cost1 * 0.4 + cost2 * 0.6\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                cluster,\n                new_solution[best_pos:start_pos],\n                new_solution[start_pos + cluster_size:]\n            ])\n\n    # Probabilistic segment inversion for diversity\n    if np.random.random() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8940415213035057,
            2.4321322441101074
        ],
        "raw_score": [
            6.294777593193928,
            6.308984515063971
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by choosing the one with the best combined objective (sum of both costs), then applies a hybrid local search combining 3-opt moves with segment inversions to generate improved neighbors while ensuring feasibility. It prioritizes solutions with lower total cost and uses probabilistic segment inversions to maintain diversity. The approach balances exploitation (via 3-opt) and exploration (via segment inversion) to improve solution quality across both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    # Here we use a simple selection strategy: choose the solution with the best combined objective\n    selected_idx = np.argmin([obj1 + obj2 for _, (obj1, obj2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid 3-opt with segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:] if c != 0 else np.array([])\n\n    # There are 4 possible ways to reconnect the segments (excluding the original)\n    options = [\n        np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3]),\n        np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3[::-1]]),\n        np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3[::-1]]),\n        np.concatenate([new_solution[:a], segment1, segment2, segment3[::-1]])\n    ]\n\n    # Evaluate all options and select the best one\n    best_option = None\n    best_cost = float('inf')\n\n    for option in options:\n        # Calculate total cost for both objectives\n        total_cost = 0\n        for i in range(n):\n            j = (i + 1) % n\n            total_cost += distance_matrix_1[option[i], option[j]] + distance_matrix_2[option[i], option[j]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_option = option.copy()\n\n    if best_option is not None:\n        new_solution = best_option\n\n    # Additional segment inversion for diversity\n    if np.random.random() < 0.5:  # 50% chance to apply segment inversion\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7338904910350743,
            0.7760787606239319
        ],
        "raw_score": [
            5.757521071231495,
            6.190310024313944
        ]
    }
]