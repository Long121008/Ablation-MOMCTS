[
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining edge exchange and segment inversion to explore diverse neighborhoods while ensuring feasibility. The selection prioritizes randomness for exploration, while the hybrid search balances edge-wise and segment-wise modifications to escape local optima. The feasibility check ensures valid TSP tours by reverting to simpler operations if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8790760004126856,
            0.47520631551742554
        ],
        "raw_score": [
            7.31569362287178,
            7.144871037754502
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution (highest sum of objectives) from the archive and applies a hybrid local search combining segment reversal and edge insertion. It randomly reverses segments and inserts edges while ensuring feasibility, falling back to a simple 2-opt if invalid. The focus is on diversity and exploration of the solution space.\n\n(Note: The original code selects the worst solution, which may not be ideal for improvement. A better approach would prioritize solutions with high potential for improvement, e.g., those near the Pareto front or with high variance in objectives.)",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        # Insert edge (a, b) by reversing the segment between them\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the hybrid approach fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9185087722772078,
            0.5027542114257812
        ],
        "raw_score": [
            10.45220321439054,
            10.552246178094743
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid criterion that balances low-cost objectives and crowding distance, then applies a novel local search combining segment reversal (prioritizing cost reduction in both objectives) and edge exchange with path-relinking (introducing edges from other solutions) while ensuring feasibility through lightweight checks and fallback mechanisms. It prioritizes cost reduction in both objectives during segment reversal and leverages diverse edges from the archive to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize low-cost solutions but also consider crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    distances = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n    crowding = np.mean(distances, axis=1)\n    normalized_costs = np.min(objectives, axis=1) / np.max(objectives, axis=1)\n    selection_scores = normalized_costs + (1 - crowding / np.max(crowding))\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel hybrid local search: segment reversal + edge exchange with path-relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment reversal based on distance matrices\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost reduction for both objectives\n    original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n    new_cost = original_cost\n    for k in range(i, j-1):\n        new_cost -= (distance_matrix_1[new_solution[k], new_solution[k+1]] + distance_matrix_2[new_solution[k], new_solution[k+1]])\n        new_cost += (distance_matrix_1[reversed_segment[k-i], reversed_segment[k-i+1]] + distance_matrix_2[reversed_segment[k-i], reversed_segment[k-i+1]])\n\n    if new_cost < original_cost:\n        new_solution[i:j] = reversed_segment\n\n    # Step 2: Edge exchange with path-relinking\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n                break\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple edge exchange if segment reversal fails\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9358999730821044,
            2.052245080471039
        ],
        "raw_score": [
            10.503285113441873,
            10.666047431412455
        ]
    },
    {
        "algorithm": "The algorithm selects balanced solutions (prioritizing those with similar objective values) from the archive, then applies a hybrid local search\u2014randomly choosing between node insertion (70% chance) or segment rotation (30%)\u2014to generate a neighbor solution while ensuring feasibility through checks for solution length and node uniqueness. It leverages the distance matrices to implicitly guide the search toward potentially better solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Randomly select from top 5 balanced solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine node insertion and segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.7:  # Higher chance for node insertion\n        # Node insertion: randomly select a node and insert it at a new position\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n    else:\n        # Segment rotation: randomly select a segment and rotate it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        k = np.random.randint(len(segment))\n        rotated_segment = np.roll(segment, k)\n        new_solution[i:j] = rotated_segment\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9201315108595929,
            0.6749270558357239
        ],
        "raw_score": [
            7.441653454247232,
            7.403118347666922
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower total distance in either objective space, then applies a hybrid local search combining random edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility. The selection is biased toward better-performing solutions (top 3 in either objective), and the local search randomly chooses between edge swaps or segment reversals to explore the solution space. The solution is validated to ensure no duplicates or missing nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with promising potential (lowest total distance in either space)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1][0], x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap and segment reversal\n    if np.random.random() < 0.5:\n        # Edge swap: randomly select two edges and swap their nodes\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal: randomly select a segment and reverse it\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5336246797501336,
            0.5794582962989807
        ],
        "raw_score": [
            9.160038133875737,
            5.586881988188598
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing lower-cost solutions (weighting the first objective 70% and the second 30%), then applies a hybrid local search: with 60% probability it reverses segments (adaptively sized based on solution quality) and with 40% probability it probabilistically inserts nodes. The method ensures feasibility by validating solution length and node uniqueness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a weighted combination of objectives\n    def objective_weight(obj):\n        return 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n\n    archive_sorted = sorted(archive, key=lambda x: objective_weight(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))  # Randomly select from top 3\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search: probabilistic choice between segment reversal and edge insertion\n    if np.random.random() < 0.6:\n        # Adaptive segment reversal: larger segments for better solutions\n        segment_size = max(2, int(n * 0.2 * (1 - selected_idx / len(archive_sorted))))\n        start = np.random.randint(0, n - segment_size + 1)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n    else:\n        # Probabilistic edge insertion: move a node to a better position\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8475511804241814,
            0.5856691598892212
        ],
        "raw_score": [
            5.177045638770812,
            7.611470422502938
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining edge-swapping (a modified 2-opt) and path-relinking (introducing edges from another solution), ensuring feasibility by maintaining valid TSP tours. It prioritizes exploration by randomly selecting segments to reverse and inserting nodes from other solutions, balancing exploitation and exploration for multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low cost but not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge-swapping and path-relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping (similar to 2-opt but more flexible)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i != j:\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path-relinking (introduce edges from another solution)\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find edges in the other solution that could improve the current one\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                # Insert the missing node at a random position\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]  # Ensure length remains the same\n                break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8595613224930644,
            0.7343329787254333
        ],
        "raw_score": [
            6.9014245420425,
            6.095714066481012
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto dominance and crowding distance, then applies a hybrid local search combining adaptive segment reversal and edge exchange, ensuring feasibility while dynamically perturbing if stuck. It prioritizes non-dominated solutions with high crowding distance for selection and uses a combination of segment reversal and edge exchange to explore the solution space, with a fallback mechanism to maintain validity. The method dynamically adjusts segment sizes and exchange probabilities to avoid local optima, with a perturbation step triggered when no improvement is detected.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: prioritize non-dominated solutions with high crowding distance\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                dominated[i] = True\n                break\n\n    non_dominated = [i for i, dom in enumerate(dominated) if not dom]\n    if not non_dominated:\n        non_dominated = list(range(len(archive)))\n\n    # Calculate crowding distance for non-dominated solutions\n    crowding = np.zeros(len(non_dominated))\n    for m in range(2):  # For each objective\n        sorted_idx = sorted(non_dominated, key=lambda i: archive[i][1][m])\n        crowding[[i for i in range(len(non_dominated)) if i == 0 or i == len(non_dominated)-1]] = np.inf\n        for i in range(1, len(non_dominated)-1):\n            crowding[i] += (archive[sorted_idx[i+1]][1][m] - archive[sorted_idx[i-1]][1][m]) / (archive[sorted_idx[-1]][1][m] - archive[sorted_idx[0]][1][m])\n\n    # Select solution with highest crowding distance\n    selected_idx = non_dominated[np.argmax(crowding)]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: adaptive segment reversal and edge exchange\n    new_solution = base_solution.copy()\n\n    # Adaptive segment reversal\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Edge exchange with bias toward improving both objectives\n    i, j = sorted(random.sample(range(n), 2))\n    if random.random() < 0.3:  # 30% chance to exchange edges\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic perturbation if stuck\n    if np.array_equal(new_solution, base_solution):\n        k = random.randint(2, n//2)\n        segments = sorted(random.sample(range(1, n), k-1))\n        segments = [0] + segments + [n]\n        random.shuffle(segments[1:-1])\n        new_solution = np.concatenate([new_solution[segments[i]:segments[i+1]] for i in range(len(segments)-1)])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8977188012442918,
            0.7962545156478882
        ],
        "raw_score": [
            7.294429526476299,
            7.116684717908891
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of normalized objective values and randomness, then applies a hybrid local search combining 3-opt with an insertion heuristic to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with higher combined normalized costs (70%) and adds randomness (30%) to avoid local optima. The local search first performs a 3-opt move on three randomly selected segments and then refines the solution by reinserting nodes at positions optimized for both objectives, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    def selection_criteria(sol_obj):\n        # Combine normalized objectives and diversity (simplified for this example)\n        norm_obj1 = sol_obj[1][0] / (sum(o[1][0] for o in archive) / len(archive) + 1e-6)\n        norm_obj2 = sol_obj[1][1] / (sum(o[1][1] for o in archive) / len(archive) + 1e-6)\n        return 0.7 * (norm_obj1 + norm_obj2) + 0.3 * np.random.random()\n\n    selected = max(archive, key=selection_criteria)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: 3-opt with insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move\n    new_segment = np.concatenate([\n        new_solution[i:j],\n        new_solution[k:],\n        new_solution[j:k],\n        new_solution[:i]\n    ])\n    new_solution[:] = new_segment\n\n    # Apply insertion heuristic to refine the solution\n    for _ in range(2):  # Number of insertion attempts\n        # Select a random node to reinsert\n        idx = np.random.randint(0, n)\n        node = new_solution[idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, idx)\n\n        # Find the best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n):\n            # Insert the node at position pos\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2  # Simple combination\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8558078839365527,
            4.305092513561249
        ],
        "raw_score": [
            6.642006530499136,
            6.384819747921993
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest objective variance (indicating potential for improvement) and applies a hybrid local search combining edge exchange (swapping two random nodes) and segment reversal (reversing a random segment), ensuring feasibility by validating uniqueness of nodes. If this fails, it falls back to a simpler edge exchange. The selection prioritizes solutions with higher objective variance, while the hybrid search innovatively combines two operations to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge exchange + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Feasibility check: ensure no duplicates or skips\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n\n    # Fallback: simple edge exchange if hybrid search fails\n    new_solution = base_solution.copy()\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.628430131798555,
            0.5967089533805847
        ],
        "raw_score": [
            7.47799082163341,
            7.578283264318682
        ]
    }
]