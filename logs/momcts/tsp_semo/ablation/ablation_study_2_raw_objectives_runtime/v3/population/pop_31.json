[
    {
        "algorithm": "The heuristic selects a random solution from the archive, applies a hybrid local search combining edge insertion and node relocation to generate a neighbor, and ensures feasibility by reverting to a simple swap if duplicates occur. The selection is random, while the local search prioritizes edge-wise and node-wise modifications for exploration. The design balances simplicity and feasibility, with fallback mechanisms to maintain valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge insertion and node relocation\n    new_solution = base_solution.copy()\n\n    # Edge insertion (insert a node at a random position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Node relocation (move a node to a new position)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if operations cause duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9722195366932449,
            0.5455512404441833
        ],
        "raw_score": [
            7.274013559989165,
            6.750318961900975
        ]
    },
    {
        "algorithm": "The algorithm selects a solution with the highest objective variance from the archive, then applies a hybrid local search combining 3-opt and node insertion to generate a neighbor. It prioritizes diversity in objectives and uses a fallback swap if the solution becomes invalid. The key design ideas are selecting high-variance solutions and combining 3-opt with node insertion for exploration, with validation to ensure feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with node insertion\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly insert a node elsewhere\n    node_to_move = new_solution[random.randint(0, n-1)]\n    insert_pos = random.randint(0, n-2)\n    if insert_pos < n-1:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            np.array([node_to_move]),\n            new_solution[insert_pos:-1][new_solution[insert_pos:-1] != node_to_move],\n            [new_solution[-1]]\n        ])\n\n    # Validate the solution\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9315092738042138,
            0.2931731939315796
        ],
        "raw_score": [
            6.562713517573391,
            9.376940086743101
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding distance to prioritize solutions near the Pareto front, then applies a hybrid local search combining adaptive segment reversal (prioritizing simultaneous gains in both objectives) and multi-objective node insertion (evaluating edges based on both objectives), while dynamically perturbing the solution if no improvement is found. It balances exploration and exploitation by adaptively adjusting the search strategy based on the archive's diversity and the current solution's potential for improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution near the Pareto front using crowding distance\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    # Hybrid local search: adaptive segment reversal and multi-objective node insertion\n    for _ in range(3):\n        # Adaptive segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            # Evaluate the new segment's contribution to both objectives\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    # Multi-objective node insertion\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find the best node to insert based on both objectives\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    # Calculate new costs\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    # Calculate improvement (normalized by current costs)\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    # Adaptive perturbation if no improvement\n    if not improved:\n        # Randomly swap segments\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Randomly insert a node from another solution\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9752152220232583,
            1.2736263275146484
        ],
        "raw_score": [
            4.153337010322309,
            10.479749296465762
        ]
    },
    {
        "algorithm": "The algorithm selects a solution near the Pareto front using crowding distance, applies a hybrid local search combining adaptive segment reversals and probabilistic edge insertions prioritizing simultaneous improvements in both objectives, and dynamically perturbs the solution if no improvement is found. The critical design ideas include prioritizing solutions with high crowding distance for selection, using segment reversals to explore local improvements, and probabilistically inserting nodes from other solutions to maintain diversity while ensuring feasibility. The algorithm balances exploration and exploitation by dynamically adjusting search strategies based on improvement outcomes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9835520421868915,
            1.2885069847106934
        ],
        "raw_score": [
            4.0347701833185425,
            10.28135107097755
        ]
    },
    {
        "algorithm": "The algorithm selects a solution near the Pareto front using crowding distance, then applies adaptive segment reversal and probabilistic edge insertions to generate neighbors, prioritizing solutions that improve both objectives while falling back to random perturbations if no improvement is found. It ensures feasibility by validating node uniqueness and maintains diversity by occasionally sampling from other solutions in the archive.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n                improved = True\n\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_improvement = 0\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    improvement = (base_obj[0] - new_cost1)/base_obj[0] + (base_obj[1] - new_cost2)/base_obj[1]\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    if not improved:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "metric_score": [
            -1.037720641543422,
            1.3144855499267578
        ],
        "raw_score": [
            4.084941344187676,
            10.466301442220711
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on high objective dominance and low solution diversity, then applies a hybrid local search combining adaptive segment inversions (prioritizing distance improvements) and probabilistic edge insertions (improving at least one objective), with fallback mechanisms to ensure feasibility. It emphasizes exploration-exploitation trade-offs through randomness and dynamic validation, always returning a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective dominance and low solution diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i, obj in enumerate(objectives):\n        dominated = np.sum(np.all((objectives <= obj) & (objectives != obj), axis=1))\n        dominance_scores[i] = dominated\n\n    diversity_scores = np.zeros(len(archive))\n    for i, sol in enumerate([s for s, _ in archive]):\n        diversity_scores[i] = len(set(sol))\n\n    scores = dominance_scores / (1 + diversity_scores)  # Prefer high dominance and low diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive segment inversion + probabilistic edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion: invert segments based on distance improvement\n    num_segments = random.randint(1, min(4, n // 3))\n    segment_indices = sorted(random.sample(range(n), num_segments))\n    segment_indices.append(n)\n    for i in range(num_segments):\n        start = segment_indices[i]\n        end = segment_indices[(i + 1) % len(segment_indices)]\n        if start > end:\n            end = n\n        segment = new_solution[start:end]\n        inverted = segment[::-1]\n        # Calculate improvement\n        before = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end % n]]\n        after = distance_matrix_1[new_solution[start-1], inverted[0]] + distance_matrix_1[inverted[-1], new_solution[end % n]]\n        if after <= before or random.random() < 0.4:  # Allow some exploration\n            new_solution[start:end] = inverted\n\n    # Probabilistic edge insertion: insert node at position that improves objectives\n    if random.random() < 0.6:\n        a, b = sorted(random.sample(range(n), 2))\n        node = new_solution[b]\n        temp = np.delete(new_solution, b)\n        for pos in range(n-1):\n            if pos == b:\n                continue\n            candidate = np.insert(temp, pos, node)\n            obj1 = sum(distance_matrix_1[candidate[i], candidate[(i + 1) % (n-1)]] for i in range(n-1))\n            obj2 = sum(distance_matrix_2[candidate[i], candidate[(i + 1) % (n-1)]] for i in range(n-1))\n            if obj1 <= distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] or obj2 <= distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution = candidate\n                break\n\n    # Feasibility check\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback: node swap if insertion fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n        else:\n            return base_solution\n\n",
        "metric_score": [
            -0.9878895834936654,
            5.405062675476074
        ],
        "raw_score": [
            10.522817348435737,
            10.571264578424586
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined normalized objective value from the archive, then applies a hybrid local search combining segment reversal and node relocation, followed by edge swaps and validation to ensure feasibility, with a fallback to random swaps if needed. It prioritizes solutions with better overall performance (sum of normalized objectives) and uses randomized operations to explore the solution space while maintaining tour validity. The key variables are the segment indices for reversal, the node and insertion position for relocation, and the edge swap candidates, with strict validation to prevent infeasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(x[1]) + 1e-6))\n    selected_solution = max_obj[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with node relocation\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Relocate a node to a position that maintains feasibility\n    node_to_move = new_solution[random.randint(0, n-1)]\n    insert_pos = random.randint(0, n-2)\n    if insert_pos < n-1:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            np.array([node_to_move]),\n            new_solution[insert_pos:-1][new_solution[insert_pos:-1] != node_to_move],\n            [new_solution[-1]]\n        ])\n\n    # Edge swap validation\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if a != b and a != n-1 and b != n-1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            if len(set(new_solution)) == n:\n                break\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Final validation\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7496000485100427,
            0.3808279037475586
        ],
        "raw_score": [
            9.372289478749114,
            9.653513168638309
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using crowding distance, then applies a hybrid local search combining adaptive segment reversal with dynamic thresholding and probabilistic edge insertion, prioritizing objectives with a weighted score (60% for first objective, 40% for second). It includes multi-phase perturbations as fallback and ensures feasibility through validation checks and repair mechanisms. The design emphasizes multi-objective improvement while maintaining solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            left = solutions[i-1][1] if i > 0 else None\n            right = solutions[i+1][1] if i < len(solutions)-1 else None\n            if left is None or right is None:\n                distances.append(float('inf'))\n            else:\n                dist = abs(right[0] - left[0]) + abs(right[1] - left[1])\n                distances.append(dist)\n        return distances\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = crowding_distance(sorted_archive)\n    selected_idx = np.argmax(distances)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    base_obj = sorted_archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improved = False\n\n    # Phase 1: Adaptive segment reversal with dynamic threshold\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            # Calculate costs\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n            # Dynamic threshold for acceptance\n            threshold1 = current_cost1 * 0.95\n            threshold2 = current_cost2 * 0.95\n\n            if (new_cost1 < threshold1 and new_cost2 < threshold2) or \\\n               (new_cost1 < threshold1 and new_cost2 <= current_cost2) or \\\n               (new_cost2 < threshold2 and new_cost1 <= current_cost1):\n                new_solution = temp_solution\n                improved = True\n                break\n\n    # Phase 2: Probabilistic edge insertion with multi-objective evaluation\n    if len(archive) > 1 and not improved:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        best_node = None\n        best_pos = -1\n        best_score = -float('inf')\n\n        for k in range(n):\n            node = other_solution[k]\n            if node not in new_solution:\n                for pos in range(n):\n                    temp_solution = np.insert(new_solution, pos, node)\n                    temp_solution = temp_solution[:n]\n\n                    new_cost1, new_cost2 = calculate_cost(temp_solution)\n                    improvement1 = (base_obj[0] - new_cost1) / base_obj[0]\n                    improvement2 = (base_obj[1] - new_cost2) / base_obj[1]\n\n                    # Weighted score combining both improvements\n                    score = 0.6 * improvement1 + 0.4 * improvement2\n\n                    if score > best_score:\n                        best_score = score\n                        best_node = node\n                        best_pos = pos\n\n        if best_node is not None:\n            new_solution = np.insert(new_solution, best_pos, best_node)\n            new_solution = new_solution[:n]\n            improved = True\n\n    # Phase 3: Multi-phase perturbation if no improvement\n    if not improved:\n        # Segment-based perturbation\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node-based perturbation\n        if len(archive) > 1:\n            other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n            other_solution = archive[other_idx][0]\n            node = np.random.choice(other_solution)\n            if node not in new_solution:\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]\n\n    # Feasibility check and fallback\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Random swap for repair\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        return new_solution\n\n",
        "metric_score": [
            -0.9746464038492153,
            1.5429846048355103
        ],
        "raw_score": [
            4.537230755981774,
            10.255993475421475
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining edge exchange and segment inversion to explore diverse neighborhoods while ensuring feasibility. The selection prioritizes randomness for exploration, while the hybrid search balances edge-wise and segment-wise modifications to escape local optima. The feasibility check ensures valid TSP tours by reverting to simpler operations if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge exchange and segment inversion\n    new_solution = base_solution.copy()\n\n    # Edge exchange (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion (reverse a random segment)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8790760004126856,
            0.47520631551742554
        ],
        "raw_score": [
            7.31569362287178,
            7.144871037754502
        ]
    },
    {
        "algorithm": "This algorithm combines adaptive Pareto dominance-based selection (prioritizing solutions with high Pareto front contribution) with a novel multi-objective segment inversion operator that dynamically balances exploration and exploitation by applying objective-weighted segment inversions, falling back to random swaps when feasibility is violated. It selects solutions with 70% probability based on Pareto dominance and 30% randomly, then applies segment inversions while reverting if no improvement is detected, ensuring feasibility through a fallback swap mechanism. The operator weights improvements by the relative costs of each objective, making it particularly effective for bi-objective optimization in TSP.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate Pareto dominance count for each solution\n    def pareto_dominance(solutions):\n        dominance = [0] * len(solutions)\n        for i, (sol_i, obj_i) in enumerate(solutions):\n            for j, (sol_j, obj_j) in enumerate(solutions):\n                if i != j and (obj_i[0] < obj_j[0] and obj_i[1] < obj_j[1]):\n                    dominance[i] += 1\n        return dominance\n\n    # Select solution with highest Pareto dominance (70% chance) or random (30% chance)\n    if np.random.random() < 0.7:\n        dominance = pareto_dominance(archive)\n        selected = archive[np.argmax(dominance)]\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current objective weights\n    weight1 = selected[1][0] / (selected[1][0] + selected[1][1] + 1e-6)\n    weight2 = selected[1][1] / (selected[1][0] + selected[1][1] + 1e-6)\n\n    # Multi-objective segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n\n        # Calculate improvement potential\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n\n        # Invert the segment\n        inverted_segment = new_solution[start:end+1][::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n\n        # Revert if no improvement\n        if (weight1 * new_cost1 + weight2 * new_cost2) >= (weight1 * original_cost1 + weight2 * original_cost2):\n            new_solution[start:end+1] = inverted_segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a random swap\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9711126442467652,
            0.6652889847755432
        ],
        "raw_score": [
            7.143172504086787,
            6.136703950363287
        ]
    }
]