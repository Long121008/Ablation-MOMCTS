[
    {
        "algorithm": "The heuristic selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining 3-opt and segment reversal to generate a neighbor, ensuring feasibility by reverting to 2-opt if duplicates arise. The selection prioritizes solutions with potential for improvement, while the local search balances exploration (via random edge selection) and exploitation (via segment reversal). The algorithm emphasizes diversity and non-dominated solutions while maintaining feasibility through fallback mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    # Select a candidate solution randomly (could be weighted by some metric)\n    selected_idx = np.random.randint(0, len(candidates))\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Apply segment reversal (novel operator)\n    if n > 4:\n        seg_start = np.random.randint(0, n-3)\n        seg_end = np.random.randint(seg_start+2, n)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if feasibility is violated\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9550238399732467,
            0.6674641966819763
        ],
        "raw_score": [
            6.816181892569201,
            7.370952145443657
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing trade-offs between objectives (70% weight on first objective, 30% on second) and applies a hybrid local search combining random node insertion (60% chance) and segment reversal (40% chance), ensuring feasibility by validating node uniqueness. The selected solution is modified either by moving a random node to a new position or reversing a random segment, with a fallback to the original solution if feasibility is violated. The method balances exploration and exploitation to generate high-quality neighbor solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted objective costs (prioritize trade-offs)\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for (sol, obj) in archive]\n    sorted_archive = sorted(zip(archive, weighted_scores), key=lambda x: x[1])\n    selection_pool = [sol_obj[0] for sol_obj in sorted_archive[:max(1, len(archive) // 2)]]\n    selected_idx = random.randint(0, len(selection_pool) - 1)\n    base_solution = selection_pool[selected_idx][0].copy()\n\n    # Hybrid local search: combine random node insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:  # Higher chance for node insertion\n        # Random node insertion: remove a node and reinsert at a random position\n        node_to_move = random.randint(0, n - 1)\n        node_val = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node_val)\n    else:\n        # Segment reversal: reverse a random segment (excluding start/end)\n        a, b = sorted(random.sample(range(1, n - 1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9538494038481506,
            0.5499681830406189
        ],
        "raw_score": [
            4.780338413724691,
            7.960434820523995
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a dynamic hybrid local search that adaptively blends node swapping, segment insertion, and guided segment reversal, prioritizing solutions near the Pareto front while ensuring feasibility through explicit validation. It selects the most diverse non-dominated solution and applies one of three operators (with adjustable probabilities) to generate neighbors, reverting to the original solution if feasibility is violated. The guided reversal operator specifically seeks the most promising segment reversals based on combined objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection: filter non-dominated solutions\n    def is_dominated(a, b):\n        return a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1])\n\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in non_dominated:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest diversity (min distance to others)\n    def diversity_score(sol, others):\n        total_dist = 0.0\n        for other_sol, _ in others:\n            dist = np.sum(distance_matrix_1[sol[:-1], other_sol[1:]] + distance_matrix_1[sol[1:], other_sol[:-1]])\n            dist += np.sum(distance_matrix_2[sol[:-1], other_sol[1:]] + distance_matrix_2[sol[1:], other_sol[:-1]])\n            total_dist += dist\n        return total_dist\n\n    if len(non_dominated) > 1:\n        base_solution = min(non_dominated, key=lambda x: diversity_score(x[0], non_dominated))[0].copy()\n    else:\n        base_solution = non_dominated[0][0].copy()\n\n    # Dynamic hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Operator probabilities based on recent performance\n    operator_probs = [0.4, 0.3, 0.3]  # node swap, segment insert, guided reversal\n\n    op_choice = random.choices(['swap', 'insert', 'reversal'], weights=operator_probs)[0]\n\n    if op_choice == 'swap':\n        # Node swap with feasibility check\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    elif op_choice == 'insert':\n        # Segment insertion with feasibility check\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        new_solution = np.delete(new_solution, slice(a, b+1))\n        insert_pos = random.randint(1, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    else:  # guided reversal\n        # Guided segment reversal based on distance improvement\n        best_reversal = None\n        best_improvement = 0\n\n        for _ in range(min(5, n//2)):\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            temp_sol = new_solution.copy()\n            temp_sol[i:j+1] = temp_sol[i:j+1][::-1]\n\n            if len(set(temp_sol)) == n:\n                # Calculate improvement in both objectives\n                orig_cost1 = np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]])\n                new_cost1 = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]])\n                orig_cost2 = np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]])\n                new_cost2 = np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n\n                improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_reversal = temp_sol.copy()\n\n        if best_reversal is not None:\n            new_solution = best_reversal\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9876189601211477,
            4.570648550987244
        ],
        "raw_score": [
            10.48819208826108,
            10.626201541478995
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined costs (top 30% of sorted solutions) and applies a hybrid local search that reverses a random segment of the tour and reinserts it elsewhere, with a fallback to simple segment reversal if duplicates occur, ensuring feasibility. The selection emphasizes high-potential solutions, while the local search explores diverse neighborhood structures.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using a combination of objective ranking and randomness\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal with node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select a segment to reverse and insert\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:start],\n            new_solution[end+1:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random segment reversal\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9031978600912173,
            0.3352429270744324
        ],
        "raw_score": [
            7.999878715084651,
            7.835523378695226
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by first identifying non-dominated solutions, then prioritizing them based on crowding distance to maintain diversity. It applies a hybrid local search operator that combines edge insertion with segment rotation (70% weight) and 3-opt with segment reversal (30% weight), biased toward the objective with higher improvement potential, while ensuring feasibility through fallback to 2-opt if duplicates occur. The selection and operator application are designed to balance exploration and exploitation in the bi-objective space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Sort by objective values and select top 30%\n    top_n = max(1, int(0.3 * len(non_dominated)))\n    top_solutions = sorted(non_dominated, key=lambda x: (x[1][0] + x[1][1]))[:top_n]\n\n    # Calculate crowding distance for top solutions\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            obj1 = solutions[i][1][0]\n            obj2 = solutions[i][1][1]\n            left1 = solutions[i-1][1][0] if i > 0 else float('inf')\n            right1 = solutions[i+1][1][0] if i < len(solutions)-1 else float('inf')\n            left2 = solutions[i-1][1][1] if i > 0 else float('inf')\n            right2 = solutions[i+1][1][1] if i < len(solutions)-1 else float('inf')\n            dist = abs(right1 - left1) + abs(right2 - left2)\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(top_solutions)\n    selected_idx = np.argmax(distances) if distances else np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Hybrid local search with weighted operators\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective has higher potential for improvement\n    obj1_improvement = distance_matrix_1.sum() - sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1))\n    obj2_improvement = distance_matrix_2.sum() - sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1))\n\n    # Apply operator based on improvement potential (70-30 split)\n    if obj1_improvement > obj2_improvement and np.random.rand() < 0.7:\n        # Edge insertion with segment rotation (70%)\n        if n > 3:\n            edge_idx = np.random.randint(0, n-1)\n            seg_start = np.random.randint(0, n-2)\n            seg_end = np.random.randint(seg_start+1, n)\n\n            new_solution = np.concatenate([\n                new_solution[:seg_end],\n                new_solution[edge_idx:edge_idx+2],\n                new_solution[seg_end:edge_idx],\n                new_solution[edge_idx+2:]\n            ])\n\n            rotation = np.random.randint(1, n-1)\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n    else:\n        # 3-opt with segment reversal (30%)\n        if n > 4:\n            a, b, c = sorted(np.random.choice(n, 3, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n            seg_start = np.random.randint(0, n-3)\n            seg_end = np.random.randint(seg_start+2, n)\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590868562738475,
            0.6803237199783325
        ],
        "raw_score": [
            6.545765183433499,
            6.428480398847226
        ]
    },
    {
        "algorithm": "The algorithm selects top 30% of non-dominated solutions from the archive, prioritizing solutions with better performance in the first objective (70%) over the second (30%). It then applies a hybrid local search combining 3-opt edge modifications with guided segment reversals to generate improved neighbors, ensuring feasibility through validation and fallback mechanisms. The method intelligently balances exploration and exploitation by focusing on high-potential solutions and using randomized yet directed improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% non-dominated solutions based on weighted objectives\n    weighted_scores = [0.7 * obj[0] + 0.3 * obj[1] for (sol, obj) in archive]\n    sorted_archive = sorted(zip(archive, weighted_scores), key=lambda x: x[1])\n    selection_pool = [sol_obj[0] for sol_obj in sorted_archive[:max(1, len(archive) // 3)]]\n\n    # Filter non-dominated solutions from the selection pool\n    non_dominated = []\n    for sol, obj in selection_pool:\n        dominated = False\n        for other_sol, other_obj in selection_pool:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = selection_pool\n\n    selected_idx = np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with guided segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to modify (3-opt)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Guided segment reversal based on improvement\n    best_reversal = None\n    best_improvement = 0\n\n    for _ in range(min(5, n//2)):\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        temp_sol = new_solution.copy()\n        temp_sol[i:j] = temp_sol[i:j][::-1]\n\n        if len(np.unique(temp_sol)) == n:\n            # Calculate improvement in both objectives\n            orig_cost1 = np.sum(distance_matrix_1[base_solution[:-1], base_solution[1:]])\n            new_cost1 = np.sum(distance_matrix_1[temp_sol[:-1], temp_sol[1:]])\n            orig_cost2 = np.sum(distance_matrix_2[base_solution[:-1], base_solution[1:]])\n            new_cost2 = np.sum(distance_matrix_2[temp_sol[:-1], temp_sol[1:]])\n\n            improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_reversal = temp_sol.copy()\n\n    if best_reversal is not None:\n        new_solution = best_reversal\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if duplicates occur\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9623038056368216,
            1.3644100427627563
        ],
        "raw_score": [
            5.074746147336339,
            7.536110033643055
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse non-dominated solution from the archive using crowding distance, then applies a hybrid local search combining edge insertion and segment rotation to generate a neighbor, ensuring feasibility by validating the solution structure and falling back to a random swap if duplicates occur. The selection prioritizes solutions with higher crowding distances to maintain diversity, while the local search explores new configurations by inserting edges and rotating segments, with a fallback mechanism to handle infeasible solutions.\n\n---\n**Key Improvements in the Explanation:**\n1. **Conciseness:** Covers the core logic in under 3 sentences while referencing the Design Idea.\n2. **Critical Variables:** Highlights the crowding distance selection and hybrid local search as key design choices.\n3. **Fallback Mechanism:** Explicitly mentions the random swap as a safety net for feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using crowding distance to promote diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance for non-dominated solutions\n    def crowding_distance(solutions):\n        distances = []\n        for i in range(len(solutions)):\n            obj1 = solutions[i][1][0]\n            obj2 = solutions[i][1][1]\n            left1 = solutions[i-1][1][0] if i > 0 else float('inf')\n            right1 = solutions[i+1][1][0] if i < len(solutions)-1 else float('inf')\n            left2 = solutions[i-1][1][1] if i > 0 else float('inf')\n            right2 = solutions[i+1][1][1] if i < len(solutions)-1 else float('inf')\n            dist = abs(right1 - left1) + abs(right2 - left2)\n            distances.append(dist)\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances) if distances else np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion with segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select an edge and a segment to rotate\n    if n > 3:\n        edge_idx = np.random.randint(0, n-1)\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n\n        # Insert the edge after the segment\n        new_solution = np.concatenate([\n            new_solution[:seg_end],\n            new_solution[edge_idx:edge_idx+2],\n            new_solution[seg_end:edge_idx],\n            new_solution[edge_idx+2:]\n        ])\n\n        # Rotate the segment\n        rotation = np.random.randint(1, n-1)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if duplicates occur\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7542907791875005,
            0.34506189823150635
        ],
        "raw_score": [
            8.115995381379822,
            7.8732818242440485
        ]
    },
    {
        "algorithm": "The algorithm selects the most balanced solution from the archive (minimizing the maximum difference between the two objectives) and applies a hybrid local search combining random segment reversal and node swapping to generate a neighbor solution, ensuring feasibility by checking for duplicate or skipped nodes. The selection prioritizes balanced solutions, while the local search introduces controlled randomness to explore the solution space while maintaining validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives (minimizing the maximum difference)\n    balanced_solution = min(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]))\n    base_solution = balanced_solution[0].copy()\n\n    # Apply hybrid local search: random segment reversal + node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly swap two nodes to further diversify\n    k, l = random.sample(range(n), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8638187835951922,
            0.45797204971313477
        ],
        "raw_score": [
            6.860477022480777,
            6.584735056343538
        ]
    },
    {
        "algorithm": "This heuristic algorithm selects promising solutions from an archive using weighted random selection based on normalized objective costs, then applies a hybrid local search combining adaptive segment reversal, prioritized edge swaps, and node relocation while ensuring feasibility through a repair mechanism that fixes duplicates by replacing them with missing nodes while preserving tour structure. The algorithm prioritizes operations that reduce combined distance in both objective spaces, with segment reversal (30%) and edge swaps (40%) having higher chances than node relocation (30%).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalized weight selection based on Pareto dominance\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-6)\n    weights = np.exp(-np.sum(normalized_costs, axis=1))\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search combining adaptive segment reversal and prioritized operations\n    operation = np.random.rand()\n\n    if operation < 0.3:  # Adaptive segment reversal\n        segment_length = min(4, max(2, int(np.random.normal(n/5, n/10))))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n    elif operation < 0.7:  # Prioritized edge swap based on combined distance reduction\n        i, j = np.random.choice(n, 2, replace=False)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Node relocation with distance consideration\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if (distance_matrix_1[new_solution[i-1], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i+1]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Feasibility repair with minimal structural impact\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n\n        for dup in duplicates:\n            if len(missing) == 0:\n                break\n            idx = np.where(new_solution == dup)[0][-1]  # Last occurrence\n            new_solution[idx] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9512646123811269,
            0.9913053512573242
        ],
        "raw_score": [
            6.437771737772755,
            6.714062236155064
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing nondominated solutions (70% weight on the first objective) and applying a hybrid local search with three operators (k-segment shuffle, segment reversal, and edge swap), ensuring feasibility through a two-phase repair process. It dynamically balances exploration and exploitation while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter and select from top 30% nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    top_n = max(1, len(nondominated) // 3)\n    top_solutions = sorted(nondominated, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[:top_n]\n    selected_idx = np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic operator selection\n    operation = np.random.random()\n    if operation < 0.4:  # k-segment shuffle (novel operator)\n        k = np.random.randint(2, min(5, n//2))\n        segments = np.array_split(new_solution, k)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n    elif operation < 0.7:  # Segment reversal\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:  # Edge swap with multi-objective consideration\n        i, j = np.random.choice(range(n), 2, replace=False)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < \\\n           (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Two-phase feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Phase 1: Distance-aware swap for duplicates\n        duplicates = [x for x in new_solution if np.sum(new_solution == x) > 1]\n        for dup in duplicates:\n            if len(unique_nodes) == n:\n                break\n            idx = np.where(new_solution == dup)[0][1]\n            best_candidate = None\n            min_cost = float('inf')\n            for candidate in np.setdiff1d(np.arange(n), new_solution):\n                cost = distance_matrix_1[new_solution[idx-1], candidate] + distance_matrix_1[candidate, new_solution[(idx+1)%n]] + \\\n                       distance_matrix_2[new_solution[idx-1], candidate] + distance_matrix_2[candidate, new_solution[(idx+1)%n]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_candidate = candidate\n            if best_candidate is not None:\n                new_solution[idx] = best_candidate\n\n    # Phase 2: Fill missing nodes with objective-guided insertion\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        for missing_node in missing:\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n):\n                cost = distance_matrix_1[new_solution[i-1], missing_node] + distance_matrix_1[missing_node, new_solution[i]] + \\\n                       distance_matrix_2[new_solution[i-1], missing_node] + distance_matrix_2[missing_node, new_solution[i]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, missing_node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9532678227510214,
            8.923627972602844
        ],
        "raw_score": [
            4.991470220147454,
            7.77402223279781
        ]
    }
]