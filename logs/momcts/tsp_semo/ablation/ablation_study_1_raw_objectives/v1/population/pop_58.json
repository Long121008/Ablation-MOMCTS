[
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing combined objective scores) and applies a hybrid local search combining random node insertions and segment shifts, ensuring feasibility by validating tour uniqueness and completeness. It adaptively adjusts parameters to explore diverse neighborhoods while falling back to simpler operations if needed. The method prioritizes exploration by randomly perturbing segments and nodes, balancing exploration with feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: combine node insertions and segment shifts\n    # Step 1: Randomly select a node to insert elsewhere\n    node = np.random.choice(new_solution)\n    idx = np.where(new_solution == node)[0][0]\n    new_solution = np.delete(new_solution, idx)\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Randomly select a segment to shift\n    segment_size = np.random.randint(2, min(5, n))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.delete(new_solution, np.s_[start:start+segment_size])\n    insert_pos = np.random.randint(0, n - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler node insertion\n        new_solution = base_solution.copy()\n        node = np.random.choice(new_solution)\n        idx = np.where(new_solution == node)[0][0]\n        new_solution = np.delete(new_solution, idx)\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9590416592200175,
            0.22849512100219727
        ],
        "raw_score": [
            6.281348843659081,
            7.059226482841522
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with weighted randomness favoring better objectives, then applies a hybrid local search combining node swapping (40% chance) and segment insertion (60% chance) for 15 iterations, ensuring feasibility by validating and repairing the tour if nodes are missing. The selection prioritizes solutions with lower objective values, while the local search explores diverse modifications to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(o[0] for o in objectives)\n    min_obj2 = min(o[1] for o in objectives)\n    weights = [(min_obj1 / o[0] + min_obj2 / o[1]) for o in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine node swapping and segment insertion\n    n = len(new_solution)\n    for _ in range(15):  # Increased iterations\n        # Randomly select two distinct edges to modify\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Node swapping: swap two nodes\n        if random.random() < 0.4:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment insertion: move a segment between two random positions\n        else:\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[b:c], new_solution[b:]])\n\n    # Ensure the solution remains a valid tour (visits each node exactly once)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Recover feasibility by reinserting missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9138960752940551,
            0.14283901453018188
        ],
        "raw_score": [
            10.419760007142234,
            10.631350875391004
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using Pareto dominance and diversity, then applies adaptive segment insertion with dynamic length and biased edge swaps prioritizing objective improvement, combining crowding-aware segment reversal and opportunistic edge swaps to generate high-quality neighbors while maintaining feasibility. The selection process favors top solutions, while the local search dynamically adjusts segment lengths and edge swaps based on objective improvements, with validation ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto dominance and diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    front = np.argsort(objectives[:, 0] + objectives[:, 1])[:min(3, len(archive))]  # Top solutions\n    selected_idx = np.random.choice(front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment insertion with dynamic length\n    segment_length = max(3, int(np.random.random() * (n // 3)))\n    start = np.random.randint(0, n - segment_length + 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    if insert_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            np.delete(new_solution, np.arange(start, start+segment_length))\n        ])\n\n    # Biased edge swaps prioritizing objective improvement\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == 0 or b == n-1:\n            continue\n\n        # Calculate objective improvement\n        obj_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]) / 2\n        obj_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) / 2\n\n        if obj_after < obj_before * 0.95 or np.random.random() < 0.2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validate solution\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6742482784628107,
            0.1022036075592041
        ],
        "raw_score": [
            6.976224185653362,
            7.299964776754653
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using dominance-aware weighted random selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.argsort(objectives[:, 0] + objectives[:, 1])\n    weights = 1.0 / (np.arange(len(ranks)) + 1)  # Higher weight for better solutions\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Calculate dominance score for adaptive behavior\n    dominance_score = (objectives[selected_idx, 0] + objectives[selected_idx, 1]) / (np.max(objectives) + 1e-8)\n\n    # Dynamic segment inversion with size based on dominance\n    segment_size = max(2, min(n//2, int(np.random.normal(n//3, n//4))))\n    if np.random.random() < 0.7 * (1 - dominance_score):\n        start = np.random.randint(0, n - segment_size + 1)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Pareto-gap biased edge swaps\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == 0 or b == n-1:\n            continue\n\n        # Calculate Pareto gap for both objectives\n        gap_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]) / 2\n        gap_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) / 2\n\n        if gap_after < gap_before * 0.9 or np.random.random() < 0.4 * dominance_score:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation for further exploration\n    if np.random.random() < 0.5 * (1 - dominance_score):\n        k = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, k)\n\n    # Validate solution\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0122375956488392,
            0.2827867269515991
        ],
        "raw_score": [
            7.256456995295721,
            7.182972763167188
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using crowding-distance weighted randomness to prioritize less crowded regions of the Pareto front, then applies adaptive segment inversion and Pareto-gap biased edge swaps to generate high-quality neighbors while maintaining feasibility. It dynamically adjusts segment sizes and swap probabilities based on dominance rank, favoring more promising solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using crowding-distance weighted randomness\n    objectives = np.array([obj for (sol, obj) in archive])\n    fronts = np.argsort(objectives[:, 0] + objectives[:, 1])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        left = max(0, i-1)\n        right = min(len(archive)-1, i+1)\n        crowding_distances[i] = np.sum(np.abs(objectives[i] - objectives[left]) + np.abs(objectives[i] - objectives[right]))\n\n    weights = crowding_distances / np.sum(crowding_distances)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate dominance rank\n    ranks = np.argsort(objectives[:, 0] + objectives[:, 1])\n    dominance_rank = np.where(ranks == selected_idx)[0][0] / len(archive)\n\n    # Adaptive segment inversion\n    segment_size = max(2, min(n//2, int(np.random.normal(n//3, n//4) * (1 - dominance_rank))))\n    start = np.random.randint(0, n - segment_size + 1)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Pareto-gap biased edge swaps\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == 0 or b == n-1:\n            continue\n\n        # Calculate Pareto gap for both objectives\n        gap_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]) / 2\n        gap_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]) / 2\n\n        if gap_after < gap_before * 0.9 or np.random.random() < 0.3 * (1 - dominance_rank):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validate solution\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0150400198524667,
            0.470720112323761
        ],
        "raw_score": [
            6.919438984852501,
            6.615261265551226
        ]
    },
    {
        "algorithm": "The algorithm combines dominance-aware selection (prioritizing solutions with better combined objective scores and higher crowding distances) with a novel \"multi-objective segment fusion\" operator that merges or swaps segments of the tour to reduce gaps between objectives, while ensuring feasibility through adaptive reinsertion. The selection process balances exploration (via crowding distance) and exploitation (via dominance rank), while the segment fusion dynamically adjusts segment sizes and operations based on potential objective improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: crowding distance and dominance rank\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.argsort(objectives[:, 0] + objectives[:, 1])\n    gaps = np.abs(objectives[:, 0] - objectives[:, 1])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = gaps[i] + (objectives[i+1, 0] - objectives[i-1, 0]) + (objectives[i+1, 1] - objectives[i-1, 1])\n\n    weighted_scores = ranks + 0.3 * crowding_distances\n    selected_idx = np.random.choice(np.argsort(weighted_scores)[:min(3, len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment fusion\n    segment_size = max(2, int(n / (ranks[selected_idx] + 2)))\n    start1 = np.random.randint(0, n - segment_size + 1)\n    start2 = np.random.randint(0, n - segment_size + 1)\n\n    segment1 = new_solution[start1:start1+segment_size]\n    segment2 = new_solution[start2:start2+segment_size]\n\n    # Calculate potential gap reduction\n    def calculate_gap(seg):\n        total_gap = 0\n        for i in range(len(seg)-1):\n            total_gap += abs(distance_matrix_1[seg[i], seg[i+1]] - distance_matrix_2[seg[i], seg[i+1]])\n        return total_gap\n\n    gap1 = calculate_gap(segment1)\n    gap2 = calculate_gap(segment2)\n\n    if gap1 > gap2:\n        # Merge segments if it reduces the maximum gap\n        merged_segment = np.concatenate([segment1, segment2])\n        new_solution = np.concatenate([\n            new_solution[:start1],\n            merged_segment,\n            new_solution[start1+segment_size:]\n        ])\n    else:\n        # Swap segments if it improves balance\n        new_solution[start1:start1+segment_size] = segment2\n        new_solution[start2:start2+segment_size] = segment1\n\n    # Adaptive segment reinsertion for feasibility\n    if len(set(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        segment = np.array(list(missing))\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Validate solution\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.926867139001377,
            0.20121318101882935
        ],
        "raw_score": [
            10.476330624423866,
            10.60625998745865
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from an archive using an adaptive dominance score that combines Pareto efficiency with crowding distance, then applies a hybrid local search combining biased edge swapping (prioritizing edges that improve both objectives) with dynamic segment inversion and random segment rotation to maintain diversity while ensuring feasibility. The selection process favors solutions with higher dominance scores but incorporates crowding distance to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    n_solutions = len(archive)\n\n    # Adaptive dominance score calculation\n    dominance_scores = np.zeros(n_solutions)\n    for i in range(n_solutions):\n        for j in range(n_solutions):\n            if i != j:\n                if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and \\\n                   (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                    dominance_scores[i] += 1\n                elif (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and \\\n                     (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                    dominance_scores[i] -= 1\n\n    # Normalize scores with crowding consideration\n    normalized_scores = np.zeros(n_solutions)\n    for i in range(n_solutions):\n        normalized_scores[i] = dominance_scores[i] + 0.3 * (np.sum((objectives[i] - objectives) ** 2) / n_solutions)\n\n    # Select solution with highest adaptive score\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search\n    # Phase 1: Biased edge swapping\n    swap_prob = 0.6 if dominance_scores[selected_idx] > 0 else 0.2\n    for i in range(n):\n        for j in range(i+2, n):\n            if np.random.random() < swap_prob:\n                # Calculate potential improvement\n                orig_cost = (distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                            distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n                            distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                            distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n                new_cost = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                            distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]] +\n                            distance_matrix_2[base_solution[i], base_solution[j]] +\n                            distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]])\n\n                if new_cost < orig_cost:\n                    # Perform swap\n                    new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    # Phase 2: Dynamic segment inversion\n    inv_prob = 0.4 if dominance_scores[selected_idx] > 0 else 0.1\n    if np.random.random() < inv_prob:\n        seg_size = max(2, min(n//2, int(np.random.normal(n//4, n//6))))\n        seg_start = np.random.randint(0, n - seg_size + 1)\n        new_solution[seg_start:seg_start+seg_size] = new_solution[seg_start:seg_start+seg_size][::-1]\n\n    # Phase 3: Random segment rotation\n    if np.random.random() < 0.3:\n        rot_size = max(2, min(n//3, int(np.random.normal(n//5, n//7))))\n        rot_start = np.random.randint(0, n - rot_size + 1)\n        rot_amount = np.random.randint(1, rot_size)\n        new_solution[rot_start:rot_start+rot_size] = np.roll(new_solution[rot_start:rot_start+rot_size], rot_amount)\n\n    # Validate solution\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.998741114974252,
            12.017665684223175
        ],
        "raw_score": [
            10.468575679908156,
            10.595801723979841
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid metric combining dominance rank and objective gap, then applies a dynamic segment relocation strategy prioritizing nodes with high objective discrepancy, followed by adaptive edge refinements to improve solution quality while maintaining feasibility. The selection process favors solutions with better combined objective values and higher gaps between objectives, while the local search focuses on relocating segments and swapping edges biased by objective-aware metrics.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection based on dominance and objective gap\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.argsort(objectives[:, 0] + objectives[:, 1])\n    gaps = np.abs(objectives[:, 0] - objectives[:, 1])\n    weighted_scores = ranks + 0.5 * gaps\n    selected_idx = np.random.choice(np.argsort(weighted_scores)[:min(3, len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment relocation with objective-aware node selection\n    segment_length = max(2, int(n / (ranks[selected_idx] + 2)))\n    start = np.random.randint(0, n - segment_length + 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Find insertion points biased by objective discrepancy\n    candidate_positions = []\n    for i in range(n):\n        if i < start or i >= start + segment_length:\n            node = new_solution[i]\n            obj_discrepancy = abs(distance_matrix_1[new_solution[i-1], node] - distance_matrix_2[new_solution[i-1], node])\n            candidate_positions.append((i, obj_discrepancy))\n\n    if candidate_positions:\n        candidate_positions.sort(key=lambda x: -x[1])\n        top_positions = [pos for pos, _ in candidate_positions[:min(3, len(candidate_positions))]]\n        insert_pos = np.random.choice(top_positions)\n\n        # Relocate segment\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n    # Adaptive edge refinements\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i == 0 or j == n-1:\n            continue\n\n        # Calculate objective-aware swap potential\n        current_gap = abs(distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]]) + \\\n                     abs(distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        swapped_gap = abs(distance_matrix_1[new_solution[i-1], new_solution[j]] - distance_matrix_2[new_solution[i-1], new_solution[j]]) + \\\n                     abs(distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] - distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if swapped_gap < current_gap * 0.85 or np.random.random() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check and repair\n    if len(set(new_solution)) != n:\n        # Reconstruct tour if invalid\n        missing = set(range(n)) - set(new_solution)\n        for i in range(n):\n            if new_solution[i] not in range(n):\n                new_solution[i] = missing.pop()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7661008908982379,
            0.17771363258361816
        ],
        "raw_score": [
            7.299462188494978,
            7.589888240095881
        ]
    },
    {
        "algorithm": "The algorithm combines dominance-aware selection with a hybrid local search that dynamically adjusts segment inversion and edge swaps based on Pareto-front gaps and dominance rank, prioritizing high-crowding regions while balancing exploration and exploitation through variable-length segments and probabilistic edge swaps. It selects solutions based on crowding distance and dominance rank, then applies segment inversions proportional to dominance level, followed by edge swaps targeting Pareto-front gaps, with additional segment reversals for further exploration. The method ensures feasibility through multi-stage validation and fallback mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using dominance and crowding distance\n    objectives = np.array([obj for (sol, obj) in archive])\n    pareto_front = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    dominance_rank = np.zeros(len(archive), dtype=int)\n    for i in range(len(archive)):\n        dominance_rank[i] = np.sum((objectives[:, 0] <= objectives[i, 0]) & (objectives[:, 1] <= objectives[i, 1]) &\n                                 ((objectives[:, 0] < objectives[i, 0]) | (objectives[:, 1] < objectives[i, 1])))\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        left = objectives[i-1] if i > 0 else objectives[i]\n        right = objectives[(i+1)%len(archive)] if i < len(archive)-1 else objectives[i]\n        crowding_distances[i] = np.sum(np.abs(objectives[i] - left) + np.abs(objectives[i] - right))\n\n    # Weighted selection based on crowding distance and dominance rank\n    weights = crowding_distances * (1.0 / (dominance_rank + 1))\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment inversion based on dominance and crowding\n    segment_size = max(2, min(n//2, int(np.random.normal(n//3, n//5) * (0.5 + 0.5 * (1 - dominance_rank[selected_idx]/len(archive))))))\n    start = np.random.randint(0, n - segment_size + 1)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Adaptive edge swaps guided by Pareto-front gaps\n    for _ in range(3):\n        # Identify edges in Pareto-front gaps\n        edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            edge_gap = np.sqrt(edge_cost1**2 + edge_cost2**2)\n            edges.append((edge_gap, i, j))\n\n        edges.sort(reverse=True, key=lambda x: x[0])\n        selected_edges = edges[:min(3, len(edges))]\n\n        for _, i, j in selected_edges:\n            if i == 0 or j == n-1:\n                continue\n\n            # Calculate potential improvement\n            dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if improvement or probabilistic acceptance based on dominance\n            if (dist1_after < dist1_before * 0.95 and dist2_after < dist2_before * 0.95) or np.random.random() < 0.3 * (1 - dominance_rank[selected_idx]/len(archive)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional segment reversal for further exploration\n    if np.random.random() < 0.5 * (1 - dominance_rank[selected_idx]/len(archive)):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9962433414949841,
            0.6551156640052795
        ],
        "raw_score": [
            6.684291026496953,
            7.010589363713041
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid of dominance-based (favoring lower-cost solutions) and diversity-aware (randomly choosing among top candidates) selection, then applies a novel local search combining adaptive segment reversal (where segment size depends on solution quality) and Pareto-optimal edge insertions (swapping edges based on potential improvements in both objectives). It prioritizes solutions with better combined quality and dynamically adjusts segment sizes and edge swaps to maintain feasibility while improving both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance and diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = np.random.choice(ranks[:min(5, len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment reversal with quality-based segment size\n    quality = 1 / (objectives[selected_idx][0] + objectives[selected_idx][1] + 1e-6)\n    segment_size = max(2, int(n * 0.3 * quality))\n    start = np.random.randint(0, n - segment_size + 1)\n    new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Pareto-optimal edge insertions with adaptive probabilities\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == 0 or b == n-1:\n            continue\n\n        # Calculate potential improvement in both objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] -\n                 distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] -\n                 distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                 distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        # Accept if both objectives improve or one improves significantly\n        if (delta1 < 0 and delta2 < 0) or (np.random.random() < 0.4 and (delta1 < 0 or delta2 < 0)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validate solution\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8532383066076394,
            0.24556082487106323
        ],
        "raw_score": [
            5.225206172175929,
            9.476601637536671
        ]
    }
]