[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the highest sum of normalized objectives) and applies a hybrid local search: either a random edge swap or node reinsertion to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with higher combined costs, while the local search explores neighborhoods through randomized edge swaps or node reinsertions. The approach balances exploration and exploitation by combining simple but effective perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_sum = -1\n    selected_solution = None\n    for sol, obj in archive:\n        normalized_obj = (obj[0] + obj[1]) / 2  # Simple normalization\n        if normalized_obj > max_sum:\n            max_sum = normalized_obj\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random edge swap or node reinsertion\n    n = len(new_solution)\n    if np.random.rand() < 0.5:  # Edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Node reinsertion\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9263534306788621,
            0.2028200626373291
        ],
        "raw_score": [
            10.527134484715972,
            10.564929956806642
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on a weighted combination of objective values and random diversity, then applies a hybrid local search combining 2.5-opt (a segment reversal) and node insertion to generate a neighbor, ensuring feasibility by validating no duplicates or missing nodes. The selection prioritizes lower objectives with added randomness, while the local search focuses on segment reversal and node repositioning for potential multi-objective improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    def selection_score(solution, objective):\n        # Prefer solutions with lower objectives but also consider diversity\n        return (objective[0] + objective[1]) * (1 + np.random.uniform(0.5, 1.5))\n\n    scored_solutions = [(solution, objective, selection_score(solution, objective))\n                       for solution, objective in archive]\n    scored_solutions.sort(key=lambda x: x[2])\n    selected_solution = scored_solutions[0][0].copy()\n\n    # Hybrid local search: 2.5-opt + node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt (generalized 2-opt)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion (move a random node to a new position)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure solution remains feasible (no duplicates and all nodes visited)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(selected_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9672586246322147,
            0.250504732131958
        ],
        "raw_score": [
            6.691336365610633,
            6.575647727482992
        ]
    },
    {
        "algorithm": "The algorithm selects a Pareto-dominated solution from the archive (prioritizing non-dominated or randomly choosing from dominated solutions) and applies a hybrid local search: it first attempts a segment reversal (2-opt-like) if it improves either objective, otherwise performs a random node reinsertion to maintain feasibility. The method ensures solution validity by checking node uniqueness and preserves the tour structure while exploring multi-objective improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a Pareto-dominated solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_index = random.choice(non_dominated_indices)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal if beneficial, else node reinsertion\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            k = random.randint(0, n-1)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            l = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, l, node)\n    else:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n    assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0259954099517012,
            0.38352054357528687
        ],
        "raw_score": [
            5.699175348104417,
            7.028717067597253
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution from the archive (based on the maximum objective value) and applies a hybrid local search combining random segment reversal and 2-opt moves to generate a neighbor solution. It prioritizes exploration of less-explored regions by focusing on the worst-performing solution and ensures feasibility by maintaining valid TSP tours. The approach balances diversity and local improvement while avoiding standard 2-opt-only strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: combine random 2-opt with a novel segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (novel segment reversal)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a random 2-opt move to ensure diversity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7627709071663467,
            0.20366013050079346
        ],
        "raw_score": [
            9.049800417335923,
            10.417538166894719
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted randomness favoring lower-cost solutions, then applies a hybrid local search combining 3-opt with a novel segment inversion strategy to generate a neighbor while ensuring feasibility. It prioritizes solutions with better combined objective values and explores local improvements through both standard and specialized operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring lower-cost solutions\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 - (normalized_costs[:, 0] + normalized_costs[:, 1]) / 2\n    weights = np.maximum(weights, 0.1)  # Ensure minimum probability\n    weights /= weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion\n    n = len(new_solution)\n    for _ in range(5):  # Number of attempts\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try 3-opt\n        candidates = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:][::-1]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:]])\n        ]\n\n        # Try segment inversion\n        segment_length = min(5, (k - j) // 2)\n        if segment_length > 1:\n            mid = j + (k - j) // 2\n            candidates.append(np.concatenate([\n                new_solution[:j], new_solution[j:mid][::-1], new_solution[mid:k], new_solution[k:]\n            ]))\n\n        # Evaluate candidates\n        best_candidate = new_solution.copy()\n        best_cost = np.inf\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate.copy()\n\n        if not np.array_equal(best_candidate, new_solution):\n            new_solution = best_candidate\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8952181140724547,
            0.3488140106201172
        ],
        "raw_score": [
            5.715211745334367,
            6.7316106930825
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing non-dominated solutions) and applies a hybrid local search combining edge exchange and node insertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. It intelligently balances exploration (random selection) and exploitation (local improvement) while considering both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        return np.random.permutation(len(instance))\n\n    # Calculate the Pareto dominance rank for each solution\n    dominated_counts = [0] * len(archive)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_counts[i] += 1\n\n    # Select non-dominated solutions (rank 0)\n    non_dominated_indices = [i for i, count in enumerate(dominated_counts) if count == 0]\n    if non_dominated_indices:\n        selected_index = random.choice(non_dominated_indices)\n    else:\n        # If no non-dominated solutions, select randomly\n        selected_index = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a full swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, perform a more sophisticated local search\n        # Step 1: Select two edges to exchange (similar to 2-opt but with additional checks)\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Step 2: Check if exchanging these edges improves both objectives\n        # Calculate the change in cost for both objectives\n        a, b, c, d = base_solution[i], base_solution[i+1], base_solution[j], base_solution[j+1] if j+1 < n else base_solution[0]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n        if delta1 < 0 or delta2 < 0:\n            # If the exchange improves at least one objective, perform it\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            # If not, try a node insertion move\n            k = random.randint(0, n - 1)\n            l = random.randint(0, n - 1)\n            if k != l:\n                # Remove node at position k and insert it after position l\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = (l + 1) % (n - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9793278915524335,
            0.41966134309768677
        ],
        "raw_score": [
            6.099593653768952,
            6.610992634938869
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using weighted randomness favoring lower-cost solutions, then applies a novel local search operator that probabilistically reverses segments and redistributes nodes, ensuring feasibility by validating the solution at each step. The method prioritizes exploration through segment reversal with decreasing probability for longer segments and adaptive node repositioning, while maintaining validity through strict checks. The selection strategy balances cost minimization with multi-objective awareness, while the local search introduces variability to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted randomness favoring lower-cost solutions\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 - (normalized_costs[:, 0] + normalized_costs[:, 1]) / 2\n    weights = np.maximum(weights, 0.1)  # Ensure minimum probability\n    weights /= weights.sum()  # Normalize to probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: Probabilistic segment reversal and node redistribution\n    n = len(new_solution)\n    for _ in range(3):  # Number of attempts\n        # Randomly select a segment to reverse with probability based on segment length\n        segment_length = np.random.randint(2, min(7, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Reverse the segment with a probability that decreases with segment length\n        if np.random.random() < (1 / (segment_length ** 0.5)):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Redistribute nodes with a probability based on their current position\n        for i in range(n):\n            if np.random.random() < 0.3:  # 30% chance to move a node\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_pos = np.random.randint(0, n - 1)\n                new_solution = np.insert(new_solution, new_pos, node)\n\n        # Ensure solution remains feasible\n        assert len(new_solution) == n\n        assert len(np.unique(new_solution)) == n\n        assert set(new_solution) == set(base_solution)\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7885160012856278,
            0.57530277967453
        ],
        "raw_score": [
            8.41986650824428,
            8.840970229145203
        ]
    },
    {
        "algorithm": "The algorithm selects a high-quality, diverse solution from the archive using Pareto dominance and crowding distance, then applies a hybrid local search combining 4-opt with a novel node relocation strategy that considers both objective spaces to generate a neighbor solution while ensuring feasibility. It prioritizes solutions on the Pareto front and evaluates candidate moves based on combined costs from both distance matrices, favoring improvements in either objective. The selection and local search are designed to balance exploration and exploitation, with multiple candidate moves evaluated per iteration to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance and crowding distance\n    fronts = []\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                if any(objectives[j] < objectives[i]):\n                    dominated[i] = True\n                    break\n\n    fronts.append(np.where(~dominated)[0])\n    remaining = np.where(dominated)[0]\n\n    while len(remaining) > 0:\n        new_front = []\n        for i in remaining:\n            is_dominated = False\n            for j in remaining:\n                if i != j and all(objectives[j] <= objectives[i]):\n                    if any(objectives[j] < objectives[i]):\n                        is_dominated = True\n                        break\n            if not is_dominated:\n                new_front.append(i)\n        fronts.append(np.array(new_front))\n        remaining = np.setdiff1d(remaining, new_front)\n\n    selected_idx = fronts[0][0] if len(fronts[0]) > 0 else fronts[1][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 4-opt with node relocation\n    n = len(new_solution)\n    for _ in range(10):  # More attempts\n        i, j, k, l = sorted(random.sample(range(n), 4))\n\n        # Try 4-opt\n        candidates = [\n            np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:l][::-1], new_solution[l:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j][::-1], new_solution[l:], new_solution[k:l][::-1]]),\n            np.concatenate([new_solution[:i], new_solution[k:l][::-1], new_solution[i:j], new_solution[j:k][::-1], new_solution[l:]])\n        ]\n\n        # Try node relocation considering both objectives\n        if k - j > 2:\n            relocate_pos = random.randint(0, n-1)\n            node = new_solution[j]\n            candidates.append(np.concatenate([\n                new_solution[:j], new_solution[j+1:relocate_pos], [node], new_solution[relocate_pos:]\n            ]))\n\n        # Evaluate candidates\n        best_candidate = new_solution.copy()\n        best_cost = np.inf\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate.copy()\n\n        if not np.array_equal(best_candidate, new_solution):\n            new_solution = best_candidate\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8738811687446012,
            0.6232319474220276
        ],
        "raw_score": [
            6.615562814710971,
            6.475572558444076
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive by prioritizing those with lower combined objectives and higher diversity, then applies a hybrid local search combining multi-segment inversion and directed node relocation to generate a neighbor solution while ensuring feasibility through validation. The method dynamically selects segment lengths, inverts segments, and optimizes node insertions based on both objectives, with multiple improvement attempts to refine the solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity and potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = np.std(normalized, axis=1)\n    scores = (normalized[:, 0] + normalized[:, 1]) * (1 - diversity)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-segment inversion with directed node relocation\n    n = len(new_solution)\n    max_attempts = 3\n    best_solution = new_solution.copy()\n    best_cost = np.inf\n\n    for _ in range(max_attempts):\n        # Select segments with dynamic length\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Invert the selected segment\n        candidate = new_solution.copy()\n        candidate[start:end] = candidate[start:end][::-1]\n\n        # Apply directed node relocation\n        for _ in range(2):\n            node_pos = np.random.randint(0, n)\n            node = candidate[node_pos]\n            candidate = np.delete(candidate, node_pos)\n            # Find best insertion position based on both objectives\n            best_pos = 0\n            best_score = np.inf\n            for pos in range(n-1):\n                temp = np.insert(candidate, pos, node)\n                cost1 = sum(distance_matrix_1[temp[i], temp[(i+1)%(n-1)]] for i in range(n-1))\n                cost2 = sum(distance_matrix_2[temp[i], temp[(i+1)%(n-1)]] for i in range(n-1))\n                if cost1 + cost2 < best_score:\n                    best_score = cost1 + cost2\n                    best_pos = pos\n            candidate = np.insert(candidate, best_pos, node)\n\n        # Evaluate candidate\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_solution = candidate.copy()\n\n    # Final validation\n    assert len(best_solution) == n\n    assert len(np.unique(best_solution)) == n\n    assert set(best_solution) == set(base_solution)\n\n    return best_solution\n\n",
        "metric_score": [
            -0.8730720906593619,
            3.7891539335250854
        ],
        "raw_score": [
            6.4016642248327615,
            5.4446887372689465
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto dominance and crowding distance to intelligently select a promising solution from the archive, then applies a hybrid local search that dynamically combines edge exchange, segment relinking, and segment inversion to generate high-quality neighbors while ensuring feasibility. The selection prioritizes non-dominated solutions with higher crowding distance, while the local search explores multiple candidate moves in each iteration to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine Pareto dominance and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate Pareto ranks\n    pareto_ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_ranks[i] = 1\n\n    # Calculate crowding distances for non-dominated solutions\n    crowding_distances = np.zeros(len(archive))\n    non_dominated = np.where(pareto_ranks == 1)[0]\n    if len(non_dominated) > 0:\n        sorted_indices = np.argsort(objectives[:, 0])\n        for i in range(len(objectives)):\n            if i in non_dominated:\n                if i == sorted_indices[0] or i == sorted_indices[-1]:\n                    crowding_distances[i] = np.inf\n                else:\n                    left = sorted_indices[np.where(sorted_indices == i)[0][0] - 1]\n                    right = sorted_indices[np.where(sorted_indices == i)[0][0] + 1]\n                    crowding_distances[i] = (objectives[right, 0] - objectives[left, 0]) / (objectives.max(axis=0)[0] - objectives.min(axis=0)[0] + 1e-10)\n\n    # Combine selection criteria\n    selection_scores = pareto_ranks * 100 + crowding_distances\n    selected_idx = np.argmax(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: dynamic segment relinking with edge exchange\n    n = len(new_solution)\n    for _ in range(5):\n        # Select random segments\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Create candidate solutions\n        candidates = [\n            # Edge exchange\n            np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:d], new_solution[d:]]),\n            # Segment relinking\n            np.concatenate([new_solution[:a], new_solution[c:d], new_solution[a:b], new_solution[b:c], new_solution[d:]]),\n            # Dynamic segment inversion\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c], new_solution[c:d][::-1], new_solution[d:]])\n        ]\n\n        # Evaluate candidates\n        best_candidate = new_solution.copy()\n        best_cost = np.inf\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate.copy()\n\n        if not np.array_equal(best_candidate, new_solution):\n            new_solution = best_candidate\n            break\n\n    return new_solution\n\n",
        "metric_score": [
            -0.75641553732051,
            0.9617184400558472
        ],
        "raw_score": [
            5.702496543759807,
            8.861167504831911
        ]
    }
]