[
    {
        "algorithm": "The algorithm selects promising solutions from the archive by identifying Pareto-efficient ones (or top 20% if none exist) and prioritizes them using a dynamic weighting (70% first objective, 30% second). It then applies a hybrid local search: 40% chance for a simple edge swap (random node swap) and 60% chance for an adaptive segment rotation (reversing or rotating a random segment), ensuring feasibility by validating uniqueness of nodes. The selected neighbor is returned after feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        top_k = max(1, len(pareto_front) // 5)\n        selected = sorted(pareto_front, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[:top_k]\n        selected = random.choice(selected)[0]\n    else:\n        selected = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.choice([1, -1])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0267881311696685,
            0.2615596652030945
        ],
        "raw_score": [
            5.343794159135672,
            7.476030051227338
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a weighted cross-space segment exchange, dynamically adjusting priorities between objectives (70%/30% based on average costs) and incorporating a 10% perturbation step for dominated solutions to escape local optima, while ensuring feasibility through validation and fallback to random swaps. The core innovation lies in the hybrid operator that alternates between segment exchanges and rotations, with a bias toward the under-represented objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = sorted(pareto_front, key=lambda x: x[1][0] + x[1][1])[:max(1, len(pareto_front) // 5)]\n    else:\n        selected = archive\n\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))\n\n    if random.random() < weight:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.891564320421259,
            0.11739110946655273
        ],
        "raw_score": [
            6.546114027058896,
            6.307434590454022
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those with better combined objective scores (60% weight on the first objective, 40% on the second), then applies a hybrid local search: 50% chance for segment inversion and 50% for an adaptive 2-opt-like swap, ensuring feasibility by validating node uniqueness. The method intelligently balances exploration and exploitation by dynamically choosing between segment-based and segment-swapping perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% solutions by combined objective score (60% first objective, 40% second)\n    sorted_archive = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])\n    top_k = max(1, len(archive) // 5)\n    candidates = [sol for sol, _ in sorted_archive[:top_k]]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 50% chance for segment inversion, 50% for adaptive 2-opt-like swap\n    if random.random() < 0.5:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Adaptive 2-opt-like swap\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Swap segments if they are not adjacent\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:]\n            new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[j:]])\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9679947436697147,
            0.12846428155899048
        ],
        "raw_score": [
            5.357749067820155,
            6.703099749157834
        ]
    },
    {
        "algorithm": "This algorithm combines Pareto-dominance-based selection with a novel multi-objective local search that dynamically adapts segment lengths, prioritizes critical edges in each objective space, and uses probabilistic edge swapping with periodic perturbations to escape local optima while maintaining feasibility. It first selects promising solutions from the archive, then applies segment refinements and edge swaps focused on high-cost edges in either objective, with controlled perturbations to introduce diversity. The algorithm ensures feasibility by validating uniqueness of nodes in the final solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance selection\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = sorted(pareto_front, key=lambda x: x[1][0] + x[1][1])[0][0]\n    else:\n        selected = sorted(archive, key=lambda x: x[1][0] + x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment refinement\n    def calculate_segment_cost(solution, start, end, matrix):\n        cost = 0\n        for i in range(start, end):\n            cost += matrix[solution[i-1], solution[i]]\n        cost += matrix[solution[end-1], solution[start]]\n        return cost\n\n    # Dynamic segment length determination\n    segment_length = max(2, min(5, n // 5))\n\n    # Probabilistic edge swapping\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, segment_length)) % n\n\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if swapped_cost < original_cost or (random.random() < 0.3 and abs(swapped_cost - original_cost) < 0.1 * original_cost):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Cross-space segment relocation\n    obj1_costs = []\n    obj2_costs = []\n    for i in range(n):\n        obj1_costs.append(distance_matrix_1[new_solution[i-1], new_solution[i]])\n        obj2_costs.append(distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n    obj1_critical = np.argsort(obj1_costs)[-1:]\n    obj2_critical = np.argsort(obj2_costs)[-1:]\n\n    for i in obj1_critical:\n        j = random.randint(0, n-1)\n        if i != j:\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n    for i in obj2_critical:\n        j = random.randint(0, n-1)\n        if i != j:\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n    # Controlled perturbation\n    if random.random() < 0.15:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8579803840065194,
            0.0881417989730835
        ],
        "raw_score": [
            7.361620871338529,
            7.409254525510471
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a hybrid local search that prioritizes high-cost edges in either objective space, dynamically adapts segment lengths, and uses probabilistic edge swaps with occasional perturbations to escape local optima while maintaining feasibility. It first selects promising solutions from the archive, then applies segment refinements and edge swaps focused on critical edges in both objectives, with controlled perturbations to introduce diversity. The algorithm ensures feasibility by validating node uniqueness in the final solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = sorted(pareto_front, key=lambda x: x[1][0] + x[1][1])[0][0]\n    else:\n        selected = sorted(archive, key=lambda x: x[1][0] + x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_segment_cost(solution, start, end, matrix):\n        cost = 0\n        for i in range(start, end):\n            cost += matrix[solution[i-1], solution[i]]\n        cost += matrix[solution[end-1], solution[start]]\n        return cost\n\n    segment_length = max(2, min(5, n // 5))\n\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, segment_length)) % n\n\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if swapped_cost < original_cost or (random.random() < 0.3 and abs(swapped_cost - original_cost) < 0.1 * original_cost):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    obj1_costs = []\n    obj2_costs = []\n    for i in range(n):\n        obj1_costs.append(distance_matrix_1[new_solution[i-1], new_solution[i]])\n        obj2_costs.append(distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n    obj1_critical = np.argsort(obj1_costs)[-1:]\n    obj2_critical = np.argsort(obj2_costs)[-1:]\n\n    for i in obj1_critical:\n        j = random.randint(0, n-1)\n        if i != j:\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n    for i in obj2_critical:\n        j = random.randint(0, n-1)\n        if i != j:\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n    if random.random() < 0.15:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.6059536824024758,
            0.08997482061386108
        ],
        "raw_score": [
            7.062117986041536,
            7.077298256224723
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a novel \"cross-space segment relocation\" operator that dynamically adapts segment lengths based on objective trade-offs, prioritizing high-potential regions while ensuring feasibility through a two-phase validation process. It selects solutions intelligently (favoring Pareto fronts but exploring dominated solutions probabilistically) and applies a weighted objective scoring to balance improvement across both spaces, with a fallback to simple swaps if feasibility is compromised. The critical design ideas are the dynamic segment relocation, weighted objective prioritization, and the hybrid selection strategy that balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection with dynamic exploration\n    objectives = np.array([obj for _, obj in archive])\n    is_pareto_efficient = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                is_pareto_efficient[i] = False\n    pareto_indices = np.where(is_pareto_efficient)[0]\n\n    if len(pareto_indices) > 0:\n        candidates = pareto_indices\n    else:\n        # Explore dominated solutions with probability based on archive size\n        exploration_prob = min(0.3, 1.0 / (len(archive) + 1))\n        if np.random.rand() < exploration_prob:\n            candidates = np.random.choice(len(archive), size=max(1, len(archive) // 5), replace=False)\n        else:\n            candidates = np.array([np.argmin(objectives[:, 0] + objectives[:, 1])])\n\n    # Dynamic weighted selection\n    weight = 0.5 + 0.5 * np.random.rand()  # Random weight between 0.5 and 1.0\n    scores = weight * objectives[:, 0] + (1 - weight) * objectives[:, 1]\n    selected_idx = candidates[np.argmin(scores[candidates])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cross-space segment relocation\n    segment_length = min(n // 3, max(2, int(np.random.normal(n // 4, n // 6))))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    # Try different insertion points\n    best_improvement = 0\n    best_insert_pos = -1\n    original_cost1, original_cost2 = calculate_improvement(new_solution)\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos + segment_length:]\n        ])\n        # Calculate improvement\n        new_cost1, new_cost2 = calculate_improvement(candidate)\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos + segment_length:]\n        ])\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0246042744516743,
            5.167974233627319
        ],
        "raw_score": [
            10.47992649312583,
            10.62714912616767
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid approach combining Pareto dominance and dynamic objective weighting, then applies a multi-stage local search involving adaptive segment reversal, non-sequential node insertion, and objective-aware edge swaps to generate high-quality neighbors while ensuring feasibility. The selection prioritizes Pareto-dominant solutions but falls back to weighted scoring if none exist, with weights dynamically adjusted based on archive diversity. The local search stages progressively refine the solution by manipulating segments and edges, with the edge swap stage specifically considering both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: Pareto-dominant solutions first, then dynamic weighted scoring\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Dynamic weighting based on current archive diversity\n        obj1_avg = np.mean([obj[0] for _, obj in archive])\n        obj2_avg = np.mean([obj[1] for _, obj in archive])\n        weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))  # Bias toward first objective if more diverse\n\n        selected = sorted(pareto_front, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n    else:\n        # Fallback to best weighted solution\n        weight = 0.6\n        selected = sorted(archive, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-stage local search\n    # Stage 1: Adaptive segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    if random.random() < 0.7:  # Higher chance for reversal\n        new_solution[a:b+1] = segment[::-1]\n\n    # Stage 2: Non-sequential node insertion\n    if n >= 5:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i-j) <= 1:\n            i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Stage 3: Objective-aware edge swap\n    if n >= 4:\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.998267486701493,
            0.3527350425720215
        ],
        "raw_score": [
            10.47269543601011,
            10.578669860567175
        ]
    },
    {
        "algorithm": "The algorithm combines hypervolume-based selection with a novel local search that prioritizes expensive edges in each objective space, performing cross-space segment relocations and intra-space edge refinements, while occasionally introducing controlled perturbations to escape local optima. It dynamically balances improvements across objectives by focusing on the most critical segments and ensuring feasibility through cycle checks and objective recalculations. The top 3 most expensive edges in each space are prioritized for relocation, with higher probabilities applied to these segments, while intra-space swaps and occasional reversals maintain diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based Pareto selection\n    def hypervolume(obj, ref_point):\n        return (ref_point[0] - obj[0]) * (ref_point[1] - obj[1])\n\n    ref_point = (max(obj[0] for _, obj in archive), max(obj[1] for _, obj in archive))\n    sorted_archive = sorted(archive, key=lambda x: hypervolume(x[1], ref_point), reverse=True)\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = random.choice(sorted_archive[:top_k])\n    base_solution, _ = selected\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Objective-space alignment local search\n    def calculate_edge_costs(solution, matrix):\n        costs = []\n        for i in range(n):\n            costs.append(matrix[solution[i-1], solution[i]])\n        return costs\n\n    obj1_costs = calculate_edge_costs(new_solution, distance_matrix_1)\n    obj2_costs = calculate_edge_costs(new_solution, distance_matrix_2)\n\n    # Identify critical segments\n    obj1_critical = np.argsort(obj1_costs)[-3:]  # Top 3 most expensive edges in obj1\n    obj2_critical = np.argsort(obj2_costs)[-3:]  # Top 3 most expensive edges in obj2\n\n    # Cross-space segment relocation\n    for i in obj1_critical:\n        if random.random() < 0.6:\n            j = random.randint(0, n-1)\n            if i != j:\n                segment = new_solution[i:i+2]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+2:j], segment, new_solution[j:]])\n\n    for i in obj2_critical:\n        if random.random() < 0.6:\n            j = random.randint(0, n-1)\n            if i != j:\n                segment = new_solution[i:i+2]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+2:j], segment, new_solution[j:]])\n\n    # Intra-space edge refinements\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Controlled perturbation\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8411372831399854,
            0.10010075569152832
        ],
        "raw_score": [
            7.586684763689524,
            7.404395999283823
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = sorted(pareto_front, key=lambda x: x[1][0] + x[1][1])[0][0]\n    else:\n        selected = sorted(archive, key=lambda x: x[1][0] + x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))\n\n    if random.random() < weight:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.choice([1, -1])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.94433168440945,
            0.2818765640258789
        ],
        "raw_score": [
            6.378110276168021,
            6.297373645293303
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those with lower weighted combined scores (70% weight on the first objective, 30% on the second), then applies a hybrid local search combining segment rotation and non-adjacent node swaps to generate feasible neighbor solutions while ensuring validity. The weighted scoring balances both objectives, and the local search operators introduce diversity through segment rotation and targeted node swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best weighted combined score (lower is better)\n    def weighted_score(solution, objectives):\n        return 0.7 * objectives[0] + 0.3 * objectives[1]\n\n    # Sort archive by weighted score and select the best 15% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 7)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Segment rotation (rotate a random segment by a random amount)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Step 2: Node swap (swap two nodes that are not adjacent)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i - j) == 1:  # Ensure nodes are not adjacent\n            i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9024818063105666,
            0.17928367853164673
        ],
        "raw_score": [
            6.0682416639386965,
            8.263773747526876
        ]
    }
]