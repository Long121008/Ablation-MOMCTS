[
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing those with lower combined objective scores) and applies a hybrid local search combining edge insertion and segment reversal to generate neighbor solutions, ensuring feasibility by maintaining valid TSP tours. The selection process focuses on high-quality solutions, while the local search operator introduces diverse modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Remove edge between i and j\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert segment at a random new position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7847710985497653,
            0.17851996421813965
        ],
        "raw_score": [
            6.337478923049993,
            6.463198668542717
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive (prioritizing non-dominated or diverse solutions) and applies a hybrid local search combining edge exchange and segment reordering to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes and falling back to simpler swaps if needed. The selection is random but could be enhanced to prioritize solutions with lower costs or higher diversity, while the local search focuses on both edge-level and segment-level modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange followed by segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reordering (reverse a random segment)\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9622793977855487,
            0.20448201894760132
        ],
        "raw_score": [
            7.30701335952615,
            7.020446555862451
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those with lower weighted combined scores (70% weight on the first objective, 30% on the second), then applies a hybrid local search combining segment rotation and non-adjacent node swaps to generate feasible neighbor solutions while ensuring validity. The weighted scoring balances both objectives, and the local search operators introduce diversity through segment rotation and targeted node swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best weighted combined score (lower is better)\n    def weighted_score(solution, objectives):\n        return 0.7 * objectives[0] + 0.3 * objectives[1]\n\n    # Sort archive by weighted score and select the best 15% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 7)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Segment rotation (rotate a random segment by a random amount)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Step 2: Node swap (swap two nodes that are not adjacent)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i - j) == 1:  # Ensure nodes are not adjacent\n            i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9024818063105666,
            0.17928367853164673
        ],
        "raw_score": [
            6.0682416639386965,
            8.263773747526876
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution from the archive (based on the sum of both objectives) and applies a hybrid local search operator: reversing a random segment of the tour and performing a random node swap, while ensuring the solution remains valid by checking for duplicates. The method prioritizes diversification by randomly modifying the tour structure, with fallback to the original solution if invalidity occurs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and node swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    segment = new_solution[start:end]\n\n    # Reverse the segment to create a new tour\n    new_segment = segment[::-1]\n    new_solution[start:end] = new_segment\n\n    # Perform a random swap between two nodes\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9581710917107531,
            0.20549225807189941
        ],
        "raw_score": [
            10.422623819898265,
            10.398352035590081
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by combining their objective scores, then applies a hybrid local search combining objective-biased edge swaps, edge insertions, and segment reversals to generate feasible neighbor solutions while prioritizing edges with higher costs in the less favorable objective. The method ensures validity by maintaining valid TSP tours through careful segment manipulation and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Objective-biased edge swap (swap edges based on which objective they belong to)\n    def get_edge_objective(i, j, matrix):\n        return matrix[i, j]\n\n    # Choose a random edge to swap\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n\n    # Decide which objective to prioritize for the swap\n    obj1_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_1)\n    obj2_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_2)\n\n    if obj1_cost > obj2_cost:\n        # Swap edges based on objective 1\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n    else:\n        # Swap edges based on objective 2\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 2: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 3: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8789912793056229,
            0.17964571714401245
        ],
        "raw_score": [
            6.999801024342688,
            6.553088726449999
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing those with lowest combined objectives) and applies a hybrid local search by reversing a random segment and swapping two non-consecutive edges, ensuring feasibility while exploring diverse neighborhoods. It balances exploitation (focusing on high-quality solutions) with exploration (perturbing the tour structure) to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n - 1)\n\n    # Reverse the segment (similar to 2-opt but more disruptive)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Additional perturbation: swap two random non-consecutive edges\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 2, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8639804524653872,
            0.1826513409614563
        ],
        "raw_score": [
            6.89278661553577,
            6.192611657749408
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest variance between its two objectives (indicating potential for improvement) and applies a hybrid local search combining edge insertion (removing and reinserting a segment of nodes) and segment reversal (flipping a random segment of nodes). The method ensures feasibility by maintaining a valid TSP tour structure, and the randomness in segment selection promotes exploration of the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (promising for improvement)\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Edge insertion - remove a random edge and reinsert it\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 2: Segment reversal - reverse a random segment\n    k = np.random.randint(2, n-1)\n    l = np.random.randint(0, n-k)\n    new_solution[l:l+k] = new_solution[l:l+k][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.5630424389731795,
            0.1928430199623108
        ],
        "raw_score": [
            7.230773789000227,
            7.233761085866266
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive using a weighted combination of objectives (60% first objective, 40% second) and applies a hybrid local search combining multi-segment reversal and edge rotation. It first reverses non-overlapping segments of the tour and then rotates edges between segments to explore diverse neighborhoods while maintaining feasibility. The approach prioritizes exploitation of good solutions through weighted selection and exploration through disruptive perturbations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted objective score\n    def weighted_score(solution, objectives):\n        # Weighted combination of objectives (can be adjusted)\n        return 0.6 * objectives[0] + 0.4 * objectives[1]\n\n    archive_sorted = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # Too small for meaningful changes\n\n    # Hybrid local search: multi-segment reversal and edge rotation\n    # Step 1: Select multiple non-overlapping segments to reverse\n    num_segments = min(3, n // 4)\n    segments = []\n    for _ in range(num_segments):\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 1, min(start + 5, n - 1))\n        segments.append((start, end))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    for seg in segments:\n        if not merged_segments:\n            merged_segments.append(seg)\n        else:\n            last_start, last_end = merged_segments[-1]\n            if seg[0] <= last_end:\n                # Merge overlapping segments\n                new_start = last_start\n                new_end = max(last_end, seg[1])\n                merged_segments[-1] = (new_start, new_end)\n            else:\n                merged_segments.append(seg)\n\n    # Reverse each segment\n    for start, end in merged_segments:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Rotate edges between segments\n    if len(merged_segments) > 1:\n        # Select two random segments\n        seg1, seg2 = random.sample(merged_segments, 2)\n\n        # Select random edges from each segment\n        edge1_start = np.random.randint(seg1[0], seg1[1])\n        edge1_end = edge1_start + 1 if edge1_start < seg1[1] else seg1[0]\n\n        edge2_start = np.random.randint(seg2[0], seg2[1])\n        edge2_end = edge2_start + 1 if edge2_start < seg2[1] else seg2[0]\n\n        # Rotate the edges (swap their positions)\n        temp = new_solution[edge1_start:edge1_end+1].copy()\n        new_solution[edge1_start:edge1_end+1] = new_solution[edge2_start:edge2_end+1]\n        new_solution[edge2_start:edge2_end+1] = temp\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8597885201267437,
            0.2027444839477539
        ],
        "raw_score": [
            6.225715493858557,
            7.019182439935018
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid criterion that balances objective quality and diversity, then applies a novel local search combining segment reversal, edge exchange, and adaptive perturbation to generate high-quality neighbors while ensuring feasibility. It prioritizes solutions with lower combined objectives but also considers diversity, and uses adaptive segment sizes and random perturbations to explore the search space effectively. The local search operations are carefully designed to maintain feasibility, with fallback mechanisms in case of duplicates.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize solutions with lower combined objectives but also consider diversity\n    def selection_score(solution, objectives):\n        # Combine objective values with a small diversity term (crowding distance approximation)\n        combined = sum(objectives)\n        diversity = np.std(objectives)  # Simple diversity measure\n        return combined - 0.1 * diversity  # Balance between quality and diversity\n\n    # Sort archive by selection score and select top 20% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: selection_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel local search: combination of segment reversal, edge exchange, and adaptive perturbation\n    # Step 1: Segment reversal (more disruptive than 2-opt)\n    seg_size = max(2, min(5, n // 4))  # Adaptive segment size\n    seg_start = random.randint(0, n - seg_size)\n    seg_end = seg_start + seg_size - 1\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Step 2: Edge exchange (non-consecutive)\n    if n > 4:\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 2, n - 1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Adaptive perturbation (randomly choose between swap or insert)\n    if random.random() < 0.3:  # 30% chance of additional perturbation\n        if random.random() < 0.5:\n            # Swap two random edges\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Insert a random segment\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if perturbation caused duplicates\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8289672217302538,
            0.35875505208969116
        ],
        "raw_score": [
            7.14970850642141,
            6.920476327523054
        ]
    },
    {
        "algorithm": "The algorithm combines multi-objective diversity-aware selection (prioritizing isolated solutions in objective space) with a two-phase local search: first, it probabilistically relocates segments to maximize combined distance reduction in both objective spaces, then conditionally inverts edges if it improves at least one objective, ensuring feasibility through validation. The selection is biased toward solutions with high objective-space isolation, and the search balances exploration (segment relocation) and exploitation (conditional inversion).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-objective diversity-aware selection\n    def objective_distance(obj1, obj2):\n        return np.sqrt((obj1[0] - obj2[0])**2 + (obj1[1] - obj2[1])**2)\n\n    # Find the most isolated solution in objective space\n    selected_idx = 0\n    max_min_dist = -1\n    for i in range(len(archive)):\n        min_dist = float('inf')\n        for j in range(len(archive)):\n            if i != j:\n                dist = objective_distance(archive[i][1], archive[j][1])\n                if dist < min_dist:\n                    min_dist = dist\n        if min_dist > max_min_dist:\n            max_min_dist = min_dist\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Phase 1: Probabilistic segment relocation based on objective-space distance\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate segment distance in both objective spaces\n    segment = new_solution[i:j+1]\n    total_dist1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n    total_dist2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n    # Find best insertion point based on combined distance reduction\n    best_pos = -1\n    best_reduction = -float('inf')\n    for pos in range(n - len(segment) + 1):\n        if pos >= i and pos <= j:\n            continue\n\n        # Calculate insertion cost\n        if pos == 0:\n            prev_node = new_solution[-1]\n        else:\n            prev_node = new_solution[pos-1]\n\n        next_node = new_solution[pos]\n\n        # Original connections\n        orig_dist1 = distance_matrix_1[prev_node, next_node]\n        orig_dist2 = distance_matrix_2[prev_node, next_node]\n\n        # New connections\n        new_dist1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        new_dist2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Combined reduction\n        reduction = (orig_dist1 + orig_dist2) - (new_dist1 + new_dist2)\n\n        if reduction > best_reduction:\n            best_reduction = reduction\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Phase 2: Conditional edge inversion based on objective-space constraints\n    if np.random.random() < 0.7:  # 70% chance of inversion\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Calculate segment's contribution to both objectives\n        segment = new_solution[a:b+1]\n        segment_dist1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_dist2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Calculate alternative segment (reversed) contribution\n        reversed_segment = segment[::-1]\n        reversed_dist1 = sum(distance_matrix_1[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n        reversed_dist2 = sum(distance_matrix_2[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n\n        # Accept inversion if it improves at least one objective\n        if (reversed_dist1 < segment_dist1 or reversed_dist2 < segment_dist2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        return base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7390643830879647,
            9.256297767162323
        ],
        "raw_score": [
            8.301632272887254,
            8.656346533017034
        ]
    }
]