[
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive (prioritizing non-dominated or diverse solutions) and applies a hybrid local search combining edge exchange and segment reordering to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes and falling back to simpler swaps if needed. The selection is random but could be enhanced to prioritize solutions with lower costs or higher diversity, while the local search focuses on both edge-level and segment-level modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange followed by segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reordering (reverse a random segment)\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9622793977855487,
            0.20448201894760132
        ],
        "raw_score": [
            7.30701335952615,
            7.020446555862451
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those with lower weighted combined scores (70% weight on the first objective, 30% on the second), then applies a hybrid local search combining segment rotation and non-adjacent node swaps to generate feasible neighbor solutions while ensuring validity. The weighted scoring balances both objectives, and the local search operators introduce diversity through segment rotation and targeted node swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best weighted combined score (lower is better)\n    def weighted_score(solution, objectives):\n        return 0.7 * objectives[0] + 0.3 * objectives[1]\n\n    # Sort archive by weighted score and select the best 15% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 7)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Segment rotation (rotate a random segment by a random amount)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Step 2: Node swap (swap two nodes that are not adjacent)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i - j) == 1:  # Ensure nodes are not adjacent\n            i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9024818063105666,
            0.17928367853164673
        ],
        "raw_score": [
            6.0682416639386965,
            8.263773747526876
        ]
    },
    {
        "algorithm": "The algorithm selects top 20% Pareto-efficient solutions from the archive (using hypervolume) and applies a hybrid local search with dynamic operator weighting (alternating between edge swaps and segment rotations) to generate neighbors, ensuring feasibility by validating tours and recalculating objectives. It also includes a 10% chance to reintroduce dominated solutions for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% Pareto-efficient solutions\n    def hypervolume(obj):\n        return obj[0] + obj[1]\n\n    sorted_archive = sorted(archive, key=lambda x: hypervolume(x[1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = sorted_archive[:top_k]\n\n    # 10% chance to reintroduce dominated solutions\n    if random.random() < 0.1 and len(archive) > top_k:\n        selected = archive[top_k:]\n\n    base_solution, base_obj = random.choice(selected)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator weighting (alternates between 70/30 and 30/70 every 10 iterations)\n    iteration = random.randint(0, 19)\n    if iteration < 10:\n        operator_weight = 0.7\n    else:\n        operator_weight = 0.3\n\n    # Edge swaps (dynamic weight)\n    if random.random() < operator_weight:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotations (remaining weight)\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.choice([1, -1])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n    # Cross-space validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9147664508158446,
            0.1948050856590271
        ],
        "raw_score": [
            6.161033810958136,
            6.307287034984366
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by identifying Pareto-efficient ones (or top 20% if none exist) and prioritizes them using a dynamic weighting (70% first objective, 30% second). It then applies a hybrid local search: 40% chance for a simple edge swap (random node swap) and 60% chance for an adaptive segment rotation (reversing or rotating a random segment), ensuring feasibility by validating uniqueness of nodes. The selected neighbor is returned after feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        top_k = max(1, len(pareto_front) // 5)\n        selected = sorted(pareto_front, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[:top_k]\n        selected = random.choice(selected)[0]\n    else:\n        selected = sorted(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.choice([1, -1])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0267881311696685,
            0.2615596652030945
        ],
        "raw_score": [
            5.343794159135672,
            7.476030051227338
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive Pareto-front selection with a hybrid local search that uses multi-segment inversion and probabilistic segment manipulation to generate high-quality neighbor solutions. It prioritizes non-dominated solutions (Pareto front) and applies either segment-based operations (reversal or rolling) or simple swaps, while ensuring feasibility through validation. The selection is biased toward better-performing solutions in the archive, with a 70% chance of using segment operations and a 30% chance of swapping nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = sorted(pareto_front, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])\n        selected = random.choice(selected[:max(1, len(selected) // 3)])[0]\n    else:\n        selected = sorted(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        if len(segment) > 1:\n            if random.random() < 0.5:\n                segment = segment[::-1]\n            else:\n                segment = np.roll(segment, random.randint(1, len(segment)-1))\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7334359966813101,
            0.10729479789733887
        ],
        "raw_score": [
            6.981823502567872,
            6.9011503670602945
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a weighted cross-space segment exchange, dynamically adjusting priorities between objectives (70%/30% based on average costs) and incorporating a 10% perturbation step for dominated solutions to escape local optima, while ensuring feasibility through validation and fallback to random swaps. The core innovation lies in the hybrid operator that alternates between segment exchanges and rotations, with a bias toward the under-represented objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = sorted(pareto_front, key=lambda x: x[1][0] + x[1][1])[:max(1, len(pareto_front) // 5)]\n    else:\n        selected = archive\n\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))\n\n    if random.random() < weight:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.891564320421259,
            0.11739110946655273
        ],
        "raw_score": [
            6.546114027058896,
            6.307434590454022
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a novel \"cross-space segment relocation\" operator that dynamically adapts segment lengths based on objective trade-offs, prioritizing high-potential regions while ensuring feasibility through a two-phase validation process. It selects solutions intelligently (favoring Pareto fronts but exploring dominated solutions probabilistically) and applies a weighted objective scoring to balance improvement across both spaces, with a fallback to simple swaps if feasibility is compromised. The critical design ideas are the dynamic segment relocation, weighted objective prioritization, and the hybrid selection strategy that balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection with dynamic exploration\n    objectives = np.array([obj for _, obj in archive])\n    is_pareto_efficient = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                is_pareto_efficient[i] = False\n    pareto_indices = np.where(is_pareto_efficient)[0]\n\n    if len(pareto_indices) > 0:\n        candidates = pareto_indices\n    else:\n        # Explore dominated solutions with probability based on archive size\n        exploration_prob = min(0.3, 1.0 / (len(archive) + 1))\n        if np.random.rand() < exploration_prob:\n            candidates = np.random.choice(len(archive), size=max(1, len(archive) // 5), replace=False)\n        else:\n            candidates = np.array([np.argmin(objectives[:, 0] + objectives[:, 1])])\n\n    # Dynamic weighted selection\n    weight = 0.5 + 0.5 * np.random.rand()  # Random weight between 0.5 and 1.0\n    scores = weight * objectives[:, 0] + (1 - weight) * objectives[:, 1]\n    selected_idx = candidates[np.argmin(scores[candidates])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cross-space segment relocation\n    segment_length = min(n // 3, max(2, int(np.random.normal(n // 4, n // 6))))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    # Try different insertion points\n    best_improvement = 0\n    best_insert_pos = -1\n    original_cost1, original_cost2 = calculate_improvement(new_solution)\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos + segment_length:]\n        ])\n        # Calculate improvement\n        new_cost1, new_cost2 = calculate_improvement(candidate)\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos + segment_length:]\n        ])\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0246042744516743,
            5.167974233627319
        ],
        "raw_score": [
            10.47992649312583,
            10.62714912616767
        ]
    },
    {
        "algorithm": "The algorithm selects the top 30% Pareto-efficient solutions from the archive, prioritizing those with better objective values (60% weight on the first objective, 40% on the second), and applies a hybrid local search combining random swaps (40%) and segment insertions (60%) to generate neighbors while ensuring feasibility through validation. The solution is chosen from the Pareto front if available, otherwise from the best-ranked solutions in the archive.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = sorted(pareto_front, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[:max(1, len(pareto_front) // 3)]\n        selected = random.choice(selected)[0]\n    else:\n        selected = sorted(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8337163858090624,
            0.1321239471435547
        ],
        "raw_score": [
            6.38186903016024,
            7.063255711444176
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid approach combining Pareto dominance and dynamic objective weighting, then applies a multi-stage local search involving adaptive segment reversal, non-sequential node insertion, and objective-aware edge swaps to generate high-quality neighbors while ensuring feasibility. The selection prioritizes Pareto-dominant solutions but falls back to weighted scoring if none exist, with weights dynamically adjusted based on archive diversity. The local search stages progressively refine the solution by manipulating segments and edges, with the edge swap stage specifically considering both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: Pareto-dominant solutions first, then dynamic weighted scoring\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Dynamic weighting based on current archive diversity\n        obj1_avg = np.mean([obj[0] for _, obj in archive])\n        obj2_avg = np.mean([obj[1] for _, obj in archive])\n        weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))  # Bias toward first objective if more diverse\n\n        selected = sorted(pareto_front, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n    else:\n        # Fallback to best weighted solution\n        weight = 0.6\n        selected = sorted(archive, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-stage local search\n    # Stage 1: Adaptive segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    if random.random() < 0.7:  # Higher chance for reversal\n        new_solution[a:b+1] = segment[::-1]\n\n    # Stage 2: Non-sequential node insertion\n    if n >= 5:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i-j) <= 1:\n            i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Stage 3: Objective-aware edge swap\n    if n >= 4:\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.998267486701493,
            0.3527350425720215
        ],
        "raw_score": [
            10.47269543601011,
            10.578669860567175
        ]
    },
    {
        "algorithm": "The algorithm selects top 20% Pareto-efficient solutions from the archive, prioritizing those with lower combined objective values, and applies a hybrid local search combining cross-space edge swaps (70%) and segment rotations (30%), weighted dynamically based on objective importance, while ensuring feasibility through node uniqueness checks and fallback mechanisms.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    top_k = max(1, len(pareto_front) // 5)\n    selected = sorted(pareto_front, key=lambda x: x[1][0] + x[1][1])[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))\n\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        if weight > 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            k = random.randint(0, n-1)\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotated = np.concatenate([segment[1:], [segment[0]]])\n        new_solution[a:b+1] = rotated\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9747010159701277,
            0.2892667055130005
        ],
        "raw_score": [
            6.269950702856275,
            6.379830913140596
        ]
    }
]