[
    {
        "algorithm": "The algorithm selects promising solutions from the archive (prioritizing those with lower combined objective scores) and applies a hybrid local search combining edge insertion and segment reversal to generate neighbor solutions, ensuring feasibility by maintaining valid TSP tours. The selection process focuses on high-quality solutions, while the local search operator introduces diverse modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Remove edge between i and j\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert segment at a random new position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 2: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.7847710985497653,
            0.17851996421813965
        ],
        "raw_score": [
            6.337478923049993,
            6.463198668542717
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive (prioritizing non-dominated or diverse solutions) and applies a hybrid local search combining edge exchange and segment reordering to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes and falling back to simpler swaps if needed. The selection is random but could be enhanced to prioritize solutions with lower costs or higher diversity, while the local search focuses on both edge-level and segment-level modifications to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange followed by segment reordering\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reordering (reverse a random segment)\n    start, end = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9622793977855487,
            0.20448201894760132
        ],
        "raw_score": [
            7.30701335952615,
            7.020446555862451
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those with lower weighted combined scores (70% weight on the first objective, 30% on the second), then applies a hybrid local search combining segment rotation and non-adjacent node swaps to generate feasible neighbor solutions while ensuring validity. The weighted scoring balances both objectives, and the local search operators introduce diversity through segment rotation and targeted node swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best weighted combined score (lower is better)\n    def weighted_score(solution, objectives):\n        return 0.7 * objectives[0] + 0.3 * objectives[1]\n\n    # Sort archive by weighted score and select the best 15% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: weighted_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 7)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment rotation + node swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Segment rotation (rotate a random segment by a random amount)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Step 2: Node swap (swap two nodes that are not adjacent)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i - j) == 1:  # Ensure nodes are not adjacent\n            i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9024818063105666,
            0.17928367853164673
        ],
        "raw_score": [
            6.0682416639386965,
            8.263773747526876
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using a hybrid approach combining Pareto dominance and dynamic objective weighting, then applies a multi-stage local search involving adaptive segment reversal, non-sequential node insertion, and objective-aware edge swaps to generate high-quality neighbors while ensuring feasibility. The selection prioritizes Pareto-dominant solutions but falls back to weighted scoring if none exist, with weights dynamically adjusted based on archive diversity. The local search stages progressively refine the solution by manipulating segments and edges, with the edge swap stage specifically considering both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: Pareto-dominant solutions first, then dynamic weighted scoring\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Dynamic weighting based on current archive diversity\n        obj1_avg = np.mean([obj[0] for _, obj in archive])\n        obj2_avg = np.mean([obj[1] for _, obj in archive])\n        weight = 0.5 + 0.5 * (obj1_avg / (obj1_avg + obj2_avg + 1e-6))  # Bias toward first objective if more diverse\n\n        selected = sorted(pareto_front, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n    else:\n        # Fallback to best weighted solution\n        weight = 0.6\n        selected = sorted(archive, key=lambda x: weight * x[1][0] + (1-weight) * x[1][1])[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-stage local search\n    # Stage 1: Adaptive segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    if random.random() < 0.7:  # Higher chance for reversal\n        new_solution[a:b+1] = segment[::-1]\n\n    # Stage 2: Non-sequential node insertion\n    if n >= 5:\n        i, j = sorted(random.sample(range(n), 2))\n        while abs(i-j) <= 1:\n            i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Stage 3: Objective-aware edge swap\n    if n >= 4:\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.998267486701493,
            0.3527350425720215
        ],
        "raw_score": [
            10.47269543601011,
            10.578669860567175
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient selection with a novel \"cross-space segment relocation\" operator that dynamically adapts segment lengths based on objective trade-offs, prioritizing high-potential regions while ensuring feasibility through a two-phase validation process. It selects solutions intelligently (favoring Pareto fronts but exploring dominated solutions probabilistically) and applies a weighted objective scoring to balance improvement across both spaces, with a fallback to simple swaps if feasibility is compromised. The critical design ideas are the dynamic segment relocation, weighted objective prioritization, and the hybrid selection strategy that balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection with dynamic exploration\n    objectives = np.array([obj for _, obj in archive])\n    is_pareto_efficient = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                is_pareto_efficient[i] = False\n    pareto_indices = np.where(is_pareto_efficient)[0]\n\n    if len(pareto_indices) > 0:\n        candidates = pareto_indices\n    else:\n        # Explore dominated solutions with probability based on archive size\n        exploration_prob = min(0.3, 1.0 / (len(archive) + 1))\n        if np.random.rand() < exploration_prob:\n            candidates = np.random.choice(len(archive), size=max(1, len(archive) // 5), replace=False)\n        else:\n            candidates = np.array([np.argmin(objectives[:, 0] + objectives[:, 1])])\n\n    # Dynamic weighted selection\n    weight = 0.5 + 0.5 * np.random.rand()  # Random weight between 0.5 and 1.0\n    scores = weight * objectives[:, 0] + (1 - weight) * objectives[:, 1]\n    selected_idx = candidates[np.argmin(scores[candidates])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Cross-space segment relocation\n    segment_length = min(n // 3, max(2, int(np.random.normal(n // 4, n // 6))))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate potential improvement in both objectives\n    def calculate_improvement(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    # Try different insertion points\n    best_improvement = 0\n    best_insert_pos = -1\n    original_cost1, original_cost2 = calculate_improvement(new_solution)\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos + segment_length:]\n        ])\n        # Calculate improvement\n        new_cost1, new_cost2 = calculate_improvement(candidate)\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos],\n            segment,\n            new_solution[best_insert_pos + segment_length:]\n        ])\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -1.0246042744516743,
            5.167974233627319
        ],
        "raw_score": [
            10.47992649312583,
            10.62714912616767
        ]
    },
    {
        "algorithm": "The algorithm selects top 20% Pareto-efficient solutions from the archive (using hypervolume) and applies a hybrid local search with dynamic operator weighting (alternating between edge swaps and segment rotations) to generate neighbors, ensuring feasibility by validating tours and recalculating objectives. It also includes a 10% chance to reintroduce dominated solutions for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% Pareto-efficient solutions\n    def hypervolume(obj):\n        return obj[0] + obj[1]\n\n    sorted_archive = sorted(archive, key=lambda x: hypervolume(x[1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    selected = sorted_archive[:top_k]\n\n    # 10% chance to reintroduce dominated solutions\n    if random.random() < 0.1 and len(archive) > top_k:\n        selected = archive[top_k:]\n\n    base_solution, base_obj = random.choice(selected)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator weighting (alternates between 70/30 and 30/70 every 10 iterations)\n    iteration = random.randint(0, 19)\n    if iteration < 10:\n        operator_weight = 0.7\n    else:\n        operator_weight = 0.3\n\n    # Edge swaps (dynamic weight)\n    if random.random() < operator_weight:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotations (remaining weight)\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.choice([1, -1])\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[a:b+1] = rotated_segment\n\n    # Cross-space validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9147664508158446,
            0.1948050856590271
        ],
        "raw_score": [
            6.161033810958136,
            6.307287034984366
        ]
    },
    {
        "algorithm": "The algorithm selects the worst solution from the archive (based on the sum of both objectives) and applies a hybrid local search operator: reversing a random segment of the tour and performing a random node swap, while ensuring the solution remains valid by checking for duplicates. The method prioritizes diversification by randomly modifying the tour structure, with fallback to the original solution if invalidity occurs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Apply a hybrid local search operator: a combination of edge insertion and node swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    start = np.random.randint(0, n)\n    end = np.random.randint(start, n)\n    segment = new_solution[start:end]\n\n    # Reverse the segment to create a new tour\n    new_segment = segment[::-1]\n    new_solution[start:end] = new_segment\n\n    # Perform a random swap between two nodes\n    i, j = np.random.choice(n, 2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9581710917107531,
            0.20549225807189941
        ],
        "raw_score": [
            10.422623819898265,
            10.398352035590081
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive by combining their objective scores, then applies a hybrid local search combining objective-biased edge swaps, edge insertions, and segment reversals to generate feasible neighbor solutions while prioritizing edges with higher costs in the less favorable objective. The method ensures validity by maintaining valid TSP tours through careful segment manipulation and edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined score (lower is better)\n    def combined_score(solution, objectives):\n        return objectives[0] + objectives[1]\n\n    # Sort archive by combined score and select the best 10% or at least 1\n    sorted_archive = sorted(archive, key=lambda x: combined_score(x[0], x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    selected = sorted_archive[:top_k]\n    base_solution, _ = random.choice(selected)\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Objective-biased edge swap (swap edges based on which objective they belong to)\n    def get_edge_objective(i, j, matrix):\n        return matrix[i, j]\n\n    # Choose a random edge to swap\n    i = random.randint(0, n-1)\n    j = (i + 1) % n\n\n    # Decide which objective to prioritize for the swap\n    obj1_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_1)\n    obj2_cost = get_edge_objective(new_solution[i], new_solution[j], distance_matrix_2)\n\n    if obj1_cost > obj2_cost:\n        # Swap edges based on objective 1\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n    else:\n        # Swap edges based on objective 2\n        k = random.randint(0, n-1)\n        l = (k + 1) % n\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Step 2: Edge insertion (move a random edge to a new position)\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 3: Segment reversal (reverse a random segment)\n    if n >= 4:\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8789912793056229,
            0.17964571714401245
        ],
        "raw_score": [
            6.999801024342688,
            6.553088726449999
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing those with lowest combined objectives) and applies a hybrid local search by reversing a random segment and swapping two non-consecutive edges, ensuring feasibility while exploring diverse neighborhoods. It balances exploitation (focusing on high-quality solutions) with exploration (perturbing the tour structure) to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n - 1)\n\n    # Reverse the segment (similar to 2-opt but more disruptive)\n    new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Additional perturbation: swap two random non-consecutive edges\n    if n > 3:\n        i = np.random.randint(0, n - 2)\n        j = np.random.randint(i + 2, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.8639804524653872,
            0.1826513409614563
        ],
        "raw_score": [
            6.89278661553577,
            6.192611657749408
        ]
    },
    {
        "algorithm": "The algorithm selects the top 20% Pareto-efficient solutions from the archive, applies a hybrid local search combining cross-space edge swaps (70% chance) and segment rotations (30% chance), and ensures feasibility by validating uniqueness of nodes. Cross-space edge swaps prioritize improving at least one objective, while segment rotations explore structural variations, dynamically balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-efficient selection (top 20%)\n    def is_pareto_dominant(a, b):\n        return (a[0] <= b[0] and a[1] < b[1]) or (a[0] < b[0] and a[1] <= b[1])\n\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_pareto_dominant(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        selected = random.choice(pareto_front)[0]\n    else:\n        selected = random.choice(archive)[0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    # 70% chance for cross-space edge swap\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate cost in both spaces\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        # Accept if improvement in at least one objective\n        if (cost1_after < cost1_before or cost2_after < cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 30% chance for segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Feasibility validation\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "metric_score": [
            -0.9534984719344859,
            3.4258954524993896
        ],
        "raw_score": [
            6.933738124716601,
            6.448856087654255
        ]
    }
]