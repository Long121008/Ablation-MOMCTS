[
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining edge reversal (2-opt-like) and segment reinsertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The selection prioritizes Pareto-efficient solutions, while the local search explores the solution space by reversing and reordering segments of the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected = archive[0][0]\n    else:\n        selected = non_dominated[np.random.choice(len(non_dominated))][0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: edge swapping + segment reinsertion\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Edge swapping\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Segment reinsertion\n    if b - a > 1:\n        segment = new_solution[a+1:b]\n        np.random.shuffle(segment)\n        new_solution[a+1:b] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.8831795237130278,
            0.44136685132980347
        ]
    },
    {
        "algorithm": "The algorithm selects the worst-performing solution from the archive (highest sum of objectives) and applies a hybrid local search operator that combines segment inversion (novel) and 2-opt moves to generate a neighbor solution while ensuring feasibility. It randomly selects two segments of the tour, inverts one segment if they overlap, or applies 2-opt otherwise, to explore diverse improvements in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment inversion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to invert (novel segment inversion)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Ensure segments do not overlap and are valid\n    if a < c < b < d:\n        # Invert the middle segment\n        new_solution[c:b] = new_solution[c:b][::-1]\n    else:\n        # Apply 2-opt between the two segments\n        new_solution[a:c] = new_solution[a:c][::-1]\n        new_solution[b:d] = new_solution[b:d][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8983048505803461,
            0.46161502599716187
        ]
    },
    {
        "algorithm": "The heuristic selects a random solution from the archive, applies a hybrid 3-opt with node-swapping to generate a neighbor, ensuring feasibility by validating uniqueness of nodes, and uses a 50% chance to further refine the solution with a simple swap. The algorithm prioritizes diversity in selection while balancing exploration (random segments) and exploitation (node-swapping).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with node-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a new order\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure no duplicates and all nodes are visited\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    # Additional node-swapping for further improvement\n    if np.random.rand() < 0.5:  # 50% chance to apply node-swapping\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9176324283959553,
            0.46636664867401123
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse Pareto-efficient solution from the archive using crowding distance, then applies a segment inversion with a multi-objective edge replacement strategy. It inverts a random segment of the tour and conditionally swaps edges based on Pareto dominance, ensuring feasibility while prioritizing non-dominated improvements in both objective spaces. The selection favors solutions with high crowding distance to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance-based selection\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(solutions)\n\n    # Compute crowding distance\n    crowding = np.zeros(n_solutions)\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, n_solutions-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance (diverse and Pareto-efficient)\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Segment inversion with multi-objective edge selection\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Invert segment\n    inverted_segment = new_solution[a:b+1][::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Multi-objective edge selection\n    for i in range(a, b):\n        current_node = new_solution[i]\n        next_node = new_solution[i+1]\n\n        # Get original and inverted edges\n        original_edge = (current_node, next_node)\n        inverted_edge = (current_node, inverted_segment[i-a])\n\n        # Calculate edge costs\n        original_cost1 = distance_matrix_1[original_edge]\n        original_cost2 = distance_matrix_2[original_edge]\n        inverted_cost1 = distance_matrix_1[inverted_edge]\n        inverted_cost2 = distance_matrix_2[inverted_edge]\n\n        # Replace if inverted edge dominates\n        if (inverted_cost1 <= original_cost1 and inverted_cost2 <= original_cost2 and\n            (inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2)):\n            new_solution[i+1] = inverted_segment[i-a]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9186313960760523,
            0.6131992936134338
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining segment reversal and edge swapping to generate a feasible neighbor solution. It prioritizes non-dominated solutions for selection and ensures feasibility by maintaining a valid TSP tour structure. The method randomly selects segments for reversal and edges for swapping, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected = archive[0][0]\n    else:\n        selected = non_dominated[np.random.choice(len(non_dominated))][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swapping\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Segment reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swapping\n    if b - a > 1:\n        c, d = np.random.choice(n, size=2, replace=False)\n        if c > d:\n            c, d = d, c\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.863947490657776,
            0.4584271311759949
        ]
    },
    {
        "algorithm": "The algorithm implements an adaptive Pareto-aware hybrid local search that combines segment inversion with edge reversal and node reinsertion, prioritizing nondominated solutions and dynamically adjusting operator intensity based on solution quality. It selects solutions probabilistically from nondominated ones (or the entire archive if none exist), then applies a segment inversion followed by conditional node reinsertion, ensuring feasibility through validation and fallback to simple swaps if needed. The method balances exploration and exploitation by favoring nondominated solutions and dynamically adjusting operator probabilities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with adaptive probability based on Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if nondominated:\n        selected_idx = np.random.choice(nondominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment inversion + edge reversal\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j+1]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[i:j+1] = new_segment\n\n    # Dynamic node reinsertion based on solution quality\n    if np.random.rand() < 0.3:  # Higher probability for nondominated solutions\n        k = np.random.randint(n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8538871949066549,
            0.5010150074958801
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a hybrid approach (70% Pareto-dominant, 30% random) and applies a novel \"segment fusion\" operator, which reorders non-overlapping segments of the tour while optionally inverting a segment with 20% probability to escape local optima. It ensures feasibility by validating node uniqueness and tour completeness. The selection prioritizes non-dominated solutions for exploitation while maintaining diversity through randomness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: 70% Pareto-dominant, 30% random\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated and np.random.rand() < 0.7:\n        selected = non_dominated[np.random.choice(len(non_dominated))][0]\n    else:\n        selected = archive[np.random.choice(len(archive))][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segment fusion operator\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reorder segments in a new configuration\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Probabilistic segment inversion (20% chance)\n    if np.random.rand() < 0.2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_order[i:j+1] = new_order[i:j+1][::-1]\n\n    # Validate solution\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    return new_solution\n\n",
        "score": [
            -0.8144455038000102,
            0.4798164963722229
        ]
    },
    {
        "algorithm": "The algorithm prioritizes non-dominated solutions from the archive, randomly selects one, and applies a hybrid local search combining segment inversion and adaptive edge swapping to generate a neighbor while ensuring feasibility through a repair mechanism. It balances exploration and exploitation by randomly choosing between operations and repairing invalid tours by reinserting missing nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    # Step 2: Select a solution (prefer non-dominated)\n    if non_dominated:\n        selected = non_dominated[np.random.choice(len(non_dominated))][0]\n    else:\n        selected = archive[np.random.choice(len(archive))][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 3: Hybrid local search\n    # Segment inversion\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive edge swapping\n    if np.random.rand() < 0.5:  # 50% chance to swap edges\n        c, d = np.random.choice(n, size=2, replace=False)\n        if c > d:\n            c, d = d, c\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Step 4: Ensure feasibility (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback: repair by reinserting missing nodes\n        missing = set(range(n)) - set(unique_nodes)\n        duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n        for m in missing:\n            for d in duplicates:\n                idx = np.where(new_solution == d)[0][0]\n                new_solution[idx] = m\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8455400396155324,
            0.4800568222999573
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-efficient solution selection with a hybrid local search that dynamically applies segment inversion, edge reversal, and node-swapping, prioritizing improvements in both objective spaces while ensuring feasibility through validation. It intelligently selects non-dominated solutions for exploration and uses distance matrices to guide node-swapping, falling back to simple swaps if needed. The method balances exploration and exploitation by randomly choosing between operators and validating solutions to maintain tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected = archive[0][0]\n    else:\n        selected = non_dominated[np.random.choice(len(non_dominated))][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Dynamic local search operator\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Segment inversion with edge reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Node-swapping based on distance matrices\n    if np.random.rand() < 0.5:\n        swap_candidates = []\n        for i in range(n):\n            for j in range(i+1, n):\n                delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                if delta1 < 0 or delta2 < 0:\n                    swap_candidates.append((i, j))\n        if swap_candidates:\n            i, j = swap_candidates[np.random.choice(len(swap_candidates))]\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8494655508599771,
            2.5585632920265198
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a hybrid approach that prioritizes non-dominated solutions (70% chance) or random solutions (30%), then applies a multi-segment inversion and reinsertion followed by probabilistic edge exchanges to improve objectives, ensuring feasibility through validation. Non-dominated solutions are given higher priority, and edge exchanges are accepted if they improve at least one objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize non-dominated solutions, then select based on diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select a non-dominated solution with probability 0.7, else select randomly\n        if np.random.rand() < 0.7:\n            selected_idx = np.random.choice(len(non_dominated))\n            base_solution = non_dominated[selected_idx][0].copy()\n        else:\n            selected_idx = np.random.choice(len(archive))\n            base_solution = archive[selected_idx][0].copy()\n    else:\n        selected_idx = np.random.choice(len(archive))\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and reinsertion\n    segments = sorted(np.random.choice(n, size=3, replace=False))\n    i, j, k = segments\n\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a new order and reverse some\n    new_order = np.concatenate([segment1, segment3[::-1], segment2, segment4[::-1]])\n\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    # Probabilistic edge exchange based on objective-specific improvements\n    for _ in range(2):  # Perform 2 edge exchanges\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate objective improvements\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Accept exchange if it improves at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8142194219853764,
            0.4921562671661377
        ]
    }
]