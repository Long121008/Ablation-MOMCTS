[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (lowest combined cost) and applies a hybrid local search combining probabilistic path reversal and beneficial edge swaps to explore neighboring solutions while ensuring feasibility. It prioritizes solutions with lower combined objective values and uses random segment reversal and targeted swaps to escape local optima. The method balances exploration and exploitation by incorporating both structural changes (reversal) and cost-improving swaps (edge exchanges).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge swaps with probabilistic path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (probabilistic path reversal)\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform edge swaps if beneficial\n    for _ in range(min(5, n//2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate current and new costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6632935098869966,
            0.4479232430458069
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower total cost) and applies a hybrid local search: it either swaps two random edges for short tours or relocates a random segment and performs edge exchange for longer tours, ensuring feasibility by maintaining a valid TSP tour. The selection favors solutions with better combined objectives, while the local search combines segment relocation and edge exchange to explore diverse neighborhoods.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or fewer\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment relocation with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # Swap two random edges if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Relocate a random segment\n        seg_start = random.randint(0, n - 4)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert segment at a new random position\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Perform edge exchange between two random edges\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6405311524028384,
            0.4156094193458557
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive (prioritizing those with the best combined objective values) and applies a hybrid local search combining 3-opt moves and a novel edge-swapping strategy to generate a neighbor solution, ensuring feasibility while balancing improvements in both objectives. The algorithm evaluates all possible 3-opt configurations to find the most beneficial move, then performs a random edge swap for further exploration, with edge selection prioritizing non-adjacent edges to maintain diversity. The solution always remains valid by preserving the TSP tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt: randomly select 3 edges and reconnect them in a different order\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Possible 3-opt moves\n        moves = [\n            (a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)\n        ]\n        best_move = None\n        best_improvement = 0\n\n        for move in moves:\n            temp_solution = new_solution.copy()\n            # Apply the move\n            temp_solution[move[0]:move[1]] = new_solution[move[0]:move[1]][::-1]\n            temp_solution[move[1]:move[2]] = new_solution[move[1]:move[2]][::-1]\n            temp_solution[move[2]:] = new_solution[move[2]:][::-1]\n\n            # Calculate the change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n            new_cost1 = distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b-1], temp_solution[b]] + distance_matrix_1[temp_solution[c-1], temp_solution[c]]\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n            new_cost2 = distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b-1], temp_solution[b]] + distance_matrix_2[temp_solution[c-1], temp_solution[c]]\n            improvement2 = old_cost2 - new_cost2\n\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_move = move\n\n        if best_move is not None:\n            a, b, c = best_move\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n            new_solution[c:] = new_solution[c:][::-1]\n\n    # Apply a novel edge-swapping strategy (e.g., swap two non-adjacent edges)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7356228671207142,
            0.4902300238609314
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive based on combined objective scores, then applies a hybrid local search combining edge swaps, node reinsertions, and adaptive segment reversals to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower total objective values and uses both distance matrices to guide improvements, with a 30% chance to accept non-strictly better segment reversals. The algorithm balances exploration and exploitation by randomly selecting operations and considering both objectives in node insertion and segment reversal decisions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values)\n    # Here we use a simple selection strategy: pick the solution with the lowest sum of objectives\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Edge swap (2-opt variant)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node reinsertion (remove a random node and reinsert it at a better position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion position based on both distance matrices\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - 1):\n        # Calculate insertion cost for both objectives\n        prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Adaptive segment reversal (reverse a segment if it improves both objectives)\n    segment_start = np.random.randint(0, n - 3)\n    segment_length = np.random.randint(2, min(5, n - segment_start))\n    segment_end = segment_start + segment_length\n\n    segment = new_solution[segment_start:segment_end]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost before and after reversal\n    prev_node = new_solution[segment_start - 1] if segment_start > 0 else new_solution[-1]\n    next_node = new_solution[segment_end] if segment_end < n else new_solution[0]\n\n    original_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    reversed_cost1 = distance_matrix_1[prev_node, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_node]\n\n    original_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n    reversed_cost2 = distance_matrix_2[prev_node, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_node]\n\n    if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or np.random.rand() < 0.3:  # 30% chance to accept even if not strictly better\n        new_solution[segment_start:segment_end] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8223968907865342,
            0.5309839248657227
        ]
    },
    {
        "algorithm": "The heuristic selects the best solution from the archive (lowest combined objective) and applies a hybrid local search that randomly rearranges segments of the tour while reversing some segments to explore diverse neighborhoods, ensuring feasibility by checking for duplicate nodes. The algorithm prioritizes solutions with lower combined costs and uses a 3-segment reordering strategy to generate neighbors, balancing exploration and feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: 3-opt-like with edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Extract segments\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct with different order\n    new_order = np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    return new_solution\n\n",
        "score": [
            -0.7186686295922018,
            0.4569772481918335
        ]
    }
]