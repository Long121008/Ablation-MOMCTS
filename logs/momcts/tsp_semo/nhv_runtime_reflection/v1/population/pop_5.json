[
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if none exist) and applies a hybrid local search combining edge reversal (2-opt-like) and segment reinsertion to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour. The selection prioritizes Pareto-efficient solutions, while the local search explores the solution space by reversing and reordering segments of the tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected = archive[0][0]\n    else:\n        selected = non_dominated[np.random.choice(len(non_dominated))][0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: edge swapping + segment reinsertion\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Edge swapping\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Segment reinsertion\n    if b - a > 1:\n        segment = new_solution[a+1:b]\n        np.random.shuffle(segment)\n        new_solution[a+1:b] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.8831795237130278,
            0.44136685132980347
        ]
    },
    {
        "algorithm": "The algorithm selects the worst-performing solution from the archive (highest sum of objectives) and applies a hybrid local search operator that combines segment inversion (novel) and 2-opt moves to generate a neighbor solution while ensuring feasibility. It randomly selects two segments of the tour, inverts one segment if they overlap, or applies 2-opt otherwise, to explore diverse improvements in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment inversion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to invert (novel segment inversion)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Ensure segments do not overlap and are valid\n    if a < c < b < d:\n        # Invert the middle segment\n        new_solution[c:b] = new_solution[c:b][::-1]\n    else:\n        # Apply 2-opt between the two segments\n        new_solution[a:c] = new_solution[a:c][::-1]\n        new_solution[b:d] = new_solution[b:d][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8983048505803461,
            0.46161502599716187
        ]
    },
    {
        "algorithm": "The heuristic selects a random solution from the archive, applies a hybrid 3-opt with node-swapping to generate a neighbor, ensuring feasibility by validating uniqueness of nodes, and uses a 50% chance to further refine the solution with a simple swap. The algorithm prioritizes diversity in selection while balancing exploration (random segments) and exploitation (node-swapping).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with node-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to modify\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a new order\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure no duplicates and all nodes are visited\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n\n    # Additional node-swapping for further improvement\n    if np.random.rand() < 0.5:  # 50% chance to apply node-swapping\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Verify the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9176324283959553,
            0.46636664867401123
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive by combining normalized objective costs and diversity, then applies a hybrid local search that uses 3-opt moves with an adaptive edge insertion strategy (30% chance) to generate neighbors while ensuring feasibility. The selection prioritizes solutions with lower combined costs and higher diversity, while the local search balances exploration and exploitation by combining structural changes (3-opt) with targeted edge adjustments.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution combining objective values and diversity\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize objectives (assuming we want to minimize both)\n        norm_cost1 = cost1 / (distance_matrix_1.sum() / len(sol)) if cost1 > 0 else 0\n        norm_cost2 = cost2 / (distance_matrix_2.sum() / len(sol)) if cost2 > 0 else 0\n        # Combine objectives with equal weight (can be adjusted)\n        combined_cost = norm_cost1 + norm_cost2\n        # Add diversity factor (simplified here)\n        diversity = len(set(sol)) / len(sol)\n        # Score is inverse of combined cost plus diversity\n        score = 1 / (combined_cost + 1e-6) + diversity\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with adaptive edge insertion\n    for _ in range(10):  # Number of attempts\n        # Randomly select 3 distinct edges to modify\n        i, j, k = sorted(np.random.choice(range(1, n), size=3, replace=False))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Adaptive edge insertion: try to improve by inserting a random edge\n        if np.random.rand() < 0.3:  # 30% chance to apply insertion\n            l, m = sorted(np.random.choice(range(n), size=2, replace=False))\n            if l != m:\n                # Insert m after l\n                new_solution = np.concatenate([\n                    new_solution[:l+1],\n                    [new_solution[m]],\n                    new_solution[l+1:m],\n                    new_solution[m+1:]\n                ])\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(set(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7361482534293463,
            0.5405706167221069
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution with high diversity from the archive, then applies a hybrid 3-opt with segment inversion strategy to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes in the tour. It prioritizes non-dominated solutions and maximizes diversity in edge selection, while the hybrid local search intelligently reorders segments to explore diverse regions of the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions that are non-dominated and have high diversity\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If no non-dominated solutions, select randomly\n        selected_sol, _ = archive[np.random.randint(len(archive))]\n    else:\n        # Select solution with highest diversity (largest sum of distances)\n        max_diversity = -1\n        selected_sol = None\n        for sol, _ in non_dominated:\n            diversity = 0\n            for i in range(len(sol)):\n                diversity += distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]]\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_sol = sol\n\n    base_solution = selected_sol.copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid strategy: 3-opt with segment inversion\n    # Select three random edges to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Create new segments by inverting middle segment and reordering\n    new_segments = [segment1, segment3[::-1], segment2[::-1], segment4]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(new_segments)\n\n    # Ensure the solution is a valid tour (circular)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7070922615502664,
            1.2628687024116516
        ]
    }
]