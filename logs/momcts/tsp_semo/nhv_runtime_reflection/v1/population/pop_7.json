[
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if none exist) and applies a multi-stage local search: first performing a k-segment inversion (randomly reversing segments of the tour) and then a guided edge contraction (reversing a segment if it improves the combined cost in both objectives). The selection prioritizes solutions that are Pareto-efficient, while the local search balances exploration and exploitation by combining randomness with objective-aware improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance-inspired selection\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n    if not nondominated:\n        nondominated = archive\n    selected_solution = random.choice(nondominated)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n >= 3:\n        k = random.randint(2, min(4, n // 2))\n        segments = sorted(random.sample(range(1, n), k))\n        segments = [0] + segments + [n]\n        for i in range(len(segments) - 1):\n            new_solution[segments[i]:segments[i+1]] = new_solution[segments[i]:segments[i+1]][::-1]\n\n    # Guided edge contraction\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            contracted = new_solution[i:j+1]\n            reversed_contracted = contracted[::-1]\n            cost1 = sum(distance_matrix_1[contracted[k], contracted[k+1]] for k in range(len(contracted)-1)) - sum(distance_matrix_1[reversed_contracted[k], reversed_contracted[k+1]] for k in range(len(reversed_contracted)-1))\n            cost2 = sum(distance_matrix_2[contracted[k], contracted[k+1]] for k in range(len(contracted)-1)) - sum(distance_matrix_2[reversed_contracted[k], reversed_contracted[k+1]] for k in range(len(reversed_contracted)-1))\n            if cost1 + cost2 > 0:\n                new_solution[i:j+1] = reversed_contracted\n\n    return new_solution\n\n",
        "score": [
            -0.923201256493205,
            0.4965274930000305
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (prioritizing lower combined objective values) and applies a hybrid local search combining segment inversion and edge swaps, ensuring feasibility by maintaining TSP tour structure. It also includes a dynamic acceptance criterion for occasional non-strict improvements to escape local optima. The method prioritizes solutions with minimal combined cost while creatively modifying segments and edges to improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with edge exchange\n    if n >= 4:\n        # Randomly select a segment to invert\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 3, n - 1))\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Randomly select two non-adjacent edges to swap\n        edge1, edge2 = sorted(random.sample(range(n), 2))\n        if abs(edge1 - edge2) > 1:\n            new_solution[edge1], new_solution[edge2] = new_solution[edge2], new_solution[edge1]\n\n    # Dynamic acceptance: allow occasional non-strict improvements\n    if random.random() < 0.3 and n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            # Check if the swap improves at least one objective\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n            if (new_cost1 <= old_cost1) or (new_cost2 <= old_cost2):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7630967912198918,
            0.467441201210022
        ]
    },
    {
        "algorithm": "The algorithm performs an adaptive bi-objective local search by first selecting promising solutions from the archive based on their combined objective values, then applying either edge exchange or segment reversal operations probabilistically, with additional edge exchanges for larger tours. It ensures feasibility through multi-step validation and falls back to the original solution if invalid. The method prioritizes solutions with lower combined costs and uses a hybrid of segment reversal and edge exchange to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 or fewer\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive local search\n    if n < 5:\n        # For small tours, perform edge exchange\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # For larger tours, perform segment reversal with probabilistic acceptance\n        seg_start = random.randint(0, n - 4)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert segment at a new position\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # With 30% probability, perform additional edge exchange\n        if random.random() < 0.3:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7516487836292935,
            0.4175735116004944
        ]
    },
    {
        "algorithm": "The algorithm combines a multi-objective selection strategy (prioritizing solutions near the Pareto front) with a novel \"bi-directional segment crossover\" operator that merges segments from two nondominated solutions while ensuring feasibility, followed by a probabilistic edge-swap phase that evaluates improvements across both objectives using both distance matrices. The selection strategy prioritizes solutions with lower combined objective costs, while the crossover and swap operations ensure balanced exploration and exploitation of the solution space while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two nondominated solutions\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    if len(archive_sorted) < 2:\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        # Select two solutions near the Pareto front\n        sol1, sol2 = archive_sorted[0][0].copy(), archive_sorted[1][0].copy()\n        n = len(sol1)\n\n        # Bi-directional segment crossover\n        start1, end1 = sorted(np.random.choice(n, 2, replace=False))\n        start2, end2 = sorted(np.random.choice(n, 2, replace=False))\n\n        segment1 = sol1[start1:end1+1]\n        segment2 = sol2[start2:end2+1]\n\n        # Create new solution by merging segments\n        new_solution = np.concatenate([\n            sol1[:start1],\n            segment2,\n            sol1[end1+1:start2],\n            segment1,\n            sol1[end2+1:]\n        ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            # Fallback to single solution if crossover fails\n            selected_solution = archive_sorted[0][0].copy()\n        else:\n            selected_solution = new_solution\n\n    # Probabilistic edge swaps for both objectives\n    n = len(selected_solution)\n    for _ in range(min(5, n//2)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate current and new costs for both objectives\n        current_cost = (distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                         distance_matrix_1[selected_solution[j-1], selected_solution[j]] +\n                         distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                         distance_matrix_2[selected_solution[j-1], selected_solution[j]])\n\n        new_cost = (distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                    distance_matrix_1[selected_solution[j-1], selected_solution[i]] +\n                    distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                    distance_matrix_2[selected_solution[j-1], selected_solution[i]])\n\n        if new_cost < current_cost:\n            selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n",
        "score": [
            -0.6455809954068036,
            0.19651687145233154
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a hybrid local search: it first randomly divides the tour into segments (up to 3) and reverses each with 50% probability, then performs probabilistic edge swaps (targeting non-adjacent edges) based on combined cost improvement in both objective spaces, ensuring feasibility by reverting invalid moves. The selection prioritizes solutions with better combined objectives, while the local search explores multi-segment inversions and edge swaps to improve both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n >= 3:\n        # Randomly divide into up to 3 segments and reverse each with 50% probability\n        segments = []\n        if n >= 3:\n            split_points = sorted(random.sample(range(1, n), min(2, n-1)))\n            segments = [new_solution[:split_points[0]]] if len(split_points) >= 1 else []\n            if len(split_points) >= 2:\n                segments.append(new_solution[split_points[0]:split_points[1]])\n                segments.append(new_solution[split_points[1]:])\n            else:\n                segments.append(new_solution[split_points[0]:])\n\n            for i in range(len(segments)):\n                if random.random() < 0.5:\n                    segments[i] = segments[i][::-1]\n\n            new_solution = np.concatenate(segments)\n\n    # Probabilistic edge swaps based on combined cost improvement\n    if n >= 4:\n        for _ in range(min(3, n // 2)):\n            i, j = sorted(random.sample(range(n), 2))\n            if abs(i - j) > 1:\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Calculate combined cost improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n                improvement1 = old_cost1 - new_cost1\n\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n                improvement2 = old_cost2 - new_cost2\n\n                if improvement1 + improvement2 > 0:\n                    new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7916015800656954,
            0.47037798166275024
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower total cost) and applies a hybrid local search: it either swaps two random edges for short tours or relocates a random segment and performs edge exchange for longer tours, ensuring feasibility by maintaining a valid TSP tour. The selection favors solutions with better combined objectives, while the local search combines segment relocation and edge exchange to explore diverse neighborhoods.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 or fewer\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random segment relocation with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        # Swap two random edges if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Relocate a random segment\n        seg_start = random.randint(0, n - 4)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n        segment = new_solution[seg_start:seg_end]\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert segment at a new random position\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        # Perform edge exchange between two random edges\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6405311524028384,
            0.4156094193458557
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower combined objective costs) and applies a two-phase local search: first identifying and reinserting critical edges (those disproportionately high in either objective space) with a 70% probability, then probabilistically reversing segments to escape local optima. Feasibility is maintained by ensuring all nodes remain unique and the tour remains closed. The method balances exploration (random segment reversal) and exploitation (critical edge handling) while avoiding standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high probability of being nondominated\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 or fewer\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # Swap two random edges if the tour is too short\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Phase 1: Identify critical edges\n    critical_edges = []\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if (cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2)) and random.random() < 0.7:\n            critical_edges.append((i, (i+1)%n))\n\n    if critical_edges:\n        # Remove critical edges and reinsert them\n        for i, j in critical_edges:\n            if j < i:\n                j += n\n            segment = new_solution[i:j]\n            remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n            insert_pos = random.randint(0, len(remaining) - 1)\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Phase 2: Probabilistic segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:\n        if random.random() < 0.5:  # 50% chance to reverse\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.8636644161452494,
            0.9593260884284973
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive based on combined objective scores, then applies a hybrid local search combining edge swaps, node reinsertions, and adaptive segment reversals to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with lower total objective values and uses both distance matrices to guide improvements, with a 30% chance to accept non-strictly better segment reversals. The algorithm balances exploration and exploitation by randomly selecting operations and considering both objectives in node insertion and segment reversal decisions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values)\n    # Here we use a simple selection strategy: pick the solution with the lowest sum of objectives\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Edge swap (2-opt variant)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node reinsertion (remove a random node and reinsert it at a better position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion position based on both distance matrices\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - 1):\n        # Calculate insertion cost for both objectives\n        prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Adaptive segment reversal (reverse a segment if it improves both objectives)\n    segment_start = np.random.randint(0, n - 3)\n    segment_length = np.random.randint(2, min(5, n - segment_start))\n    segment_end = segment_start + segment_length\n\n    segment = new_solution[segment_start:segment_end]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost before and after reversal\n    prev_node = new_solution[segment_start - 1] if segment_start > 0 else new_solution[-1]\n    next_node = new_solution[segment_end] if segment_end < n else new_solution[0]\n\n    original_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    reversed_cost1 = distance_matrix_1[prev_node, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_node]\n\n    original_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n    reversed_cost2 = distance_matrix_2[prev_node, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_node]\n\n    if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or np.random.rand() < 0.3:  # 30% chance to accept even if not strictly better\n        new_solution[segment_start:segment_end] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8223968907865342,
            0.5309839248657227
        ]
    },
    {
        "algorithm": "The heuristic selects a promising solution from the archive (prioritizing those with the best combined objective values) and applies a hybrid local search combining 3-opt moves and a novel edge-swapping strategy to generate a neighbor solution, ensuring feasibility while balancing improvements in both objectives. The algorithm evaluates all possible 3-opt configurations to find the most beneficial move, then performs a random edge swap for further exploration, with edge selection prioritizing non-adjacent edges to maintain diversity. The solution always remains valid by preserving the TSP tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., one with good objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt: randomly select 3 edges and reconnect them in a different order\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Possible 3-opt moves\n        moves = [\n            (a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)\n        ]\n        best_move = None\n        best_improvement = 0\n\n        for move in moves:\n            temp_solution = new_solution.copy()\n            # Apply the move\n            temp_solution[move[0]:move[1]] = new_solution[move[0]:move[1]][::-1]\n            temp_solution[move[1]:move[2]] = new_solution[move[1]:move[2]][::-1]\n            temp_solution[move[2]:] = new_solution[move[2]:][::-1]\n\n            # Calculate the change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n            new_cost1 = distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b-1], temp_solution[b]] + distance_matrix_1[temp_solution[c-1], temp_solution[c]]\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n            new_cost2 = distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b-1], temp_solution[b]] + distance_matrix_2[temp_solution[c-1], temp_solution[c]]\n            improvement2 = old_cost2 - new_cost2\n\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_move = move\n\n        if best_move is not None:\n            a, b, c = best_move\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n            new_solution[c:] = new_solution[c:][::-1]\n\n    # Apply a novel edge-swapping strategy (e.g., swap two non-adjacent edges)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7356228671207142,
            0.4902300238609314
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (lowest combined cost) and applies a hybrid local search combining probabilistic path reversal and beneficial edge swaps to explore neighboring solutions while ensuring feasibility. It prioritizes solutions with lower combined objective values and uses random segment reversal and targeted swaps to escape local optima. The method balances exploration and exploitation by incorporating both structural changes (reversal) and cost-improving swaps (edge exchanges).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge swaps with probabilistic path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (probabilistic path reversal)\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Perform edge swaps if beneficial\n    for _ in range(min(5, n//2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate current and new costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6632935098869966,
            0.4479232430458069
        ]
    }
]