[
    {
        "algorithm": "The algorithm selects a solution from the archive using hypervolume-based prioritization, then applies adaptive segment reinsertion and a cross-dimensional edge exchange operator to generate a neighbor solution while ensuring feasibility. It dynamically balances exploration and exploitation, with a fallback to randomized shuffling if feasibility is compromised, and explicitly considers both objective spaces during local search. The key design ideas are prioritizing Pareto-efficient regions, space-aware segment reinsertion, and cross-dimensional edge exchange, all while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge exchange\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Swap edges between i and j in both spaces\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8137926732783934,
            0.07694697380065918
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, then applies a hybrid local search combining adaptive segment reinsertion with cross-dimensional 3-opt moves, prioritizing Pareto-efficient edge exchanges while ensuring feasibility through validation and fallback mechanisms. It focuses on improving solutions by intelligently reordering segments and evaluating alternative configurations in both objective spaces, with a fallback to random shuffling if feasibility is compromised. The selection is hypervolume-based, while the local search emphasizes cross-dimensional optimization and segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional 3-opt\n    if n > 3:\n        x, y, z = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n\n        # Evaluate all possible segment orderings and reversals\n        combinations = [\n            (np.concatenate([segment1, segment2]), False),\n            (np.concatenate([segment2, segment1]), False),\n            (np.concatenate([segment1[::-1], segment2]), True),\n            (np.concatenate([segment2, segment1[::-1]]), True)\n        ]\n\n        best_cost = float('inf')\n        best_combination = None\n        for comb, reversed_flag in combinations:\n            # Calculate cost for the new combination\n            cost1 = distance_matrix_1[new_solution[x-1], comb[0]] + distance_matrix_1[comb[-1], new_solution[z]]\n            cost2 = distance_matrix_2[new_solution[x-1], comb[0]] + distance_matrix_2[comb[-1], new_solution[z]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_combination = comb\n\n        if best_combination is not None:\n            new_solution = np.concatenate([new_solution[:x], best_combination, new_solution[z:]])\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9722888250495916,
            0.09567373991012573
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, applies adaptive segment reinsertion and cross-dimensional edge swaps to generate a neighbor, prioritizing Pareto-efficient edge exchanges in both objective spaces while ensuring feasibility through validation and fallback mechanisms. It emphasizes intelligent solution selection and hybrid local search with explicit multi-objective considerations, balancing exploration and exploitation in the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge swaps\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Evaluate edge swaps in both dimensions\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9674406834015334,
            0.0788697600364685
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a weighted adaptive strategy that prioritizes solutions with higher diversity in objectives, then applies a segment exchange move (similar to 3-opt but with a novel structure) to generate a neighbor. If the move is invalid, it falls back to a random 3-opt move to ensure feasibility. The weights dynamically adjust based on objective diversity, and the segment exchange explores inter-space correlations by rearranging segments between the two objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity) if np.sum(diversity) > 0 else np.array([0.5, 0.5])\n    weighted_objectives = weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1]\n\n    selected_idx = np.argmin(weighted_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[b:c]\n    segment3 = base_solution[c:d]\n\n    new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    return new_solution\n\n",
        "score": [
            -0.9919248668007465,
            0.227209210395813
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, applies adaptive segment reinsertion and cross-dimensional 4-opt moves to explore improved configurations, prioritizing Pareto-efficient edge exchanges while ensuring feasibility through validation and fallback mechanisms. It intelligently reorders segments and evaluates alternative configurations in both objective spaces, with a fallback to random shuffling if feasibility is compromised. The approach balances exploration of diverse segment permutations with exploitation of cross-dimensional cost improvements, while maintaining solution validity through strict checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional 4-opt\n    if n > 4:\n        x, y, z, w = sorted(np.random.choice(n, size=4, replace=False))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n        segment3 = new_solution[z:w]\n\n        # Evaluate all possible segment orderings and reversals\n        combinations = [\n            (np.concatenate([segment1, segment2, segment3]), False),\n            (np.concatenate([segment1, segment3, segment2]), False),\n            (np.concatenate([segment2, segment1, segment3]), False),\n            (np.concatenate([segment2, segment3, segment1]), False),\n            (np.concatenate([segment3, segment1, segment2]), False),\n            (np.concatenate([segment3, segment2, segment1]), False),\n            (np.concatenate([segment1[::-1], segment2, segment3]), True),\n            (np.concatenate([segment1, segment2[::-1], segment3]), True),\n            (np.concatenate([segment1, segment2, segment3[::-1]]), True)\n        ]\n\n        best_cost = float('inf')\n        best_combination = None\n        for comb, reversed_flag in combinations:\n            # Calculate cost for the new combination\n            cost1 = distance_matrix_1[new_solution[x-1], comb[0]] + distance_matrix_1[comb[-1], new_solution[w]]\n            cost2 = distance_matrix_2[new_solution[x-1], comb[0]] + distance_matrix_2[comb[-1], new_solution[w]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_combination = comb\n\n        if best_combination is not None:\n            new_solution = np.concatenate([new_solution[:x], best_combination, new_solution[w:]])\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9896284131547612,
            0.11232298612594604
        ]
    },
    {
        "algorithm": "The algorithm first selects a promising solution from the archive using a weighted combination of hypervolume contribution (70%) and the product of objectives (30%), then applies a hybrid local search operator with 60% probability for segment reinsertion and 40% for cross-dimensional edge swaps, followed by an additional 30% chance of segment reversal, while ensuring feasibility through validation and falling back to a simple swap if needed. The selection prioritizes Pareto-efficient solutions with balanced objectives, while the local search adaptively balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Combined selection criterion (70% hypervolume, 30% product of objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    product_objectives = objectives.prod(axis=1)\n    combined_score = 0.7 * hypervolume + 0.3 * product_objectives\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Hybrid local search operator\n    operator_choice = np.random.choice(['reinsertion', 'edge_swap'], p=[0.6, 0.4])\n\n    if operator_choice == 'reinsertion':\n        # Adaptive segment reinsertion\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n        segment = base_solution[a:b]\n        insert_pos = np.random.randint(0, n - len(segment))\n        new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n    else:\n        # Cross-dimensional edge swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Evaluate edge swaps in both dimensions\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional segment reversal for further improvement\n    if np.random.rand() < 0.3:\n        k, l = np.random.choice(n, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Step 3: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.022498640977425,
            0.2626815438270569
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using hypervolume-based selection, then applies a hybrid local search combining adaptive segment reinsertion and cross-dimensional 3-opt moves to generate a neighbor solution while ensuring feasibility through validation checks and fallback mechanisms. It prioritizes exploration through segment manipulation and exploitation through objective-aware evaluation, with fallback strategies maintaining solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    temp_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional 3-opt with objective-aware evaluation\n    if n > 3:\n        x, y, z = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = temp_solution[x:y]\n        segment2 = temp_solution[y:z]\n\n        combinations = [\n            (np.concatenate([segment1, segment2]), False),\n            (np.concatenate([segment2, segment1]), False),\n            (np.concatenate([segment1[::-1], segment2]), True),\n            (np.concatenate([segment2, segment1[::-1]]), True)\n        ]\n\n        best_cost = float('inf')\n        best_combination = None\n        for comb, reversed_flag in combinations:\n            cost1 = distance_matrix_1[temp_solution[x-1], comb[0]] + distance_matrix_1[comb[-1], temp_solution[z]]\n            cost2 = distance_matrix_2[temp_solution[x-1], comb[0]] + distance_matrix_2[comb[-1], temp_solution[z]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_combination = comb\n\n        if best_combination is not None:\n            temp_solution = np.concatenate([temp_solution[:x], best_combination, temp_solution[z:]])\n\n    # Step 4: Segment reversal for additional exploration\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n\n    # Step 5: Feasibility check and fallback\n    if len(temp_solution) != n or len(np.unique(temp_solution)) != n:\n        # Fallback to randomized segment shuffle with cross-dimensional evaluation\n        for _ in range(3):\n            np.random.shuffle(temp_solution)\n            if len(temp_solution) == n and len(np.unique(temp_solution)) == n:\n                break\n        else:\n            # Final fallback to simple swap if all else fails\n            d, e = np.random.choice(n, size=2, replace=False)\n            temp_solution[d], temp_solution[e] = temp_solution[e], temp_solution[d]\n\n    new_solution = temp_solution.copy()\n    return new_solution\n\n",
        "score": [
            -0.9914979101837657,
            0.12161469459533691
        ]
    },
    {
        "algorithm": "The algorithm combines hypervolume-based selection with a multi-phase local search: first realigning segments to improve both objectives, then contracting edges to further reduce costs, while ensuring feasibility through validation and fallback mechanisms. It prioritizes nondominated operations and adaptively balances exploration/exploitation, with the hypervolume selection favoring solutions with high potential for improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-phase local search operator\n    # Phase 1: Pareto-efficient segment realignment\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b]\n    best_pos = -1\n    best_cost1 = best_cost2 = float('inf')\n\n    for i in range(n):\n        if i >= a and i < b:\n            continue\n        # Calculate costs for inserting segment at position i\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        if cost1 < best_cost1 and cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Phase 2: Cross-dimensional edge contraction\n    if np.random.rand() < 0.6:\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Check if contracting edges i-j and j-k would improve both objectives\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n\n    # Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Randomized segment inversion\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7262990116083332,
            0.07826483249664307
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high-sum-objective solutions) and generates a neighbor by combining edge insertion and segment reversal, ensuring feasibility through validation and fallback to a simple swap if needed. The hybrid local search leverages random segment operations to explore diverse improvements while maintaining TSP validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Heuristic: Select a solution that is not dominated and has high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (for simplicity)\n    # In practice, you might use more sophisticated selection criteria\n    objectives = np.array([obj for (sol, obj) in archive])\n    sum_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Edge insertion + segment reversal\n    # 1. Randomly select two distinct edges and insert one between the other\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insert the edge between i and j\n    new_solution = np.concatenate([base_solution[:i+1], base_solution[j:], base_solution[i+1:j]])\n\n    # 2. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9833221092967197,
            0.243777334690094
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (weighted 0.7 for the first objective and 0.3 for the second) and applies a hybrid local search combining segment reversal, adaptive 3-opt moves, cross-segment insertion, and targeted node swaps to improve both objectives while maintaining feasibility. It prioritizes segments and nodes with lower combined costs in the distance matrices, ensuring valid TSP tours through careful insertion and swap operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective score (0.7*obj1 + 0.3*obj2)\n    objectives = np.array([(0.7 * obj[0] + 0.3 * obj[1]) for (sol, obj) in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal + adaptive 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment = new_solution[a:b+1].copy()\n\n    # Reverse the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Adaptive 3-opt move\n    # Find the best insertion point for the reversed segment\n    best_pos = -1\n    best_cost = float('inf')\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n        # Calculate cost after insertion\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Cross-segment insertion: optimally reinsert nodes between segments\n    if n > 3:\n        x, y = sorted(np.random.choice(n, size=2, replace=False))\n        node_to_move = new_solution[x]\n        segment = new_solution[y:y+2]\n\n        # Find best insertion point for the node\n        best_pos = -1\n        best_cost = float('inf')\n        for i in range(n):\n            if i >= y and i < y+2:\n                continue\n            # Calculate cost after insertion\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Targeted node swaps to balance objectives\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9773837019599685,
            0.1599225401878357
        ]
    }
]