[
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high-sum-objective solutions) and generates a neighbor by combining edge insertion and segment reversal, ensuring feasibility through validation and fallback to a simple swap if needed. The hybrid local search leverages random segment operations to explore diverse improvements while maintaining TSP validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Heuristic: Select a solution that is not dominated and has high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (for simplicity)\n    # In practice, you might use more sophisticated selection criteria\n    objectives = np.array([obj for (sol, obj) in archive])\n    sum_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Edge insertion + segment reversal\n    # 1. Randomly select two distinct edges and insert one between the other\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insert the edge between i and j\n    new_solution = np.concatenate([base_solution[:i+1], base_solution[j:], base_solution[i+1:j]])\n\n    # 2. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9833221092967197,
            0.243777334690094
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high combined objective values) and generates a neighbor by first reversing a random segment of the tour (edge inversion) and then reordering nodes within that segment based on their combined distance contributions (dynamic node reordering). The method ensures feasibility by maintaining valid TSP tours while targeting improvements in both objective spaces through adaptive segment selection and objective-aware node reordering.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high combined objective)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge inversion: reverse a segment of the tour\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Dynamic node reordering: place nodes in order of their combined distance contribution\n    segment = new_solution[a:b+1]\n    segment_distances = []\n    for i in range(len(segment)):\n        node = segment[i]\n        prev_node = segment[i-1] if i > 0 else segment[-1]\n        next_node = segment[(i+1)%len(segment)]\n        dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        segment_distances.append((i, dist1 + dist2))\n\n    segment_distances.sort(key=lambda x: x[1])\n    reordered_segment = [segment[i] for i, _ in segment_distances]\n    new_solution[a:b+1] = reordered_segment\n\n    return new_solution\n\n",
        "score": [
            -0.978951748126899,
            0.23892003297805786
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (weighted 0.7 for the first objective and 0.3 for the second) and applies a hybrid local search combining segment reversal, adaptive 3-opt moves, cross-segment insertion, and targeted node swaps to improve both objectives while maintaining feasibility. It prioritizes segments and nodes with lower combined costs in the distance matrices, ensuring valid TSP tours through careful insertion and swap operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective score (0.7*obj1 + 0.3*obj2)\n    objectives = np.array([(0.7 * obj[0] + 0.3 * obj[1]) for (sol, obj) in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal + adaptive 3-opt\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment = new_solution[a:b+1].copy()\n\n    # Reverse the segment\n    new_solution[a:b+1] = segment[::-1]\n\n    # Adaptive 3-opt move\n    # Find the best insertion point for the reversed segment\n    best_pos = -1\n    best_cost = float('inf')\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n        # Calculate cost after insertion\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Cross-segment insertion: optimally reinsert nodes between segments\n    if n > 3:\n        x, y = sorted(np.random.choice(n, size=2, replace=False))\n        node_to_move = new_solution[x]\n        segment = new_solution[y:y+2]\n\n        # Find best insertion point for the node\n        best_pos = -1\n        best_cost = float('inf')\n        for i in range(n):\n            if i >= y and i < y+2:\n                continue\n            # Calculate cost after insertion\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Targeted node swaps to balance objectives\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9773837019599685,
            0.1599225401878357
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using hypervolume-based prioritization, then applies adaptive segment reinsertion and a cross-dimensional edge exchange operator to generate a neighbor solution while ensuring feasibility. It dynamically balances exploration and exploitation, with a fallback to randomized shuffling if feasibility is compromised, and explicitly considers both objective spaces during local search. The key design ideas are prioritizing Pareto-efficient regions, space-aware segment reinsertion, and cross-dimensional edge exchange, all while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge exchange\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Swap edges between i and j in both spaces\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8137926732783934,
            0.07694697380065918
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, then applies a hybrid local search combining adaptive segment reinsertion with cross-dimensional 3-opt moves, prioritizing Pareto-efficient edge exchanges while ensuring feasibility through validation and fallback mechanisms. It focuses on improving solutions by intelligently reordering segments and evaluating alternative configurations in both objective spaces, with a fallback to random shuffling if feasibility is compromised. The selection is hypervolume-based, while the local search emphasizes cross-dimensional optimization and segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional 3-opt\n    if n > 3:\n        x, y, z = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[x:y]\n        segment2 = new_solution[y:z]\n\n        # Evaluate all possible segment orderings and reversals\n        combinations = [\n            (np.concatenate([segment1, segment2]), False),\n            (np.concatenate([segment2, segment1]), False),\n            (np.concatenate([segment1[::-1], segment2]), True),\n            (np.concatenate([segment2, segment1[::-1]]), True)\n        ]\n\n        best_cost = float('inf')\n        best_combination = None\n        for comb, reversed_flag in combinations:\n            # Calculate cost for the new combination\n            cost1 = distance_matrix_1[new_solution[x-1], comb[0]] + distance_matrix_1[comb[-1], new_solution[z]]\n            cost2 = distance_matrix_2[new_solution[x-1], comb[0]] + distance_matrix_2[comb[-1], new_solution[z]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_combination = comb\n\n        if best_combination is not None:\n            new_solution = np.concatenate([new_solution[:x], best_combination, new_solution[z:]])\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9722888250495916,
            0.09567373991012573
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, applies adaptive segment reinsertion and cross-dimensional edge swaps to generate a neighbor, prioritizing Pareto-efficient edge exchanges in both objective spaces while ensuring feasibility through validation and fallback mechanisms. It emphasizes intelligent solution selection and hybrid local search with explicit multi-objective considerations, balancing exploration and exploitation in the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge swaps\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Evaluate edge swaps in both dimensions\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9674406834015334,
            0.0788697600364685
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using hypervolume-based selection to prioritize Pareto-optimal regions, then applies a hybrid local search combining adaptive segment insertion, dynamic edge reversal, and probabilistic node swaps, with a fallback to randomized segment shuffling to ensure feasibility while maintaining diversity. The hypervolume calculation (max_obj1 - obj1) * (max_obj2 - obj2) gives higher priority to solutions with better trade-offs between objectives, while the local search operators (segment insertion, edge reversal, and node swaps) explore the solution space with increasing diversification. The fallback ensures feasibility by guaranteeing all nodes are visited exactly once.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection to prioritize Pareto-optimal regions\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment insertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Dynamic edge reversal\n    c, d = np.random.choice(n, size=2, replace=False)\n    c, d = min(c, d), max(c, d)\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Step 4: Probabilistic node swap\n    if np.random.rand() < 0.3:\n        e, f = np.random.choice(n, size=2, replace=False)\n        new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    # Ensure feasibility\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9586840287574495,
            0.08330374956130981
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (weighted equally for both objectives) and applies a hybrid local search combining segment inversion, adaptive 4-opt moves, cross-segment relocation, and balanced node exchanges to improve both objectives while ensuring feasibility. It prioritizes segments and nodes with lower combined costs in the distance matrices, using careful insertion and swap operations to maintain valid TSP tours. The method balances exploration (random segment/node selection) with exploitation (cost-based optimization) to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objective score (0.5*obj1 + 0.5*obj2)\n    objectives = np.array([(0.5 * obj[0] + 0.5 * obj[1]) for (sol, obj) in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: segment inversion + adaptive 4-opt\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n    segment1 = new_solution[a:b+1].copy()\n    segment2 = new_solution[c:d+1].copy()\n\n    # Invert the segments\n    new_solution[a:b+1] = segment1[::-1]\n    new_solution[c:d+1] = segment2[::-1]\n\n    # Adaptive 4-opt move: find best insertion points for the inverted segments\n    best_pos1, best_pos2 = -1, -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n        for j in range(n):\n            if j >= c and j <= d or j == i:\n                continue\n            # Calculate cost after insertion\n            cost1 = (distance_matrix_1[new_solution[i-1], segment1[0]] + distance_matrix_1[segment1[-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j-1], segment2[0]] + distance_matrix_1[segment2[-1], new_solution[j]])\n            cost2 = (distance_matrix_2[new_solution[i-1], segment1[0]] + distance_matrix_2[segment1[-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], segment2[0]] + distance_matrix_2[segment2[-1], new_solution[j]])\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos1, best_pos2 = i, j\n\n    if best_pos1 != -1 and best_pos2 != -1:\n        new_solution = np.concatenate([new_solution[:best_pos1], segment1, new_solution[best_pos1:best_pos2], segment2, new_solution[best_pos2:]])\n\n    # Cross-segment relocation: optimally reinsert nodes between segments\n    if n > 4:\n        x, y = sorted(np.random.choice(n, size=2, replace=False))\n        node_to_move = new_solution[x]\n        segment = new_solution[y:y+3]\n\n        # Find best insertion point for the node\n        best_pos = -1\n        best_cost = float('inf')\n        for i in range(n):\n            if i >= y and i < y+3:\n                continue\n            # Calculate cost after insertion\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Balanced node exchanges to balance objectives\n    for _ in range(4):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9674036544387967,
            0.8195474743843079
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of objectives (70% first objective, 30% second), then applies a hybrid local search combining objective-driven segment reversals (targeting the top 5 edges per objective) and probabilistic perturbations (segment reversal, edge insertion, or edge swap). It ensures feasibility by reverting to minimal swaps with 30% probability if the solution becomes invalid. The primary objective is prioritized 60% of the time, with secondary perturbations applied probabilistically.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on combined objective scores\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_scores = objectives[:, 0] * 0.7 + objectives[:, 1] * 0.3  # Weighted combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Calculate edge importance scores for each objective\n    def calculate_edge_scores(solution, distance_matrix):\n        scores = np.zeros(n)\n        for i in range(n):\n            u = solution[i]\n            v = solution[(i+1) % n]\n            scores[i] = distance_matrix[u, v]\n        return scores\n\n    scores1 = calculate_edge_scores(base_solution, distance_matrix_1)\n    scores2 = calculate_edge_scores(base_solution, distance_matrix_2)\n\n    # Step 3: Adaptive segment selection based on objective-specific edge weights\n    if np.random.random() < 0.6:  # Primary objective phase\n        critical_edges = np.argsort(scores1)[-5:]  # Top 5 edges in first objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Secondary objective phase\n        critical_edges = np.argsort(scores2)[-5:]  # Top 5 edges in second objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4: Probabilistic three-phase perturbation\n    perturbation_prob = np.random.random()\n    if perturbation_prob < 0.33:\n        # Phase 1: Segment reversal\n        segment_length = min(4, n-1)\n        start = np.random.randint(1, n-segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n    elif perturbation_prob < 0.66:\n        # Phase 2: Edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n    else:\n        # Phase 3: Edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility with higher probability of minimal swap\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        if np.random.random() < 0.3:  # 30% chance of minimal swap\n            idx1, idx2 = np.random.choice(n, 2, replace=False)\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.967276626629581,
            0.2662750482559204
        ]
    },
    {
        "algorithm": "The algorithm selects a hypervolume-optimal solution from the archive, applies adaptive segment reinsertion to modify the tour, and performs cross-dimensional edge swaps prioritizing Pareto-efficient improvements in both objective spaces while ensuring feasibility through validation and fallback mechanisms. It emphasizes high-quality edge exchanges by evaluating swaps in both objective spaces and reverts to randomized segment shuffling if feasibility is compromised. The key novelty lies in the hybrid local search combining segment reinsertion with cross-dimensional edge swaps, with a 70% probability threshold for edge swaps to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Hypervolume-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    max_obj1, max_obj2 = np.max(objectives, axis=0)\n    hypervolume = (max_obj1 - objectives[:, 0]) * (max_obj2 - objectives[:, 1])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Adaptive segment reinsertion\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n    segment = base_solution[a:b]\n    insert_pos = np.random.randint(0, n - len(segment))\n    new_solution = np.concatenate([base_solution[:insert_pos], segment, base_solution[insert_pos:]])\n\n    # Step 3: Cross-dimensional edge swaps\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if j - i > 1:\n            # Evaluate edge swaps in both dimensions\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 4: Feasibility check and fallback\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to randomized segment shuffle\n        np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8556766004298841,
            0.08361208438873291
        ]
    }
]