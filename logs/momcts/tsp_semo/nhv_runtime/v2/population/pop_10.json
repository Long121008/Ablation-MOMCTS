[
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high-sum-objective solutions) and generates a neighbor by combining edge insertion and segment reversal, ensuring feasibility through validation and fallback to a simple swap if needed. The hybrid local search leverages random segment operations to explore diverse improvements while maintaining TSP validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Heuristic: Select a solution that is not dominated and has high potential for improvement\n    # Here, we select a solution with the highest sum of objectives (for simplicity)\n    # In practice, you might use more sophisticated selection criteria\n    objectives = np.array([obj for (sol, obj) in archive])\n    sum_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Edge insertion + segment reversal\n    # 1. Randomly select two distinct edges and insert one between the other\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Insert the edge between i and j\n    new_solution = np.concatenate([base_solution[:i+1], base_solution[j:], base_solution[i+1:j]])\n\n    # 2. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.9833221092967197,
            0.243777334690094
        ]
    },
    {
        "algorithm": "The heuristic function selects a promising solution from the archive (prioritizing those with lower combined objectives) and applies a hybrid local search combining edge insertion and node swapping to generate a neighbor solution while ensuring feasibility. It first randomly selects a segment of the tour, attempts to reinsert a node optimally, and then performs targeted node swaps to improve the solution. The method balances exploration (random segment selection) with exploitation (optimized insertions and swaps) to navigate the trade-off between objectives effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low combined objective)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Edge insertion: try to insert a random node elsewhere\n    if len(segment) > 1:\n        node_to_move = segment[np.random.randint(0, len(segment))]\n        segment = segment[segment != node_to_move]\n\n        # Find best insertion point\n        best_pos = -1\n        best_cost = float('inf')\n        for i in range(n):\n            if i >= a and i <= b:\n                continue\n            # Calculate cost after insertion\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Node swapping: swap two nodes that improve the solution\n    for _ in range(2):  # Try a few swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.866672080587731,
            0.0872378945350647
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on the sum of normalized objectives, then generates a neighbor by combining a random segment reversal with a probabilistic edge swap, ensuring feasibility through validation and fallback to a simple reversal if needed. The selection prioritizes solutions with better overall performance across both objectives, while the hybrid local search explores modifications by reversing segments and swapping edges probabilistically, with a fallback to basic reversal for validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    sum_normalized = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(sum_normalized)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment reversal + probabilistic edge swap\n    # 1. Randomly select a segment and reverse it\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # 2. Probabilistically swap two edges\n    if np.random.rand() < 0.5:  # 50% chance to perform swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        if i+1 < j:  # Ensure valid segment\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        m, n = min(m, n), max(m, n)\n        new_solution[m:n+1] = new_solution[m:n+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9398636422991159,
            0.23097997903823853
        ]
    },
    {
        "algorithm": "This heuristic selects a promising solution from the archive using a weighted objective score (prioritizing solutions with lower combined costs), then applies a hybrid local search combining segment reversal, objective-aware node insertion, and adaptive node swapping to generate an improved neighbor solution while ensuring feasibility. The algorithm balances exploration and exploitation by favoring moves that improve at least one objective, with higher weights given to the sum of objectives (0.7) over the maximum (0.3) in the insertion step.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted objective score\n    def objective_score(obj):\n        return 0.6 * (obj[0] + obj[1]) + 0.4 * max(obj[0], obj[1])  # Balance between sum and max objectives\n\n    archive_sorted = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create neighbor solution\n    new_solution = base_solution.copy()\n\n    # Segment reversal with objective-aware selection\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost before reversal\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate segment cost after reversal\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept reversal if it improves at least one objective\n        if not (new_seg_cost1 <= seg_cost1 and new_seg_cost2 <= seg_cost2):\n            new_solution[a:b+1] = segment  # Revert if no improvement\n\n    # Objective-aware node insertion\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        mask = new_solution != node_to_move\n        remaining_nodes = new_solution[mask]\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            if i == node_to_move or new_solution[i] == node_to_move:\n                continue\n\n            # Calculate insertion costs\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n\n            # Weighted score combining both objectives\n            score = 0.7 * (cost1 + cost2) + 0.3 * max(cost1, cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Adaptive node swapping based on objective improvement\n    for _ in range(3):  # Try multiple swaps\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and new costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i]])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9374014090401595,
            0.19761645793914795
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing high combined objective values) and generates a neighbor by first reversing a random segment of the tour (edge inversion) and then reordering nodes within that segment based on their combined distance contributions (dynamic node reordering). The method ensures feasibility by maintaining valid TSP tours while targeting improvements in both objective spaces through adaptive segment selection and objective-aware node reordering.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high combined objective)\n    archive_sorted = sorted(archive, key=lambda x: -sum(x[1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge inversion: reverse a segment of the tour\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Dynamic node reordering: place nodes in order of their combined distance contribution\n    segment = new_solution[a:b+1]\n    segment_distances = []\n    for i in range(len(segment)):\n        node = segment[i]\n        prev_node = segment[i-1] if i > 0 else segment[-1]\n        next_node = segment[(i+1)%len(segment)]\n        dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        segment_distances.append((i, dist1 + dist2))\n\n    segment_distances.sort(key=lambda x: x[1])\n    reordered_segment = [segment[i] for i, _ in segment_distances]\n    new_solution[a:b+1] = reordered_segment\n\n    return new_solution\n\n",
        "score": [
            -0.978951748126899,
            0.23892003297805786
        ]
    },
    {
        "algorithm": "The algorithm prioritizes low-combined-objective solutions from the archive, applies a segment relocation strategy to improve both objectives simultaneously, and falls back to a targeted node swap if no relocation yields improvement, ensuring feasibility through validation. It leverages distance matrices to evaluate cost improvements and maintains tour validity by checking for duplicate or missing nodes. The selection of segments and positions is randomized but guided by cost reduction, with a structured fallback mechanism.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low combined objectives\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best position to insert the segment\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n        # Calculate cost after inserting the segment at position i\n        cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        # Remove the segment and insert it at the best position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # Fallback to a targeted node swap if no improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n        if cost1 + cost2 < distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8093032156508456,
            0.23830902576446533
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of objectives (60% first objective, 40% second), then applies a hybrid local search combining edge importance-based segment reversal (prioritizing critical edges in either objective space) and probabilistic two-phase perturbations (segment reversal or edge insertion). It ensures feasibility by reverting to a minimal swap if needed, with the first objective given higher priority in selection and phase transitions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on combined objective scores\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Calculate edge importance scores for each objective\n    def calculate_edge_scores(solution, distance_matrix):\n        scores = np.zeros(n)\n        for i in range(n):\n            u = solution[i]\n            v = solution[(i+1) % n]\n            scores[i] = distance_matrix[u, v]\n        return scores\n\n    scores1 = calculate_edge_scores(base_solution, distance_matrix_1)\n    scores2 = calculate_edge_scores(base_solution, distance_matrix_2)\n\n    # Step 3: Adaptive segment selection based on objective-specific edge weights\n    if np.random.random() < 0.7:  # Primary objective phase\n        critical_edges = np.argsort(scores1)[-3:]  # Top 3 edges in first objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Secondary objective phase\n        critical_edges = np.argsort(scores2)[-3:]  # Top 3 edges in second objective\n        if len(critical_edges) >= 2:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4: Probabilistic two-phase perturbation\n    if np.random.random() < 0.5:\n        # Phase 1: Segment reversal with objective-specific probability\n        if np.random.random() < 0.6:\n            segment_length = min(3, n-1)\n            start = np.random.randint(1, n-segment_length)\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:\n            # Phase 2: Edge insertion with complementary objective guidance\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], new_solution[i+1:j]])\n\n    # Ensure feasibility\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Minimal perturbation if infeasible\n        idx1, idx2 = np.random.choice(n, 2, replace=False)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.9119137505906443,
            0.24568456411361694
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution from the archive with the lowest combined objectives, then applies a hybrid local search combining segment reversal and optimized node insertion, ensuring feasibility through validation and falling back to a swap if needed. The method prioritizes solutions with minimal total cost across both objectives and uses a two-phase local search (segment reversal followed by node insertion) to explore the solution space efficiently, with a fallback mechanism to maintain tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a nondominated solution with the lowest combined objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    sum_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmin(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment reversal + optimized insertion\n    # 1. Segment reversal\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # 2. Optimized node insertion\n    if n > 2:\n        node_to_move = np.random.choice(new_solution)\n        segment = new_solution[new_solution != node_to_move]\n\n        best_pos = -1\n        best_cost = float('inf')\n        for i in range(n):\n            if i > 0 and new_solution[i-1] == node_to_move:\n                continue\n            cost1 = distance_matrix_1[new_solution[i-1], node_to_move] + distance_matrix_1[node_to_move, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], node_to_move] + distance_matrix_2[node_to_move, new_solution[i]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to swap\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.8116566414689501,
            0.24543476104736328
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest product of objectives, then generates a neighbor by performing a random 3-opt move followed by a segment rotation, ensuring feasibility through validation. If validation fails, it falls back to a simple 2-opt move. The method prioritizes solutions with balanced objectives (high product) and explores diverse improvements via hybrid local search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with the highest product of objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    product_objectives = objectives.prod(axis=1)\n    selected_idx = np.argmax(product_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Perform 3-opt move\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Step 3: Perform segment rotation\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    m = np.random.randint(1, l - k + 1)\n    new_solution[k:l+1] = np.roll(new_solution[k:l+1], m)\n\n    # Ensure feasibility\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above fails\n        m, n = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.8992370648392503,
            0.24571096897125244
        ]
    },
    {
        "algorithm": "The algorithm selects a promising nondominated solution from the archive, applies a hybrid local search combining segment reversal and optimized edge insertion to generate a neighbor, and ensures feasibility by validating the solution or falling back to a simple swap if needed. It prioritizes solutions that are not dominated in either objective space while using distance matrices to evaluate the quality of edge insertions. The structure alternates between a random segment reversal and a cost-based edge insertion, with a fallback mechanism to maintain validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising nondominated solution\n    objectives = np.array([obj for (sol, obj) in archive])\n    nondominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(nondominated)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search - Segment reversal + optimized edge insertion\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # 1. Random segment reversal\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # 2. Optimized edge insertion\n    if n > 3:\n        # Select a random node and find the best insertion point\n        node_to_move = new_solution[np.random.randint(1, n-1)]\n        best_pos = -1\n        best_cost = float('inf')\n\n        # Remove the node temporarily\n        temp_solution = new_solution[new_solution != node_to_move]\n\n        for i in range(len(temp_solution)):\n            # Calculate cost after insertion\n            prev_node = temp_solution[i-1] if i > 0 else temp_solution[-1]\n            next_node = temp_solution[i] if i < len(temp_solution) else temp_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node] - distance_matrix_2[prev_node, next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            # Insert the node at the best position\n            new_solution = np.concatenate([\n                temp_solution[:best_pos],\n                [node_to_move],\n                temp_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8929939886182452,
            0.3432426452636719
        ]
    }
]