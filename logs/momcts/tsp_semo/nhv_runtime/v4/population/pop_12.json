[
    {
        "algorithm": "The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.925254721365585,
            0.20645654201507568
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9481146534985749,
            0.2827843427658081
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5451367216570713,
            0.20511656999588013
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9020578250800095,
            0.21142607927322388
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8780436728534554,
            0.24034792184829712
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.8603430639441416,
            0.22855353355407715
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.893215863330194,
            0.2730424404144287
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8412695745447691,
            0.2388128638267517
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining a 4-opt move and a custom edge-reversal operator that prioritizes improving both objectives while ensuring feasibility. The 4-opt move reverses segments between randomly selected positions, while the edge-reversal operator flips a segment only if it improves both objectives, reverting to the original if the solution becomes invalid. The selection and local search balance exploration and exploitation by favoring lower-cost solutions and validating feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 4-opt with custom edge-reversal\n    if n >= 4:\n        # 4-opt move: Select 4 distinct positions and reverse segments\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n        new_solution[a:b] = selected_solution[a:b][::-1]\n        new_solution[b:c] = selected_solution[b:c][::-1]\n        new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Custom edge-reversal: Reverse a segment based on both objectives\n    if n >= 3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        current_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]]\n\n        # Accept reversal if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.825007250619317,
            0.23849892616271973
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive (prioritizing those with higher combined objective costs) and decomposes it into segments, optimizing each segment independently via a multi-objective edge-swap that only accepts swaps improving both objectives. It reconstructs the solution while ensuring feasibility, reverting to the original if invalid. The key innovation is segment-wise optimization with a strict bi-objective improvement criterion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8208473905516692,
            0.2640572786331177
        ]
    }
]