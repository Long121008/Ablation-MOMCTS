[
    {
        "algorithm": "The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.925254721365585,
            0.20645654201507568
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9481146534985749,
            0.2827843427658081
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9020578250800095,
            0.21142607927322388
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8780436728534554,
            0.24034792184829712
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.8603430639441416,
            0.22855353355407715
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8412695745447691,
            0.2388128638267517
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining a 4-opt move and a custom edge-reversal operator that prioritizes improving both objectives while ensuring feasibility. The 4-opt move reverses segments between randomly selected positions, while the edge-reversal operator flips a segment only if it improves both objectives, reverting to the original if the solution becomes invalid. The selection and local search balance exploration and exploitation by favoring lower-cost solutions and validating feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 4-opt with custom edge-reversal\n    if n >= 4:\n        # 4-opt move: Select 4 distinct positions and reverse segments\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n        new_solution[a:b] = selected_solution[a:b][::-1]\n        new_solution[b:c] = selected_solution[b:c][::-1]\n        new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Custom edge-reversal: Reverse a segment based on both objectives\n    if n >= 3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        current_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]]\n\n        # Accept reversal if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.825007250619317,
            0.23849892616271973
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive based on objective diversity (using standard deviation of costs), applies a 4-opt move to disrupt the tour, and optionally performs a novel edge-insertion strategy (70% chance) to reinsert a node between non-adjacent edges, ensuring feasibility by validating uniqueness of nodes. The method prioritizes diversity in selection and combines local search operators for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply 4-opt move\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Perform 4-opt: reverse segments between two pairs of points\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n    new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Novel edge-insertion: insert a node between two non-adjacent edges\n    if np.random.rand() < 0.7:  # 70% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1:  # Ensure non-adjacent edges\n            node_to_insert = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7638616008021419,
            0.2535017132759094
        ]
    },
    {
        "algorithm": "The heuristic selects a solution with high crowding distance from the archive to focus on diverse, potentially improvable regions, then applies a hybrid local search combining randomized 3-opt moves with segment reversals to escape local optima while ensuring feasibility. It prioritizes exploration by randomizing 3-opt configurations and balances exploitation with segment reversals, using objective-space diversity to guide selection. The algorithm emphasizes both objective-space diversity and novel neighborhood exploration to generate high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.650333661828972,
            0.42457258701324463
        ]
    }
]