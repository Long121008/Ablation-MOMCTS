[
    {
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "score": [
            -1.007662801692291,
            0.3636525273323059
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.9140602379001828,
            0.13315963745117188
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9311444140549993,
            0.28459417819976807
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by normalizing objectives and applying a dynamic 3-opt variant that intelligently adjusts segment lengths based on local cost gradients, ensuring feasibility through cost-aware segment operations. It prioritizes solutions with higher combined normalized objectives and evaluates all possible 3-opt moves while dynamically adjusting segment lengths (2-5 nodes) with a 40% probability to improve solution quality. The method ensures feasibility by maintaining valid TSP tours through careful segment manipulation and cost comparisons.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic 3-opt with cost-aware segment length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    while i == j or j == k or k == i:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    i, j, k = sorted([i, j, k])\n\n    # Calculate current cost of the segments\n    cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n             distance_matrix_1[new_solution[k-1], new_solution[k]])\n    cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n             distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n    # Generate all possible 3-opt moves\n    segments = [\n        [new_solution[i:j], new_solution[j:k], new_solution[k:]],\n        [new_solution[i:j], new_solution[k:][::-1], new_solution[j:k][::-1]],\n        [new_solution[j:k], new_solution[i:j], new_solution[k:]],\n        [new_solution[j:k], new_solution[k:][::-1], new_solution[i:j][::-1]],\n        [new_solution[k:], new_solution[i:j], new_solution[j:k]],\n        [new_solution[k:][::-1], new_solution[j:k][::-1], new_solution[i:j]]\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all possible orderings\n    for seg1, seg2, seg3 in segments:\n        candidate = np.concatenate([new_solution[:i], seg1, seg2, seg3])\n        new_cost1 = (sum(distance_matrix_1[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_1[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_1[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        new_cost2 = (sum(distance_matrix_2[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_2[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_2[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        total_cost = new_cost1 + new_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.9513669212246623,
            0.4071865677833557
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on inverse combined objective values) and applies a hybrid local search combining edge insertion and segment reversal to generate a new feasible neighbor solution. It prioritizes solutions with better combined objective values while using random segment manipulation to explore the solution space while maintaining TSP feasibility. The method avoids 2-opt by using a novel combination of insertion and reversal operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined normalized improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate potential as inverse of combined objective\n        potential = 1.0 / (obj[0] + obj[1] + 1e-10)  # Add small epsilon to avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: move segment [i:j] to position k\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    k = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Segment reversal: reverse a random segment\n    l, m = np.random.choice(n, size=2, replace=False)\n    if l > m:\n        l, m = m, l\n    new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8677688148376028,
            0.21988224983215332
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with better combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility through validation. The selection heuristic focuses on solutions with lower total objectives, and the local search operator introduces diversity by randomly perturbing the tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def compute_potential(solution, obj1, obj2):\n        # Simple heuristic: prioritize solutions with better objectives\n        return obj1 + obj2\n\n    archive_with_potential = [(solution, obj1, obj2, compute_potential(solution, obj1, obj2))\n                              for solution, (obj1, obj2) in archive]\n    archive_with_potential.sort(key=lambda x: x[3])\n    selected = archive_with_potential[-1][0].copy()  # Select the most promising solution\n\n    # Hybrid local search: combine node insertion and edge reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8834512122886744,
            0.23437249660491943
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using normalized objective values (summing normalized costs from both spaces) and applies a dynamic 3-opt variant, prioritizing segments with low combined cost gradients from both objectives. It then performs variable-length segment reversals and edge insertions while ensuring feasibility through uniqueness checks. The selection emphasizes solutions with better relative performance, while the local search adaptively explores neighborhoods based on local cost gradients.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalized objective-based selection\n    def normalized_objective(obj1, obj2, min_obj1, max_obj1, min_obj2, max_obj2):\n        if max_obj1 == min_obj1:\n            norm_obj1 = 0.0\n        else:\n            norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n        if max_obj2 == min_obj2:\n            norm_obj2 = 0.0\n        else:\n            norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n        return norm_obj1 + norm_obj2\n\n    objectives = [obj for _, obj in archive]\n    min_obj1, max_obj1 = min(obj[0] for obj in objectives), max(obj[0] for obj in objectives)\n    min_obj2, max_obj2 = min(obj[1] for obj in objectives), max(obj[1] for obj in objectives)\n\n    archive_with_score = [\n        (solution, normalized_objective(obj1, obj2, min_obj1, max_obj1, min_obj2, max_obj2))\n        for (solution, (obj1, obj2)) in archive\n    ]\n    archive_with_score.sort(key=lambda x: x[1])\n    selected = archive_with_score[-1][0].copy()  # Select the most promising solution\n\n    # Dynamic 3-opt variant\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine segment lengths based on local cost gradients\n        def compute_gradient(solution, pos, distance_matrix):\n            prev_node = solution[pos - 1]\n            curr_node = solution[pos]\n            next_node = solution[(pos + 1) % n]\n            gradient = distance_matrix[prev_node, curr_node] + distance_matrix[curr_node, next_node]\n            return gradient\n\n        # Select segments based on cost gradients\n        gradients_1 = [compute_gradient(new_solution, i, distance_matrix_1) for i in range(n)]\n        gradients_2 = [compute_gradient(new_solution, i, distance_matrix_2) for i in range(n)]\n        combined_gradients = [g1 + g2 for g1, g2 in zip(gradients_1, gradients_2)]\n        sorted_indices = sorted(range(n), key=lambda i: combined_gradients[i])\n        low_gradient_indices = sorted_indices[:max(2, n // 4)]\n\n        # Randomly select a segment to reverse\n        i = np.random.choice(low_gradient_indices)\n        j = np.random.randint(i, min(i + n // 3, n))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.choice([idx for idx in range(n) if idx not in range(i, j+1)])\n            edge = new_solution[edge_pos:edge_pos+2]\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                edge,\n                new_solution[insert_pos:edge_pos],\n                new_solution[edge_pos+2:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8869527211667101,
            0.2799438238143921
        ]
    },
    {
        "algorithm": "The algorithm combines cost-aware selection with a dynamic segment insertion operator that intelligently selects solutions based on normalized objectives and applies variable-length segment insertions guided by local cost gradients, ensuring feasibility through cost-aware segment operations and maintaining diversity by prioritizing non-dominated solutions while dynamically adjusting segment lengths (2-5 nodes) with a 40% probability to improve solution quality. The selection prioritizes solutions with higher combined normalized objectives, and the local search explores multiple candidate segment insertions (including reversals) to find cost-improving moves, with an additional 40% chance to dynamically adjust segment lengths for further optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment insertion with cost-aware length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    i, j = sorted([i, j])\n\n    # Calculate current cost of the segments\n    cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    # Determine segment length dynamically\n    segment_length = np.random.randint(2, min(6, n//3))\n    if i + segment_length >= n:\n        segment_length = n - i - 1\n    if j + segment_length >= n:\n        segment_length = n - j - 1\n\n    # Extract segments to insert\n    segment1 = new_solution[i:i+segment_length]\n    segment2 = new_solution[j:j+segment_length]\n\n    # Generate candidate solutions by inserting segments\n    candidates = [\n        np.concatenate([new_solution[:i], segment2, new_solution[i:j], segment1, new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment1, new_solution[i:j], segment2, new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment1[::-1], new_solution[i:j], segment2[::-1], new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment2[::-1], new_solution[i:j], segment1[::-1], new_solution[j+segment_length:]])\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all candidates\n    for candidate in candidates:\n        total_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n        total_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n        total_cost = total_cost1 + total_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.9272425605659993,
            0.319599986076355
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on normalized combined objectives, then applies a hybrid local search combining dynamic segment relocation with probabilistic segment fusion (40% chance) and segment inversion (30% chance), ensuring feasibility by checking for missing nodes and reinserting them randomly. The fusion process evaluates adjacent segment combinations to determine the most beneficial relocation, while the probabilistic inversion adds diversity to the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment relocation with probabilistic fusion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Determine segment length dynamically\n    segment_length = j - i\n    if segment_length > 1 and random.random() < 0.4:  # 40% chance to fuse with adjacent segments\n        # Try fusing with left and right segments\n        left_fusion = np.concatenate([new_solution[max(0, i-1):i], segment])\n        right_fusion = np.concatenate([segment, new_solution[j:min(j+2, n)]])\n\n        # Evaluate both fusion options\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            return cost1 + cost2\n\n        left_cost = evaluate(left_fusion)\n        right_cost = evaluate(right_fusion)\n\n        if left_cost < right_cost:\n            segment = left_fusion\n            i = max(0, i-1)\n        else:\n            segment = right_fusion\n\n    # Relocate the segment to a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic segment inversion\n    if random.random() < 0.3:  # 30% chance to invert a segment\n        inv_i, inv_j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[inv_i:inv_j] = new_solution[inv_i:inv_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7519570738412087,
            0.32621240615844727
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive using a weighted combination of normalized objectives (60% for the first objective, 40% for the second), then applies a hybrid local search combining 4-opt with adaptive segment reversal, dynamically adjusting reversal probabilities based on solution quality while ensuring feasibility through validation checks. The method prioritizes solutions with better objective values and uses both segment reordering and reversal to explore the search space, with fallback to the original solution if validation fails.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher than second\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive segment reversal\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Generate all possible 4-segment combinations\n    segments = [\n        new_solution[i:j], new_solution[j:k], new_solution[k:l], new_solution[l:] if l != n else np.array([])\n    ]\n\n    # Generate all possible orderings and reversals\n    from itertools import permutations\n    best_solution = new_solution.copy()\n    best_cost = np.inf\n\n    for perm in permutations(segments):\n        # Try both original and reversed segments\n        for reversal_mask in range(2**4):\n            current_solution = new_solution.copy()\n            temp_segments = list(perm)\n            for m in range(4):\n                if reversal_mask & (1 << m):\n                    temp_segments[m] = temp_segments[m][::-1]\n\n            # Reconstruct solution\n            new_tour = np.concatenate([\n                current_solution[:i],\n                *temp_segments,\n                current_solution[l:] if l != n else np.array([])\n            ])\n\n            # Check feasibility\n            if len(np.unique(new_tour)) == n:\n                # Evaluate cost\n                cost1 = sum(distance_matrix_1[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                cost2 = sum(distance_matrix_2[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_solution = new_tour.copy()\n\n    # Adaptive segment reversal based on solution quality\n    current_cost1 = sum(distance_matrix_1[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    current_cost2 = sum(distance_matrix_2[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    avg_cost = (current_cost1 + current_cost2) / 2\n\n    if avg_cost < np.mean(objectives[:, 0] + objectives[:, 1]) / 2:\n        # If solution is better than average, apply more aggressive reversal\n        reversal_prob = 0.5\n    else:\n        # If solution is worse than average, apply more conservative reversal\n        reversal_prob = 0.2\n\n    if np.random.rand() < reversal_prob:\n        rev_i, rev_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[rev_i:rev_j] = best_solution[rev_i:rev_j][::-1]\n\n    # Final validation check\n    if len(np.unique(best_solution)) != n:\n        # Fallback to original solution if validation fails\n        best_solution = base_solution.copy()\n\n    return best_solution\n\n",
        "score": [
            -0.891607011625859,
            11.704376697540283
        ]
    }
]