[
    {
        "algorithm": "The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.925254721365585,
            0.20645654201507568
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9481146534985749,
            0.2827843427658081
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5451367216570713,
            0.20511656999588013
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.94438110626965,
            0.2759231925010681
        ]
    },
    {
        "algorithm": "The algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9879140490693281,
            0.3575114607810974
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.9377858774270942,
            0.2215670943260193
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by combining normalized objectives and diversity scores, then applies a hybrid local search (60% edge-swap, 40% constrained segment insertion) to generate a neighbor solution while ensuring feasibility through node uniqueness validation. It prioritizes multi-objective improvement in edge-swaps and allows occasional diversification in segment insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    scores = np.sum(normalized, axis=1) + 0.5 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: 60% edge-swap, 40% constrained segment insertion\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Constrained segment insertion\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b = sorted([a, b])\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9442062933891868,
            0.25356727838516235
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9868076364651988,
            2.0267587304115295
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9020578250800095,
            0.21142607927322388
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9756411093506061,
            0.6009257435798645
        ]
    }
]