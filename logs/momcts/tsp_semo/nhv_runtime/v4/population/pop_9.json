[
    {
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "score": [
            -1.007662801692291,
            0.3636525273323059
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.9140602379001828,
            0.13315963745117188
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9311444140549993,
            0.28459417819976807
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by normalizing objectives and applying a dynamic 3-opt variant that intelligently adjusts segment lengths based on local cost gradients, ensuring feasibility through cost-aware segment operations. It prioritizes solutions with higher combined normalized objectives and evaluates all possible 3-opt moves while dynamically adjusting segment lengths (2-5 nodes) with a 40% probability to improve solution quality. The method ensures feasibility by maintaining valid TSP tours through careful segment manipulation and cost comparisons.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic 3-opt with cost-aware segment length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    while i == j or j == k or k == i:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    i, j, k = sorted([i, j, k])\n\n    # Calculate current cost of the segments\n    cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n             distance_matrix_1[new_solution[k-1], new_solution[k]])\n    cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n             distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n    # Generate all possible 3-opt moves\n    segments = [\n        [new_solution[i:j], new_solution[j:k], new_solution[k:]],\n        [new_solution[i:j], new_solution[k:][::-1], new_solution[j:k][::-1]],\n        [new_solution[j:k], new_solution[i:j], new_solution[k:]],\n        [new_solution[j:k], new_solution[k:][::-1], new_solution[i:j][::-1]],\n        [new_solution[k:], new_solution[i:j], new_solution[j:k]],\n        [new_solution[k:][::-1], new_solution[j:k][::-1], new_solution[i:j]]\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all possible orderings\n    for seg1, seg2, seg3 in segments:\n        candidate = np.concatenate([new_solution[:i], seg1, seg2, seg3])\n        new_cost1 = (sum(distance_matrix_1[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_1[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_1[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        new_cost2 = (sum(distance_matrix_2[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_2[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_2[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        total_cost = new_cost1 + new_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.9513669212246623,
            0.4071865677833557
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on inverse combined objective values) and applies a hybrid local search combining edge insertion and segment reversal to generate a new feasible neighbor solution. It prioritizes solutions with better combined objective values while using random segment manipulation to explore the solution space while maintaining TSP feasibility. The method avoids 2-opt by using a novel combination of insertion and reversal operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined normalized improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate potential as inverse of combined objective\n        potential = 1.0 / (obj[0] + obj[1] + 1e-10)  # Add small epsilon to avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: move segment [i:j] to position k\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    k = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Segment reversal: reverse a random segment\n    l, m = np.random.choice(n, size=2, replace=False)\n    if l > m:\n        l, m = m, l\n    new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8677688148376028,
            0.21988224983215332
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with better combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility through validation. The selection heuristic focuses on solutions with lower total objectives, and the local search operator introduces diversity by randomly perturbing the tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def compute_potential(solution, obj1, obj2):\n        # Simple heuristic: prioritize solutions with better objectives\n        return obj1 + obj2\n\n    archive_with_potential = [(solution, obj1, obj2, compute_potential(solution, obj1, obj2))\n                              for solution, (obj1, obj2) in archive]\n    archive_with_potential.sort(key=lambda x: x[3])\n    selected = archive_with_potential[-1][0].copy()  # Select the most promising solution\n\n    # Hybrid local search: combine node insertion and edge reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8834512122886744,
            0.23437249660491943
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive using a weighted combination of normalized objectives (60% for the first objective, 40% for the second), then applies a hybrid local search combining 4-opt with adaptive segment reversal, dynamically adjusting reversal probabilities based on solution quality while ensuring feasibility through validation checks. The method prioritizes solutions with better objective values and uses both segment reordering and reversal to explore the search space, with fallback to the original solution if validation fails.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher than second\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive segment reversal\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Generate all possible 4-segment combinations\n    segments = [\n        new_solution[i:j], new_solution[j:k], new_solution[k:l], new_solution[l:] if l != n else np.array([])\n    ]\n\n    # Generate all possible orderings and reversals\n    from itertools import permutations\n    best_solution = new_solution.copy()\n    best_cost = np.inf\n\n    for perm in permutations(segments):\n        # Try both original and reversed segments\n        for reversal_mask in range(2**4):\n            current_solution = new_solution.copy()\n            temp_segments = list(perm)\n            for m in range(4):\n                if reversal_mask & (1 << m):\n                    temp_segments[m] = temp_segments[m][::-1]\n\n            # Reconstruct solution\n            new_tour = np.concatenate([\n                current_solution[:i],\n                *temp_segments,\n                current_solution[l:] if l != n else np.array([])\n            ])\n\n            # Check feasibility\n            if len(np.unique(new_tour)) == n:\n                # Evaluate cost\n                cost1 = sum(distance_matrix_1[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                cost2 = sum(distance_matrix_2[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_solution = new_tour.copy()\n\n    # Adaptive segment reversal based on solution quality\n    current_cost1 = sum(distance_matrix_1[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    current_cost2 = sum(distance_matrix_2[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    avg_cost = (current_cost1 + current_cost2) / 2\n\n    if avg_cost < np.mean(objectives[:, 0] + objectives[:, 1]) / 2:\n        # If solution is better than average, apply more aggressive reversal\n        reversal_prob = 0.5\n    else:\n        # If solution is worse than average, apply more conservative reversal\n        reversal_prob = 0.2\n\n    if np.random.rand() < reversal_prob:\n        rev_i, rev_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[rev_i:rev_j] = best_solution[rev_i:rev_j][::-1]\n\n    # Final validation check\n    if len(np.unique(best_solution)) != n:\n        # Fallback to original solution if validation fails\n        best_solution = base_solution.copy()\n\n    return best_solution\n\n",
        "score": [
            -0.891607011625859,
            11.704376697540283
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive based on normalized combined objectives, then applies a hybrid local search combining dynamic segment relocation with probabilistic segment fusion (40% chance) and segment inversion (30% chance), ensuring feasibility by checking for missing nodes and reinserting them randomly. The fusion process evaluates adjacent segment combinations to determine the most beneficial relocation, while the probabilistic inversion adds diversity to the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment relocation with probabilistic fusion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Determine segment length dynamically\n    segment_length = j - i\n    if segment_length > 1 and random.random() < 0.4:  # 40% chance to fuse with adjacent segments\n        # Try fusing with left and right segments\n        left_fusion = np.concatenate([new_solution[max(0, i-1):i], segment])\n        right_fusion = np.concatenate([segment, new_solution[j:min(j+2, n)]])\n\n        # Evaluate both fusion options\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            return cost1 + cost2\n\n        left_cost = evaluate(left_fusion)\n        right_cost = evaluate(right_fusion)\n\n        if left_cost < right_cost:\n            segment = left_fusion\n            i = max(0, i-1)\n        else:\n            segment = right_fusion\n\n    # Relocate the segment to a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic segment inversion\n    if random.random() < 0.3:  # 30% chance to invert a segment\n        inv_i, inv_j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[inv_i:inv_j] = new_solution[inv_i:inv_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7519570738412087,
            0.32621240615844727
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: select a solution with high crowding distance\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_order = np.argsort(objectives[:, i])\n            crowding_dist[sorted_order[0]] = np.inf\n            crowding_dist[sorted_order[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with objective-biased edge swapping\n    if n < 4:\n        # For small instances, perform a biased edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or np.random.rand() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to relocate\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n\n        # Find insertion point based on objective bias\n        if np.random.rand() < 0.5:\n            # Bias toward first objective\n            best_insert = -1\n            best_cost = np.inf\n            for insert_pos in range(segment_end, n):\n                if insert_pos == segment_start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:segment_start],\n                    new_solution[segment_end:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n                cost = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_insert = insert_pos\n        else:\n            # Bias toward second objective\n            best_insert = -1\n            best_cost = np.inf\n            for insert_pos in range(segment_end, n):\n                if insert_pos == segment_start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:segment_start],\n                    new_solution[segment_end:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n                cost = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_insert = insert_pos\n\n        if best_insert != -1:\n            new_solution = np.concatenate([\n                new_solution[:segment_start],\n                new_solution[segment_end:best_insert],\n                segment,\n                new_solution[best_insert:]\n            ])\n\n        # Perform objective-biased edge swaps\n        if np.random.rand() < 0.4:\n            i, j = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.5:\n                # Bias toward first objective\n                cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                if cost1_after < cost1_before:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Bias toward second objective\n                cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n                if cost2_after < cost2_before:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6456143647913559,
            0.9584646821022034
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive using crowding distance to identify solutions in less explored regions of the Pareto front, then applies a hybrid local search combining 4-opt with adaptive segment reversal. It evaluates all possible segment orderings and reversals to find the best improvement while occasionally applying probabilistic segment reversals to escape local optima. The method prioritizes solutions with diverse objective improvements while ensuring feasibility through careful segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_idx = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n\n    for i in range(objectives.shape[1]):\n        sorted_obj = objectives[sorted_idx[:, i], i]\n        normalized_obj = (sorted_obj - np.min(sorted_obj)) / (np.max(sorted_obj) - np.min(sorted_obj) + 1e-8)\n        crowding[sorted_idx[0, i]] += np.inf\n        crowding[sorted_idx[-1, i]] += np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j, i]] += normalized_obj[j+1] - normalized_obj[j-1]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive segment reversal\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Apply 4-opt\n    segments = [\n        new_solution[i:j],\n        new_solution[j:k],\n        new_solution[k:l],\n        new_solution[l:] if l != n else np.array([])\n    ]\n\n    # Generate all possible orderings and reversals\n    from itertools import permutations\n    orderings = []\n    for perm in permutations(range(4)):\n        for rev_mask in range(16):  # 4 segments, each can be reversed (2^4 = 16 combinations)\n            temp = new_solution[:i].copy()\n            for idx in perm:\n                segment = segments[idx].copy()\n                if rev_mask & (1 << idx):\n                    segment = segment[::-1]\n                temp = np.concatenate([temp, segment])\n            orderings.append(temp)\n\n    # Evaluate and select best ordering\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Adaptive segment reversal based on objective improvement\n    if np.random.rand() < 0.5:\n        rev_i, rev_j = sorted(np.random.choice(n, 2, replace=False))\n        original_cost1 = sum(distance_matrix_1[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n        original_cost2 = sum(distance_matrix_2[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n\n        reversed_segment = best_solution.copy()\n        reversed_segment[rev_i:rev_j] = reversed_segment[rev_i:rev_j][::-1]\n\n        new_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n        new_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.2 * (1 - (new_cost1 + new_cost2) / (original_cost1 + original_cost2 + 1e-8))):\n            best_solution = reversed_segment\n\n    return best_solution\n\n",
        "score": [
            -0.7321734195798153,
            10.81631624698639
        ]
    }
]