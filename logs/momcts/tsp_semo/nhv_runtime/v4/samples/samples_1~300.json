[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "score": [
            -1.007662801692291,
            0.3636525273323059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "score": [
            -1.007662801692291,
            0.3636525273323059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "score": [
            -1.007662801692291,
            0.3636525273323059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.9140602379001828,
            0.13315963745117188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.9140602379001828,
            0.13315963745117188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The algorithm selects the most promising solution from the archive (based on inverse combined objective values) and applies a hybrid local search combining edge insertion and segment reversal to generate a new feasible neighbor solution. It prioritizes solutions with better combined objective values while using random segment manipulation to explore the solution space while maintaining TSP feasibility. The method avoids 2-opt by using a novel combination of insertion and reversal operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined normalized improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate potential as inverse of combined objective\n        potential = 1.0 / (obj[0] + obj[1] + 1e-10)  # Add small epsilon to avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: move segment [i:j] to position k\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    k = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Segment reversal: reverse a random segment\n    l, m = np.random.choice(n, size=2, replace=False)\n    if l > m:\n        l, m = m, l\n    new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8677688148376028,
            0.21988224983215332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined normalized improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate potential as inverse of combined objective\n        potential = 1.0 / (obj[0] + obj[1] + 1e-10)  # Add small epsilon to avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: move segment [i:j] to position k\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    k = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Segment reversal: reverse a random segment\n    l, m = np.random.choice(n, size=2, replace=False)\n    if l > m:\n        l, m = m, l\n    new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9311444140549993,
            0.28459417819976807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with better combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility through validation. The selection heuristic focuses on solutions with lower total objectives, and the local search operator introduces diversity by randomly perturbing the tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def compute_potential(solution, obj1, obj2):\n        # Simple heuristic: prioritize solutions with better objectives\n        return obj1 + obj2\n\n    archive_with_potential = [(solution, obj1, obj2, compute_potential(solution, obj1, obj2))\n                              for solution, (obj1, obj2) in archive]\n    archive_with_potential.sort(key=lambda x: x[3])\n    selected = archive_with_potential[-1][0].copy()  # Select the most promising solution\n\n    # Hybrid local search: combine node insertion and edge reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8834512122886744,
            0.23437249660491943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def compute_potential(solution, obj1, obj2):\n        # Simple heuristic: prioritize solutions with better objectives\n        return obj1 + obj2\n\n    archive_with_potential = [(solution, obj1, obj2, compute_potential(solution, obj1, obj2))\n                              for solution, (obj1, obj2) in archive]\n    archive_with_potential.sort(key=lambda x: x[3])\n    selected = archive_with_potential[-1][0].copy()  # Select the most promising solution\n\n    # Hybrid local search: combine node insertion and edge reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm selects the most promising solution from the archive based on normalized combined objectives, then applies a hybrid local search combining dynamic segment relocation with probabilistic segment fusion (40% chance) and segment inversion (30% chance), ensuring feasibility by checking for missing nodes and reinserting them randomly. The fusion process evaluates adjacent segment combinations to determine the most beneficial relocation, while the probabilistic inversion adds diversity to the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment relocation with probabilistic fusion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Determine segment length dynamically\n    segment_length = j - i\n    if segment_length > 1 and random.random() < 0.4:  # 40% chance to fuse with adjacent segments\n        # Try fusing with left and right segments\n        left_fusion = np.concatenate([new_solution[max(0, i-1):i], segment])\n        right_fusion = np.concatenate([segment, new_solution[j:min(j+2, n)]])\n\n        # Evaluate both fusion options\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            return cost1 + cost2\n\n        left_cost = evaluate(left_fusion)\n        right_cost = evaluate(right_fusion)\n\n        if left_cost < right_cost:\n            segment = left_fusion\n            i = max(0, i-1)\n        else:\n            segment = right_fusion\n\n    # Relocate the segment to a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic segment inversion\n    if random.random() < 0.3:  # 30% chance to invert a segment\n        inv_i, inv_j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[inv_i:inv_j] = new_solution[inv_i:inv_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7519570738412087,
            0.32621240615844727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment relocation with probabilistic fusion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n\n    # Determine segment length dynamically\n    segment_length = j - i\n    if segment_length > 1 and random.random() < 0.4:  # 40% chance to fuse with adjacent segments\n        # Try fusing with left and right segments\n        left_fusion = np.concatenate([new_solution[max(0, i-1):i], segment])\n        right_fusion = np.concatenate([segment, new_solution[j:min(j+2, n)]])\n\n        # Evaluate both fusion options\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n            cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n            return cost1 + cost2\n\n        left_cost = evaluate(left_fusion)\n        right_cost = evaluate(right_fusion)\n\n        if left_cost < right_cost:\n            segment = left_fusion\n            i = max(0, i-1)\n        else:\n            segment = right_fusion\n\n    # Relocate the segment to a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Probabilistic segment inversion\n    if random.random() < 0.3:  # 30% chance to invert a segment\n        inv_i, inv_j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[inv_i:inv_j] = new_solution[inv_i:inv_j][::-1]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 7,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: select a solution with high crowding distance\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_order = np.argsort(objectives[:, i])\n            crowding_dist[sorted_order[0]] = np.inf\n            crowding_dist[sorted_order[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with objective-biased edge swapping\n    if n < 4:\n        # For small instances, perform a biased edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or np.random.rand() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to relocate\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n\n        # Find insertion point based on objective bias\n        if np.random.rand() < 0.5:\n            # Bias toward first objective\n            best_insert = -1\n            best_cost = np.inf\n            for insert_pos in range(segment_end, n):\n                if insert_pos == segment_start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:segment_start],\n                    new_solution[segment_end:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n                cost = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_insert = insert_pos\n        else:\n            # Bias toward second objective\n            best_insert = -1\n            best_cost = np.inf\n            for insert_pos in range(segment_end, n):\n                if insert_pos == segment_start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:segment_start],\n                    new_solution[segment_end:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n                cost = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_insert = insert_pos\n\n        if best_insert != -1:\n            new_solution = np.concatenate([\n                new_solution[:segment_start],\n                new_solution[segment_end:best_insert],\n                segment,\n                new_solution[best_insert:]\n            ])\n\n        # Perform objective-biased edge swaps\n        if np.random.rand() < 0.4:\n            i, j = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.5:\n                # Bias toward first objective\n                cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                if cost1_after < cost1_before:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Bias toward second objective\n                cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n                if cost2_after < cost2_before:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6456143647913559,
            0.9584646821022034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: select a solution with high crowding distance\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_dist = np.zeros(len(archive))\n        for i in range(2):\n            sorted_order = np.argsort(objectives[:, i])\n            crowding_dist[sorted_order[0]] = np.inf\n            crowding_dist[sorted_order[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_dist[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-10)\n\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with objective-biased edge swapping\n    if n < 4:\n        # For small instances, perform a biased edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or np.random.rand() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to relocate\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n\n        # Find insertion point based on objective bias\n        if np.random.rand() < 0.5:\n            # Bias toward first objective\n            best_insert = -1\n            best_cost = np.inf\n            for insert_pos in range(segment_end, n):\n                if insert_pos == segment_start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:segment_start],\n                    new_solution[segment_end:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n                cost = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_insert = insert_pos\n        else:\n            # Bias toward second objective\n            best_insert = -1\n            best_cost = np.inf\n            for insert_pos in range(segment_end, n):\n                if insert_pos == segment_start:\n                    continue\n                temp_sol = np.concatenate([\n                    new_solution[:segment_start],\n                    new_solution[segment_end:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n                cost = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_insert = insert_pos\n\n        if best_insert != -1:\n            new_solution = np.concatenate([\n                new_solution[:segment_start],\n                new_solution[segment_end:best_insert],\n                segment,\n                new_solution[best_insert:]\n            ])\n\n        # Perform objective-biased edge swaps\n        if np.random.rand() < 0.4:\n            i, j = np.random.choice(n, 2, replace=False)\n            if np.random.rand() < 0.5:\n                # Bias toward first objective\n                cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                if cost1_after < cost1_before:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Bias toward second objective\n                cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n                if cost2_after < cost2_before:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "The algorithm selects the best solution from the archive using a weighted combination of normalized objectives (60% for the first objective, 40% for the second), then applies a hybrid local search combining 4-opt with adaptive segment reversal, dynamically adjusting reversal probabilities based on solution quality while ensuring feasibility through validation checks. The method prioritizes solutions with better objective values and uses both segment reordering and reversal to explore the search space, with fallback to the original solution if validation fails.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher than second\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive segment reversal\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Generate all possible 4-segment combinations\n    segments = [\n        new_solution[i:j], new_solution[j:k], new_solution[k:l], new_solution[l:] if l != n else np.array([])\n    ]\n\n    # Generate all possible orderings and reversals\n    from itertools import permutations\n    best_solution = new_solution.copy()\n    best_cost = np.inf\n\n    for perm in permutations(segments):\n        # Try both original and reversed segments\n        for reversal_mask in range(2**4):\n            current_solution = new_solution.copy()\n            temp_segments = list(perm)\n            for m in range(4):\n                if reversal_mask & (1 << m):\n                    temp_segments[m] = temp_segments[m][::-1]\n\n            # Reconstruct solution\n            new_tour = np.concatenate([\n                current_solution[:i],\n                *temp_segments,\n                current_solution[l:] if l != n else np.array([])\n            ])\n\n            # Check feasibility\n            if len(np.unique(new_tour)) == n:\n                # Evaluate cost\n                cost1 = sum(distance_matrix_1[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                cost2 = sum(distance_matrix_2[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_solution = new_tour.copy()\n\n    # Adaptive segment reversal based on solution quality\n    current_cost1 = sum(distance_matrix_1[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    current_cost2 = sum(distance_matrix_2[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    avg_cost = (current_cost1 + current_cost2) / 2\n\n    if avg_cost < np.mean(objectives[:, 0] + objectives[:, 1]) / 2:\n        # If solution is better than average, apply more aggressive reversal\n        reversal_prob = 0.5\n    else:\n        # If solution is worse than average, apply more conservative reversal\n        reversal_prob = 0.2\n\n    if np.random.rand() < reversal_prob:\n        rev_i, rev_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[rev_i:rev_j] = best_solution[rev_i:rev_j][::-1]\n\n    # Final validation check\n    if len(np.unique(best_solution)) != n:\n        # Fallback to original solution if validation fails\n        best_solution = base_solution.copy()\n\n    return best_solution\n\n",
        "score": [
            -0.891607011625859,
            11.704376697540283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best weighted combination of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher than second\n    scores = np.dot(norm_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive segment reversal\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Generate all possible 4-segment combinations\n    segments = [\n        new_solution[i:j], new_solution[j:k], new_solution[k:l], new_solution[l:] if l != n else np.array([])\n    ]\n\n    # Generate all possible orderings and reversals\n    from itertools import permutations\n    best_solution = new_solution.copy()\n    best_cost = np.inf\n\n    for perm in permutations(segments):\n        # Try both original and reversed segments\n        for reversal_mask in range(2**4):\n            current_solution = new_solution.copy()\n            temp_segments = list(perm)\n            for m in range(4):\n                if reversal_mask & (1 << m):\n                    temp_segments[m] = temp_segments[m][::-1]\n\n            # Reconstruct solution\n            new_tour = np.concatenate([\n                current_solution[:i],\n                *temp_segments,\n                current_solution[l:] if l != n else np.array([])\n            ])\n\n            # Check feasibility\n            if len(np.unique(new_tour)) == n:\n                # Evaluate cost\n                cost1 = sum(distance_matrix_1[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                cost2 = sum(distance_matrix_2[new_tour[i-1], new_tour[i]] for i in range(len(new_tour)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_solution = new_tour.copy()\n\n    # Adaptive segment reversal based on solution quality\n    current_cost1 = sum(distance_matrix_1[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    current_cost2 = sum(distance_matrix_2[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n    avg_cost = (current_cost1 + current_cost2) / 2\n\n    if avg_cost < np.mean(objectives[:, 0] + objectives[:, 1]) / 2:\n        # If solution is better than average, apply more aggressive reversal\n        reversal_prob = 0.5\n    else:\n        # If solution is worse than average, apply more conservative reversal\n        reversal_prob = 0.2\n\n    if np.random.rand() < reversal_prob:\n        rev_i, rev_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[rev_i:rev_j] = best_solution[rev_i:rev_j][::-1]\n\n    # Final validation check\n    if len(np.unique(best_solution)) != n:\n        # Fallback to original solution if validation fails\n        best_solution = base_solution.copy()\n\n    return best_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 9,
        "algorithm": "The algorithm selects the most promising solution from the archive using crowding distance to identify solutions in less explored regions of the Pareto front, then applies a hybrid local search combining 4-opt with adaptive segment reversal. It evaluates all possible segment orderings and reversals to find the best improvement while occasionally applying probabilistic segment reversals to escape local optima. The method prioritizes solutions with diverse objective improvements while ensuring feasibility through careful segment manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_idx = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n\n    for i in range(objectives.shape[1]):\n        sorted_obj = objectives[sorted_idx[:, i], i]\n        normalized_obj = (sorted_obj - np.min(sorted_obj)) / (np.max(sorted_obj) - np.min(sorted_obj) + 1e-8)\n        crowding[sorted_idx[0, i]] += np.inf\n        crowding[sorted_idx[-1, i]] += np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j, i]] += normalized_obj[j+1] - normalized_obj[j-1]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive segment reversal\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Apply 4-opt\n    segments = [\n        new_solution[i:j],\n        new_solution[j:k],\n        new_solution[k:l],\n        new_solution[l:] if l != n else np.array([])\n    ]\n\n    # Generate all possible orderings and reversals\n    from itertools import permutations\n    orderings = []\n    for perm in permutations(range(4)):\n        for rev_mask in range(16):  # 4 segments, each can be reversed (2^4 = 16 combinations)\n            temp = new_solution[:i].copy()\n            for idx in perm:\n                segment = segments[idx].copy()\n                if rev_mask & (1 << idx):\n                    segment = segment[::-1]\n                temp = np.concatenate([temp, segment])\n            orderings.append(temp)\n\n    # Evaluate and select best ordering\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Adaptive segment reversal based on objective improvement\n    if np.random.rand() < 0.5:\n        rev_i, rev_j = sorted(np.random.choice(n, 2, replace=False))\n        original_cost1 = sum(distance_matrix_1[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n        original_cost2 = sum(distance_matrix_2[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n\n        reversed_segment = best_solution.copy()\n        reversed_segment[rev_i:rev_j] = reversed_segment[rev_i:rev_j][::-1]\n\n        new_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n        new_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.2 * (1 - (new_cost1 + new_cost2) / (original_cost1 + original_cost2 + 1e-8))):\n            best_solution = reversed_segment\n\n    return best_solution\n\n",
        "score": [
            -0.7321734195798153,
            10.81631624698639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_idx = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n\n    for i in range(objectives.shape[1]):\n        sorted_obj = objectives[sorted_idx[:, i], i]\n        normalized_obj = (sorted_obj - np.min(sorted_obj)) / (np.max(sorted_obj) - np.min(sorted_obj) + 1e-8)\n        crowding[sorted_idx[0, i]] += np.inf\n        crowding[sorted_idx[-1, i]] += np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j, i]] += normalized_obj[j+1] - normalized_obj[j-1]\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 4-opt with adaptive segment reversal\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    # Apply 4-opt\n    segments = [\n        new_solution[i:j],\n        new_solution[j:k],\n        new_solution[k:l],\n        new_solution[l:] if l != n else np.array([])\n    ]\n\n    # Generate all possible orderings and reversals\n    from itertools import permutations\n    orderings = []\n    for perm in permutations(range(4)):\n        for rev_mask in range(16):  # 4 segments, each can be reversed (2^4 = 16 combinations)\n            temp = new_solution[:i].copy()\n            for idx in perm:\n                segment = segments[idx].copy()\n                if rev_mask & (1 << idx):\n                    segment = segment[::-1]\n                temp = np.concatenate([temp, segment])\n            orderings.append(temp)\n\n    # Evaluate and select best ordering\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Adaptive segment reversal based on objective improvement\n    if np.random.rand() < 0.5:\n        rev_i, rev_j = sorted(np.random.choice(n, 2, replace=False))\n        original_cost1 = sum(distance_matrix_1[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n        original_cost2 = sum(distance_matrix_2[best_solution[i-1], best_solution[i]] for i in range(len(best_solution)))\n\n        reversed_segment = best_solution.copy()\n        reversed_segment[rev_i:rev_j] = reversed_segment[rev_i:rev_j][::-1]\n\n        new_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n        new_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.2 * (1 - (new_cost1 + new_cost2) / (original_cost1 + original_cost2 + 1e-8))):\n            best_solution = reversed_segment\n\n    return best_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 3 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: ### Ineffective Self-Reflection (4 Points)\n- **Keywords**: Dominated heuristics, segment length variation, cost-aware selection, feasibility checks.\n- **Advice**: Focus on hybridizing intelligent selection (e.g., normalized objectives) with novel local search (e.g., variable-length segment operations). Prioritize cost evaluation over randomness.\n- **Avoid**: Over-reliance on dominated heuristics or simplistic segment reversals. Ignore feasibility checks mid-operation.\n- **Explanation**: Balancing exploration/exploitation via cost-aware selection and variable-length segments ensures high-quality neighbors while preserving feasibility. Dominated heuristics lack structure; dominated heuristics are only useful for initialization.\n\n---\n**Next Step**: Design a heuristic combining normalized objective evaluation with a 3-opt variant that dynamically adjusts segment lengths based on local cost gradients.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 10,
        "algorithm": "The algorithm selects the most promising solution from the archive by normalizing objectives and applying a dynamic 3-opt variant that intelligently adjusts segment lengths based on local cost gradients, ensuring feasibility through cost-aware segment operations. It prioritizes solutions with higher combined normalized objectives and evaluates all possible 3-opt moves while dynamically adjusting segment lengths (2-5 nodes) with a 40% probability to improve solution quality. The method ensures feasibility by maintaining valid TSP tours through careful segment manipulation and cost comparisons.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic 3-opt with cost-aware segment length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    while i == j or j == k or k == i:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    i, j, k = sorted([i, j, k])\n\n    # Calculate current cost of the segments\n    cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n             distance_matrix_1[new_solution[k-1], new_solution[k]])\n    cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n             distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n    # Generate all possible 3-opt moves\n    segments = [\n        [new_solution[i:j], new_solution[j:k], new_solution[k:]],\n        [new_solution[i:j], new_solution[k:][::-1], new_solution[j:k][::-1]],\n        [new_solution[j:k], new_solution[i:j], new_solution[k:]],\n        [new_solution[j:k], new_solution[k:][::-1], new_solution[i:j][::-1]],\n        [new_solution[k:], new_solution[i:j], new_solution[j:k]],\n        [new_solution[k:][::-1], new_solution[j:k][::-1], new_solution[i:j]]\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all possible orderings\n    for seg1, seg2, seg3 in segments:\n        candidate = np.concatenate([new_solution[:i], seg1, seg2, seg3])\n        new_cost1 = (sum(distance_matrix_1[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_1[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_1[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        new_cost2 = (sum(distance_matrix_2[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_2[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_2[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        total_cost = new_cost1 + new_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.9513669212246623,
            0.4071865677833557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic 3-opt with cost-aware segment length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    while i == j or j == k or k == i:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    i, j, k = sorted([i, j, k])\n\n    # Calculate current cost of the segments\n    cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n             distance_matrix_1[new_solution[k-1], new_solution[k]])\n    cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n             distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n    # Generate all possible 3-opt moves\n    segments = [\n        [new_solution[i:j], new_solution[j:k], new_solution[k:]],\n        [new_solution[i:j], new_solution[k:][::-1], new_solution[j:k][::-1]],\n        [new_solution[j:k], new_solution[i:j], new_solution[k:]],\n        [new_solution[j:k], new_solution[k:][::-1], new_solution[i:j][::-1]],\n        [new_solution[k:], new_solution[i:j], new_solution[j:k]],\n        [new_solution[k:][::-1], new_solution[j:k][::-1], new_solution[i:j]]\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all possible orderings\n    for seg1, seg2, seg3 in segments:\n        candidate = np.concatenate([new_solution[:i], seg1, seg2, seg3])\n        new_cost1 = (sum(distance_matrix_1[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_1[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_1[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        new_cost2 = (sum(distance_matrix_2[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_2[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_2[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        total_cost = new_cost1 + new_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the most promising solution from the archive by normalizing objectives and applying a dynamic 3-opt variant that intelligently adjusts segment lengths based on local cost gradients, ensuring feasibility through cost-aware segment operations. It prioritizes solutions with higher combined normalized objectives and evaluates all possible 3-opt moves while dynamically adjusting segment lengths (2-5 nodes) with a 40% probability to improve solution quality. The method ensures feasibility by maintaining valid TSP tours through careful segment manipulation and cost comparisons.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic 3-opt with cost-aware segment length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    while i == j or j == k or k == i:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    i, j, k = sorted([i, j, k])\n\n    # Calculate current cost of the segments\n    cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n             distance_matrix_1[new_solution[k-1], new_solution[k]])\n    cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n             distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n    # Generate all possible 3-opt moves\n    segments = [\n        [new_solution[i:j], new_solution[j:k], new_solution[k:]],\n        [new_solution[i:j], new_solution[k:][::-1], new_solution[j:k][::-1]],\n        [new_solution[j:k], new_solution[i:j], new_solution[k:]],\n        [new_solution[j:k], new_solution[k:][::-1], new_solution[i:j][::-1]],\n        [new_solution[k:], new_solution[i:j], new_solution[j:k]],\n        [new_solution[k:][::-1], new_solution[j:k][::-1], new_solution[i:j]]\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all possible orderings\n    for seg1, seg2, seg3 in segments:\n        candidate = np.concatenate([new_solution[:i], seg1, seg2, seg3])\n        new_cost1 = (sum(distance_matrix_1[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_1[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_1[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        new_cost2 = (sum(distance_matrix_2[candidate[l-1], candidate[l]] for l in range(len(candidate))) +\n                     sum(distance_matrix_2[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) +\n                     sum(distance_matrix_2[seg2[l-1], seg2[l]] for l in range(1, len(seg2))))\n        total_cost = new_cost1 + new_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection (4 Points)\n- **Keywords**: Dominated heuristics, segment length variation, cost-aware selection, feasibility checks.\n- **Advice**: Focus on hybridizing intelligent selection (e.g., normalized objectives) with novel local search (e.g., variable-length segment operations). Prioritize cost evaluation over randomness.\n- **Avoid**: Over-reliance on dominated heuristics or simplistic segment reversals. Ignore feasibility checks mid-operation.\n- **Explanation**: Balancing exploration/exploitation via cost-aware selection and variable-length segments ensures high-quality neighbors while preserving feasibility. Dominated heuristics lack structure; dominated heuristics are only useful for initialization.\n\n---\n**Next Step**: Design a heuristic combining normalized objective evaluation with a 3-opt variant that dynamically adjusts segment lengths based on local cost gradients.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm combines cost-aware selection with a dynamic segment insertion operator that intelligently selects solutions based on normalized objectives and applies variable-length segment insertions guided by local cost gradients, ensuring feasibility through cost-aware segment operations and maintaining diversity by prioritizing non-dominated solutions while dynamically adjusting segment lengths (2-5 nodes) with a 40% probability to improve solution quality. The selection prioritizes solutions with higher combined normalized objectives, and the local search explores multiple candidate segment insertions (including reversals) to find cost-improving moves, with an additional 40% chance to dynamically adjust segment lengths for further optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment insertion with cost-aware length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    i, j = sorted([i, j])\n\n    # Calculate current cost of the segments\n    cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    # Determine segment length dynamically\n    segment_length = np.random.randint(2, min(6, n//3))\n    if i + segment_length >= n:\n        segment_length = n - i - 1\n    if j + segment_length >= n:\n        segment_length = n - j - 1\n\n    # Extract segments to insert\n    segment1 = new_solution[i:i+segment_length]\n    segment2 = new_solution[j:j+segment_length]\n\n    # Generate candidate solutions by inserting segments\n    candidates = [\n        np.concatenate([new_solution[:i], segment2, new_solution[i:j], segment1, new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment1, new_solution[i:j], segment2, new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment1[::-1], new_solution[i:j], segment2[::-1], new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment2[::-1], new_solution[i:j], segment1[::-1], new_solution[j+segment_length:]])\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all candidates\n    for candidate in candidates:\n        total_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n        total_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n        total_cost = total_cost1 + total_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.9272425605659993,
            0.319599986076355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment insertion with cost-aware length adjustment\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while i == j:\n        j = np.random.randint(0, n)\n\n    i, j = sorted([i, j])\n\n    # Calculate current cost of the segments\n    cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    # Determine segment length dynamically\n    segment_length = np.random.randint(2, min(6, n//3))\n    if i + segment_length >= n:\n        segment_length = n - i - 1\n    if j + segment_length >= n:\n        segment_length = n - j - 1\n\n    # Extract segments to insert\n    segment1 = new_solution[i:i+segment_length]\n    segment2 = new_solution[j:j+segment_length]\n\n    # Generate candidate solutions by inserting segments\n    candidates = [\n        np.concatenate([new_solution[:i], segment2, new_solution[i:j], segment1, new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment1, new_solution[i:j], segment2, new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment1[::-1], new_solution[i:j], segment2[::-1], new_solution[j+segment_length:]]),\n        np.concatenate([new_solution[:i], segment2[::-1], new_solution[i:j], segment1[::-1], new_solution[j+segment_length:]])\n    ]\n\n    best_solution = new_solution.copy()\n    best_cost = cost1 + cost2\n\n    # Evaluate all candidates\n    for candidate in candidates:\n        total_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n        total_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n        total_cost = total_cost1 + total_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = candidate.copy()\n\n    # Dynamic segment length adjustment based on cost gradients\n    if np.random.rand() < 0.4:  # 40% chance to adjust segment lengths\n        segment_length = np.random.randint(2, min(6, n//3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate cost of current segment\n        current_cost1 = sum(distance_matrix_1[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n        current_cost2 = sum(distance_matrix_2[best_solution[l-1], best_solution[l]] for l in range(start, end+1))\n\n        # Try expanding the segment\n        if end < n - 1:\n            expanded_cost1 = current_cost1 + distance_matrix_1[best_solution[end], best_solution[end+1]]\n            expanded_cost2 = current_cost2 + distance_matrix_2[best_solution[end], best_solution[end+1]]\n            if (expanded_cost1 + expanded_cost2) < (current_cost1 + current_cost2):\n                end += 1\n\n        # Try shrinking the segment\n        if end > start + 1:\n            shrunk_cost1 = current_cost1 - distance_matrix_1[best_solution[end-1], best_solution[end]]\n            shrunk_cost2 = current_cost2 - distance_matrix_2[best_solution[end-1], best_solution[end]]\n            if (shrunk_cost1 + shrunk_cost2) < (current_cost1 + current_cost2):\n                end -= 1\n\n        # Apply the adjusted segment\n        if end > start:\n            best_solution[start:end] = best_solution[start:end][::-1]\n\n    return best_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with better combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility through validation. The selection heuristic focuses on solutions with lower total objectives, and the local search operator introduces diversity by randomly perturbing the tour structure.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def compute_potential(solution, obj1, obj2):\n        # Simple heuristic: prioritize solutions with better objectives\n        return obj1 + obj2\n\n    archive_with_potential = [(solution, obj1, obj2, compute_potential(solution, obj1, obj2))\n                              for solution, (obj1, obj2) in archive]\n    archive_with_potential.sort(key=lambda x: x[3])\n    selected = archive_with_potential[-1][0].copy()  # Select the most promising solution\n\n    # Hybrid local search: combine node insertion and edge reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            ### Ineffective Self-Reflection (4 Points)\n- **Keywords**: Dominated heuristics, segment length variation, cost-aware selection, feasibility checks.\n- **Advice**: Focus on hybridizing intelligent selection (e.g., normalized objectives) with novel local search (e.g., variable-length segment operations). Prioritize cost evaluation over randomness.\n- **Avoid**: Over-reliance on dominated heuristics or simplistic segment reversals. Ignore feasibility checks mid-operation.\n- **Explanation**: Balancing exploration/exploitation via cost-aware selection and variable-length segments ensures high-quality neighbors while preserving feasibility. Dominated heuristics lack structure; dominated heuristics are only useful for initialization.\n\n---\n**Next Step**: Design a heuristic combining normalized objective evaluation with a 3-opt variant that dynamically adjusts segment lengths based on local cost gradients.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 12,
        "algorithm": "The algorithm selects a promising solution from the archive using normalized objective values (summing normalized costs from both spaces) and applies a dynamic 3-opt variant, prioritizing segments with low combined cost gradients from both objectives. It then performs variable-length segment reversals and edge insertions while ensuring feasibility through uniqueness checks. The selection emphasizes solutions with better relative performance, while the local search adaptively explores neighborhoods based on local cost gradients.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalized objective-based selection\n    def normalized_objective(obj1, obj2, min_obj1, max_obj1, min_obj2, max_obj2):\n        if max_obj1 == min_obj1:\n            norm_obj1 = 0.0\n        else:\n            norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n        if max_obj2 == min_obj2:\n            norm_obj2 = 0.0\n        else:\n            norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n        return norm_obj1 + norm_obj2\n\n    objectives = [obj for _, obj in archive]\n    min_obj1, max_obj1 = min(obj[0] for obj in objectives), max(obj[0] for obj in objectives)\n    min_obj2, max_obj2 = min(obj[1] for obj in objectives), max(obj[1] for obj in objectives)\n\n    archive_with_score = [\n        (solution, normalized_objective(obj1, obj2, min_obj1, max_obj1, min_obj2, max_obj2))\n        for (solution, (obj1, obj2)) in archive\n    ]\n    archive_with_score.sort(key=lambda x: x[1])\n    selected = archive_with_score[-1][0].copy()  # Select the most promising solution\n\n    # Dynamic 3-opt variant\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine segment lengths based on local cost gradients\n        def compute_gradient(solution, pos, distance_matrix):\n            prev_node = solution[pos - 1]\n            curr_node = solution[pos]\n            next_node = solution[(pos + 1) % n]\n            gradient = distance_matrix[prev_node, curr_node] + distance_matrix[curr_node, next_node]\n            return gradient\n\n        # Select segments based on cost gradients\n        gradients_1 = [compute_gradient(new_solution, i, distance_matrix_1) for i in range(n)]\n        gradients_2 = [compute_gradient(new_solution, i, distance_matrix_2) for i in range(n)]\n        combined_gradients = [g1 + g2 for g1, g2 in zip(gradients_1, gradients_2)]\n        sorted_indices = sorted(range(n), key=lambda i: combined_gradients[i])\n        low_gradient_indices = sorted_indices[:max(2, n // 4)]\n\n        # Randomly select a segment to reverse\n        i = np.random.choice(low_gradient_indices)\n        j = np.random.randint(i, min(i + n // 3, n))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.choice([idx for idx in range(n) if idx not in range(i, j+1)])\n            edge = new_solution[edge_pos:edge_pos+2]\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                edge,\n                new_solution[insert_pos:edge_pos],\n                new_solution[edge_pos+2:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8869527211667101,
            0.2799438238143921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalized objective-based selection\n    def normalized_objective(obj1, obj2, min_obj1, max_obj1, min_obj2, max_obj2):\n        if max_obj1 == min_obj1:\n            norm_obj1 = 0.0\n        else:\n            norm_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n        if max_obj2 == min_obj2:\n            norm_obj2 = 0.0\n        else:\n            norm_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n        return norm_obj1 + norm_obj2\n\n    objectives = [obj for _, obj in archive]\n    min_obj1, max_obj1 = min(obj[0] for obj in objectives), max(obj[0] for obj in objectives)\n    min_obj2, max_obj2 = min(obj[1] for obj in objectives), max(obj[1] for obj in objectives)\n\n    archive_with_score = [\n        (solution, normalized_objective(obj1, obj2, min_obj1, max_obj1, min_obj2, max_obj2))\n        for (solution, (obj1, obj2)) in archive\n    ]\n    archive_with_score.sort(key=lambda x: x[1])\n    selected = archive_with_score[-1][0].copy()  # Select the most promising solution\n\n    # Dynamic 3-opt variant\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine segment lengths based on local cost gradients\n        def compute_gradient(solution, pos, distance_matrix):\n            prev_node = solution[pos - 1]\n            curr_node = solution[pos]\n            next_node = solution[(pos + 1) % n]\n            gradient = distance_matrix[prev_node, curr_node] + distance_matrix[curr_node, next_node]\n            return gradient\n\n        # Select segments based on cost gradients\n        gradients_1 = [compute_gradient(new_solution, i, distance_matrix_1) for i in range(n)]\n        gradients_2 = [compute_gradient(new_solution, i, distance_matrix_2) for i in range(n)]\n        combined_gradients = [g1 + g2 for g1, g2 in zip(gradients_1, gradients_2)]\n        sorted_indices = sorted(range(n), key=lambda i: combined_gradients[i])\n        low_gradient_indices = sorted_indices[:max(2, n // 4)]\n\n        # Randomly select a segment to reverse\n        i = np.random.choice(low_gradient_indices)\n        j = np.random.randint(i, min(i + n // 3, n))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.choice([idx for idx in range(n) if idx not in range(i, j+1)])\n            edge = new_solution[edge_pos:edge_pos+2]\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                edge,\n                new_solution[insert_pos:edge_pos],\n                new_solution[edge_pos+2:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 13,
        "algorithm": "The algorithm selects a high-quality solution from the archive by prioritizing those with high diversity (low edge overlap with other solutions) and good objective values, then applies a hybrid local search combining segment inversion and edge relocation with adaptive perturbation to generate a feasible neighbor solution while avoiding local optima. The selection criterion balances diversity and objective improvement, while the local search uses probabilistic segment lengths and edge relocations to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined diversity and objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        sol_i = archive[i][0]\n        dist1 = sum(distance_matrix_1[sol_i[j], sol_i[j+1]] for j in range(len(sol_i)-1)) + distance_matrix_1[sol_i[-1], sol_i[0]]\n        dist2 = sum(distance_matrix_2[sol_i[j], sol_i[j+1]] for j in range(len(sol_i)-1)) + distance_matrix_2[sol_i[-1], sol_i[0]]\n\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            sol_j = archive[j][0]\n            shared_edges = sum(1 for a in range(len(sol_i)) for b in range(len(sol_j)) if sol_i[a] == sol_j[b] and sol_i[(a+1)%len(sol_i)] == sol_j[(b+1)%len(sol_j)])\n            diversity[i] += shared_edges / (len(sol_i) * len(sol_j))\n\n    scores = (1 - diversity) * (1 - (objectives[:,0] + objectives[:,1]) / (objectives[:,0].max() + objectives[:,1].max() + 1e-8))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive perturbation\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment inversion with adaptive length\n        segment_length = min(n//2, max(2, int(np.random.normal(n//4, n//8))))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Edge relocation with adaptive selection\n        if n > 4:\n            relocate_pos = np.random.randint(0, n)\n            edge_pos = np.random.randint(0, n)\n            while abs(edge_pos - relocate_pos) < 2 and n > 3:\n                edge_pos = np.random.randint(0, n)\n\n            edge = new_solution[edge_pos]\n            new_solution = np.concatenate([\n                new_solution[:relocate_pos],\n                np.array([edge]),\n                new_solution[relocate_pos:edge_pos],\n                new_solution[edge_pos+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.779449504256453,
            11.382856011390686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined diversity and objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        sol_i = archive[i][0]\n        dist1 = sum(distance_matrix_1[sol_i[j], sol_i[j+1]] for j in range(len(sol_i)-1)) + distance_matrix_1[sol_i[-1], sol_i[0]]\n        dist2 = sum(distance_matrix_2[sol_i[j], sol_i[j+1]] for j in range(len(sol_i)-1)) + distance_matrix_2[sol_i[-1], sol_i[0]]\n\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            sol_j = archive[j][0]\n            shared_edges = sum(1 for a in range(len(sol_i)) for b in range(len(sol_j)) if sol_i[a] == sol_j[b] and sol_i[(a+1)%len(sol_i)] == sol_j[(b+1)%len(sol_j)])\n            diversity[i] += shared_edges / (len(sol_i) * len(sol_j))\n\n    scores = (1 - diversity) * (1 - (objectives[:,0] + objectives[:,1]) / (objectives[:,0].max() + objectives[:,1].max() + 1e-8))\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive perturbation\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment inversion with adaptive length\n        segment_length = min(n//2, max(2, int(np.random.normal(n//4, n//8))))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Edge relocation with adaptive selection\n        if n > 4:\n            relocate_pos = np.random.randint(0, n)\n            edge_pos = np.random.randint(0, n)\n            while abs(edge_pos - relocate_pos) < 2 and n > 3:\n                edge_pos = np.random.randint(0, n)\n\n            edge = new_solution[edge_pos]\n            new_solution = np.concatenate([\n                new_solution[:relocate_pos],\n                np.array([edge]),\n                new_solution[relocate_pos:edge_pos],\n                new_solution[edge_pos+1:]\n            ])\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 3 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe heuristic selects the most promising solution from the archive (based on normalized combined objectives) and applies a hybrid local search combining 3-opt with segment inversion, prioritizing cost reduction by evaluating all possible segment orderings and optionally inverting segments to escape local optima while ensuring feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with segment inversion\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Reconstruct with different orderings\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion as a secondary operation\n    if np.random.rand() < 0.3:  # 30% chance to apply inversion\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive at random and applies a hybrid local search operator that combines segment reversal and edge insertion to generate a neighbor solution. It prioritizes non-dominated or diverse solutions for selection and ensures feasibility by maintaining valid TSP tours. The method intelligently explores neighborhoods by reversing segments and inserting edges, avoiding standard 2-opt while maintaining diversity in the search process.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a segment to reverse\n        segment_start = np.random.randint(0, n - 2)\n        segment_end = np.random.randint(segment_start + 2, n)\n        segment = new_solution[segment_start:segment_end]\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n        # Insert a random edge from another part of the tour\n        if n > 4:\n            insert_pos = np.random.randint(0, n - 1)\n            edge_pos = np.random.randint(0, n - 2)\n            if edge_pos != insert_pos and edge_pos + 1 != insert_pos:\n                edge = new_solution[edge_pos:edge_pos+2]\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    edge,\n                    new_solution[insert_pos:edge_pos],\n                    new_solution[edge_pos+2:]\n                ])\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: Local cost gradients, adaptive 3-opt, normalized objectives, dynamic segment lengths.\n- **Advice**: Hybridize normalized objective evaluation with a 3-opt variant that adjusts segment lengths based on local cost gradients. Prioritize cost-aware segment selection over randomness.\n- **Avoid**: Fixed-length segments or random segment reversal. Ignore gradient-based segment adjustment.\n- **Explanation**: Dynamic segment lengths and gradient-aware selection ensure high-quality neighbors while preserving feasibility. Normalized objectives guide exploitation, while adaptive 3-opt balances exploration.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 14,
        "algorithm": "The algorithm selects the most promising solution from the archive by normalizing its objectives and applying a hybrid local search combining adaptive 3-opt with gradient-aware segment selection, prioritizing edges with high cost gradients to generate high-quality neighbors while ensuring feasibility. It evaluates multiple segment orderings and inversions probabilistically based on gradient information to explore the solution space effectively. The key design ideas are the gradient-based segment selection and adaptive 3-opt with dynamic segment handling, ensuring both exploration and exploitation of the search space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for each edge\n    def calculate_gradient(sol, dm1, dm2):\n        gradients = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = dm1[sol[i], sol[j]] + dm1[sol[j], sol[(j+1)%n]]\n            cost2 = dm2[sol[i], sol[j]] + dm2[sol[j], sol[(j+1)%n]]\n            gradients.append((cost1 + cost2) / 2)\n        return np.array(gradients)\n\n    gradients = calculate_gradient(new_solution, distance_matrix_1, distance_matrix_2)\n\n    # Adaptive 3-opt with gradient-aware segment selection\n    # Select segments based on high-gradient edges\n    edges = np.argsort(gradients)[-3:]  # Top 3 high-gradient edges\n    i, j, k = sorted(np.random.choice(edges, 3, replace=False))\n\n    # Apply adaptive 3-opt with dynamic segment lengths\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Generate all possible orderings and inversions\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion with probability based on gradient\n    inversion_prob = min(0.5, np.mean(gradients[edges]) / np.max(gradients))\n    if np.random.rand() < inversion_prob:\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.8323417424124755,
            0.40328651666641235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined normalized objective\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / max_obj\n    scores = np.sum(norm_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate local cost gradients for each edge\n    def calculate_gradient(sol, dm1, dm2):\n        gradients = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = dm1[sol[i], sol[j]] + dm1[sol[j], sol[(j+1)%n]]\n            cost2 = dm2[sol[i], sol[j]] + dm2[sol[j], sol[(j+1)%n]]\n            gradients.append((cost1 + cost2) / 2)\n        return np.array(gradients)\n\n    gradients = calculate_gradient(new_solution, distance_matrix_1, distance_matrix_2)\n\n    # Adaptive 3-opt with gradient-aware segment selection\n    # Select segments based on high-gradient edges\n    edges = np.argsort(gradients)[-3:]  # Top 3 high-gradient edges\n    i, j, k = sorted(np.random.choice(edges, 3, replace=False))\n\n    # Apply adaptive 3-opt with dynamic segment lengths\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else np.array([])\n\n    # Generate all possible orderings and inversions\n    orderings = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n    ]\n\n    # Evaluate all orderings and select the best one\n    best_solution = new_solution\n    best_cost = np.inf\n\n    for sol in orderings:\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = sol.copy()\n\n    # Apply segment inversion with probability based on gradient\n    inversion_prob = min(0.5, np.mean(gradients[edges]) / np.max(gradients))\n    if np.random.rand() < inversion_prob:\n        inv_i, inv_j = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[inv_i:inv_j] = best_solution[inv_i:inv_j][::-1]\n\n    return best_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive by prioritizing those with better combined objective values, then applies a hybrid local search combining segment reversal and node insertion to generate a neighbor solution while ensuring feasibility through validation. The selection heuristic focuses on solutions with lower total objectives, and the local search operator introduces diversity by randomly perturbing the tour structure.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    def compute_potential(solution, obj1, obj2):\n        # Simple heuristic: prioritize solutions with better objectives\n        return obj1 + obj2\n\n    archive_with_potential = [(solution, obj1, obj2, compute_potential(solution, obj1, obj2))\n                              for solution, (obj1, obj2) in archive]\n    archive_with_potential.sort(key=lambda x: x[3])\n    selected = archive_with_potential[-1][0].copy()  # Select the most promising solution\n\n    # Hybrid local search: combine node insertion and edge reversal\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse\n    i = np.random.randint(0, n)\n    j = np.random.randint(i, n)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node and insert it into a new position\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Local cost gradients, adaptive 3-opt, normalized objectives, dynamic segment lengths.\n- **Advice**: Hybridize normalized objective evaluation with a 3-opt variant that adjusts segment lengths based on local cost gradients. Prioritize cost-aware segment selection over randomness.\n- **Avoid**: Fixed-length segments or random segment reversal. Ignore gradient-based segment adjustment.\n- **Explanation**: Dynamic segment lengths and gradient-aware selection ensure high-quality neighbors while preserving feasibility. Normalized objectives guide exploitation, while adaptive 3-opt balances exploration.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 15,
        "algorithm": "The algorithm selects a promising solution from the archive based on normalized objectives, then applies an adaptive 3-opt variant that dynamically adjusts segment lengths, prioritizes cost-improving moves, and ensures feasibility by validating and repairing the solution through gradient-informed segment insertion and removal, balancing exploration and exploitation. It uses normalized objectives to guide selection and cost gradients to inform segment operations, while maintaining feasibility through duplicate removal and missing node reinsertion. The key design ideas are cost-aware segment selection, gradient-driven local search, and adaptive segment lengths for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives to prioritize cost-aware selection\n    def normalize_objectives(obj1, obj2):\n        max_obj1 = max(s[1][0] for s in archive)\n        max_obj2 = max(s[1][1] for s in archive)\n        if max_obj1 == 0 or max_obj2 == 0:\n            return obj1, obj2\n        return obj1 / max_obj1, obj2 / max_obj2\n\n    # Compute potential for each solution using normalized objectives\n    archive_with_potential = []\n    for solution, (obj1, obj2) in archive:\n        norm_obj1, norm_obj2 = normalize_objectives(obj1, obj2)\n        potential = norm_obj1 + norm_obj2\n        archive_with_potential.append((solution, obj1, obj2, potential))\n\n    # Select the solution with the highest potential\n    archive_with_potential.sort(key=lambda x: x[3], reverse=True)\n    selected = archive_with_potential[0][0].copy()\n\n    # Adaptive 3-opt with gradient-aware segment adjustment\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Compute local cost gradients for segment selection\n    def compute_segment_cost(solution, start, end, distance_matrix):\n        cost = 0\n        for i in range(start, end):\n            cost += distance_matrix[solution[i], solution[i+1]]\n        cost += distance_matrix[solution[end], solution[start]]  # Close the loop\n        return cost\n\n    # Randomly select segments based on cost gradients\n    segment_lengths = [2, 3, 4]  # Dynamic segment lengths\n    segment_length = random.choice(segment_lengths)\n    i = random.randint(0, n - segment_length - 1)\n    j = i + segment_length\n\n    # Compute cost gradients for the selected segment\n    cost1 = compute_segment_cost(new_solution, i, j, distance_matrix_1)\n    cost2 = compute_segment_cost(new_solution, i, j, distance_matrix_2)\n    total_cost = cost1 + cost2\n\n    # Reverse the segment if it improves the cost gradient\n    if random.random() < 0.5:  # 50% chance to reverse\n        reversed_segment = new_solution[i:j+1][::-1]\n        reversed_cost1 = compute_segment_cost(reversed_segment, 0, len(reversed_segment) - 1, distance_matrix_1)\n        reversed_cost2 = compute_segment_cost(reversed_segment, 0, len(reversed_segment) - 1, distance_matrix_2)\n        reversed_total_cost = reversed_cost1 + reversed_cost2\n        if reversed_total_cost < total_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    # Insert the segment at a new position based on cost gradients\n    new_pos = random.randint(0, n - segment_length - 1)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Ensure feasibility by removing duplicates and reinserting missing nodes\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8963962391935619,
            1.837124526500702
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives to prioritize cost-aware selection\n    def normalize_objectives(obj1, obj2):\n        max_obj1 = max(s[1][0] for s in archive)\n        max_obj2 = max(s[1][1] for s in archive)\n        if max_obj1 == 0 or max_obj2 == 0:\n            return obj1, obj2\n        return obj1 / max_obj1, obj2 / max_obj2\n\n    # Compute potential for each solution using normalized objectives\n    archive_with_potential = []\n    for solution, (obj1, obj2) in archive:\n        norm_obj1, norm_obj2 = normalize_objectives(obj1, obj2)\n        potential = norm_obj1 + norm_obj2\n        archive_with_potential.append((solution, obj1, obj2, potential))\n\n    # Select the solution with the highest potential\n    archive_with_potential.sort(key=lambda x: x[3], reverse=True)\n    selected = archive_with_potential[0][0].copy()\n\n    # Adaptive 3-opt with gradient-aware segment adjustment\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Compute local cost gradients for segment selection\n    def compute_segment_cost(solution, start, end, distance_matrix):\n        cost = 0\n        for i in range(start, end):\n            cost += distance_matrix[solution[i], solution[i+1]]\n        cost += distance_matrix[solution[end], solution[start]]  # Close the loop\n        return cost\n\n    # Randomly select segments based on cost gradients\n    segment_lengths = [2, 3, 4]  # Dynamic segment lengths\n    segment_length = random.choice(segment_lengths)\n    i = random.randint(0, n - segment_length - 1)\n    j = i + segment_length\n\n    # Compute cost gradients for the selected segment\n    cost1 = compute_segment_cost(new_solution, i, j, distance_matrix_1)\n    cost2 = compute_segment_cost(new_solution, i, j, distance_matrix_2)\n    total_cost = cost1 + cost2\n\n    # Reverse the segment if it improves the cost gradient\n    if random.random() < 0.5:  # 50% chance to reverse\n        reversed_segment = new_solution[i:j+1][::-1]\n        reversed_cost1 = compute_segment_cost(reversed_segment, 0, len(reversed_segment) - 1, distance_matrix_1)\n        reversed_cost2 = compute_segment_cost(reversed_segment, 0, len(reversed_segment) - 1, distance_matrix_2)\n        reversed_total_cost = reversed_cost1 + reversed_cost2\n        if reversed_total_cost < total_cost:\n            new_solution[i:j+1] = reversed_segment\n\n    # Insert the segment at a new position based on cost gradients\n    new_pos = random.randint(0, n - segment_length - 1)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Ensure feasibility by removing duplicates and reinserting missing nodes\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects the most promising solution from the archive (based on inverse combined objective values) and applies a hybrid local search combining edge insertion and segment reversal to generate a new feasible neighbor solution. It prioritizes solutions with better combined objective values while using random segment manipulation to explore the solution space while maintaining TSP feasibility. The method avoids 2-opt by using a novel combination of insertion and reversal operations.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest combined normalized improvement potential\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate potential as inverse of combined objective\n        potential = 1.0 / (obj[0] + obj[1] + 1e-10)  # Add small epsilon to avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge insertion: move segment [i:j] to position k\n    segment = new_solution[i:j]\n    remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n    k = np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Segment reversal: reverse a random segment\n    l, m = np.random.choice(n, size=2, replace=False)\n    if l > m:\n        l, m = m, l\n    new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: Local cost gradients, adaptive 3-opt, normalized objectives, dynamic segment lengths.\n- **Advice**: Hybridize normalized objective evaluation with a 3-opt variant that adjusts segment lengths based on local cost gradients. Prioritize cost-aware segment selection over randomness.\n- **Avoid**: Fixed-length segments or random segment reversal. Ignore gradient-based segment adjustment.\n- **Explanation**: Dynamic segment lengths and gradient-aware selection ensure high-quality neighbors while preserving feasibility. Normalized objectives guide exploitation, while adaptive 3-opt balances exploration.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 16,
        "algorithm": "The algorithm combines gradient-aware segment selection with adaptive segment manipulation to generate high-quality neighbors in bi-objective TSP. It prioritizes high-gradient segments (indicating potential improvement) for reversal or relocation, then inserts them optimally based on combined objective costs, while ensuring feasibility through duplicate removal and cost-aware node reinsertion. The selection of promising solutions from the archive is guided by a normalized objective score, balancing both objectives during the search process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best normalized objective (prioritizing balanced improvement)\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        # Normalized objective score (harmonic mean of both objectives)\n        score = (obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-10)\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate local cost gradients for both objectives\n    def calculate_gradient(solution, distance_matrix):\n        gradient = np.zeros(n, dtype=float)\n        for i in range(n):\n            prev = solution[i-1]\n            curr = solution[i]\n            next_node = solution[(i+1) % n]\n            # Cost difference if we remove edge (prev, curr) and add (prev, next_node)\n            gradient[i] = distance_matrix[prev, next_node] - distance_matrix[prev, curr]\n        return gradient\n\n    gradient1 = calculate_gradient(new_solution, distance_matrix_1)\n    gradient2 = calculate_gradient(new_solution, distance_matrix_2)\n    combined_gradient = np.abs(gradient1) + np.abs(gradient2)\n\n    # Select segments based on combined gradient (high gradient = high potential for improvement)\n    sorted_indices = np.argsort(combined_gradient)[::-1]\n    top_indices = sorted_indices[:min(5, len(sorted_indices))]\n\n    # Randomly select a segment to modify (prioritizing high-gradient nodes)\n    if len(top_indices) > 0:\n        i = np.random.choice(top_indices)\n    else:\n        i = np.random.randint(n)\n\n    # Determine segment length based on local gradient (longer segments in high-gradient regions)\n    max_length = min(5, n - i)\n    segment_length = np.random.randint(1, max_length + 1)\n    j = min(i + segment_length, n)\n\n    # Extract and potentially reverse the segment\n    segment = new_solution[i:j]\n    if np.random.random() < 0.7:  # Higher probability to reverse high-gradient segments\n        segment = segment[::-1]\n\n    # Find optimal insertion point for the segment in both objectives\n    def calculate_insertion_cost(solution, segment, pos, distance_matrix):\n        n = len(solution)\n        cost = 0\n        # Remove the segment from current position\n        if pos < i:\n            cost -= distance_matrix[solution[pos-1], solution[pos]] + distance_matrix[solution[i-1], solution[i]]\n            cost += distance_matrix[solution[pos-1], solution[i]] + distance_matrix[solution[i-1], solution[pos]]\n        else:\n            cost -= distance_matrix[solution[i-1], solution[i]] + distance_matrix[solution[j-1], solution[j]]\n            cost += distance_matrix[solution[i-1], solution[j]] + distance_matrix[solution[j-1], solution[i]]\n        # Add the segment at new position\n        if pos > 0:\n            cost += distance_matrix[solution[pos-1], segment[0]]\n        if pos + len(segment) < n:\n            cost += distance_matrix[segment[-1], solution[pos + len(segment)]]\n        return cost\n\n    # Evaluate all possible insertion points\n    best_pos = -1\n    best_cost = float('inf')\n    for pos in range(0, n - len(segment) + 1):\n        if pos >= i and pos <= j:\n            continue  # Skip current position\n        cost1 = calculate_insertion_cost(new_solution, segment, pos, distance_matrix_1)\n        cost2 = calculate_insertion_cost(new_solution, segment, pos, distance_matrix_2)\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Perform the insertion\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, np.arange(i, j))\n        ])\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Find insertion point that minimizes both objectives\n            best_insert_pos = 0\n            best_insert_cost = float('inf')\n            for pos in range(len(new_solution) + 1):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n                if cost1 + cost2 < best_insert_cost:\n                    best_insert_cost = cost1 + cost2\n                    best_insert_pos = pos\n            new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7363980661436572,
            0.6578397750854492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best normalized objective (prioritizing balanced improvement)\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        # Normalized objective score (harmonic mean of both objectives)\n        score = (obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-10)\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate local cost gradients for both objectives\n    def calculate_gradient(solution, distance_matrix):\n        gradient = np.zeros(n, dtype=float)\n        for i in range(n):\n            prev = solution[i-1]\n            curr = solution[i]\n            next_node = solution[(i+1) % n]\n            # Cost difference if we remove edge (prev, curr) and add (prev, next_node)\n            gradient[i] = distance_matrix[prev, next_node] - distance_matrix[prev, curr]\n        return gradient\n\n    gradient1 = calculate_gradient(new_solution, distance_matrix_1)\n    gradient2 = calculate_gradient(new_solution, distance_matrix_2)\n    combined_gradient = np.abs(gradient1) + np.abs(gradient2)\n\n    # Select segments based on combined gradient (high gradient = high potential for improvement)\n    sorted_indices = np.argsort(combined_gradient)[::-1]\n    top_indices = sorted_indices[:min(5, len(sorted_indices))]\n\n    # Randomly select a segment to modify (prioritizing high-gradient nodes)\n    if len(top_indices) > 0:\n        i = np.random.choice(top_indices)\n    else:\n        i = np.random.randint(n)\n\n    # Determine segment length based on local gradient (longer segments in high-gradient regions)\n    max_length = min(5, n - i)\n    segment_length = np.random.randint(1, max_length + 1)\n    j = min(i + segment_length, n)\n\n    # Extract and potentially reverse the segment\n    segment = new_solution[i:j]\n    if np.random.random() < 0.7:  # Higher probability to reverse high-gradient segments\n        segment = segment[::-1]\n\n    # Find optimal insertion point for the segment in both objectives\n    def calculate_insertion_cost(solution, segment, pos, distance_matrix):\n        n = len(solution)\n        cost = 0\n        # Remove the segment from current position\n        if pos < i:\n            cost -= distance_matrix[solution[pos-1], solution[pos]] + distance_matrix[solution[i-1], solution[i]]\n            cost += distance_matrix[solution[pos-1], solution[i]] + distance_matrix[solution[i-1], solution[pos]]\n        else:\n            cost -= distance_matrix[solution[i-1], solution[i]] + distance_matrix[solution[j-1], solution[j]]\n            cost += distance_matrix[solution[i-1], solution[j]] + distance_matrix[solution[j-1], solution[i]]\n        # Add the segment at new position\n        if pos > 0:\n            cost += distance_matrix[solution[pos-1], segment[0]]\n        if pos + len(segment) < n:\n            cost += distance_matrix[segment[-1], solution[pos + len(segment)]]\n        return cost\n\n    # Evaluate all possible insertion points\n    best_pos = -1\n    best_cost = float('inf')\n    for pos in range(0, n - len(segment) + 1):\n        if pos >= i and pos <= j:\n            continue  # Skip current position\n        cost1 = calculate_insertion_cost(new_solution, segment, pos, distance_matrix_1)\n        cost2 = calculate_insertion_cost(new_solution, segment, pos, distance_matrix_2)\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Perform the insertion\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, np.arange(i, j))\n        ])\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Find insertion point that minimizes both objectives\n            best_insert_pos = 0\n            best_insert_cost = float('inf')\n            for pos in range(len(new_solution) + 1):\n                temp_solution = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(len(temp_solution)-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n                if cost1 + cost2 < best_insert_cost:\n                    best_insert_cost = cost1 + cost2\n                    best_insert_pos = pos\n            new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 17,
        "algorithm": "The algorithm selects a non-dominated solution from the archive (or a random one if none exist), then applies a hybrid local search combining adaptive segment swapping and probabilistic edge relocation. It ensures feasibility through a two-phase repair mechanism that removes duplicates and inserts missing nodes, prioritizing non-dominated solutions for exploration while maintaining valid TSP tours. The segment length and operations are randomized to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated)\n    else:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    segment_length = max(2, min(5, random.randint(1, n//3)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Probabilistic edge relocation\n    if random.random() < 0.7:\n        target_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:target_pos],\n            segment,\n            np.setdiff1d(new_solution, segment)\n        ])\n    else:\n        # Reverse segment with probability\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Two-phase repair mechanism\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    duplicate_nodes = unique_nodes[counts > 1]\n\n    # Phase 1: Remove duplicates\n    for node in duplicate_nodes:\n        indices = np.where(new_solution == node)[0][1:]\n        for idx in sorted(indices, reverse=True):\n            new_solution = np.delete(new_solution, idx)\n\n    # Phase 2: Insert missing nodes\n    for node in missing_nodes:\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7398418876195465,
            0.7004734873771667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated)\n    else:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment swapping\n    segment_length = max(2, min(5, random.randint(1, n//3)))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Probabilistic edge relocation\n    if random.random() < 0.7:\n        target_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:target_pos],\n            segment,\n            np.setdiff1d(new_solution, segment)\n        ])\n    else:\n        # Reverse segment with probability\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Two-phase repair mechanism\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    duplicate_nodes = unique_nodes[counts > 1]\n\n    # Phase 1: Remove duplicates\n    for node in duplicate_nodes:\n        indices = np.where(new_solution == node)[0][1:]\n        for idx in sorted(indices, reverse=True):\n            new_solution = np.delete(new_solution, idx)\n\n    # Phase 2: Insert missing nodes\n    for node in missing_nodes:\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the best solution from the archive (weighted equally between both objectives) and applies a hybrid local search combining segment reversal and variable-length segment insertion, ensuring feasibility by removing duplicates and reinserting missing nodes. The method prioritizes exploration over exploitation by randomly varying segment lengths and insertion points.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.5, 0.5]\n    best_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n\n    # Hybrid local search: combine 3-opt with a novel move that swaps segments of varying lengths\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(j, min(j + 5, n-1))  # Variable-length segment\n\n    # Perform a novel move: reverse one segment and insert it elsewhere\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]  # Reverse with 50% probability\n\n    # Insert the segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos + len(segment):]\n    ])\n\n    # Ensure the solution remains valid by removing duplicates\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        # Add missing nodes (simple insertion)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 18,
        "algorithm": "The algorithm selects a solution from the archive using a weighted sum of objectives (prioritizing the objective with lower average cost), then applies a hybrid local search combining segment swapping (70% probability) or reversal (30% probability) with variable-length segments, followed by a feasibility check that removes duplicates and reinserts missing nodes at positions that minimize the weighted sum of both objectives. The weights dynamically adjust based on the average costs of each objective, ensuring a balanced exploration of the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_avg = np.mean([s[1][0] for s in archive])\n    obj2_avg = np.mean([s[1][1] for s in archive])\n    total_avg = obj1_avg + obj2_avg\n    weights = [obj2_avg/total_avg, obj1_avg/total_avg] if total_avg > 0 else [0.5, 0.5]\n\n    # Select solution with weighted sum\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    new_solution = selected[0].copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with variable lengths\n    i, j = sorted(random.sample(range(n), 2))\n    segment_length = random.randint(1, min(5, n//2))\n    k = min(j + segment_length, n-1)\n\n    # Swap segments with 70% probability, otherwise reverse one segment\n    if random.random() < 0.7:\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n    else:\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Ensure validity by removing duplicates and reinserting missing nodes\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Insert at position that minimizes both objective changes\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)+1):\n                temp = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n))\n                total_cost = weights[0]*cost1 + weights[1]*cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5950315788130505,
            0.24301737546920776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_avg = np.mean([s[1][0] for s in archive])\n    obj2_avg = np.mean([s[1][1] for s in archive])\n    total_avg = obj1_avg + obj2_avg\n    weights = [obj2_avg/total_avg, obj1_avg/total_avg] if total_avg > 0 else [0.5, 0.5]\n\n    # Select solution with weighted sum\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])\n    new_solution = selected[0].copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment swap with variable lengths\n    i, j = sorted(random.sample(range(n), 2))\n    segment_length = random.randint(1, min(5, n//2))\n    k = min(j + segment_length, n-1)\n\n    # Swap segments with 70% probability, otherwise reverse one segment\n    if random.random() < 0.7:\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n    else:\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Ensure validity by removing duplicates and reinserting missing nodes\n    unique_nodes, indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(indices)]\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Insert at position that minimizes both objective changes\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)+1):\n                temp = np.insert(new_solution, pos, node)\n                cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n))\n                cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n))\n                total_cost = weights[0]*cost1 + weights[1]*cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic selects a solution with high crowding distance from the archive to focus on diverse, potentially improvable regions, then applies a hybrid local search combining randomized 3-opt moves with segment reversals to escape local optima while ensuring feasibility. It prioritizes exploration by randomizing 3-opt configurations and balances exploitation with segment reversals, using objective-space diversity to guide selection. The algorithm emphasizes both objective-space diversity and novel neighborhood exploration to generate high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.650333661828972,
            0.42457258701324463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic selects a solution with high crowding distance from the archive to focus on diverse, potentially improvable regions, then applies a hybrid local search combining randomized 3-opt moves with segment reversals to escape local optima while ensuring feasibility. It prioritizes exploration by randomizing 3-opt configurations and balances exploitation with segment reversals, using objective-space diversity to guide selection. The algorithm emphasizes both objective-space diversity and novel neighborhood exploration to generate high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.650333661828972,
            0.42457258701324463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 1,
        "algorithm": "The heuristic selects a solution with high crowding distance from the archive to focus on diverse, potentially improvable regions, then applies a hybrid local search combining randomized 3-opt moves with segment reversals to escape local optima while ensuring feasibility. It prioritizes exploration by randomizing 3-opt configurations and balances exploitation with segment reversals, using objective-space diversity to guide selection. The algorithm emphasizes both objective-space diversity and novel neighborhood exploration to generate high-quality solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.650333661828972,
            0.42457258701324463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8780436728534554,
            0.24034792184829712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8780436728534554,
            0.24034792184829712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 2,
        "algorithm": "The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8780436728534554,
            0.24034792184829712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9020578250800095,
            0.21142607927322388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9020578250800095,
            0.21142607927322388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 3,
        "algorithm": "The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9020578250800095,
            0.21142607927322388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.925254721365585,
            0.20645654201507568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.925254721365585,
            0.20645654201507568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 4,
        "algorithm": "The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.925254721365585,
            0.20645654201507568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe the design idea and main steps of your algorithm in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 5,
        "algorithm": "The algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8412695745447691,
            0.2388128638267517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "operation": "i1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9481146534985749,
            0.2827843427658081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 6,
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9481146534985749,
            0.2827843427658081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 7,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.8603430639441416,
            0.22855353355407715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 8,
        "algorithm": "The algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining a 4-opt move and a custom edge-reversal operator that prioritizes improving both objectives while ensuring feasibility. The 4-opt move reverses segments between randomly selected positions, while the edge-reversal operator flips a segment only if it improves both objectives, reverting to the original if the solution becomes invalid. The selection and local search balance exploration and exploitation by favoring lower-cost solutions and validating feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 4-opt with custom edge-reversal\n    if n >= 4:\n        # 4-opt move: Select 4 distinct positions and reverse segments\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n        new_solution[a:b] = selected_solution[a:b][::-1]\n        new_solution[b:c] = selected_solution[b:c][::-1]\n        new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Custom edge-reversal: Reverse a segment based on both objectives\n    if n >= 3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        current_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]]\n\n        # Accept reversal if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.825007250619317,
            0.23849892616271973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 4-opt with custom edge-reversal\n    if n >= 4:\n        # 4-opt move: Select 4 distinct positions and reverse segments\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n        new_solution[a:b] = selected_solution[a:b][::-1]\n        new_solution[b:c] = selected_solution[b:c][::-1]\n        new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Custom edge-reversal: Reverse a segment based on both objectives\n    if n >= 3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        current_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]]\n\n        # Accept reversal if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 9,
        "algorithm": "The algorithm selects a solution from the archive based on objective diversity (using standard deviation of costs), applies a 4-opt move to disrupt the tour, and optionally performs a novel edge-insertion strategy (70% chance) to reinsert a node between non-adjacent edges, ensuring feasibility by validating uniqueness of nodes. The method prioritizes diversity in selection and combines local search operators for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply 4-opt move\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Perform 4-opt: reverse segments between two pairs of points\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n    new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Novel edge-insertion: insert a node between two non-adjacent edges\n    if np.random.rand() < 0.7:  # 70% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1:  # Ensure non-adjacent edges\n            node_to_insert = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7638616008021419,
            0.2535017132759094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply 4-opt move\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    a, b, c, d = sorted([a, b, c, d])\n\n    # Perform 4-opt: reverse segments between two pairs of points\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n    new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Novel edge-insertion: insert a node between two non-adjacent edges\n    if np.random.rand() < 0.7:  # 70% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1:  # Ensure non-adjacent edges\n            node_to_insert = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with a weighted random choice favoring lower-cost solutions, then applies a hybrid local search combining a 4-opt move and a custom edge-reversal operator that prioritizes improving both objectives while ensuring feasibility. The 4-opt move reverses segments between randomly selected positions, while the edge-reversal operator flips a segment only if it improves both objectives, reverting to the original if the solution becomes invalid. The selection and local search balance exploration and exploitation by favoring lower-cost solutions and validating feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([sum(obj) for _, obj in archive])\n    probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 4-opt with custom edge-reversal\n    if n >= 4:\n        # 4-opt move: Select 4 distinct positions and reverse segments\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n        new_solution[a:b] = selected_solution[a:b][::-1]\n        new_solution[b:c] = selected_solution[b:c][::-1]\n        new_solution[c:d] = selected_solution[c:d][::-1]\n\n    # Custom edge-reversal: Reverse a segment based on both objectives\n    if n >= 3:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]] + distance_matrix_1[selected_solution[j-1], selected_solution[j]]\n        current_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]] + distance_matrix_2[selected_solution[j-1], selected_solution[j]]\n        new_cost1 = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j-1], selected_solution[i]]\n        new_cost2 = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j-1], selected_solution[i]]\n\n        # Accept reversal if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 10,
        "algorithm": "The algorithm selects a high-potential solution from the archive (prioritizing those with higher combined objective costs) and decomposes it into segments, optimizing each segment independently via a multi-objective edge-swap that only accepts swaps improving both objectives. It reconstructs the solution while ensuring feasibility, reverting to the original if invalid. The key innovation is segment-wise optimization with a strict bi-objective improvement criterion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8208473905516692,
            0.2640572786331177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            \n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 11,
        "algorithm": "The algorithm selects the solution with the highest combined objective from the archive, then applies a hybrid local search using segment reversal, node relocation, and edge swapping, prioritizing improvements in the objective that is currently worse, while ensuring feasibility through multi-step validation. The search dynamically adapts operations based on objective imbalance and validates moves using distance matrices to guide improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(3):  # Perform 3 operations per iteration\n        operation = np.random.choice(['reversal', 'relocation', 'swap'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                # Check if reversing improves obj1\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                # Check if reversing improves obj2\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'relocation':\n            # Node relocation with bias toward improving the prioritized objective\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                # Check if moving improves obj1\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                # Check if moving improves obj2\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'swap':\n            # Edge swap with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                # Check if swapping improves obj1\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Check if swapping improves obj2\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8169662460607223,
            0.2976660132408142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(3):  # Perform 3 operations per iteration\n        operation = np.random.choice(['reversal', 'relocation', 'swap'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                # Check if reversing improves obj1\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                # Check if reversing improves obj2\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'relocation':\n            # Node relocation with bias toward improving the prioritized objective\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                # Check if moving improves obj1\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                # Check if moving improves obj2\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'swap':\n            # Edge swap with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                # Check if swapping improves obj1\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Check if swapping improves obj2\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 12,
        "algorithm": "The algorithm selects a solution from the archive with the highest crowding distance (indicating potential for improvement) and applies a hybrid local search combining segment reversal and cross-exchange operations to generate a neighbor solution while ensuring feasibility. It prioritizes solutions near the Pareto front and explores diverse neighborhoods through randomized segment manipulation. The method ensures validity by checking for duplicate nodes in the generated solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        return archive[0][0].copy()\n\n    # Calculate crowding distance for each solution\n    fronts = np.argsort(objectives[:, 0] + objectives[:, 1])[::-1]\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = float('inf')\n        crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal and cross-exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Segment reversal\n    temp = new_solution.copy()\n    temp[a:b+1] = temp[a:b+1][::-1]\n\n    # Cross-exchange\n    temp[c], temp[d] = temp[d], temp[c]\n\n    # Validate solution\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7547831794378723,
            0.3466237187385559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 1:\n        return archive[0][0].copy()\n\n    # Calculate crowding distance for each solution\n    fronts = np.argsort(objectives[:, 0] + objectives[:, 1])[::-1]\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = float('inf')\n        crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal and cross-exchange\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Segment reversal\n    temp = new_solution.copy()\n    temp[a:b+1] = temp[a:b+1][::-1]\n\n    # Cross-exchange\n    temp[c], temp[d] = temp[d], temp[c]\n\n    # Validate solution\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 13,
        "algorithm": "The algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5451367216570713,
            0.20511656999588013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 13,
        "algorithm": "The algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5451367216570713,
            0.20511656999588013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 2 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s a concise reflection on effective self-reflection for designing better heuristics:\n\n- **Keywords**: **Exploitation vs. Exploration**, **Feasibility Checks**, **Objective Balance**, **Diverse Operators**\n- **Advice**: Prioritize high-potential regions (like Heuristic 2) but combine with diverse operators (like Heuristic 1\u2019s edge-swap) to escape local optima. Ensure robust feasibility checks across both objectives.\n- **Avoid**: Over-reliance on random selection or single operators. Ignore objective balance or feasibility constraints.\n- **Explanation**: Balance strategic selection (exploitation) with diversity (exploration) to avoid premature convergence. Always validate feasibility and objective trade-offs to ensure high-quality solutions.\n\n**Actionable Idea**: Design a hybrid heuristic that dynamically switches between operators (e.g., edge-swap and partial reversal) based on solution quality and diversity, ensuring feasibility and objective balance.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 14,
        "algorithm": "The algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.893215863330194,
            0.2730424404144287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a concise reflection on effective self-reflection for designing better heuristics:\n\n- **Keywords**: **Exploitation vs. Exploration**, **Feasibility Checks**, **Objective Balance**, **Diverse Operators**\n- **Advice**: Prioritize high-potential regions (like Heuristic 2) but combine with diverse operators (like Heuristic 1\u2019s edge-swap) to escape local optima. Ensure robust feasibility checks across both objectives.\n- **Avoid**: Over-reliance on random selection or single operators. Ignore objective balance or feasibility constraints.\n- **Explanation**: Balance strategic selection (exploitation) with diversity (exploration) to avoid premature convergence. Always validate feasibility and objective trade-offs to ensure high-quality solutions.\n\n**Actionable Idea**: Design a hybrid heuristic that dynamically switches between operators (e.g., edge-swap and partial reversal) based on solution quality and diversity, ensuring feasibility and objective balance.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 15,
        "algorithm": "The algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.94438110626965,
            0.2759231925010681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a concise reflection on effective self-reflection for designing better heuristics:\n\n- **Keywords**: **Exploitation vs. Exploration**, **Feasibility Checks**, **Objective Balance**, **Diverse Operators**\n- **Advice**: Prioritize high-potential regions (like Heuristic 2) but combine with diverse operators (like Heuristic 1\u2019s edge-swap) to escape local optima. Ensure robust feasibility checks across both objectives.\n- **Avoid**: Over-reliance on random selection or single operators. Ignore objective balance or feasibility constraints.\n- **Explanation**: Balance strategic selection (exploitation) with diversity (exploration) to avoid premature convergence. Always validate feasibility and objective trade-offs to ensure high-quality solutions.\n\n**Actionable Idea**: Design a hybrid heuristic that dynamically switches between operators (e.g., edge-swap and partial reversal) based on solution quality and diversity, ensuring feasibility and objective balance.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 16,
        "algorithm": "The algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8834292092715244,
            0.22790420055389404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 17,
        "algorithm": "The algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9756411093506061,
            0.6009257435798645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 17,
        "algorithm": "The algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9756411093506061,
            0.6009257435798645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 18,
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9144468290000943,
            0.25475645065307617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 3 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: API_FAILED\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 19,
        "algorithm": "The algorithm selects a solution from the archive with the lowest sum of normalized objectives (prioritizing high-potential candidates), then applies a hybrid local search combining a novel edge-swap (prioritizing swaps that improve both objectives) and a constrained segment inversion (reversing segments if they improve both costs). It ensures feasibility by validating tours and reverting to the original solution if invalid. The approach balances exploitation (targeted edge swaps) and exploration (random segment inversions) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized = objectives / (min_obj + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmin(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel edge-swap: prioritize edges that improve both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Try multiple edge swaps and keep the best one that improves both objectives\n    best_swap = None\n    best_improvement = 0\n\n    for _ in range(min(10, n//2)):  # Limit the number of trials\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = temp_solution.copy()\n\n    if best_swap is not None:\n        new_solution = best_swap\n\n    # Constrained segment inversion: invert a segment if it improves both objectives\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    temp_solution = new_solution.copy()\n    temp_solution[a:b] = temp_solution[a:b][::-1]\n\n    if len(np.unique(temp_solution)) == n:\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n            new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7335396465331961,
            2.3471015095710754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized = objectives / (min_obj + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmin(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel edge-swap: prioritize edges that improve both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Try multiple edge swaps and keep the best one that improves both objectives\n    best_swap = None\n    best_improvement = 0\n\n    for _ in range(min(10, n//2)):  # Limit the number of trials\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = temp_solution.copy()\n\n    if best_swap is not None:\n        new_solution = best_swap\n\n    # Constrained segment inversion: invert a segment if it improves both objectives\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    temp_solution = new_solution.copy()\n    temp_solution[a:b] = temp_solution[a:b][::-1]\n\n    if len(np.unique(temp_solution)) == n:\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n            new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            API_FAILED\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 20,
        "algorithm": "The algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9415771459065421,
            2.1370423436164856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            API_FAILED\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 21,
        "algorithm": "The algorithm selects a solution from the archive by balancing objective diversity and quality, then applies a segment-based perturbation that reorders tour segments based on their combined position scores in both objective spaces, followed by a multi-objective-aware edge insertion step that prioritizes swaps improving both objectives while ensuring feasibility. The selection prioritizes diversity (70%) over quality (30%), and the local search uses segment reordering and constrained edge swaps to generate improved neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (combining objective diversity and quality)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity_scores = np.std(normalized, axis=1)\n    quality_scores = np.sum(normalized, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * quality_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment-based perturbation: reorder segments based on cross-space positions\n    segment_size = max(2, n // 5)\n    num_segments = n // segment_size\n    if num_segments < 2:\n        return new_solution\n\n    # Calculate segment scores based on average positions in both spaces\n    segment_scores = []\n    for i in range(num_segments):\n        start = i * segment_size\n        end = start + segment_size\n        segment_nodes = base_solution[start:end]\n        avg_x1 = np.mean(instance[segment_nodes, 0])\n        avg_y1 = np.mean(instance[segment_nodes, 1])\n        avg_x2 = np.mean(instance[segment_nodes, 2])\n        avg_y2 = np.mean(instance[segment_nodes, 3])\n        score = avg_x1 + avg_y1 + avg_x2 + avg_y2  # Combined position score\n        segment_scores.append(score)\n\n    # Sort segments based on their scores\n    sorted_indices = np.argsort(segment_scores)\n    new_order = []\n    for i in sorted_indices:\n        start = i * segment_size\n        end = start + segment_size\n        new_order.extend(base_solution[start:end])\n\n    # Handle remaining nodes if any\n    remaining = n - len(new_order)\n    if remaining > 0:\n        new_order.extend(base_solution[-remaining:])\n\n    new_solution = np.array(new_order)\n\n    # Multi-objective-aware edge insertion: prioritize edges with best combined improvement\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Find edges that could potentially improve both objectives\n    improvement_edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if j - i > 1:  # Skip adjacent nodes\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                new_cost1 = calculate_cost(temp_sol, distance_matrix_1)\n                new_cost2 = calculate_cost(temp_sol, distance_matrix_2)\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n                    improvement_edges.append((i, j, new_cost1 + new_cost2))\n\n    if improvement_edges:\n        # Select the edge with best combined improvement\n        improvement_edges.sort(key=lambda x: x[2])\n        best_i, best_j, _ = improvement_edges[0]\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8599019784834802,
            4.650597453117371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement (combining objective diversity and quality)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity_scores = np.std(normalized, axis=1)\n    quality_scores = np.sum(normalized, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * quality_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment-based perturbation: reorder segments based on cross-space positions\n    segment_size = max(2, n // 5)\n    num_segments = n // segment_size\n    if num_segments < 2:\n        return new_solution\n\n    # Calculate segment scores based on average positions in both spaces\n    segment_scores = []\n    for i in range(num_segments):\n        start = i * segment_size\n        end = start + segment_size\n        segment_nodes = base_solution[start:end]\n        avg_x1 = np.mean(instance[segment_nodes, 0])\n        avg_y1 = np.mean(instance[segment_nodes, 1])\n        avg_x2 = np.mean(instance[segment_nodes, 2])\n        avg_y2 = np.mean(instance[segment_nodes, 3])\n        score = avg_x1 + avg_y1 + avg_x2 + avg_y2  # Combined position score\n        segment_scores.append(score)\n\n    # Sort segments based on their scores\n    sorted_indices = np.argsort(segment_scores)\n    new_order = []\n    for i in sorted_indices:\n        start = i * segment_size\n        end = start + segment_size\n        new_order.extend(base_solution[start:end])\n\n    # Handle remaining nodes if any\n    remaining = n - len(new_order)\n    if remaining > 0:\n        new_order.extend(base_solution[-remaining:])\n\n    new_solution = np.array(new_order)\n\n    # Multi-objective-aware edge insertion: prioritize edges with best combined improvement\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Find edges that could potentially improve both objectives\n    improvement_edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if j - i > 1:  # Skip adjacent nodes\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                new_cost1 = calculate_cost(temp_sol, distance_matrix_1)\n                new_cost2 = calculate_cost(temp_sol, distance_matrix_2)\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n                    improvement_edges.append((i, j, new_cost1 + new_cost2))\n\n    if improvement_edges:\n        # Select the edge with best combined improvement\n        improvement_edges.sort(key=lambda x: x[2])\n        best_i, best_j, _ = improvement_edges[0]\n        new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 22,
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of normalized objective values and diversity, then applies a segment insertion followed by a constrained edge reversal (only if it improves both objectives or with a 15% probability), ensuring feasibility by validating the tour structure. The selection prioritizes solutions with better normalized objectives (70%) while slightly favoring diverse solutions (30%), and the local search balances exploitation (improving both objectives) with exploration (probabilistic acceptance).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine normalized objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    weights = 0.7 * np.sum(normalized, axis=1) + 0.3 * np.sum(diversity)\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment insertion: move a random segment to a new position\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Constrained edge reversal: reverse edges only if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.15:\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8321016016339864,
            0.32090818881988525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine normalized objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    weights = 0.7 * np.sum(normalized, axis=1) + 0.3 * np.sum(diversity)\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment insertion: move a random segment to a new position\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Constrained edge reversal: reverse edges only if it improves both objectives\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.15:\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 23,
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with high normalized objective sums) and applies a hybrid local search combining constrained 2-opt (only accepting moves that improve at least one objective or with a small random probability) and probabilistic edge swaps (prioritizing moves that improve both objectives). It ensures feasibility by validating the tour structure and includes a fallback to the original solution if duplicates occur. The selection and improvement strategies focus on balancing exploration and exploitation, with randomness helping escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Constrained 2-opt: swap segments only if it improves at least one objective\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 or new_cost2 < current_cost2) or np.random.rand() < 0.15:\n        new_solution = temp_solution\n\n    # Probabilistic edge swap: swap edges with probability based on improvement\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    improvement_prob = 0.3 if (new_cost1 < current_cost1 and new_cost2 < current_cost2) else 0.05\n    if np.random.rand() < improvement_prob:\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7812860806021287,
            0.2989129424095154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Constrained 2-opt: swap segments only if it improves at least one objective\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 or new_cost2 < current_cost2) or np.random.rand() < 0.15:\n        new_solution = temp_solution\n\n    # Probabilistic edge swap: swap edges with probability based on improvement\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    improvement_prob = 0.3 if (new_cost1 < current_cost1 and new_cost2 < current_cost2) else 0.05\n    if np.random.rand() < improvement_prob:\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            API_FAILED\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 24,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search combining partial tour reversal, constrained edge swap, and novel edge-swap\n    # Step 1: Partial tour reversal for exploration\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Constrained edge swap for exploitation\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:  # More randomness for exploration\n        new_solution = temp_solution\n\n    # Step 3: Novel edge-swap between non-adjacent edges if it improves at least one objective\n    if np.random.rand() < 0.4:  # Higher chance to apply the novel operator\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n        if not (k == 0 and l == n-1):  # Avoid swapping the first and last edges\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n            temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n            if (temp_cost1 < current_cost1 or temp_cost2 < current_cost2) or np.random.rand() < 0.2:\n                new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7311701514317326,
            0.2783443331718445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search combining partial tour reversal, constrained edge swap, and novel edge-swap\n    # Step 1: Partial tour reversal for exploration\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Constrained edge swap for exploitation\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:  # More randomness for exploration\n        new_solution = temp_solution\n\n    # Step 3: Novel edge-swap between non-adjacent edges if it improves at least one objective\n    if np.random.rand() < 0.4:  # Higher chance to apply the novel operator\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n        if not (k == 0 and l == n-1):  # Avoid swapping the first and last edges\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n\n            temp_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            temp_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n            if (temp_cost1 < current_cost1 or temp_cost2 < current_cost2) or np.random.rand() < 0.2:\n                new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: **Adaptive Operator Selection**, **Multi-Objective Feasibility**, **Diversity-Aware Exploitation**, **Structural Balance**\n- **Advice**: Combine adaptive operator switching (e.g., edge-swap + distance-aware relocation) with nondominated selection to balance exploration and exploitation. Validate feasibility across both objectives and prioritize structurally balanced solutions.\n- **Avoid**: Static operators or random selection without objective-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Dynamic operator adaptation ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 25,
        "algorithm": "The algorithm selects a promising solution from the archive by balancing objective diversity and structural balance (measured by edge length variance), then applies a hybrid local search combining edge-swap and distance-aware relocation to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with balanced edge lengths (higher `balance_scores`) and prefers swaps that improve both objectives, with occasional random exploration. The selection weights combine normalized objective values and balance scores to guide the choice of base solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural balance\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate structural balance (variance of edge lengths)\n    balance_scores = np.zeros(len(archive))\n    for i, (sol, _) in enumerate(archive):\n        edges1 = [distance_matrix_1[sol[k], sol[(k+1)%len(sol)]] for k in range(len(sol))]\n        edges2 = [distance_matrix_2[sol[k], sol[(k+1)%len(sol)]] for k in range(len(sol))]\n        balance_scores[i] = np.std(edges1) * np.std(edges2)\n\n    # Combine objective and balance scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.7 * balance_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    # Step 1: Edge-swap with objective-aware selection\n    def calculate_cost(sol, dist_mat):\n        return sum(dist_mat[sol[k], sol[(k+1)%n]] for k in range(n))\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Find candidate edges to swap\n    candidates = []\n    for i in range(n):\n        for j in range(i+2, n):\n            if j != (i+1)%n and j != (i-1)%n:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                new_cost1 = calculate_cost(temp, distance_matrix_1)\n                new_cost2 = calculate_cost(temp, distance_matrix_2)\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.15:\n                    candidates.append((i, j, new_cost1, new_cost2))\n\n    if candidates:\n        i, j, _, _ = max(candidates, key=lambda x: -(x[2] + x[3]))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Distance-aware relocation\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8762358055761299,
            4.6851019859313965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural balance\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate structural balance (variance of edge lengths)\n    balance_scores = np.zeros(len(archive))\n    for i, (sol, _) in enumerate(archive):\n        edges1 = [distance_matrix_1[sol[k], sol[(k+1)%len(sol)]] for k in range(len(sol))]\n        edges2 = [distance_matrix_2[sol[k], sol[(k+1)%len(sol)]] for k in range(len(sol))]\n        balance_scores[i] = np.std(edges1) * np.std(edges2)\n\n    # Combine objective and balance scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.7 * balance_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    # Step 1: Edge-swap with objective-aware selection\n    def calculate_cost(sol, dist_mat):\n        return sum(dist_mat[sol[k], sol[(k+1)%n]] for k in range(n))\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Find candidate edges to swap\n    candidates = []\n    for i in range(n):\n        for j in range(i+2, n):\n            if j != (i+1)%n and j != (i-1)%n:\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                new_cost1 = calculate_cost(temp, distance_matrix_1)\n                new_cost2 = calculate_cost(temp, distance_matrix_2)\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.15:\n                    candidates.append((i, j, new_cost1, new_cost2))\n\n    if candidates:\n        i, j, _, _ = max(candidates, key=lambda x: -(x[2] + x[3]))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Distance-aware relocation\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Operator Selection**, **Multi-Objective Feasibility**, **Diversity-Aware Exploitation**, **Structural Balance**\n- **Advice**: Combine adaptive operator switching (e.g., edge-swap + distance-aware relocation) with nondominated selection to balance exploration and exploitation. Validate feasibility across both objectives and prioritize structurally balanced solutions.\n- **Avoid**: Static operators or random selection without objective-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Dynamic operator adaptation ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 26,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with balanced objectives and high structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = 1 - np.abs(norm_objectives[:, 0] - norm_objectives[:, 1])\n\n    # Calculate structural diversity (edit distance to other solutions)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_solutions = [sol for j, (sol, _) in enumerate(archive) if j != i]\n        diversity_scores[i] = np.mean([np.sum(archive[i][0] != other) for other in other_solutions])\n\n    # Combine balance and diversity scores\n    selection_weights = balance_scores * diversity_scores\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search combining edge-swap and distance-aware relocation\n    # Step 1: Edge-swap with adaptive segment size\n    segment_size = min(4, max(1, int(np.random.normal(n/5, n/10))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Perform edge-swap within the segment\n    if end - start >= 2:\n        i, j = np.random.choice(range(start, end), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Distance-aware relocation based on both objectives\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on both distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7475336034786585,
            1.179361641407013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with balanced objectives and high structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = 1 - np.abs(norm_objectives[:, 0] - norm_objectives[:, 1])\n\n    # Calculate structural diversity (edit distance to other solutions)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_solutions = [sol for j, (sol, _) in enumerate(archive) if j != i]\n        diversity_scores[i] = np.mean([np.sum(archive[i][0] != other) for other in other_solutions])\n\n    # Combine balance and diversity scores\n    selection_weights = balance_scores * diversity_scores\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search combining edge-swap and distance-aware relocation\n    # Step 1: Edge-swap with adaptive segment size\n    segment_size = min(4, max(1, int(np.random.normal(n/5, n/10))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Perform edge-swap within the segment\n    if end - start >= 2:\n        i, j = np.random.choice(range(start, end), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Distance-aware relocation based on both objectives\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on both distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Operator Selection**, **Multi-Objective Feasibility**, **Diversity-Aware Exploitation**, **Structural Balance**\n- **Advice**: Combine adaptive operator switching (e.g., edge-swap + distance-aware relocation) with nondominated selection to balance exploration and exploitation. Validate feasibility across both objectives and prioritize structurally balanced solutions.\n- **Avoid**: Static operators or random selection without objective-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Dynamic operator adaptation ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 27,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize structurally balanced and nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate structural balance (low variance in segment lengths)\n    segment_vars = []\n    for sol in solutions:\n        segments = []\n        for i in range(len(sol)):\n            segments.append(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]])\n        segment_vars.append(np.var(segments))\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Combine structural balance and nondominated status\n    scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            scores[i] = 1 / (1 + segment_vars[i])\n\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive operator selection\n    if np.random.random() < 0.5:\n        # Segment-based reversal\n        segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Distance-aware node relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9493323547445034,
            1.0181962251663208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize structurally balanced and nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate structural balance (low variance in segment lengths)\n    segment_vars = []\n    for sol in solutions:\n        segments = []\n        for i in range(len(sol)):\n            segments.append(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]])\n        segment_vars.append(np.var(segments))\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Combine structural balance and nondominated status\n    scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            scores[i] = 1 / (1 + segment_vars[i])\n\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive operator selection\n    if np.random.random() < 0.5:\n        # Segment-based reversal\n        segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Distance-aware node relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 28,
        "algorithm": "The algorithm selects promising solutions from an archive using a weighted combination of objective quality and structural diversity, then applies a novel hybrid local search that combines adaptive segment-based swaps (with reversal or shifting) and probabilistic node insertion guided by both distance matrices and instance-specific features, ensuring feasibility through validation checks. Objective quality is prioritized (weight 0.6-0.8) over diversity (weight 0.4-0.6) when solutions are well-converged, while segment operations favor reversal (70%) over shifting and insertion uses exponential probability weighting based on distance improvements and coordinate ratios.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective quality and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate structural diversity (differences in node ordering)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_solutions = [sol for j, (sol, _) in enumerate(archive) if j != i]\n        diversity = 0\n        for other in other_solutions:\n            diversity += np.mean(archive[i][0] != other)\n        diversity_scores[i] = diversity / len(other_solutions) if other_solutions else 0\n\n    # Combine scores with adaptive weights\n    objective_weight = 0.6 + 0.4 * (1 - np.mean(norm_objectives, axis=0)[0])\n    diversity_weight = 0.4 + 0.6 * (1 - np.mean(norm_objectives, axis=0)[0])\n    selection_weights = (objective_weight * (1 - norm_objectives[:, 0]) + diversity_weight * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Adaptive segment-based swap with objective-aware selection\n    segment_size = max(2, min(n // 3, int(np.random.normal(n/5, n/10))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Calculate segment quality based on both objectives\n    segment_cost = 0\n    for i in range(start, end):\n        segment_cost += (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n    # Probabilistically decide to reverse or shift the segment\n    if np.random.random() < 0.7:  # Higher probability for reversal\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        shift_pos = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, slice(start, end))\n        new_solution = np.insert(new_solution, shift_pos, segment)\n\n    # Step 2: Probabilistic node insertion with instance-aware guidance\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate insertion probabilities based on both distance matrices and instance features\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n\n            # Incorporate instance-specific features\n            node_coords = instance[node]\n            l_coords = instance[new_solution[(l-1)%n]]\n            distance_ratio = (np.linalg.norm(node_coords[:2] - l_coords[:2]) /\n                             np.linalg.norm(node_coords[2:] - l_coords[2:]) + 1e-8)\n\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8)) * distance_ratio\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.926417845628506,
            1.6654201745986938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective quality and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate structural diversity (differences in node ordering)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_solutions = [sol for j, (sol, _) in enumerate(archive) if j != i]\n        diversity = 0\n        for other in other_solutions:\n            diversity += np.mean(archive[i][0] != other)\n        diversity_scores[i] = diversity / len(other_solutions) if other_solutions else 0\n\n    # Combine scores with adaptive weights\n    objective_weight = 0.6 + 0.4 * (1 - np.mean(norm_objectives, axis=0)[0])\n    diversity_weight = 0.4 + 0.6 * (1 - np.mean(norm_objectives, axis=0)[0])\n    selection_weights = (objective_weight * (1 - norm_objectives[:, 0]) + diversity_weight * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Adaptive segment-based swap with objective-aware selection\n    segment_size = max(2, min(n // 3, int(np.random.normal(n/5, n/10))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Calculate segment quality based on both objectives\n    segment_cost = 0\n    for i in range(start, end):\n        segment_cost += (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n    # Probabilistically decide to reverse or shift the segment\n    if np.random.random() < 0.7:  # Higher probability for reversal\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        shift_pos = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, slice(start, end))\n        new_solution = np.insert(new_solution, shift_pos, segment)\n\n    # Step 2: Probabilistic node insertion with instance-aware guidance\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate insertion probabilities based on both distance matrices and instance features\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n\n            # Incorporate instance-specific features\n            node_coords = instance[node]\n            l_coords = instance[new_solution[(l-1)%n]]\n            distance_ratio = (np.linalg.norm(node_coords[:2] - l_coords[:2]) /\n                             np.linalg.norm(node_coords[2:] - l_coords[2:]) + 1e-8)\n\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8)) * distance_ratio\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 29,
        "algorithm": "The algorithm selects a promising solution from the archive by combining objective diversity and structural diversity (with higher emphasis on diversity), then applies a hybrid local search that first performs a partial tour reversal with an adaptive segment size and subsequently uses probabilistic node insertion based on distance matrices from both objectives. The selection weights favor solutions with better diversity scores, and the local search ensures feasibility by validating the uniqueness of nodes in the generated solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity with different weights\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Different selection weights: emphasize diversity more\n    selection_weights = np.exp(-0.3 * norm_objectives[:, 0] - 0.3 * norm_objectives[:, 1] + 0.7 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search with different parameters\n    # Step 1: Partial tour reversal with different adaptive segment size calculation\n    segment_size = min(5, max(2, int(np.random.normal(n/3, n/6))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node insertion based on distance matrices\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9150644974518245,
            0.6465880870819092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity with different weights\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Different selection weights: emphasize diversity more\n    selection_weights = np.exp(-0.3 * norm_objectives[:, 0] - 0.3 * norm_objectives[:, 1] + 0.7 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search with different parameters\n    # Step 1: Partial tour reversal with different adaptive segment size calculation\n    segment_size = min(5, max(2, int(np.random.normal(n/3, n/6))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node insertion based on distance matrices\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Operator Selection**, **Multi-Objective Feasibility**, **Diversity-Aware Exploitation**, **Structural Balance**\n- **Advice**: Combine adaptive operator switching (e.g., edge-swap + distance-aware relocation) with nondominated selection to balance exploration and exploitation. Validate feasibility across both objectives and prioritize structurally balanced solutions.\n- **Avoid**: Static operators or random selection without objective-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Dynamic operator adaptation ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 30,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search combining adaptive segment reversal, distance-aware node insertion, and probabilistic edge exchange\n    # Step 1: Adaptive segment reversal with size based on solution quality and diversity\n    segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Distance-aware node insertion based on both objective spaces\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Probabilistic edge exchange based on solution structure\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.random() < 0.7:  # Higher probability for edge exchange\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8429498511971971,
            0.6625462174415588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search combining adaptive segment reversal, distance-aware node insertion, and probabilistic edge exchange\n    # Step 1: Adaptive segment reversal with size based on solution quality and diversity\n    segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Distance-aware node insertion based on both objective spaces\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Probabilistic edge exchange based on solution structure\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.random() < 0.7:  # Higher probability for edge exchange\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, selected nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(Response in <100 words, meeting the tip.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 31,
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing nondominated ones with high objective diversity, then applies a hybrid local search combining edge-swap and distance-aware relocation to generate a neighbor solution while ensuring feasibility through node uniqueness validation. It uses probabilistic selection based on cost differences to guide the relocation step, favoring moves that reduce total tour length in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_nondominated[i] = False\n\n    if not any(is_nondominated):\n        selected_idx = np.random.choice(len(archive))\n    else:\n        nondominated_indices = np.where(is_nondominated)[0]\n        diversity_scores = np.zeros(len(nondominated_indices))\n        for i, idx in enumerate(nondominated_indices):\n            other_objectives = np.delete(objectives, idx, axis=0)\n            diversity_scores[i] = np.mean(np.linalg.norm(objectives[idx] - other_objectives, axis=1))\n        selected_idx = nondominated_indices[np.argmax(diversity_scores)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: edge-swap and distance-aware relocation\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Edge-swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Distance-aware relocation\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    current_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] + \\\n                  distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n\n    probs = np.zeros(n)\n    for l in range(n):\n        if l == k or l == (k-1)%n or l == (k+1)%n:\n            continue\n        new_cost = distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] + \\\n                  distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]]\n        probs[l] = np.exp(-(new_cost - current_cost) / (current_cost + 1e-8))\n\n    probs /= probs.sum()\n    l = np.random.choice(n, p=probs)\n\n    if l != k and l != (k-1)%n and l != (k+1)%n:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7774039571844935,
            0.7259412407875061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_nondominated[i] = False\n\n    if not any(is_nondominated):\n        selected_idx = np.random.choice(len(archive))\n    else:\n        nondominated_indices = np.where(is_nondominated)[0]\n        diversity_scores = np.zeros(len(nondominated_indices))\n        for i, idx in enumerate(nondominated_indices):\n            other_objectives = np.delete(objectives, idx, axis=0)\n            diversity_scores[i] = np.mean(np.linalg.norm(objectives[idx] - other_objectives, axis=1))\n        selected_idx = nondominated_indices[np.argmax(diversity_scores)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: edge-swap and distance-aware relocation\n    a, b = np.random.choice(n, size=2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Edge-swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Distance-aware relocation\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    current_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] + \\\n                  distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n\n    probs = np.zeros(n)\n    for l in range(n):\n        if l == k or l == (k-1)%n or l == (k+1)%n:\n            continue\n        new_cost = distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] + \\\n                  distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]]\n        probs[l] = np.exp(-(new_cost - current_cost) / (current_cost + 1e-8))\n\n    probs /= probs.sum()\n    l = np.random.choice(n, p=probs)\n\n    if l != k and l != (k-1)%n and l != (k+1)%n:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, selected nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(Response in <100 words, meeting the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 32,
        "algorithm": "The algorithm selects a solution from the archive based on high objective variance and low dominance, then applies a hybrid local search combining edge-swaps (60% probability) and distance-aware relocations (40% probability), ensuring feasibility by validating uniqueness of nodes and occasionally reverting to the original solution if the new solution is dominated. The operator selection adapts to structural balance, prioritizing edge-swaps for stability and relocations for diversity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: prioritize solutions with high objective variance and low dominance\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    dominance = np.prod(objectives / np.max(objectives, axis=0), axis=1)\n    selection_score = variance[0] * variance[1] / (dominance + 1e-6)\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: adaptive edge-swap and distance-aware relocation\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Operator selection based on structural balance\n    if np.random.random() < 0.6:\n        # Edge-swap with probability 0.6\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Distance-aware relocation\n        k = np.random.randint(0, n)\n        # Find the node with maximum distance to its neighbors\n        max_dist = -1\n        best_l = -1\n        for l in range(n):\n            if l == k or l == (k + 1) % n or l == (k - 1) % n:\n                continue\n            dist = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l]]\n            if dist > max_dist:\n                max_dist = dist\n                best_l = l\n        if best_l != -1:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_l, node)\n\n    # Feasibility validation across both objectives\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.4:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8800271005035823,
            0.4907640218734741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: prioritize solutions with high objective variance and low dominance\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    dominance = np.prod(objectives / np.max(objectives, axis=0), axis=1)\n    selection_score = variance[0] * variance[1] / (dominance + 1e-6)\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: adaptive edge-swap and distance-aware relocation\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Operator selection based on structural balance\n    if np.random.random() < 0.6:\n        # Edge-swap with probability 0.6\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Distance-aware relocation\n        k = np.random.randint(0, n)\n        # Find the node with maximum distance to its neighbors\n        max_dist = -1\n        best_l = -1\n        for l in range(n):\n            if l == k or l == (k + 1) % n or l == (k - 1) % n:\n                continue\n            dist = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l]]\n            if dist > max_dist:\n                max_dist = dist\n                best_l = l\n        if best_l != -1:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_l, node)\n\n    # Feasibility validation across both objectives\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.4:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, selected nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(Response in <100 words, meeting the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 33,
        "algorithm": "The algorithm selects diverse Pareto-dominant solutions from the archive and applies a hybrid local search that adaptively alternates between edge-swaps and distance-aware relocations, prioritizing operators that improve objectives while maintaining feasibility through validation. It balances exploration and exploitation by favoring edge-swaps (70%) and using probabilistic selection for relocations, with small randomness to escape local optima. The solution is validated to ensure no nodes are revisited or skipped.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: prioritize Pareto-dominant solutions with high structural diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.zeros(len(pareto_front))\n    for i, idx in enumerate(pareto_front):\n        sol = solutions[idx]\n        diversity = 0\n        for j in range(len(sol)):\n            diversity += np.linalg.norm(instance[sol[j], :2] - instance[sol[(j+1)%len(sol)], :2])\n            diversity += np.linalg.norm(instance[sol[j], 2:] - instance[sol[(j+1)%len(sol)], 2:])\n        diversity_scores[i] = diversity\n\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive operator selection\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if np.random.rand() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with distance-aware selection\n        candidates = []\n        for i in range(n):\n            for j in range(i+2, n):\n                if j != (i+1)%n and j != (i-1)%n:\n                    candidates.append((i, j))\n\n        if candidates:\n            i, j = random.choice(candidates)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n            if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.2:\n                new_solution = temp_solution\n    else:\n        # Distance-aware relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        current_dist = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] + \\\n                       distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] + \\\n                       distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]]\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        if probs.sum() > 0:\n            probs /= probs.sum()\n            l = np.random.choice(n, p=probs)\n            if l != k and l != (k-1)%n and l != (k+1)%n:\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7853938470401209,
            14.428902506828308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: prioritize Pareto-dominant solutions with high structural diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    diversity_scores = np.zeros(len(pareto_front))\n    for i, idx in enumerate(pareto_front):\n        sol = solutions[idx]\n        diversity = 0\n        for j in range(len(sol)):\n            diversity += np.linalg.norm(instance[sol[j], :2] - instance[sol[(j+1)%len(sol)], :2])\n            diversity += np.linalg.norm(instance[sol[j], 2:] - instance[sol[(j+1)%len(sol)], 2:])\n        diversity_scores[i] = diversity\n\n    selected_idx = pareto_front[np.argmax(diversity_scores)]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive operator selection\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if np.random.rand() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with distance-aware selection\n        candidates = []\n        for i in range(n):\n            for j in range(i+2, n):\n                if j != (i+1)%n and j != (i-1)%n:\n                    candidates.append((i, j))\n\n        if candidates:\n            i, j = random.choice(candidates)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n            new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n            if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.2:\n                new_solution = temp_solution\n    else:\n        # Distance-aware relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        current_dist = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] + \\\n                       distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] + \\\n                       distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]]\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        if probs.sum() > 0:\n            probs /= probs.sum()\n            l = np.random.choice(n, p=probs)\n            if l != k and l != (k-1)%n and l != (k+1)%n:\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 34,
        "algorithm": "This algorithm intelligently selects a solution from the archive based on balanced objective improvement potential, then applies a dynamic hybrid local search combining segment reversal, constrained node swapping, and probabilistic edge insertion, while ensuring feasibility and incorporating adaptive randomness to escape local optima while maintaining solution quality. It prioritizes balanced solutions and adaptively applies operators with probabilistic selection, validating feasibility and using temperature-based acceptance to improve solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (np.max(objectives, axis=0) - min_obj + 1e-8)\n    balance = 1 - np.abs(normalized[:, 0] - normalized[:, 1])\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Adaptive operator selection\n    operator_prob = np.random.rand()\n    if operator_prob < 0.4:  # Segment reversal\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    elif operator_prob < 0.7:  # Constrained node swapping\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Probabilistic edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        # Adaptive acceptance criterion\n        temp = 0.1 * (current_cost1 + current_cost2) / 2\n        delta1 = new_cost1 - current_cost1\n        delta2 = new_cost2 - current_cost2\n        if (delta1 > 0 or delta2 > 0) and np.random.rand() > np.exp(-(delta1 + delta2)/temp):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7752071262972617,
            0.33293604850769043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    normalized = (objectives - min_obj) / (np.max(objectives, axis=0) - min_obj + 1e-8)\n    balance = 1 - np.abs(normalized[:, 0] - normalized[:, 1])\n    selected_idx = np.argmax(balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Adaptive operator selection\n    operator_prob = np.random.rand()\n    if operator_prob < 0.4:  # Segment reversal\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n    elif operator_prob < 0.7:  # Constrained node swapping\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Probabilistic edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        # Adaptive acceptance criterion\n        temp = 0.1 * (current_cost1 + current_cost2) / 2\n        delta1 = new_cost1 - current_cost1\n        delta2 = new_cost2 - current_cost2\n        if (delta1 > 0 or delta2 > 0) and np.random.rand() > np.exp(-(delta1 + delta2)/temp):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 35,
        "algorithm": "The algorithm prioritizes diverse solutions from the archive, uses adaptive hybrid local search (combining partial tour reversal and constrained edge swaps), and employs probabilistic acceptance to balance exploration and exploitation while ensuring feasibility through strict validation. It dynamically adjusts segment sizes and swap selections based on objective ratios, favoring solutions with better trade-offs between the two objectives. The selection process emphasizes diversity, while the local search adapts to the solution's objective characteristics to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: prioritize solutions with diverse objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity = np.sum(np.abs(objectives - mean_obj), axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Adaptive hybrid local search\n    if np.random.rand() < 0.4:\n        # Partial tour reversal with objective-aware segment selection\n        obj_ratio = current_cost1 / (current_cost2 + 1e-6)\n        segment_size = int(min(n/2, max(2, np.random.normal(loc=obj_ratio*2, scale=1))))\n        start = np.random.randint(0, n - segment_size + 1)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n    else:\n        # Constrained edge swap with objective-based selection\n        candidates = []\n        for i in range(n):\n            for j in range(i+2, n):\n                if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n                   (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n                    candidates.append((i, j))\n        if candidates:\n            i, j = random.choice(candidates)\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Feasibility validation and probabilistic acceptance\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 > current_cost1 and new_cost2 > current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            pass\n        else:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6099220107777322,
            0.6817824840545654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: prioritize solutions with diverse objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity = np.sum(np.abs(objectives - mean_obj), axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Adaptive hybrid local search\n    if np.random.rand() < 0.4:\n        # Partial tour reversal with objective-aware segment selection\n        obj_ratio = current_cost1 / (current_cost2 + 1e-6)\n        segment_size = int(min(n/2, max(2, np.random.normal(loc=obj_ratio*2, scale=1))))\n        start = np.random.randint(0, n - segment_size + 1)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n    else:\n        # Constrained edge swap with objective-based selection\n        candidates = []\n        for i in range(n):\n            for j in range(i+2, n):\n                if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n                   (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n                    candidates.append((i, j))\n        if candidates:\n            i, j = random.choice(candidates)\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Feasibility validation and probabilistic acceptance\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 > current_cost1 and new_cost2 > current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            pass\n        else:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, selected nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(Response in <100 words, meeting the tip.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 36,
        "algorithm": "The algorithm selects promising solutions from the archive using Pareto dominance and objective diversity, then applies a hybrid local search that adaptively combines edge reversal and distance-aware node relocation, prioritizing the objective with stronger dominance while ensuring feasibility through validation and occasional random perturbations to escape local optima. It balances improvement potential for both objectives by favoring edge reversals when one objective dominates significantly, otherwise using node relocation to explore better positions, with fallback to the original solution if no improvement is found.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_nondominated[i] = False\n    nondominated_indices = np.where(is_nondominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n    diversity = np.max(objectives[nondominated_indices], axis=1) - np.min(objectives[nondominated_indices], axis=1)\n    selected_idx = np.random.choice(nondominated_indices, p=diversity/np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Adaptive hybrid local search\n    if np.random.rand() < 0.7:  # Higher probability for edge reversal when first objective dominates\n        if current_cost1 > current_cost2 * 1.2:  # Strong first objective dominance\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            # Distance-aware node relocation\n            k = np.random.randint(0, n)\n            candidates = []\n            for l in range(n):\n                if l != k and l != (k+1)%n:\n                    temp_sol = new_solution.copy()\n                    node = temp_sol[k]\n                    temp_sol = np.delete(temp_sol, k)\n                    temp_sol = np.insert(temp_sol, l, node)\n                    cost1 = calculate_cost(temp_sol, distance_matrix_1)\n                    cost2 = calculate_cost(temp_sol, distance_matrix_2)\n                    if (cost1 < current_cost1 or cost2 < current_cost2):\n                        candidates.append((l, cost1, cost2))\n            if candidates:\n                l, _, _ = max(candidates, key=lambda x: (x[1] < current_cost1, x[2] < current_cost2))\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n    else:\n        # Small random perturbation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8560449892866057,
            2.998673439025879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_nondominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_nondominated[i] = False\n    nondominated_indices = np.where(is_nondominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n    diversity = np.max(objectives[nondominated_indices], axis=1) - np.min(objectives[nondominated_indices], axis=1)\n    selected_idx = np.random.choice(nondominated_indices, p=diversity/np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Adaptive hybrid local search\n    if np.random.rand() < 0.7:  # Higher probability for edge reversal when first objective dominates\n        if current_cost1 > current_cost2 * 1.2:  # Strong first objective dominance\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            # Distance-aware node relocation\n            k = np.random.randint(0, n)\n            candidates = []\n            for l in range(n):\n                if l != k and l != (k+1)%n:\n                    temp_sol = new_solution.copy()\n                    node = temp_sol[k]\n                    temp_sol = np.delete(temp_sol, k)\n                    temp_sol = np.insert(temp_sol, l, node)\n                    cost1 = calculate_cost(temp_sol, distance_matrix_1)\n                    cost2 = calculate_cost(temp_sol, distance_matrix_2)\n                    if (cost1 < current_cost1 or cost2 < current_cost2):\n                        candidates.append((l, cost1, cost2))\n            if candidates:\n                l, _, _ = max(candidates, key=lambda x: (x[1] < current_cost1, x[2] < current_cost2))\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n    else:\n        # Small random perturbation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s a concise, actionable heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 37,
        "algorithm": "The algorithm selects nondominated solutions with high objective diversity from the archive, then applies a hybrid local search combining adaptive edge-swap and distance-aware node relocation, ensuring feasibility by validating node uniqueness and prioritizing exploration of structural diversity in the solution space. It intelligently balances exploration and exploitation by favoring edge-swaps that maintain or improve objective costs while using probabilistic relocation based on distance improvements. The method ensures feasibility through validation and falls back to the original solution if needed, while maintaining the TSP tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        diversity_scores = np.zeros(len(nondominated))\n        for idx, i in enumerate(nondominated):\n            other_objectives = np.delete(objectives, i, axis=0)\n            diversity_scores[idx] = np.mean(np.linalg.norm(objectives[i] - other_objectives, axis=1))\n        selected_idx = nondominated[np.argmax(diversity_scores)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: adaptive edge-swap and distance-aware relocation\n    # Edge-swap with objective balance check\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.1:\n        new_solution = temp_solution\n\n    # Distance-aware node relocation\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n\n    current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                    distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n    probs = np.zeros(n)\n    for l in range(n):\n        if l == k or l == (k-1)%n or l == (k+1)%n:\n            continue\n        new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                    distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n        probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n    probs /= probs.sum()\n    l = np.random.choice(n, p=probs)\n\n    if l != k and l != (k-1)%n and l != (k+1)%n:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7631974640617264,
            0.9550284743309021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        diversity_scores = np.zeros(len(nondominated))\n        for idx, i in enumerate(nondominated):\n            other_objectives = np.delete(objectives, i, axis=0)\n            diversity_scores[idx] = np.mean(np.linalg.norm(objectives[i] - other_objectives, axis=1))\n        selected_idx = nondominated[np.argmax(diversity_scores)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: adaptive edge-swap and distance-aware relocation\n    # Edge-swap with objective balance check\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.1:\n        new_solution = temp_solution\n\n    # Distance-aware node relocation\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n\n    current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                    distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n    probs = np.zeros(n)\n    for l in range(n):\n        if l == k or l == (k-1)%n or l == (k+1)%n:\n            continue\n        new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                    distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n        probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n    probs /= probs.sum()\n    l = np.random.choice(n, p=probs)\n\n    if l != k and l != (k-1)%n and l != (k+1)%n:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a concise, actionable heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 38,
        "algorithm": "The algorithm selects nondominated solutions from the archive, prioritizes those with high objective diversity, and applies a hybrid local search combining distance-aware edge swaps and constrained relocations, adaptively prioritizing improvements in the more critical objective while maintaining feasibility through structural validation. It balances exploration of diverse solutions with exploitation of promising regions, using adaptive operator selection based on current objective dominance to guide the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto filtering to select nondominated solutions\n    def is_dominated(a, b):\n        return a[0] >= b[0] and a[1] >= b[1] and (a[0] > b[0] or a[1] > b[1])\n\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_idx = np.random.randint(len(archive))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        # Select solution with highest objective diversity\n        objectives = np.array([obj for _, obj in nondominated])\n        diversity = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: distance-aware edge swap with structural balance\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    while j - i == 1:  # Ensure non-adjacent nodes\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate distances in both spaces\n    dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n    # Adaptive operator selection based on objective dominance\n    if current_cost1 > current_cost2 or (dist1_before - dist1_after) > (dist2_before - dist2_after):\n        # Perform edge swap if it improves the more critical objective\n        new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n    else:\n        # Perform constrained relocation if it maintains structural balance\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6303750828228921,
            0.39489448070526123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto filtering to select nondominated solutions\n    def is_dominated(a, b):\n        return a[0] >= b[0] and a[1] >= b[1] and (a[0] > b[0] or a[1] > b[1])\n\n    nondominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if is_dominated(obj, other_obj):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        selected_idx = np.random.randint(len(archive))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        # Select solution with highest objective diversity\n        objectives = np.array([obj for _, obj in nondominated])\n        diversity = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: distance-aware edge swap with structural balance\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    while j - i == 1:  # Ensure non-adjacent nodes\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate distances in both spaces\n    dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n    # Adaptive operator selection based on objective dominance\n    if current_cost1 > current_cost2 or (dist1_before - dist1_after) > (dist2_before - dist2_after):\n        # Perform edge swap if it improves the more critical objective\n        new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n    else:\n        # Perform constrained relocation if it maintains structural balance\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a concise, actionable heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 39,
        "algorithm": "The algorithm selects promising solutions from the archive using Pareto-aware crowding distance, then applies a hybrid local search that alternates between distance-aware edge relocations and segment reversals based on the structural imbalance between the two objective spaces, ensuring feasibility by validating tour connectivity and node uniqueness. The operator selection prioritizes edge relocations for imbalanced solutions and segment reversals for balanced ones, with the imbalance ratio determining the approach.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: choose solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solutions with high crowding distance\n    top_indices = np.argsort(crowding_dist)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance in both objective spaces\n    def calculate_imbalance(solution, distance_matrix):\n        total_length = 0\n        for i in range(n):\n            total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total_length\n\n    imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n    imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n    imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n    # Hybrid local search: alternate between operators based on imbalance\n    if imbalance_ratio > 0.3:  # If significant imbalance, prioritize distance-aware relocation\n        # Distance-aware edge relocation\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and (i != 0 or j != n-1):  # Avoid first/last edge\n                # Calculate potential improvement in both objectives\n                old_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Swap edges\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Revert if worse in both objectives\n                if new_dist1 > old_dist1 and new_dist2 > old_dist2:\n                    new_solution[j] = new_solution[i]\n                    new_solution[i] = temp\n    else:  # If balanced, prioritize segment reversal\n        if n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.9547265839760125,
            0.369709849357605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: choose solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solutions with high crowding distance\n    top_indices = np.argsort(crowding_dist)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance in both objective spaces\n    def calculate_imbalance(solution, distance_matrix):\n        total_length = 0\n        for i in range(n):\n            total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total_length\n\n    imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n    imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n    imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n    # Hybrid local search: alternate between operators based on imbalance\n    if imbalance_ratio > 0.3:  # If significant imbalance, prioritize distance-aware relocation\n        # Distance-aware edge relocation\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and (i != 0 or j != n-1):  # Avoid first/last edge\n                # Calculate potential improvement in both objectives\n                old_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Swap edges\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Revert if worse in both objectives\n                if new_dist1 > old_dist1 and new_dist2 > old_dist2:\n                    new_solution[j] = new_solution[i]\n                    new_solution[i] = temp\n    else:  # If balanced, prioritize segment reversal\n        if n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 40,
        "algorithm": "This algorithm selects high-potential solutions from the archive using dynamic weighted scores (prioritizing objectives with higher diversity) and applies a hybrid local search combining non-adjacent segment swaps, random reinsertions, and probabilistic edge flips to generate feasible neighbors, ensuring all nodes are visited exactly once. The selection process emphasizes solutions with better performance in objectives showing greater diversity, while the local search operators introduce controlled perturbations to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic weighted objective scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Adaptive weights based on solution diversity\n    diversity = np.std(normalized, axis=0)\n    weights = diversity / diversity.sum()\n    scores = normalized[:, 0] * weights[0] + normalized[:, 1] * weights[1]\n\n    # Select top 20% of solutions with probability proportional to score\n    top_indices = np.argsort(scores)[-max(1, len(archive) // 5):]\n    probs = scores[top_indices] / scores[top_indices].sum()\n    selected_idx = np.random.choice(top_indices, p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: non-adjacent segment swap + random reinsertion + edge flip\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Non-adjacent segment swap\n    if n > 4:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Random node reinsertion\n    if n > 3 and np.random.rand() < 0.3:\n        pos = np.random.randint(0, n)\n        node = new_solution[pos]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Probabilistic edge flip\n    if n > 2 and np.random.rand() < 0.2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.7531381999976701,
            0.29371631145477295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic weighted objective scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Adaptive weights based on solution diversity\n    diversity = np.std(normalized, axis=0)\n    weights = diversity / diversity.sum()\n    scores = normalized[:, 0] * weights[0] + normalized[:, 1] * weights[1]\n\n    # Select top 20% of solutions with probability proportional to score\n    top_indices = np.argsort(scores)[-max(1, len(archive) // 5):]\n    probs = scores[top_indices] / scores[top_indices].sum()\n    selected_idx = np.random.choice(top_indices, p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: non-adjacent segment swap + random reinsertion + edge flip\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Non-adjacent segment swap\n    if n > 4:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Random node reinsertion\n    if n > 3 and np.random.rand() < 0.3:\n        pos = np.random.randint(0, n)\n        node = new_solution[pos]\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Probabilistic edge flip\n    if n > 2 and np.random.rand() < 0.2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 41,
        "algorithm": "The algorithm dynamically selects promising solutions from the archive by prioritizing those with better performance in the second objective (60%) over the first (40%), then applies a hybrid local search combining adaptive segment reversal and targeted edge swaps to generate neighbors while ensuring feasibility. It focuses on improving both objectives through probabilistic edge swaps based on distance reduction and maintains solution validity through strict checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection (prioritize second objective)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.4 + normalized[:, 1] * 0.6  # Dynamic weights\n\n    # Select top 25% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 4)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal (longer segments with probability)\n    if n > 4:\n        segment_length = min(n // 2, np.random.randint(2, n // 2 + 1))\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Targeted edge swap (focus on improving both objectives)\n    if n > 5:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if j - i > 1:\n            # Swap edges with probability based on distance improvement\n            d1_old = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n            d1_new = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n            d2_old = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n            d2_new = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n            if (d1_new < d1_old or d2_new < d2_old) and np.random.random() < 0.7:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8455053089820819,
            0.24639886617660522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted selection (prioritize second objective)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.4 + normalized[:, 1] * 0.6  # Dynamic weights\n\n    # Select top 25% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 4)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal (longer segments with probability)\n    if n > 4:\n        segment_length = min(n // 2, np.random.randint(2, n // 2 + 1))\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Targeted edge swap (focus on improving both objectives)\n    if n > 5:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if j - i > 1:\n            # Swap edges with probability based on distance improvement\n            d1_old = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n            d1_new = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n            d2_old = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n            d2_new = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n            if (d1_new < d1_old or d2_new < d2_old) and np.random.random() < 0.7:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 42,
        "algorithm": "The algorithm selects a solution from the archive with high objective diversity (nondominated and high variance) and applies an adaptive hybrid local search combining edge-swap and distance-aware relocation, ensuring feasibility by validating node uniqueness. It prioritizes solutions with significant differences between objectives and uses probabilistic node relocation based on distance improvements in both coordinate spaces. The method balances exploration (random selection) and exploitation (distance-aware moves) while maintaining feasibility through validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (nondominated and high variance)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        variances = [abs(obj[0] - obj[1]) for obj in objectives[nondominated]]\n        selected_idx = nondominated[np.argmax(variances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    # Edge-swap with distance-aware selection\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate potential improvement\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n        new_solution = temp_solution\n\n    # Distance-aware relocation\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n\n    # Calculate relocation probabilities based on distance improvement\n    current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                    distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n    probs = np.zeros(n)\n    for l in range(n):\n        if l == k or l == (k-1)%n or l == (k+1)%n:\n            continue\n        new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                    distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n        probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n    probs /= probs.sum()\n    l = np.random.choice(n, p=probs)\n\n    if l != k and l != (k-1)%n and l != (k+1)%n:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6106193948066365,
            0.4771905541419983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (nondominated and high variance)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        variances = [abs(obj[0] - obj[1]) for obj in objectives[nondominated]]\n        selected_idx = nondominated[np.argmax(variances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    # Edge-swap with distance-aware selection\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate potential improvement\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n        new_solution = temp_solution\n\n    # Distance-aware relocation\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n\n    # Calculate relocation probabilities based on distance improvement\n    current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                    distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n    probs = np.zeros(n)\n    for l in range(n):\n        if l == k or l == (k-1)%n or l == (k+1)%n:\n            continue\n        new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                    distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n        probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n    probs /= probs.sum()\n    l = np.random.choice(n, p=probs)\n\n    if l != k and l != (k-1)%n and l != (k+1)%n:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 43,
        "algorithm": "The algorithm selects a solution from the archive prioritizing those with high objective diversity (measured by variance between the two objectives), then applies a hybrid local search alternating between a \"cross-space edge relocation\" operator (repositioning edges based on objective imbalance) and a \"balanced segment reversal\" operator (reversing segments while preserving nondominance), ensuring feasibility by validating node uniqueness and dynamically adjusting operator probabilities for exploration/exploitation balance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Alternate between cross-space edge relocation and balanced segment reversal\n    if np.random.rand() < 0.6:  # Higher probability for cross-space relocation\n        # Cross-space edge relocation\n        edge_scores = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            score = abs(cost1 - cost2)  # High score means high imbalance\n            edge_scores.append(score)\n\n        # Select edges with high imbalance between objectives\n        selected_edges = np.argsort(edge_scores)[-2:]  # Top 2 edges\n        for edge in selected_edges:\n            if np.random.rand() < 0.5:\n                # Relocate the edge to a position that balances both objectives\n                new_pos = np.random.randint(0, n)\n                if new_pos != edge and new_pos != (edge + 1) % n:\n                    new_solution = np.roll(new_solution, -new_pos)\n                    new_solution[0], new_solution[edge] = new_solution[edge], new_solution[0]\n                    new_solution = np.roll(new_solution, new_pos)\n    else:\n        # Balanced segment reversal\n        segment_length = min(4, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Reverse the segment and check if it maintains nondominance\n        temp_solution = base_solution.copy()\n        temp_solution[start:end] = base_solution[start:end][::-1]\n\n        # Validate nondominance in both objectives\n        def calculate_cost(solution, distance_matrix):\n            cost = 0\n            for i in range(len(solution)):\n                cost += distance_matrix[solution[i], solution[(i + 1) % len(solution)]]\n            return cost\n\n        old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        # Accept if not dominated\n        if not ((new_cost1 > old_cost1 and new_cost2 >= old_cost2) or (new_cost1 >= old_cost1 and new_cost2 > old_cost2)):\n            new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.5751468418647319,
            0.7702716588973999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Alternate between cross-space edge relocation and balanced segment reversal\n    if np.random.rand() < 0.6:  # Higher probability for cross-space relocation\n        # Cross-space edge relocation\n        edge_scores = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            score = abs(cost1 - cost2)  # High score means high imbalance\n            edge_scores.append(score)\n\n        # Select edges with high imbalance between objectives\n        selected_edges = np.argsort(edge_scores)[-2:]  # Top 2 edges\n        for edge in selected_edges:\n            if np.random.rand() < 0.5:\n                # Relocate the edge to a position that balances both objectives\n                new_pos = np.random.randint(0, n)\n                if new_pos != edge and new_pos != (edge + 1) % n:\n                    new_solution = np.roll(new_solution, -new_pos)\n                    new_solution[0], new_solution[edge] = new_solution[edge], new_solution[0]\n                    new_solution = np.roll(new_solution, new_pos)\n    else:\n        # Balanced segment reversal\n        segment_length = min(4, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Reverse the segment and check if it maintains nondominance\n        temp_solution = base_solution.copy()\n        temp_solution[start:end] = base_solution[start:end][::-1]\n\n        # Validate nondominance in both objectives\n        def calculate_cost(solution, distance_matrix):\n            cost = 0\n            for i in range(len(solution)):\n                cost += distance_matrix[solution[i], solution[(i + 1) % len(solution)]]\n            return cost\n\n        old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        # Accept if not dominated\n        if not ((new_cost1 > old_cost1 and new_cost2 >= old_cost2) or (new_cost1 >= old_cost1 and new_cost2 > old_cost2)):\n            new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 44,
        "algorithm": "The algorithm selects promising solutions from an archive based on objective diversity (prioritizing those with high trade-offs) and applies a hybrid local search that alternates between edge-swaps (focusing on critical edges) and distance-aware relocations (randomly swapping nodes), dynamically adjusting segment lengths based on problem size, while ensuring feasibility by validating node uniqueness. It balances exploration and exploitation by probabilistically favoring operators that improve structural balance between objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with high nondominated diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.std(objectives, axis=0)\n    diversity_threshold = np.median(crowding_distances) * 1.5\n    high_diversity_indices = np.where(np.min(objectives, axis=1) > diversity_threshold)[0]\n\n    if len(high_diversity_indices) == 0:\n        selected_idx = np.argmax(np.sum(objectives, axis=1))\n    else:\n        selected_idx = np.random.choice(high_diversity_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment length based on objective variance\n    segment_length = max(2, min(5, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Alternate between edge-swap and distance-aware relocation\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective awareness\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            importance = abs(cost1 - cost2) * (1 / (cost1 + cost2 + 1e-6))\n            edge_importance.append(importance)\n\n        important_edges = np.argsort(edge_importance)[-2:]\n        for edge in important_edges:\n            if np.random.rand() < 0.7:\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n    else:\n        # Distance-aware relocation\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.9075535264116197,
            0.34682369232177734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with high nondominated diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.std(objectives, axis=0)\n    diversity_threshold = np.median(crowding_distances) * 1.5\n    high_diversity_indices = np.where(np.min(objectives, axis=1) > diversity_threshold)[0]\n\n    if len(high_diversity_indices) == 0:\n        selected_idx = np.argmax(np.sum(objectives, axis=1))\n    else:\n        selected_idx = np.random.choice(high_diversity_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment length based on objective variance\n    segment_length = max(2, min(5, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Alternate between edge-swap and distance-aware relocation\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective awareness\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            importance = abs(cost1 - cost2) * (1 / (cost1 + cost2 + 1e-6))\n            edge_importance.append(importance)\n\n        important_edges = np.argsort(edge_importance)[-2:]\n        for edge in important_edges:\n            if np.random.rand() < 0.7:\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n    else:\n        # Distance-aware relocation\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 45,
        "algorithm": "The algorithm selects a solution from the archive (prioritizing those with higher combined objective values) and applies a multi-objective segment insertion operator that probabilistically moves segments to positions with high objective variance, ensuring feasibility by validating the new solution. The segment length is randomly chosen (2-4 nodes), and insertion positions are scored based on the average absolute difference between costs in the two objectives. The new solution is validated for uniqueness before returning.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (simplified approach)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective segment insertion\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start + segment_length]\n\n    # Calculate insertion positions based on objective variance\n    insertion_scores = []\n    for i in range(n - segment_length + 1):\n        if i == start:  # Skip original position\n            insertion_scores.append(0)\n            continue\n        # Calculate average variance for potential insertion\n        avg_variance = 0\n        for j in range(len(segment)):\n            node_prev = base_solution[i + j - 1] if i + j > 0 else base_solution[-1]\n            node_next = base_solution[i + j]\n            cost1 = distance_matrix_1[node_prev, segment[j]] + distance_matrix_1[segment[j], node_next]\n            cost2 = distance_matrix_2[node_prev, segment[j]] + distance_matrix_2[segment[j], node_next]\n            avg_variance += abs(cost1 - cost2)\n        insertion_scores.append(avg_variance / len(segment))\n\n    if any(s > 0 for s in insertion_scores):\n        best_pos = np.argmax(insertion_scores)\n        if best_pos != start:\n            # Remove original segment\n            new_solution = np.concatenate([base_solution[:start], base_solution[start + segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.9081538245752377,
            0.3004065155982971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (simplified approach)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective segment insertion\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    segment = base_solution[start:start + segment_length]\n\n    # Calculate insertion positions based on objective variance\n    insertion_scores = []\n    for i in range(n - segment_length + 1):\n        if i == start:  # Skip original position\n            insertion_scores.append(0)\n            continue\n        # Calculate average variance for potential insertion\n        avg_variance = 0\n        for j in range(len(segment)):\n            node_prev = base_solution[i + j - 1] if i + j > 0 else base_solution[-1]\n            node_next = base_solution[i + j]\n            cost1 = distance_matrix_1[node_prev, segment[j]] + distance_matrix_1[segment[j], node_next]\n            cost2 = distance_matrix_2[node_prev, segment[j]] + distance_matrix_2[segment[j], node_next]\n            avg_variance += abs(cost1 - cost2)\n        insertion_scores.append(avg_variance / len(segment))\n\n    if any(s > 0 for s in insertion_scores):\n        best_pos = np.argmax(insertion_scores)\n        if best_pos != start:\n            # Remove original segment\n            new_solution = np.concatenate([base_solution[:start], base_solution[start + segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 46,
        "algorithm": "The algorithm selects a high-potential solution from the archive (based on combined objective values), applies a dynamic segment reversal, and uses a multi-objective edge modification strategy prioritizing edges with high cost variance between objectives, ensuring feasibility through validation checks. It dynamically adjusts segment length and probabilistically modifies edges with significant cost differences, balancing exploration and exploitation. The solution prioritizes edges with normalized cost differences, ensuring diverse and high-quality improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment reversal with multi-objective awareness\n    segment_length = min(5, n // 2)  # Larger dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection with probabilistic modification\n    if np.random.rand() < 0.8:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on normalized cost differences\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            normalized_diff = abs(cost1 - cost2) / (cost1 + cost2 + 1e-10)  # Avoid division by zero\n            edge_importance.append(normalized_diff)\n\n        # Select edges with high normalized differences for potential modification\n        important_edges = np.argsort(edge_importance)[-3:]  # Top 3 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.6:  # Higher chance to modify each selected edge\n                neighbor = (edge + 2) % n  # Modify with a larger step\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.865858743701543,
            0.22853302955627441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment reversal with multi-objective awareness\n    segment_length = min(5, n // 2)  # Larger dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection with probabilistic modification\n    if np.random.rand() < 0.8:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on normalized cost differences\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            normalized_diff = abs(cost1 - cost2) / (cost1 + cost2 + 1e-10)  # Avoid division by zero\n            edge_importance.append(normalized_diff)\n\n        # Select edges with high normalized differences for potential modification\n        important_edges = np.argsort(edge_importance)[-3:]  # Top 3 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.6:  # Higher chance to modify each selected edge\n                neighbor = (edge + 2) % n  # Modify with a larger step\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive (prioritizing those with higher combined objective values) and applies a hybrid local search combining segment reversal with multi-objective-aware edge modification. It dynamically selects segment lengths, reverses them, and probabilistically modifies edges with high variance in cost contributions between objectives, ensuring feasibility by validating uniqueness. The novel approach balances exploration of both objective spaces through variance-based edge selection and dynamic segment adjustment.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Segment reversal with multi-objective awareness\n    segment_length = min(4, n // 3)  # Dynamic segment size\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Reverse the segment\n    new_solution[start:end] = base_solution[start:end][::-1]\n\n    # Multi-objective edge selection\n    if np.random.rand() < 0.7:  # Higher probability to apply the novel operator\n        # Calculate edge importance based on objective variance\n        edge_importance = []\n        for i in range(n):\n            node1 = base_solution[i]\n            node2 = base_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            variance = abs(cost1 - cost2)\n            edge_importance.append(variance)\n\n        # Select edges with high variance for potential modification\n        important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n        for edge in important_edges:\n            if np.random.rand() < 0.5:  # 50% chance to modify each selected edge\n                neighbor = (edge + 1) % n\n                new_solution[edge], new_solution[neighbor] = new_solution[neighbor], new_solution[edge]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s a refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 47,
        "algorithm": "The algorithm selects nondominated solutions with high objective diversity from the archive, then applies a hybrid local search combining segment reversal and edge relocation, prioritizing edges with high cost variance between objectives while dynamically adjusting operator probabilities to balance exploitation and exploration, ensuring feasibility through node uniqueness checks. The selection favors solutions with balanced objective trade-offs, and the local search alternates between multi-objective-aware segment reversal (with dynamic segment sizes) and distance-aware edge relocation, with higher probabilities for segment reversal and relocation of high-variance edges.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter nondominated solutions with high objective diversity\n    nondominated = []\n    objectives = [obj for _, obj in archive]\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution with highest objective diversity\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in nondominated]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search\n    if np.random.rand() < 0.6:  # Higher probability for segment reversal\n        # Multi-objective-aware segment reversal\n        segment_length = min(5, n // 2)  # Dynamic segment size\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = base_solution[start:end][::-1]\n\n        # Edge relocation based on cost variance\n        if np.random.rand() < 0.4:\n            edge_importance = []\n            for i in range(n):\n                node1 = base_solution[i]\n                node2 = base_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node1, node2]\n                cost2 = distance_matrix_2[node1, node2]\n                variance = abs(cost1 - cost2)\n                edge_importance.append(variance)\n\n            important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n            for edge in important_edges:\n                if np.random.rand() < 0.6:  # Higher probability to relocate\n                    # Find best insertion point\n                    best_pos = edge\n                    best_cost = float('inf')\n                    for pos in range(n):\n                        if pos != edge and pos != (edge + 1) % n:\n                            temp = new_solution.copy()\n                            temp = np.roll(temp, -pos)\n                            temp[0], temp[1] = temp[1], temp[0]\n                            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                            total_cost = cost1 + cost2\n                            if total_cost < best_cost:\n                                best_cost = total_cost\n                                best_pos = pos\n                    if best_pos != edge:\n                        new_solution = np.roll(new_solution, -best_pos)\n                        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n    else:\n        # Distance-aware edge relocation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if not (i == 0 and j == n-1):\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5941747024106235,
            0.3925003409385681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter nondominated solutions with high objective diversity\n    nondominated = []\n    objectives = [obj for _, obj in archive]\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution with highest objective diversity\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in nondominated]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search\n    if np.random.rand() < 0.6:  # Higher probability for segment reversal\n        # Multi-objective-aware segment reversal\n        segment_length = min(5, n // 2)  # Dynamic segment size\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = base_solution[start:end][::-1]\n\n        # Edge relocation based on cost variance\n        if np.random.rand() < 0.4:\n            edge_importance = []\n            for i in range(n):\n                node1 = base_solution[i]\n                node2 = base_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[node1, node2]\n                cost2 = distance_matrix_2[node1, node2]\n                variance = abs(cost1 - cost2)\n                edge_importance.append(variance)\n\n            important_edges = np.argsort(edge_importance)[-2:]  # Top 2 edges\n            for edge in important_edges:\n                if np.random.rand() < 0.6:  # Higher probability to relocate\n                    # Find best insertion point\n                    best_pos = edge\n                    best_cost = float('inf')\n                    for pos in range(n):\n                        if pos != edge and pos != (edge + 1) % n:\n                            temp = new_solution.copy()\n                            temp = np.roll(temp, -pos)\n                            temp[0], temp[1] = temp[1], temp[0]\n                            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                            total_cost = cost1 + cost2\n                            if total_cost < best_cost:\n                                best_cost = total_cost\n                                best_pos = pos\n                    if best_pos != edge:\n                        new_solution = np.roll(new_solution, -best_pos)\n                        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n    else:\n        # Distance-aware edge relocation\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if not (i == 0 and j == n-1):\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects promising solutions from the archive using Pareto-aware crowding distance, then applies a hybrid local search that alternates between distance-aware edge relocations and segment reversals based on the structural imbalance between the two objective spaces, ensuring feasibility by validating tour connectivity and node uniqueness. The operator selection prioritizes edge relocations for imbalanced solutions and segment reversals for balanced ones, with the imbalance ratio determining the approach.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: choose solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solutions with high crowding distance\n    top_indices = np.argsort(crowding_dist)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance in both objective spaces\n    def calculate_imbalance(solution, distance_matrix):\n        total_length = 0\n        for i in range(n):\n            total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total_length\n\n    imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n    imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n    imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n    # Hybrid local search: alternate between operators based on imbalance\n    if imbalance_ratio > 0.3:  # If significant imbalance, prioritize distance-aware relocation\n        # Distance-aware edge relocation\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and (i != 0 or j != n-1):  # Avoid first/last edge\n                # Calculate potential improvement in both objectives\n                old_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Swap edges\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Revert if worse in both objectives\n                if new_dist1 > old_dist1 and new_dist2 > old_dist2:\n                    new_solution[j] = new_solution[i]\n                    new_solution[i] = temp\n    else:  # If balanced, prioritize segment reversal\n        if n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 48,
        "algorithm": "The algorithm selects promising solutions from the archive using Pareto-aware crowding distance, then applies an adaptive hybrid local search that prioritizes either distance-aware edge relocations (when objectives are imbalanced) or segment reversals (when balanced), with occasional diversification steps to ensure feasibility and high-quality solutions. The selection balances exploration and exploitation by dynamically adjusting operators based on structural imbalance between objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance\n    def calculate_imbalance(solution, distance_matrix):\n        total = 0\n        for i in range(n):\n            total += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total\n\n    imbalance = abs(calculate_imbalance(new_solution, distance_matrix_1) -\n                   calculate_imbalance(new_solution, distance_matrix_2)) / (\n                   calculate_imbalance(new_solution, distance_matrix_1) +\n                   calculate_imbalance(new_solution, distance_matrix_2) + 1e-8)\n\n    # Adaptive hybrid local search\n    if imbalance > 0.3:  # High imbalance - prioritize distance-aware relocation\n        if n > 3:\n            i, j = np.random.choice(n, 2, replace=False)\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            # Accept if improves at least one objective\n            if (calculate_imbalance(temp, distance_matrix_1) < calculate_imbalance(new_solution, distance_matrix_1) or\n                calculate_imbalance(temp, distance_matrix_2) < calculate_imbalance(new_solution, distance_matrix_2)):\n                new_solution = temp\n    else:  # Balanced - prioritize segment reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Additional diversification with small probability\n    if np.random.rand() < 0.1:\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Validate feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.5970620944917678,
            0.428679883480072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance\n    def calculate_imbalance(solution, distance_matrix):\n        total = 0\n        for i in range(n):\n            total += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total\n\n    imbalance = abs(calculate_imbalance(new_solution, distance_matrix_1) -\n                   calculate_imbalance(new_solution, distance_matrix_2)) / (\n                   calculate_imbalance(new_solution, distance_matrix_1) +\n                   calculate_imbalance(new_solution, distance_matrix_2) + 1e-8)\n\n    # Adaptive hybrid local search\n    if imbalance > 0.3:  # High imbalance - prioritize distance-aware relocation\n        if n > 3:\n            i, j = np.random.choice(n, 2, replace=False)\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            # Accept if improves at least one objective\n            if (calculate_imbalance(temp, distance_matrix_1) < calculate_imbalance(new_solution, distance_matrix_1) or\n                calculate_imbalance(temp, distance_matrix_2) < calculate_imbalance(new_solution, distance_matrix_2)):\n                new_solution = temp\n    else:  # Balanced - prioritize segment reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Additional diversification with small probability\n    if np.random.rand() < 0.1:\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Validate feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 49,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8643293894826791,
            4.075331330299377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize structurally balanced and nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate structural balance (low variance in segment lengths)\n    segment_vars = []\n    for sol in solutions:\n        segments = []\n        for i in range(len(sol)):\n            segments.append(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]])\n        segment_vars.append(np.var(segments))\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Combine structural balance and nondominated status\n    scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            scores[i] = 1 / (1 + segment_vars[i])\n\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive operator selection\n    if np.random.random() < 0.5:\n        # Segment-based reversal\n        segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Distance-aware node relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 50,
        "algorithm": "The algorithm combines Pareto-aware selection with adaptive operator fusion, prioritizing nondominated solutions with high objective diversity while dynamically applying segment reversal, edge swapping, or cross-space operations based on local improvement potential, ensuring feasibility through multi-objective validation and probabilistic acceptance of balanced improvements. It emphasizes nondominated solutions and balances exploration with exploitation through weighted operator selection and cross-dimensional validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Calculate objective diversity\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            diversity[i] = np.sqrt((objectives[i, 0] - np.mean(objectives[:, 0]))**2 + (objectives[i, 1] - np.mean(objectives[:, 1]))**2)\n\n    if np.sum(diversity) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=diversity/diversity.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator selection\n    operator = np.random.choice(['segment', 'edge_swap', 'cross_space'], p=[0.4, 0.3, 0.3])\n\n    if operator == 'segment':\n        # Adaptive segment reversal with cross-dimensional validation\n        segment_size = max(2, min(5, int(np.random.normal(n/6, n/12))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2:\n            new_solution = temp_sol\n\n    elif operator == 'edge_swap':\n        # Distance-aware edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            return new_solution\n\n        temp_sol = new_solution.copy()\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    else:  # cross_space\n        # Cross-space edge swap with structural balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate cross-space importance\n        importance1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        importance2 = distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if importance1 + importance2 > np.median([distance_matrix_1[a, b] + distance_matrix_2[a, b] for a, b in zip(new_solution, np.roll(new_solution, 1))]):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8407465481832438,
            13.037222743034363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Calculate objective diversity\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            diversity[i] = np.sqrt((objectives[i, 0] - np.mean(objectives[:, 0]))**2 + (objectives[i, 1] - np.mean(objectives[:, 1]))**2)\n\n    if np.sum(diversity) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=diversity/diversity.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic operator selection\n    operator = np.random.choice(['segment', 'edge_swap', 'cross_space'], p=[0.4, 0.3, 0.3])\n\n    if operator == 'segment':\n        # Adaptive segment reversal with cross-dimensional validation\n        segment_size = max(2, min(5, int(np.random.normal(n/6, n/12))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2:\n            new_solution = temp_sol\n\n    elif operator == 'edge_swap':\n        # Distance-aware edge swap\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            return new_solution\n\n        temp_sol = new_solution.copy()\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    else:  # cross_space\n        # Cross-space edge swap with structural balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate cross-space importance\n        importance1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        importance2 = distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if importance1 + importance2 > np.median([distance_matrix_1[a, b] + distance_matrix_2[a, b] for a, b in zip(new_solution, np.roll(new_solution, 1))]):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 51,
        "algorithm": "The algorithm selects high-potential solutions from the archive using a weighted objective score (60% for the first objective, 40% for the second), then applies a hybrid local search combining multi-dimensional node swapping and adaptive cluster-based reversal, ensuring feasibility through probabilistic validation and dynamic segment adjustment. The method prioritizes spatial proximity in both dimensions to identify clusters, then performs intelligent swaps and reversals within these clusters, balancing cost improvements with occasional random exploration to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node clusters based on spatial proximity in both dimensions\n    def calculate_clusters():\n        clusters = []\n        current_cluster = [base_solution[0]]\n        for i in range(1, n):\n            prev_node = base_solution[i-1]\n            current_node = base_solution[i]\n            dist1 = np.linalg.norm(instance[current_node, :2] - instance[prev_node, :2])\n            dist2 = np.linalg.norm(instance[current_node, 2:] - instance[prev_node, 2:])\n            if dist1 < np.mean(distance_matrix_1) * 0.7 and dist2 < np.mean(distance_matrix_2) * 0.7:\n                current_cluster.append(current_node)\n            else:\n                if len(current_cluster) > 2:\n                    clusters.append(current_cluster)\n                current_cluster = [current_node]\n        if len(current_cluster) > 2:\n            clusters.append(current_cluster)\n        return clusters\n\n    clusters = calculate_clusters()\n\n    # Multi-dimensional node swapping\n    for cluster in clusters:\n        if len(cluster) < 3:\n            continue\n        cluster_pos = [np.where(base_solution == node)[0][0] for node in cluster]\n        for i in range(min(2, len(cluster))):\n            node1 = np.random.choice(cluster)\n            node2 = np.random.choice(base_solution)\n            if node2 in cluster:\n                continue\n\n            temp_sol = new_solution.copy()\n            pos1 = np.where(temp_sol == node1)[0][0]\n            pos2 = np.where(temp_sol == node2)[0][0]\n\n            temp_sol[pos1], temp_sol[pos2] = temp_sol[pos2], temp_sol[pos1]\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n                cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))) or np.random.rand() < 0.2:\n                new_solution = temp_sol\n\n    # Adaptive cluster-based reversal\n    for cluster in clusters:\n        if len(cluster) < 3:\n            continue\n        cluster_pos = [np.where(new_solution == node)[0][0] for node in cluster]\n        start = min(cluster_pos)\n        end = max(cluster_pos) + 1\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.1:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8528252700466059,
            0.4776872992515564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node clusters based on spatial proximity in both dimensions\n    def calculate_clusters():\n        clusters = []\n        current_cluster = [base_solution[0]]\n        for i in range(1, n):\n            prev_node = base_solution[i-1]\n            current_node = base_solution[i]\n            dist1 = np.linalg.norm(instance[current_node, :2] - instance[prev_node, :2])\n            dist2 = np.linalg.norm(instance[current_node, 2:] - instance[prev_node, 2:])\n            if dist1 < np.mean(distance_matrix_1) * 0.7 and dist2 < np.mean(distance_matrix_2) * 0.7:\n                current_cluster.append(current_node)\n            else:\n                if len(current_cluster) > 2:\n                    clusters.append(current_cluster)\n                current_cluster = [current_node]\n        if len(current_cluster) > 2:\n            clusters.append(current_cluster)\n        return clusters\n\n    clusters = calculate_clusters()\n\n    # Multi-dimensional node swapping\n    for cluster in clusters:\n        if len(cluster) < 3:\n            continue\n        cluster_pos = [np.where(base_solution == node)[0][0] for node in cluster]\n        for i in range(min(2, len(cluster))):\n            node1 = np.random.choice(cluster)\n            node2 = np.random.choice(base_solution)\n            if node2 in cluster:\n                continue\n\n            temp_sol = new_solution.copy()\n            pos1 = np.where(temp_sol == node1)[0][0]\n            pos2 = np.where(temp_sol == node2)[0][0]\n\n            temp_sol[pos1], temp_sol[pos2] = temp_sol[pos2], temp_sol[pos1]\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n                cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))) or np.random.rand() < 0.2:\n                new_solution = temp_sol\n\n    # Adaptive cluster-based reversal\n    for cluster in clusters:\n        if len(cluster) < 3:\n            continue\n        cluster_pos = [np.where(new_solution == node)[0][0] for node in cluster]\n        start = min(cluster_pos)\n        end = max(cluster_pos) + 1\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.1:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 52,
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective sum, then applies a hybrid local search combining cross-dimensional node swapping (prioritizing high-contribution nodes) and variable-length segment reversals (adjusting segment sizes dynamically) to generate a neighbor solution while ensuring feasibility. The method balances exploitation of high-importance nodes with exploration via randomized segment operations, allowing for both fine-grained and coarse-grained improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective sum (weights based on inverse objective values)\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives + 1e-6)\n    weighted_sums = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node contribution based on both objectives (difference from average)\n    avg_contrib = np.mean([distance_matrix_1[i, (i+1)%n] + distance_matrix_2[i, (i+1)%n] for i in range(n)])\n    contributions = [distance_matrix_1[i, (i+1)%n] + distance_matrix_2[i, (i+1)%n] for i in range(n)]\n    importance = [abs(contrib - avg_contrib) for contrib in contributions]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node swapping\n    for i in range(min(4, n//3)):\n        node1 = sorted_nodes[i]\n        node2 = sorted_nodes[(i+1)%n]\n\n        if node1 == node2 or abs(node1 - node2) < 2:\n            continue\n\n        temp_sol = new_solution.copy()\n        temp_sol[node1], temp_sol[node2] = temp_sol[node2], temp_sol[node1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2:\n            new_solution = temp_sol\n\n    # Variable-length segment reversal\n    min_seg = max(2, n//8)\n    max_seg = max(4, n//3)\n    for _ in range(3):\n        seg_size = np.random.randint(min_seg, max_seg)\n        start = np.random.randint(0, n - seg_size)\n        end = start + seg_size\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old + 0.05 * cost1_old and cost2_new <= cost2_old + 0.05 * cost2_old) or np.random.rand() < 0.1:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7636699057440133,
            0.5467585325241089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective sum (weights based on inverse objective values)\n    objectives = np.array([obj for _, obj in archive])\n    weights = 1 / (objectives + 1e-6)\n    weighted_sums = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmax(weighted_sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node contribution based on both objectives (difference from average)\n    avg_contrib = np.mean([distance_matrix_1[i, (i+1)%n] + distance_matrix_2[i, (i+1)%n] for i in range(n)])\n    contributions = [distance_matrix_1[i, (i+1)%n] + distance_matrix_2[i, (i+1)%n] for i in range(n)]\n    importance = [abs(contrib - avg_contrib) for contrib in contributions]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node swapping\n    for i in range(min(4, n//3)):\n        node1 = sorted_nodes[i]\n        node2 = sorted_nodes[(i+1)%n]\n\n        if node1 == node2 or abs(node1 - node2) < 2:\n            continue\n\n        temp_sol = new_solution.copy()\n        temp_sol[node1], temp_sol[node2] = temp_sol[node2], temp_sol[node1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2:\n            new_solution = temp_sol\n\n    # Variable-length segment reversal\n    min_seg = max(2, n//8)\n    max_seg = max(4, n//3)\n    for _ in range(3):\n        seg_size = np.random.randint(min_seg, max_seg)\n        start = np.random.randint(0, n - seg_size)\n        end = start + seg_size\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old + 0.05 * cost1_old and cost2_new <= cost2_old + 0.05 * cost2_old) or np.random.rand() < 0.1:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 3 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 53,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9868076364651988,
            2.0267587304115295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 3 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap and distance-aware relocation in a hybrid operator, select nondominated solutions with high objective diversity, and validate feasibility across both objectives.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 53,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9868076364651988,
            2.0267587304115295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects promising solutions from the archive using Pareto-aware crowding distance, then applies a hybrid local search that alternates between distance-aware edge relocations and segment reversals based on the structural imbalance between the two objective spaces, ensuring feasibility by validating tour connectivity and node uniqueness. The operator selection prioritizes edge relocations for imbalanced solutions and segment reversals for balanced ones, with the imbalance ratio determining the approach.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: choose solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solutions with high crowding distance\n    top_indices = np.argsort(crowding_dist)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance in both objective spaces\n    def calculate_imbalance(solution, distance_matrix):\n        total_length = 0\n        for i in range(n):\n            total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total_length\n\n    imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n    imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n    imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n    # Hybrid local search: alternate between operators based on imbalance\n    if imbalance_ratio > 0.3:  # If significant imbalance, prioritize distance-aware relocation\n        # Distance-aware edge relocation\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and (i != 0 or j != n-1):  # Avoid first/last edge\n                # Calculate potential improvement in both objectives\n                old_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Swap edges\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Revert if worse in both objectives\n                if new_dist1 > old_dist1 and new_dist2 > old_dist2:\n                    new_solution[j] = new_solution[i]\n                    new_solution[i] = temp\n    else:  # If balanced, prioritize segment reversal\n        if n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap (for local optimization) and distance-aware relocation (for global exploration) in a hybrid operator. Select nondominated solutions with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 54,
        "algorithm": "The algorithm selects nondominated solutions with high diversity using Pareto-aware crowding distance, then applies a hybrid local search combining edge-swap and distance-aware relocation to generate neighbors while ensuring feasibility through structural balance validation. It prioritizes solutions with high crowding distance (indicating objective diversity) and uses probabilistic relocation based on distance matrices to balance improvements across both objectives. The method reverts to the base solution if feasibility or structural imbalance is violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select nondominated solutions with high crowding distance\n    nondominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        candidates = [i for i in nondominated if crowding_dist[i] > np.median(crowding_dist[nondominated])]\n        selected_idx = np.random.choice(candidates) if candidates else np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge-swap and distance-aware relocation\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if not (i == 0 and j == n-1):  # Avoid first/last edge\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for distance-aware relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and structural balance\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        # Check structural balance in both objectives\n        def calculate_imbalance(solution, distance_matrix):\n            total_length = 0\n            for i in range(n):\n                total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n            return total_length\n\n        imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n        imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n        imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n        if imbalance_ratio > 0.4:  # If imbalance too high, revert\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8187816822509957,
            1.027609944343567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select nondominated solutions with high crowding distance\n    nondominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.argmax(crowding_dist)\n    else:\n        candidates = [i for i in nondominated if crowding_dist[i] > np.median(crowding_dist[nondominated])]\n        selected_idx = np.random.choice(candidates) if candidates else np.argmax(crowding_dist)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: combine edge-swap and distance-aware relocation\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        if not (i == 0 and j == n-1):  # Avoid first/last edge\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for distance-aware relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and structural balance\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        # Check structural balance in both objectives\n        def calculate_imbalance(solution, distance_matrix):\n            total_length = 0\n            for i in range(n):\n                total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n            return total_length\n\n        imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n        imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n        imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n        if imbalance_ratio > 0.4:  # If imbalance too high, revert\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap (for local optimization) and distance-aware relocation (for global exploration) in a hybrid operator. Select nondominated solutions with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 55,
        "algorithm": "The algorithm selects high-diversity solutions from the archive, prioritizes nodes with high importance in both objectives for relocation, and uses adaptive edge swaps to generate neighbors while ensuring feasibility. It balances exploration/exploitation through dynamic probabilities and thresholds, favoring moves that improve both objectives while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity and low dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    diversity = np.sum(variance)\n    threshold = np.mean(variance) * 0.5\n    candidates = [i for i in range(len(archive)) if np.sum(variance) > threshold]\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.argmax([np.sum(objectives[i]) for i in candidates])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance for both objectives\n    def node_importance(node_idx):\n        contrib1 = (distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] +\n                     distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]])\n        contrib2 = (distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] +\n                     distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]])\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation with adaptive probability\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        prob = 0.5 + 0.5 * (importance[node] / max(importance))\n        if np.random.rand() > prob:\n            continue\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        threshold = 0.1 + 0.2 * (np.sum(objectives[selected_idx]) / np.sum(np.max(objectives, axis=0)))\n        if ((cost1_new <= cost1_old and cost2_new <= cost2_old) or\n            (np.random.rand() < threshold and (cost1_new <= cost1_old or cost2_new <= cost2_old))):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9616758531127807,
            2.6132646203041077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity and low dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    diversity = np.sum(variance)\n    threshold = np.mean(variance) * 0.5\n    candidates = [i for i in range(len(archive)) if np.sum(variance) > threshold]\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.argmax([np.sum(objectives[i]) for i in candidates])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance for both objectives\n    def node_importance(node_idx):\n        contrib1 = (distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] +\n                     distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]])\n        contrib2 = (distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] +\n                     distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]])\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation with adaptive probability\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        prob = 0.5 + 0.5 * (importance[node] / max(importance))\n        if np.random.rand() > prob:\n            continue\n\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        threshold = 0.1 + 0.2 * (np.sum(objectives[selected_idx]) / np.sum(np.max(objectives, axis=0)))\n        if ((cost1_new <= cost1_old and cost2_new <= cost2_old) or\n            (np.random.rand() < threshold and (cost1_new <= cost1_old or cost2_new <= cost2_old))):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap (for local optimization) and distance-aware relocation (for global exploration) in a hybrid operator. Select nondominated solutions with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 56,
        "algorithm": "The algorithm selects high-variance solutions from the archive (indicating multi-objective potential) and applies a hybrid local search alternating between cross-dimensional edge-swaps (validating non-crossing edges in one space but crossing in the other) and segment inversions (flipping high-contribution segments). It ensures feasibility by validating tours and objective trade-offs before acceptance, with a fallback to the base solution if invalid. The method prioritizes solutions with diverse objectives and employs creative, non-standard operators to improve both spaces simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(variance))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Alternate between cross-dimensional edge-swap and segment inversion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Cross-dimensional edge-swap: Select edges that are non-crossing in one space but crossing in the other\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Validate the swap\n            cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2:\n                new_solution = temp_solution\n\n        # Segment inversion based on objective contribution\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the contribution of the segment to both objectives\n        contrib1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(a, b))\n        contrib2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(a, b))\n\n        # Invert the segment if it has high contribution to both objectives\n        if contrib1 > np.mean(distance_matrix_1) or contrib2 > np.mean(distance_matrix_2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9002286227458345,
            0.43765145540237427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective variance (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(variance))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Alternate between cross-dimensional edge-swap and segment inversion\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Cross-dimensional edge-swap: Select edges that are non-crossing in one space but crossing in the other\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Validate the swap\n            cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2:\n                new_solution = temp_solution\n\n        # Segment inversion based on objective contribution\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the contribution of the segment to both objectives\n        contrib1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(a, b))\n        contrib2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(a, b))\n\n        # Invert the segment if it has high contribution to both objectives\n        if contrib1 > np.mean(distance_matrix_1) or contrib2 > np.mean(distance_matrix_2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        None\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 57,
        "algorithm": "This algorithm selects the most promising solution from an archive using a weighted multi-objective scoring system (prioritizing the first objective with 0.6 weight), then applies a hybrid local search combining node importance-based relocations and adaptive edge swaps, validated through curvature constraints and multi-objective cost checks while ensuring tour feasibility through final validation. The node importance calculation balances both objectives (0.7/0.3 weighting) and geometric factors, while the adaptive edge swaps incorporate probabilistic acceptance of non-dominated solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    weights = np.array([0.6, 0.4])  # Weighted preference for first objective\n    weighted_scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node importance calculation\n    def node_importance(node_idx):\n        prev_idx = (node_idx - 1) % n\n        next_idx = (node_idx + 1) % n\n        contrib1 = (distance_matrix_1[node_idx, prev_idx] + distance_matrix_1[node_idx, next_idx]) * 0.7\n        contrib2 = (distance_matrix_2[node_idx, prev_idx] + distance_matrix_2[node_idx, next_idx]) * 0.3\n        angle_factor = np.arctan2(instance[node_idx, 1] - instance[prev_idx, 1], instance[node_idx, 0] - instance[prev_idx, 0]) - \\\n                      np.arctan2(instance[next_idx, 1] - instance[node_idx, 1], instance[next_idx, 0] - instance[node_idx, 0])\n        return contrib1 + contrib2 + abs(angle_factor)\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid node relocation with multi-objective validation\n    for i in range(min(4, n//3)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate multi-objective cost with adaptive weights\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 * 0.6 + cost2 * 0.4\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with curvature-based validation\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) < 2:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check for improved objectives and curvature constraints\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Curvature validation\n        valid = True\n        for k in [i, j, (i-1)%n, (j-1)%n]:\n            angle1 = np.arctan2(instance[temp_solution[(k+1)%n], 1] - instance[temp_solution[k], 1],\n                               instance[temp_solution[(k+1)%n], 0] - instance[temp_solution[k], 0])\n            angle2 = np.arctan2(instance[temp_solution[(k+2)%n], 1] - instance[temp_solution[(k+1)%n], 1],\n                               instance[temp_solution[(k+2)%n], 0] - instance[temp_solution[(k+1)%n], 0])\n            if abs(angle1 - angle2) > np.pi/2:\n                valid = False\n                break\n\n        if valid and ((cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2):\n            new_solution = temp_solution\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.927326155277252,
            2.7729485034942627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    weights = np.array([0.6, 0.4])  # Weighted preference for first objective\n    weighted_scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-dimensional node importance calculation\n    def node_importance(node_idx):\n        prev_idx = (node_idx - 1) % n\n        next_idx = (node_idx + 1) % n\n        contrib1 = (distance_matrix_1[node_idx, prev_idx] + distance_matrix_1[node_idx, next_idx]) * 0.7\n        contrib2 = (distance_matrix_2[node_idx, prev_idx] + distance_matrix_2[node_idx, next_idx]) * 0.3\n        angle_factor = np.arctan2(instance[node_idx, 1] - instance[prev_idx, 1], instance[node_idx, 0] - instance[prev_idx, 0]) - \\\n                      np.arctan2(instance[next_idx, 1] - instance[node_idx, 1], instance[next_idx, 0] - instance[node_idx, 0])\n        return contrib1 + contrib2 + abs(angle_factor)\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid node relocation with multi-objective validation\n    for i in range(min(4, n//3)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate multi-objective cost with adaptive weights\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 * 0.6 + cost2 * 0.4\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with curvature-based validation\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) < 2:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check for improved objectives and curvature constraints\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Curvature validation\n        valid = True\n        for k in [i, j, (i-1)%n, (j-1)%n]:\n            angle1 = np.arctan2(instance[temp_solution[(k+1)%n], 1] - instance[temp_solution[k], 1],\n                               instance[temp_solution[(k+1)%n], 0] - instance[temp_solution[k], 0])\n            angle2 = np.arctan2(instance[temp_solution[(k+2)%n], 1] - instance[temp_solution[(k+1)%n], 1],\n                               instance[temp_solution[(k+2)%n], 0] - instance[temp_solution[(k+1)%n], 0])\n            if abs(angle1 - angle2) > np.pi/2:\n                valid = False\n                break\n\n        if valid and ((cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2):\n            new_solution = temp_solution\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n or not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        None\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 58,
        "algorithm": "The algorithm selects a solution from the archive based on objective diversity (highest standard deviation of normalized objectives) and applies a hybrid local search combining dynamic segment reversal and cross-dimensional node insertion. It prioritizes non-dominated improvements in both objectives, with occasional random acceptance to escape local optima, while ensuring feasibility by verifying node uniqueness. The method balances exploration of trade-offs with local improvement through iterative segment reversals and node insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    diversity = np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment reversal with multi-objective evaluation\n    segment_length = max(2, min(5, n//4))\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n        if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n            cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))):\n            new_solution = temp_sol\n\n    # Cross-dimensional node insertion with adaptive selection\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n            continue\n\n        temp_sol = new_solution.copy()\n        temp_sol = np.delete(temp_sol, node)\n        temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n        cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n        if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n            cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) or\n            np.random.rand() < 0.2):\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6617963122547978,
            1.1444172859191895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    diversity = np.std(normalized, axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment reversal with multi-objective evaluation\n    segment_length = max(2, min(5, n//4))\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n        if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n            cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))):\n            new_solution = temp_sol\n\n    # Cross-dimensional node insertion with adaptive selection\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n            continue\n\n        temp_sol = new_solution.copy()\n        temp_sol = np.delete(temp_sol, node)\n        temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n        cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n        if (cost1 <= sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) and\n            cost2 <= sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) or\n            np.random.rand() < 0.2):\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 4 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine edge-swap (for local optimization) and distance-aware relocation (for global exploration) in a hybrid operator. Select nondominated solutions with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 59,
        "algorithm": "The algorithm selects a promising solution from the archive based on high normalized objective diversity or total objective sum, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing important nodes) and adaptive segment reversal (dynamically adjusting segment sizes), while ensuring feasibility and allowing probabilistic acceptance of non-dominated solutions. It balances exploitation and exploration by alternating between global relocation and local segment reversals, with edge swaps only when they improve both objectives. The algorithm prioritizes nodes with high combined importance in both objectives and dynamically adjusts segment sizes based on improvement potential.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high normalized objective diversity or highest sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    variances = np.var(normalized, axis=1)\n    diversity_threshold = np.percentile(variances, 75)  # Select solutions with above-median diversity\n\n    candidate_indices = [i for i, var in enumerate(variances) if var >= diversity_threshold]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.argmax(np.sum(normalized[candidate_indices], axis=1))\n    selected_idx = candidate_indices[selected_idx]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search: alternate between relocation and segment reversal\n    for phase in range(2):  # Two phases: relocation then segment reversal\n        if phase == 0:  # Relocation phase\n            for i in range(min(3, n//2)):\n                node = sorted_nodes[i]\n                best_pos = -1\n                min_cost = float('inf')\n\n                for pos in range(n):\n                    if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                        continue\n\n                    temp_sol = new_solution.copy()\n                    temp_sol = np.delete(temp_sol, node)\n                    temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n                    cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    total_cost = cost1 + cost2\n\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_pos = pos\n\n                if best_pos != -1:\n                    new_solution = np.delete(new_solution, node)\n                    new_solution = np.insert(new_solution, best_pos, base_solution[node])\n        else:  # Segment reversal phase\n            segment_size = max(2, min(6, n//4))\n            for _ in range(2):\n                start = np.random.randint(0, n - segment_size)\n                end = start + segment_size\n\n                temp_sol = new_solution.copy()\n                temp_sol[start:end] = temp_sol[start:end][::-1]\n\n                cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n                    new_solution = temp_sol\n\n    # Edge swap phase (only if improves both objectives)\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8602722093341773,
            2.2757058143615723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high normalized objective diversity or highest sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    variances = np.var(normalized, axis=1)\n    diversity_threshold = np.percentile(variances, 75)  # Select solutions with above-median diversity\n\n    candidate_indices = [i for i, var in enumerate(variances) if var >= diversity_threshold]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.argmax(np.sum(normalized[candidate_indices], axis=1))\n    selected_idx = candidate_indices[selected_idx]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search: alternate between relocation and segment reversal\n    for phase in range(2):  # Two phases: relocation then segment reversal\n        if phase == 0:  # Relocation phase\n            for i in range(min(3, n//2)):\n                node = sorted_nodes[i]\n                best_pos = -1\n                min_cost = float('inf')\n\n                for pos in range(n):\n                    if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                        continue\n\n                    temp_sol = new_solution.copy()\n                    temp_sol = np.delete(temp_sol, node)\n                    temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n                    cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    total_cost = cost1 + cost2\n\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_pos = pos\n\n                if best_pos != -1:\n                    new_solution = np.delete(new_solution, node)\n                    new_solution = np.insert(new_solution, best_pos, base_solution[node])\n        else:  # Segment reversal phase\n            segment_size = max(2, min(6, n//4))\n            for _ in range(2):\n                start = np.random.randint(0, n - segment_size)\n                end = start + segment_size\n\n                temp_sol = new_solution.copy()\n                temp_sol[start:end] = temp_sol[start:end][::-1]\n\n                cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n                    new_solution = temp_sol\n\n    # Edge swap phase (only if improves both objectives)\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 7 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects promising solutions from the archive using Pareto-aware crowding distance, then applies a hybrid local search that alternates between distance-aware edge relocations and segment reversals based on the structural imbalance between the two objective spaces, ensuring feasibility by validating tour connectivity and node uniqueness. The operator selection prioritizes edge relocations for imbalanced solutions and segment reversals for balanced ones, with the imbalance ratio determining the approach.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: choose solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solutions with high crowding distance\n    top_indices = np.argsort(crowding_dist)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance in both objective spaces\n    def calculate_imbalance(solution, distance_matrix):\n        total_length = 0\n        for i in range(n):\n            total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total_length\n\n    imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n    imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n    imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n    # Hybrid local search: alternate between operators based on imbalance\n    if imbalance_ratio > 0.3:  # If significant imbalance, prioritize distance-aware relocation\n        # Distance-aware edge relocation\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and (i != 0 or j != n-1):  # Avoid first/last edge\n                # Calculate potential improvement in both objectives\n                old_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Swap edges\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Revert if worse in both objectives\n                if new_dist1 > old_dist1 and new_dist2 > old_dist2:\n                    new_solution[j] = new_solution[i]\n                    new_solution[i] = temp\n    else:  # If balanced, prioritize segment reversal\n        if n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 60,
        "algorithm": "The algorithm selects high-diversity solutions from the archive (based on objective variance) and applies a hybrid local search combining adaptive edge-swaps and distance-aware relocations, prioritizing balanced improvements between objectives while ensuring feasibility through strict validation. It alternates between two operators (edge-swap and relocation) with probabilistic selection, using distance matrices to guide moves toward lower-cost solutions while maintaining tour validity. The method emphasizes objective balance in improvements and includes a fallback to the original solution if feasibility is compromised.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (variance > threshold)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    threshold = np.percentile(variances, 75)  # Use 75th percentile as threshold\n    diverse_indices = [i for i, v in enumerate(variances) if v > threshold]\n    if not diverse_indices:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(diverse_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: alternate between edge-swap and distance-aware relocation\n    for _ in range(2):  # Apply operator twice\n        if np.random.rand() < 0.5:  # Edge-swap\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            if not (i == 0 and j == n-1):  # Avoid first/last edge\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Validate feasibility and objective balance\n                if len(np.unique(temp_solution)) == n:\n                    cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    # Accept if balanced improvement or random chance\n                    if (abs(cost1_new - cost2_new) <= abs(cost1_old - cost2_old)) or np.random.rand() < 0.2:\n                        new_solution = temp_solution\n        else:  # Distance-aware relocation\n            node = np.random.randint(0, n)\n            current_pos = np.where(new_solution == base_solution[node])[0][0]\n\n            # Calculate relocation probabilities based on distance matrices\n            probs = np.zeros(n)\n            for pos in range(n):\n                if pos == current_pos or pos == (current_pos-1)%n or pos == (current_pos+1)%n:\n                    continue\n                temp_sol = new_solution.copy()\n                temp_sol = np.delete(temp_sol, current_pos)\n                temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                probs[pos] = np.exp(-(cost1 + cost2) / (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) +\n                                                       sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) + 1e-8))\n\n            probs /= probs.sum()\n            new_pos = np.random.choice(n, p=probs)\n            if new_pos != current_pos and new_pos != (current_pos-1)%n and new_pos != (current_pos+1)%n:\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, new_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7574943130051239,
            1.303741693496704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (variance > threshold)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=1)\n    threshold = np.percentile(variances, 75)  # Use 75th percentile as threshold\n    diverse_indices = [i for i, v in enumerate(variances) if v > threshold]\n    if not diverse_indices:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(diverse_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: alternate between edge-swap and distance-aware relocation\n    for _ in range(2):  # Apply operator twice\n        if np.random.rand() < 0.5:  # Edge-swap\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            if not (i == 0 and j == n-1):  # Avoid first/last edge\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                # Validate feasibility and objective balance\n                if len(np.unique(temp_solution)) == n:\n                    cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                    cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    # Accept if balanced improvement or random chance\n                    if (abs(cost1_new - cost2_new) <= abs(cost1_old - cost2_old)) or np.random.rand() < 0.2:\n                        new_solution = temp_solution\n        else:  # Distance-aware relocation\n            node = np.random.randint(0, n)\n            current_pos = np.where(new_solution == base_solution[node])[0][0]\n\n            # Calculate relocation probabilities based on distance matrices\n            probs = np.zeros(n)\n            for pos in range(n):\n                if pos == current_pos or pos == (current_pos-1)%n or pos == (current_pos+1)%n:\n                    continue\n                temp_sol = new_solution.copy()\n                temp_sol = np.delete(temp_sol, current_pos)\n                temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                probs[pos] = np.exp(-(cost1 + cost2) / (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) +\n                                                       sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) + 1e-8))\n\n            probs /= probs.sum()\n            new_pos = np.random.choice(n, p=probs)\n            if new_pos != current_pos and new_pos != (current_pos-1)%n and new_pos != (current_pos+1)%n:\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, new_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 61,
        "algorithm": "This algorithm implements a multi-objective cluster-based local search for bi-objective TSP, prioritizing nondominated solutions with high diversity and applying alternating edge swaps and node relocations within spatial clusters, dynamically adjusting move acceptance based on objective balance while ensuring feasibility through strict validation checks. The key innovations include cluster-based partitioning in both objective spaces and a dynamic cost-weighting scheme that balances exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select high-diversity nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cluster-based local search\n    # Create clusters based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Calculate distance in both dimensions\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        # Cluster threshold based on median distance\n        median_dist = np.median(distance_matrix_1)\n        if avg_dist < 1.2 * median_dist or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Step 3: Balanced cluster-based edge swap and node relocation\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select random nodes within cluster\n        nodes = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(nodes) < 2:\n            continue\n\n        # Alternate between edge swap and node relocation\n        if np.random.rand() < 0.6:  # 60% chance for edge swap\n            i, j = np.random.choice(nodes, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Calculate costs\n            cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            # Dynamic acceptance based on objective balance\n            balance = 0.5 * (cost1_new - cost2_new) / (cost1_new + cost2_new + 1e-6)\n            if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2 + 0.3 * balance:\n                new_solution = temp_sol\n        else:  # Node relocation\n            node = np.random.choice(nodes)\n            best_pos = -1\n            min_cost = float('inf')\n\n            for pos in range(n):\n                if pos in nodes or pos == (node-1)%n or pos == (node+1)%n:\n                    continue\n\n                temp_sol = new_solution.copy()\n                temp_sol = np.delete(temp_sol, node)\n                temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n                # Dynamic cost weighting\n                weight = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n                total_cost = weight * cost1 + (1 - weight) * cost2\n\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            if best_pos != -1 and np.random.rand() < 0.7:\n                new_solution = np.delete(new_solution, node)\n                new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9339525574237777,
            3.5170525312423706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select high-diversity nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cluster-based local search\n    # Create clusters based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Calculate distance in both dimensions\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        # Cluster threshold based on median distance\n        median_dist = np.median(distance_matrix_1)\n        if avg_dist < 1.2 * median_dist or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Step 3: Balanced cluster-based edge swap and node relocation\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select random nodes within cluster\n        nodes = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(nodes) < 2:\n            continue\n\n        # Alternate between edge swap and node relocation\n        if np.random.rand() < 0.6:  # 60% chance for edge swap\n            i, j = np.random.choice(nodes, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Calculate costs\n            cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            # Dynamic acceptance based on objective balance\n            balance = 0.5 * (cost1_new - cost2_new) / (cost1_new + cost2_new + 1e-6)\n            if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.2 + 0.3 * balance:\n                new_solution = temp_sol\n        else:  # Node relocation\n            node = np.random.choice(nodes)\n            best_pos = -1\n            min_cost = float('inf')\n\n            for pos in range(n):\n                if pos in nodes or pos == (node-1)%n or pos == (node+1)%n:\n                    continue\n\n                temp_sol = new_solution.copy()\n                temp_sol = np.delete(temp_sol, node)\n                temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n                # Dynamic cost weighting\n                weight = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n                total_cost = weight * cost1 + (1 - weight) * cost2\n\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            if best_pos != -1 and np.random.rand() < 0.7:\n                new_solution = np.delete(new_solution, node)\n                new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 62,
        "algorithm": "The algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9879140490693281,
            0.3575114607810974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 62,
        "algorithm": "The algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9879140490693281,
            0.3575114607810974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        None\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 63,
        "algorithm": "The algorithm selects promising solutions from an archive using quality scores based on objective values, then applies a hybrid local search combining multi-dimensional edge analysis and adaptive node reinsertion, prioritizing edges with high combined importance in both objective spaces while dynamically balancing objective improvements during node placement. It ensures feasibility by validating uniqueness of nodes and falls back to the original solution if invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate solution quality scores\n    def quality_score(obj):\n        return np.exp(-(obj[0] + obj[1]) / (np.mean(objectives) + 1e-6))\n\n    scores = np.array([quality_score(obj) for obj in objectives])\n    selection_probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Multi-dimensional edge analysis\n    def edge_importance(i, j):\n        node_i = base_solution[i]\n        node_j = base_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j]\n        dist2 = distance_matrix_2[node_i, node_j]\n        return (dist1 + dist2) * (1 + abs(dist1 - dist2) / (dist1 + dist2 + 1e-6))\n\n    # Find critical edges\n    edge_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        edge_scores.append(edge_importance(i, j))\n    sorted_edges = np.argsort(edge_scores)[::-1]\n\n    # Step 3: Adaptive edge perturbation\n    for edge_idx in sorted_edges[:min(3, n//2)]:\n        i = edge_idx\n        j = (i + 1) % n\n\n        # Find alternative nodes for replacement\n        candidates = []\n        for k in range(n):\n            if k != i and k != j and k != (i-1)%n and k != (j+1)%n:\n                candidates.append(k)\n\n        if not candidates:\n            continue\n\n        # Select best candidate based on multi-objective improvement\n        best_candidate = None\n        best_improvement = 0\n\n        for k in candidates:\n            # Calculate potential improvement\n            old_dist1 = distance_matrix_1[base_solution[i], base_solution[j]]\n            old_dist2 = distance_matrix_2[base_solution[i], base_solution[j]]\n            new_dist1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[k], base_solution[j]]\n            new_dist2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[k], base_solution[j]]\n\n            improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = k\n\n        if best_candidate is not None and np.random.rand() < 0.8:  # 80% chance to accept\n            # Perform edge replacement\n            temp_sol = new_solution.copy()\n            temp_sol = np.insert(temp_sol, j, base_solution[best_candidate])\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Node reinsertion with objective-aware placement\n    for _ in range(min(2, n//3)):\n        node = np.random.choice(new_solution)\n        temp_sol = new_solution.copy()\n        temp_sol = temp_sol[temp_sol != node]\n\n        best_pos = -1\n        best_score = float('-inf')\n\n        for pos in range(len(temp_sol)):\n            # Insert node at position pos\n            candidate_sol = np.insert(temp_sol, pos, node)\n\n            # Calculate objective scores\n            cost1 = sum(distance_matrix_1[candidate_sol[k], candidate_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate_sol[k], candidate_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic objective weighting\n            alpha = 0.5 * (1 + np.tanh((cost1 - cost2) / (cost1 + cost2 + 1e-6)))\n            score = - (alpha * cost1 + (1 - alpha) * cost2)\n\n            if score > best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7290289056699478,
            7.344151616096497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate solution quality scores\n    def quality_score(obj):\n        return np.exp(-(obj[0] + obj[1]) / (np.mean(objectives) + 1e-6))\n\n    scores = np.array([quality_score(obj) for obj in objectives])\n    selection_probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Multi-dimensional edge analysis\n    def edge_importance(i, j):\n        node_i = base_solution[i]\n        node_j = base_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j]\n        dist2 = distance_matrix_2[node_i, node_j]\n        return (dist1 + dist2) * (1 + abs(dist1 - dist2) / (dist1 + dist2 + 1e-6))\n\n    # Find critical edges\n    edge_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        edge_scores.append(edge_importance(i, j))\n    sorted_edges = np.argsort(edge_scores)[::-1]\n\n    # Step 3: Adaptive edge perturbation\n    for edge_idx in sorted_edges[:min(3, n//2)]:\n        i = edge_idx\n        j = (i + 1) % n\n\n        # Find alternative nodes for replacement\n        candidates = []\n        for k in range(n):\n            if k != i and k != j and k != (i-1)%n and k != (j+1)%n:\n                candidates.append(k)\n\n        if not candidates:\n            continue\n\n        # Select best candidate based on multi-objective improvement\n        best_candidate = None\n        best_improvement = 0\n\n        for k in candidates:\n            # Calculate potential improvement\n            old_dist1 = distance_matrix_1[base_solution[i], base_solution[j]]\n            old_dist2 = distance_matrix_2[base_solution[i], base_solution[j]]\n            new_dist1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[k], base_solution[j]]\n            new_dist2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[k], base_solution[j]]\n\n            improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = k\n\n        if best_candidate is not None and np.random.rand() < 0.8:  # 80% chance to accept\n            # Perform edge replacement\n            temp_sol = new_solution.copy()\n            temp_sol = np.insert(temp_sol, j, base_solution[best_candidate])\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Node reinsertion with objective-aware placement\n    for _ in range(min(2, n//3)):\n        node = np.random.choice(new_solution)\n        temp_sol = new_solution.copy()\n        temp_sol = temp_sol[temp_sol != node]\n\n        best_pos = -1\n        best_score = float('-inf')\n\n        for pos in range(len(temp_sol)):\n            # Insert node at position pos\n            candidate_sol = np.insert(temp_sol, pos, node)\n\n            # Calculate objective scores\n            cost1 = sum(distance_matrix_1[candidate_sol[k], candidate_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate_sol[k], candidate_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic objective weighting\n            alpha = 0.5 * (1 + np.tanh((cost1 - cost2) / (cost1 + cost2 + 1e-6)))\n            score = - (alpha * cost1 + (1 - alpha) * cost2)\n\n            if score > best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_sol, best_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        None\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 64,
        "algorithm": "The algorithm selects a promising solution from the archive by balancing objective values and diversity, then applies segment-based reordering (with higher probability for cost reduction) and cross-dimensional edge flipping (accepting moves improving either objective) to generate a neighbor solution while ensuring feasibility. The first objective is prioritized (60% weight), with diversity (30% weight) and segment reordering (60% probability) further guiding the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with balanced objectives and high diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n\n    # Calculate weighted score combining objectives and diversity\n    diversity = np.std(normalized_obj, axis=0)\n    weights = np.array([0.6, 0.4])  # More weight on first objective\n    scores = np.sum(normalized_obj * weights, axis=1) + 0.3 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Segment-based reordering\n    segment_size = max(3, n // 4)\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment cost in both dimensions\n        seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Reorder segment based on combined cost\n        if np.random.rand() < 0.6:  # Higher probability to reorder\n            segment = segment[::-1] if seg_cost1 + seg_cost2 > np.random.rand() * np.mean(distance_matrix_1) else segment\n            new_solution[i:i+segment_size] = segment\n\n    # Step 3: Cross-dimensional edge flipping\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or abs(i-j) == 1 or abs(i-j) == n-1:\n            continue\n\n        # Calculate cost change in both dimensions\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        temp_sol = new_solution.copy()\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n        new_cost1 = (distance_matrix_1[temp_sol[i-1], temp_sol[i]] +\n                     distance_matrix_1[temp_sol[j-1], temp_sol[j]])\n        new_cost2 = (distance_matrix_2[temp_sol[i-1], temp_sol[i]] +\n                     distance_matrix_2[temp_sol[j-1], temp_sol[j]])\n\n        # Accept if improvement in at least one dimension\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2) and np.random.rand() < 0.8:\n            new_solution = temp_sol\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7287233850921626,
            0.33681321144104004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with balanced objectives and high diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-6)\n\n    # Calculate weighted score combining objectives and diversity\n    diversity = np.std(normalized_obj, axis=0)\n    weights = np.array([0.6, 0.4])  # More weight on first objective\n    scores = np.sum(normalized_obj * weights, axis=1) + 0.3 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Segment-based reordering\n    segment_size = max(3, n // 4)\n    for i in range(0, n, segment_size):\n        segment = base_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment cost in both dimensions\n        seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Reorder segment based on combined cost\n        if np.random.rand() < 0.6:  # Higher probability to reorder\n            segment = segment[::-1] if seg_cost1 + seg_cost2 > np.random.rand() * np.mean(distance_matrix_1) else segment\n            new_solution[i:i+segment_size] = segment\n\n    # Step 3: Cross-dimensional edge flipping\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or abs(i-j) == 1 or abs(i-j) == n-1:\n            continue\n\n        # Calculate cost change in both dimensions\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        temp_sol = new_solution.copy()\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n        new_cost1 = (distance_matrix_1[temp_sol[i-1], temp_sol[i]] +\n                     distance_matrix_1[temp_sol[j-1], temp_sol[j]])\n        new_cost2 = (distance_matrix_2[temp_sol[i-1], temp_sol[i]] +\n                     distance_matrix_2[temp_sol[j-1], temp_sol[j]])\n\n        # Accept if improvement in at least one dimension\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2) and np.random.rand() < 0.8:\n            new_solution = temp_sol\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 4 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        # Fall back to all solutions if no nondominated found\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Cross-dimensional edge clustering and swap\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cluster edges based on spatial proximity in both dimensions\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Check if current node belongs to current cluster\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Perform cluster-based edge swaps\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges from the cluster to swap\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Check if swap is valid\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 3: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            # Calculate cost in both dimensions\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Dynamic balancing factor\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:  # 70% chance to accept\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive using normalized objective sums, then applies a hybrid local search combining cross-dimensional node relocation (prioritizing nodes with high combined importance) and adaptive segment-based reversal (dynamically adjusting segment sizes for balanced exploration). The method ensures feasibility through validation and probabilistic acceptance, balancing both objectives while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Cross-dimensional node relocation\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        # Find best insertion point in both spaces\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check if reversal improves both objectives\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 65,
        "algorithm": "The algorithm selects nondominated solutions with high objective diversity, then applies a hybrid local search combining cross-dimensional edge clustering, adaptive node reinsertion, and segment-based reversal, while dynamically balancing between objectives and ensuring feasibility through strict validation. It prioritizes nodes with high importance in both spaces, uses a dynamic balancing factor to adapt to the current solution's trade-off, and validates all moves to ensure the tour remains feasible in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Step 3: Cross-dimensional edge clustering and swap\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Step 5: Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8009623551261941,
            4.262157440185547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                is_dominated[i] = True\n                break\n    nondominated_indices = np.where(~is_dominated)[0]\n\n    if len(nondominated_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with highest diversity\n        diversity = np.std(objectives[nondominated_indices], axis=0)\n        selected_idx = nondominated_indices[np.argmax(np.sum(diversity))]\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Step 3: Cross-dimensional edge clustering and swap\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        dist1 = np.linalg.norm(instance[node, :2] - instance[prev_node, :2])\n        dist2 = np.linalg.norm(instance[node, 2:] - instance[prev_node, 2:])\n        avg_dist = (dist1 + dist2) / 2\n\n        if avg_dist < 1.5 * np.mean(distance_matrix_1) or len(current_cluster) < 3:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        edge_indices = [np.where(base_solution == node)[0][0] for node in cluster]\n        if len(edge_indices) < 2:\n            continue\n\n        i, j = np.random.choice(edge_indices, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        if not (i == 0 and j == n-1):\n            temp_sol = new_solution.copy()\n            temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Adaptive node reinsertion\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            balance_factor = 0.5 + 0.5 * (cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            total_cost = balance_factor * cost1 + (1 - balance_factor) * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and np.random.rand() < 0.7:\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Step 5: Adaptive segment-based reversal\n    segment_size = max(2, min(6, n//4))\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        temp_sol = new_solution.copy()\n        temp_sol[start:end] = temp_sol[start:end][::-1]\n\n        cost1_new = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_sol\n\n    # Final feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 7 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from an archive using a weighted combination of objective values and structural diversity, then applies a hybrid local search combining partial tour reversal with probabilistic node relocation to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with balanced objectives and high diversity, while the local search adaptively adjusts segment sizes and relocation probabilities based on distance matrices to explore the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective diversity and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity score (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        other_objectives = np.delete(norm_objectives, i, axis=0)\n        diversity_scores[i] = np.mean(np.linalg.norm(norm_objectives[i] - other_objectives, axis=1))\n\n    # Combine objective and diversity scores\n    selection_weights = np.exp(-norm_objectives[:, 0] - norm_objectives[:, 1] + 0.5 * diversity_scores)\n    selection_weights /= selection_weights.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel hybrid local search\n    # Step 1: Partial tour reversal with adaptive segment size\n    segment_size = min(3, max(1, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Probabilistic node relocation based on distance matrices\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities based on distance matrices\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects promising solutions from the archive using Pareto-aware crowding distance, then applies a hybrid local search that alternates between distance-aware edge relocations and segment reversals based on the structural imbalance between the two objective spaces, ensuring feasibility by validating tour connectivity and node uniqueness. The operator selection prioritizes edge relocations for imbalanced solutions and segment reversals for balanced ones, with the imbalance ratio determining the approach.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: choose solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solutions with high crowding distance\n    top_indices = np.argsort(crowding_dist)[-max(1, len(archive) // 3):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate structural imbalance in both objective spaces\n    def calculate_imbalance(solution, distance_matrix):\n        total_length = 0\n        for i in range(n):\n            total_length += distance_matrix[solution[i], solution[(i+1)%n]]\n        return total_length\n\n    imbalance_1 = calculate_imbalance(new_solution, distance_matrix_1)\n    imbalance_2 = calculate_imbalance(new_solution, distance_matrix_2)\n    imbalance_ratio = abs(imbalance_1 - imbalance_2) / (imbalance_1 + imbalance_2 + 1e-8)\n\n    # Hybrid local search: alternate between operators based on imbalance\n    if imbalance_ratio > 0.3:  # If significant imbalance, prioritize distance-aware relocation\n        # Distance-aware edge relocation\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and (i != 0 or j != n-1):  # Avoid first/last edge\n                # Calculate potential improvement in both objectives\n                old_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                old_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Swap edges\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n                new_dist1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_dist2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                # Revert if worse in both objectives\n                if new_dist1 > old_dist1 and new_dist2 > old_dist2:\n                    new_solution[j] = new_solution[i]\n                    new_solution[i] = temp\n    else:  # If balanced, prioritize segment reversal\n        if n > 3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 66,
        "algorithm": "The algorithm selects high-potential solutions from the archive by prioritizing nondominated solutions with high objective diversity, then applies a hybrid local search combining edge-swap (for exploitation) and distance-aware relocation (for exploration) to generate neighbors while ensuring feasibility through validation checks. The selection process balances diversity and nondominance, while the local search adaptively improves solutions by trading off cost reductions in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with high diversity (variance > threshold)\n        diversity = [np.var([objectives[i][0], objectives[i][1]]) for i in nondominated]\n        threshold = np.percentile(diversity, 75)  # Top 25% diversity\n        high_diversity = [i for i, d in zip(nondominated, diversity) if d >= threshold]\n        selected_idx = np.random.choice(high_diversity) if high_diversity else np.random.choice(nondominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive hybrid local search\n    def calculate_cost(sol, dist_mat):\n        return sum(dist_mat[sol[i], sol[(i+1)%n]] for i in range(n))\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Edge-swap (for exploitation)\n    i, j = np.random.choice(n, size=2, replace=False)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.2:\n        new_solution = temp_solution\n\n    # Distance-aware relocation (for exploration)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == k or pos == (k-1)%n or pos == (k+1)%n:\n            continue\n\n        temp_sol = new_solution.copy()\n        temp_sol = np.delete(temp_sol, k)\n        temp_sol = np.insert(temp_sol, pos, node)\n\n        cost1 = calculate_cost(temp_sol, distance_matrix_1)\n        cost2 = calculate_cost(temp_sol, distance_matrix_2)\n\n        if cost1 + cost2 < min_cost:\n            min_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n, \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.9340099608961918,
            1.9233949780464172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from nondominated with high diversity (variance > threshold)\n        diversity = [np.var([objectives[i][0], objectives[i][1]]) for i in nondominated]\n        threshold = np.percentile(diversity, 75)  # Top 25% diversity\n        high_diversity = [i for i, d in zip(nondominated, diversity) if d >= threshold]\n        selected_idx = np.random.choice(high_diversity) if high_diversity else np.random.choice(nondominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive hybrid local search\n    def calculate_cost(sol, dist_mat):\n        return sum(dist_mat[sol[i], sol[(i+1)%n]] for i in range(n))\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Edge-swap (for exploitation)\n    i, j = np.random.choice(n, size=2, replace=False)\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.2:\n        new_solution = temp_solution\n\n    # Distance-aware relocation (for exploration)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    best_pos = -1\n    min_cost = float('inf')\n\n    for pos in range(n):\n        if pos == k or pos == (k-1)%n or pos == (k+1)%n:\n            continue\n\n        temp_sol = new_solution.copy()\n        temp_sol = np.delete(temp_sol, k)\n        temp_sol = np.insert(temp_sol, pos, node)\n\n        cost1 = calculate_cost(temp_sol, distance_matrix_1)\n        cost2 = calculate_cost(temp_sol, distance_matrix_2)\n\n        if cost1 + cost2 < min_cost:\n            min_cost = cost1 + cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == n, \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 67,
        "algorithm": "The algorithm selects high-variance, balanced-cost solutions from the archive and applies a hybrid local search combining a 3-opt move with distance-aware node relocation, prioritizing improvements in both objectives while ensuring tour feasibility through node uniqueness checks. It adaptively refines solutions by evaluating random 3-node segments and relocating nodes to positions that improve both cost metrics, with a small probability of accepting non-improving moves to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance and balanced cost ratio\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.abs(objectives[:, 0] - objectives[:, 1])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-10)\n    scores = variances * ratios\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt move with distance-aware relocation\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # 3-opt move\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n    temp_solution[j:k] = temp_solution[j:k][::-1]\n\n    # Distance-aware relocation\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for idx in range(n):\n            cost += dist_mat[sol[idx], sol[(idx+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Try relocating a node to a position that improves both objectives\n    for _ in range(3):\n        node_pos = np.random.randint(n)\n        node = temp_solution[node_pos]\n        possible_positions = [p for p in range(n) if p != node_pos and p != (node_pos + 1) % n and p != (node_pos - 1) % n]\n\n        if not possible_positions:\n            continue\n\n        for new_pos in possible_positions:\n            candidate = temp_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, new_pos, node)\n\n            new_cost1 = calculate_cost(candidate, distance_matrix_1)\n            new_cost2 = calculate_cost(candidate, distance_matrix_2)\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n                temp_solution = candidate\n                current_cost1 = new_cost1\n                current_cost2 = new_cost2\n                break\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(temp_solution)) == n:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5804931350673405,
            0.8831629157066345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance and balanced cost ratio\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.abs(objectives[:, 0] - objectives[:, 1])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-10)\n    scores = variances * ratios\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt move with distance-aware relocation\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # 3-opt move\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n    temp_solution[j:k] = temp_solution[j:k][::-1]\n\n    # Distance-aware relocation\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for idx in range(n):\n            cost += dist_mat[sol[idx], sol[(idx+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    # Try relocating a node to a position that improves both objectives\n    for _ in range(3):\n        node_pos = np.random.randint(n)\n        node = temp_solution[node_pos]\n        possible_positions = [p for p in range(n) if p != node_pos and p != (node_pos + 1) % n and p != (node_pos - 1) % n]\n\n        if not possible_positions:\n            continue\n\n        for new_pos in possible_positions:\n            candidate = temp_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, new_pos, node)\n\n            new_cost1 = calculate_cost(candidate, distance_matrix_1)\n            new_cost2 = calculate_cost(candidate, distance_matrix_2)\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.1:\n                temp_solution = candidate\n                current_cost1 = new_cost1\n                current_cost2 = new_cost2\n                break\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(temp_solution)) == n:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 68,
        "algorithm": "The algorithm selects high-diversity solutions from the archive (where objective variances exceed a threshold) and applies a hybrid local search alternating between edge-swaps (for local optimization) and distance-aware relocations (for global exploration), ensuring feasibility by validating node uniqueness while prioritizing balanced objective trade-offs. The method dynamically switches between exploitation and exploration based on solution dominance, with feasibility checks across both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.abs(objectives[:, 0] - objectives[:, 1])\n    threshold = np.mean(variances) + np.std(variances)\n    candidate_indices = np.where(variances > threshold)[0]\n\n    if len(candidate_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternate between edge-swap and distance-aware relocation\n    operator = np.random.choice(['edge_swap', 'relocation'])\n\n    if operator == 'edge_swap':\n        # Edge-swap: swap two non-adjacent edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        a, b = sorted([i, j])\n        new_solution[b], new_solution[(a + 1) % n] = new_solution[(a + 1) % n], new_solution[b]\n    else:\n        # Distance-aware relocation: move a node to minimize distance in both objectives\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        costs = []\n        for pos in range(n - 1):\n            temp_sol = np.insert(new_solution.copy(), pos, node)\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i + 1) % (n - 1)]] for i in range(n - 1))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i + 1) % (n - 1)]] for i in range(n - 1))\n            costs.append((cost1 + cost2) / 2)  # Average cost\n        best_pos = np.argmin(costs)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.812046886315482,
            0.6376326084136963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.abs(objectives[:, 0] - objectives[:, 1])\n    threshold = np.mean(variances) + np.std(variances)\n    candidate_indices = np.where(variances > threshold)[0]\n\n    if len(candidate_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidate_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternate between edge-swap and distance-aware relocation\n    operator = np.random.choice(['edge_swap', 'relocation'])\n\n    if operator == 'edge_swap':\n        # Edge-swap: swap two non-adjacent edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        a, b = sorted([i, j])\n        new_solution[b], new_solution[(a + 1) % n] = new_solution[(a + 1) % n], new_solution[b]\n    else:\n        # Distance-aware relocation: move a node to minimize distance in both objectives\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        costs = []\n        for pos in range(n - 1):\n            temp_sol = np.insert(new_solution.copy(), pos, node)\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i + 1) % (n - 1)]] for i in range(n - 1))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i + 1) % (n - 1)]] for i in range(n - 1))\n            costs.append((cost1 + cost2) / 2)  # Average cost\n        best_pos = np.argmin(costs)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 69,
        "algorithm": "The algorithm selects a solution from the archive with the highest normalized objective sum (indicating potential for improvement in both objectives) and applies a hybrid local search combining 3-opt and node insertion, ensuring feasibility by maintaining unique node visits and tour continuity. The method prioritizes solutions with higher combined objective values and uses randomized 3-opt and node insertion to explore the search space while guaranteeing valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    normalized_sums = [(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for _, obj in archive]\n    selected_idx = np.argmax(normalized_sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt and node insertion\n    # 3-opt operation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    temp = new_solution.copy()\n    temp[a:b+1] = temp[a:b+1][::-1]\n    temp[b:c+1] = temp[b:c+1][::-1]\n\n    # Node insertion\n    if n > 4:\n        pos = np.random.randint(0, n)\n        node = np.random.choice(new_solution)\n        temp = np.insert(temp, pos, node)\n        temp = np.delete(temp, np.where(temp == node)[0][1])  # Remove duplicate\n\n    # Ensure validity\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8269490172675499,
            0.7930809259414673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    normalized_sums = [(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for _, obj in archive]\n    selected_idx = np.argmax(normalized_sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt and node insertion\n    # 3-opt operation\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    temp = new_solution.copy()\n    temp[a:b+1] = temp[a:b+1][::-1]\n    temp[b:c+1] = temp[b:c+1][::-1]\n\n    # Node insertion\n    if n > 4:\n        pos = np.random.randint(0, n)\n        node = np.random.choice(new_solution)\n        temp = np.insert(temp, pos, node)\n        temp = np.delete(temp, np.where(temp == node)[0][1])  # Remove duplicate\n\n    # Ensure validity\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 70,
        "algorithm": "The algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.9377858774270942,
            0.2215670943260193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Operator Fusion**, **Multi-Objective Feasibility**, **Diversity-Aware Selection**, **Structural Balance**\n- **Advice**: Combine **edge-swap** (for local optimization) and **distance-aware relocation** (for global exploration) in a hybrid operator. Select **nondominated solutions** with high objective diversity (e.g., variance > threshold) and validate feasibility across both objective spaces.\n- **Avoid**: Static operators or random selection without Pareto-aware filtering. Ignore structural balance or feasibility checks.\n- **Explanation**: Adaptive operator fusion ensures diverse local search while maintaining feasibility, and nondominated selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high objective diversity (e.g., variance > threshold).\n2. **Local Search**: Alternate between edge-swap (for exploitation) and distance-aware relocation (for exploration), ensuring feasibility.\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs to avoid bias.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 71,
        "algorithm": "This algorithm selects high-diversity nondominated solutions from the archive, then applies a hybrid local search alternating between edge-swap (for balanced solutions) and distance-aware relocation (for diverse ones), ensuring feasibility by validating node uniqueness and tour continuity in both objective spaces. It prioritizes solutions with objective variance above a threshold and adapts its operator selection based on the current solution's balance, favoring edge-swap for balanced solutions and relocation for diverse ones.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high diversity (variance > threshold)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.abs(objectives[:, 0] - objectives[:, 1])\n    threshold = np.percentile(variances, 75)  # Use 75th percentile as threshold\n    candidates = [i for i, var in enumerate(variances) if var > threshold]\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Determine operator based on objective balance\n    obj_balance = abs(archive[selected_idx][1][0] - archive[selected_idx][1][1])\n    use_relocation = obj_balance > np.mean(variances)  # Use relocation if highly diverse\n\n    if use_relocation:\n        # Distance-aware relocation\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        # Find position with minimal distance increase\n        min_dist = float('inf')\n        best_pos = i\n        for pos in range(n):\n            if pos == i:\n                continue\n            temp = new_solution.copy()\n            temp = np.insert(temp, pos, temp[i])\n            temp = np.delete(temp, i if pos > i else i + 1)\n\n            # Calculate total distance in both spaces\n            total_dist1 = sum(distance_matrix_1[temp[k], temp[(k+1)%n]] for k in range(n))\n            total_dist2 = sum(distance_matrix_2[temp[k], temp[(k+1)%n]] for k in range(n))\n            if total_dist1 + total_dist2 < min_dist:\n                min_dist = total_dist1 + total_dist2\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, new_solution[i])\n        new_solution = np.delete(new_solution, i if best_pos > i else i + 1)\n    else:\n        # Edge-swap with minimal distance increase\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Evaluate all possible swaps\n        min_dist = float('inf')\n        best_swap = (i, j)\n        for k in range(n):\n            for l in range(k+1, n):\n                if l == (k + 1) % n:\n                    continue\n                temp = new_solution.copy()\n                temp[k], temp[l] = temp[l], temp[k]\n\n                # Calculate total distance in both spaces\n                total_dist1 = sum(distance_matrix_1[temp[m], temp[(m+1)%n]] for m in range(n))\n                total_dist2 = sum(distance_matrix_2[temp[m], temp[(m+1)%n]] for m in range(n))\n                if total_dist1 + total_dist2 < min_dist:\n                    min_dist = total_dist1 + total_dist2\n                    best_swap = (k, l)\n\n        new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5344552542646414,
            3.6419809460639954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions with high diversity (variance > threshold)\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.abs(objectives[:, 0] - objectives[:, 1])\n    threshold = np.percentile(variances, 75)  # Use 75th percentile as threshold\n    candidates = [i for i, var in enumerate(variances) if var > threshold]\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Determine operator based on objective balance\n    obj_balance = abs(archive[selected_idx][1][0] - archive[selected_idx][1][1])\n    use_relocation = obj_balance > np.mean(variances)  # Use relocation if highly diverse\n\n    if use_relocation:\n        # Distance-aware relocation\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        # Find position with minimal distance increase\n        min_dist = float('inf')\n        best_pos = i\n        for pos in range(n):\n            if pos == i:\n                continue\n            temp = new_solution.copy()\n            temp = np.insert(temp, pos, temp[i])\n            temp = np.delete(temp, i if pos > i else i + 1)\n\n            # Calculate total distance in both spaces\n            total_dist1 = sum(distance_matrix_1[temp[k], temp[(k+1)%n]] for k in range(n))\n            total_dist2 = sum(distance_matrix_2[temp[k], temp[(k+1)%n]] for k in range(n))\n            if total_dist1 + total_dist2 < min_dist:\n                min_dist = total_dist1 + total_dist2\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, new_solution[i])\n        new_solution = np.delete(new_solution, i if best_pos > i else i + 1)\n    else:\n        # Edge-swap with minimal distance increase\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Evaluate all possible swaps\n        min_dist = float('inf')\n        best_swap = (i, j)\n        for k in range(n):\n            for l in range(k+1, n):\n                if l == (k + 1) % n:\n                    continue\n                temp = new_solution.copy()\n                temp[k], temp[l] = temp[l], temp[k]\n\n                # Calculate total distance in both spaces\n                total_dist1 = sum(distance_matrix_1[temp[m], temp[(m+1)%n]] for m in range(n))\n                total_dist2 = sum(distance_matrix_2[temp[m], temp[(m+1)%n]] for m in range(n))\n                if total_dist1 + total_dist2 < min_dist:\n                    min_dist = total_dist1 + total_dist2\n                    best_swap = (k, l)\n\n        new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 5 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: **Hybrid Segment Swap**, **Cross-Dimensional Validation**, **Pareto-Aware Selection**, **Structural Balance**\n- **Advice**: Use a novel **hybrid segment swap** (combining 3-opt with cross-dimensional edge insertion) to balance local and global improvements. Select solutions with **high Pareto diversity** (e.g., crowding distance > threshold) and validate feasibility across both objectives.\n- **Avoid**: Static 2-opt or greedy single-objective operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The hybrid operator ensures diverse exploration while maintaining feasibility, and Pareto-aware selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 72,
        "algorithm": "The algorithm selects a high-crowding-distance solution from the Pareto frontier, applies a hybrid local search combining 3-opt segment reversal and cross-dimensional edge insertion, and validates feasibility while maintaining structural balance between objectives. It prioritizes solutions with high diversity (crowding distance) and ensures neighbor solutions remain valid TSP tours by checking for duplicate nodes and extreme edge lengths. The hybrid operator balances exploration (random segment selection) with exploitation (cross-dimensional validation), while structural balance ensures objective costs remain proportionally aligned.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high Pareto diversity (crowding distance > threshold)\n    objectives = np.array([obj for _, obj in archive])\n    n_front = len(archive)\n    crowding_dist = np.zeros(n_front)\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, n_front - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i + 1], m] - objectives[sorted_idx[i - 1], m])\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid segment swap with cross-dimensional validation\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # 3-opt segment reversal\n    temp_sol = new_solution.copy()\n    temp_sol[a:b] = temp_sol[a:b][::-1]\n    temp_sol[b:c] = temp_sol[b:c][::-1]\n\n    # Cross-dimensional edge insertion\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    if not (i == 0 and j == n - 1):\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n    # Validate cross-dimensional feasibility\n    valid = True\n    for k in range(n):\n        next_k = (k + 1) % n\n        dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n        dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n        if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n            valid = False\n            break\n\n    if valid and len(np.unique(temp_sol)) == n:\n        new_solution = temp_sol\n\n    # Step 3: Accept if structural balance is maintained\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n\n    if abs(new_cost1 - new_cost2) > abs(current_cost1 - current_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9459412578269996,
            1.0659641027450562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solution with high Pareto diversity (crowding distance > threshold)\n    objectives = np.array([obj for _, obj in archive])\n    n_front = len(archive)\n    crowding_dist = np.zeros(n_front)\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, n_front - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i + 1], m] - objectives[sorted_idx[i - 1], m])\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid segment swap with cross-dimensional validation\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # 3-opt segment reversal\n    temp_sol = new_solution.copy()\n    temp_sol[a:b] = temp_sol[a:b][::-1]\n    temp_sol[b:c] = temp_sol[b:c][::-1]\n\n    # Cross-dimensional edge insertion\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    if not (i == 0 and j == n - 1):\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n    # Validate cross-dimensional feasibility\n    valid = True\n    for k in range(n):\n        next_k = (k + 1) % n\n        dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n        dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n        if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n            valid = False\n            break\n\n    if valid and len(np.unique(temp_sol)) == n:\n        new_solution = temp_sol\n\n    # Step 3: Accept if structural balance is maintained\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n\n    if abs(new_cost1 - new_cost2) > abs(current_cost1 - current_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive (prioritizing those with higher combined objective costs) and decomposes it into segments, optimizing each segment independently via a multi-objective edge-swap that only accepts swaps improving both objectives. It reconstructs the solution while ensuring feasibility, reverting to the original if invalid. The key innovation is segment-wise optimization with a strict bi-objective improvement criterion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Hybrid Segment Swap**, **Cross-Dimensional Validation**, **Pareto-Aware Selection**, **Structural Balance**\n- **Advice**: Use a novel **hybrid segment swap** (combining 3-opt with cross-dimensional edge insertion) to balance local and global improvements. Select solutions with **high Pareto diversity** (e.g., crowding distance > threshold) and validate feasibility across both objectives.\n- **Avoid**: Static 2-opt or greedy single-objective operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The hybrid operator ensures diverse exploration while maintaining feasibility, and Pareto-aware selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 73,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto diversity (crowding distance > threshold)\n    crowding_distances = []\n    for sol, obj in archive:\n        crowding_dist = 0.0\n        for i in range(2):\n            sorted_objs = sorted([o[i] for _, o in archive])\n            if len(sorted_objs) <= 2:\n                crowding_dist += 1.0\n                continue\n            obj_val = obj[i]\n            if obj_val == sorted_objs[0] or obj_val == sorted_objs[-1]:\n                crowding_dist += 1.0\n                continue\n            idx = np.where(np.array(sorted_objs) == obj_val)[0][0]\n            crowding_dist += (sorted_objs[idx+1] - sorted_objs[idx-1]) / (sorted_objs[-1] - sorted_objs[0])\n        crowding_distances.append(crowding_dist)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid segment swap: combine 3-opt with cross-dimensional edge insertion\n    segment_size = max(2, n // 4)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    for seg in segments:\n        if len(seg) < 3:\n            continue\n        # Randomly select three edges to swap\n        i, j, k = np.random.choice(len(seg), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Calculate cost difference in both objectives\n        current_cost1 = (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]] + distance_matrix_1[seg[k-1], seg[k]])\n        current_cost2 = (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]] + distance_matrix_2[seg[k-1], seg[k]])\n        new_cost1 = (distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[k]] + distance_matrix_1[seg[k-1], seg[i]])\n        new_cost2 = (distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[k]] + distance_matrix_2[seg[k-1], seg[i]])\n\n        # Accept swap if it improves both objectives or maintains balance\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or \\\n           (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2)):\n            seg[i], seg[j], seg[k] = seg[j], seg[k], seg[i]\n\n    # Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6940115171742824,
            2.7566508054733276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto diversity (crowding distance > threshold)\n    crowding_distances = []\n    for sol, obj in archive:\n        crowding_dist = 0.0\n        for i in range(2):\n            sorted_objs = sorted([o[i] for _, o in archive])\n            if len(sorted_objs) <= 2:\n                crowding_dist += 1.0\n                continue\n            obj_val = obj[i]\n            if obj_val == sorted_objs[0] or obj_val == sorted_objs[-1]:\n                crowding_dist += 1.0\n                continue\n            idx = np.where(np.array(sorted_objs) == obj_val)[0][0]\n            crowding_dist += (sorted_objs[idx+1] - sorted_objs[idx-1]) / (sorted_objs[-1] - sorted_objs[0])\n        crowding_distances.append(crowding_dist)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid segment swap: combine 3-opt with cross-dimensional edge insertion\n    segment_size = max(2, n // 4)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    for seg in segments:\n        if len(seg) < 3:\n            continue\n        # Randomly select three edges to swap\n        i, j, k = np.random.choice(len(seg), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Calculate cost difference in both objectives\n        current_cost1 = (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]] + distance_matrix_1[seg[k-1], seg[k]])\n        current_cost2 = (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]] + distance_matrix_2[seg[k-1], seg[k]])\n        new_cost1 = (distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[k]] + distance_matrix_1[seg[k-1], seg[i]])\n        new_cost2 = (distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[k]] + distance_matrix_2[seg[k-1], seg[i]])\n\n        # Accept swap if it improves both objectives or maintains balance\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or \\\n           (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2)):\n            seg[i], seg[j], seg[k] = seg[j], seg[k], seg[i]\n\n    # Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a high-potential solution from the archive (prioritizing those with higher combined objective costs) and decomposes it into segments, optimizing each segment independently via a multi-objective edge-swap that only accepts swaps improving both objectives. It reconstructs the solution while ensuring feasibility, reverting to the original if invalid. The key innovation is segment-wise optimization with a strict bi-objective improvement criterion.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 74,
        "algorithm": "The algorithm selects a high-potential solution from the archive using crowding distance (prioritizing solutions in less explored regions), then applies a dynamic segment-wise optimization with multi-objective edge swaps (adjusting segment sizes and acceptance criteria based on local improvement potential), ensuring feasibility through greedy reconstruction with backtracking. The key innovations are the adaptive segment decomposition and dynamic acceptance criteria that balance both objectives, while the backtracking mechanism maintains solution validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment decomposition based on local improvement potential\n    segments = []\n    i = 0\n    while i < n:\n        segment_size = min(4, max(2, n // (5 + np.random.randint(3))))  # Adaptive segment size\n        segments.append(base_solution[i:i+segment_size])\n        i += segment_size\n\n    # Multi-objective edge-swap with dynamic acceptance criteria\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n\n        # Calculate segment cost\n        seg_cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        seg_cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n\n        # Try multiple edge swaps\n        for _ in range(3):\n            i, j = np.random.choice(len(seg), size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate swap impact\n            delta1 = (distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]) - \\\n                    (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]])\n            delta2 = (distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]) - \\\n                    (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]])\n\n            # Dynamic acceptance: accept if both objectives improve or if one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * seg_cost1 and delta2 < 0) or (delta1 < 0 and delta2 < -0.1 * seg_cost2):\n                seg[i], seg[j] = seg[j], seg[i]\n\n    # Greedy reconstruction with backtracking\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        # Backtrack to last valid solution\n        for i in range(len(segments)):\n            temp_solution = np.concatenate(segments[:i+1])\n            if len(np.unique(temp_solution)) == len(temp_solution):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7446509070403723,
            0.6167067289352417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment decomposition based on local improvement potential\n    segments = []\n    i = 0\n    while i < n:\n        segment_size = min(4, max(2, n // (5 + np.random.randint(3))))  # Adaptive segment size\n        segments.append(base_solution[i:i+segment_size])\n        i += segment_size\n\n    # Multi-objective edge-swap with dynamic acceptance criteria\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n\n        # Calculate segment cost\n        seg_cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        seg_cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n\n        # Try multiple edge swaps\n        for _ in range(3):\n            i, j = np.random.choice(len(seg), size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate swap impact\n            delta1 = (distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]) - \\\n                    (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]])\n            delta2 = (distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]) - \\\n                    (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]])\n\n            # Dynamic acceptance: accept if both objectives improve or if one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < -0.1 * seg_cost1 and delta2 < 0) or (delta1 < 0 and delta2 < -0.1 * seg_cost2):\n                seg[i], seg[j] = seg[j], seg[i]\n\n    # Greedy reconstruction with backtracking\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        # Backtrack to last valid solution\n        for i in range(len(segments)):\n            temp_solution = np.concatenate(segments[:i+1])\n            if len(np.unique(temp_solution)) == len(temp_solution):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a high-potential solution from the archive (prioritizing those with higher combined objective costs) and decomposes it into segments, optimizing each segment independently via a multi-objective edge-swap that only accepts swaps improving both objectives. It reconstructs the solution while ensuring feasibility, reverting to the original if invalid. The key innovation is segment-wise optimization with a strict bi-objective improvement criterion.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 75,
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid criterion combining objective values and diversity, then applies a segment-based local search with relaxed bi-objective edge-swaps to generate a neighbor solution while ensuring feasibility through validation. It prioritizes solutions with better overall performance and diversity, decomposes the tour into overlapping segments, and optimizes each segment by accepting swaps that improve at least one objective, finally reconstructing and validating the solution.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.std([sum(obj) for _, obj in archive])\n    weights = objectives + diversity * 0.5\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Decompose into overlapping segments\n    segment_size = max(2, n // 3)\n    segments = []\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Step 2: Optimize each segment with relaxed bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Relaxed improvement: accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7832031278017717,
            0.30778253078460693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.std([sum(obj) for _, obj in archive])\n    weights = objectives + diversity * 0.5\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Decompose into overlapping segments\n    segment_size = max(2, n // 3)\n    segments = []\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Step 2: Optimize each segment with relaxed bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Relaxed improvement: accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive (prioritizing those with higher combined objective costs) and decomposes it into segments, optimizing each segment independently via a multi-objective edge-swap that only accepts swaps improving both objectives. It reconstructs the solution while ensuring feasibility, reverting to the original if invalid. The key innovation is segment-wise optimization with a strict bi-objective improvement criterion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Hybrid Segment Swap**, **Cross-Dimensional Validation**, **Pareto-Aware Selection**, **Structural Balance**\n- **Advice**: Use a novel **hybrid segment swap** (combining 3-opt with cross-dimensional edge insertion) to balance local and global improvements. Select solutions with **high Pareto diversity** (e.g., crowding distance > threshold) and validate feasibility across both objectives.\n- **Avoid**: Static 2-opt or greedy single-objective operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The hybrid operator ensures diverse exploration while maintaining feasibility, and Pareto-aware selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 76,
        "algorithm": "The algorithm selects a high-diversity solution from the archive (using crowding distance), decomposes it into segments, and applies a hybrid 3-opt operator to each segment, accepting improvements only if they reduce both objectives. It reconstructs the solution while ensuring feasibility, falling back to the original if the new solution is invalid. The key innovation is the segment-based hybrid local search that prioritizes bi-objective improvements while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto diversity (highest crowding distance)\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n        if n < 2:\n            return np.zeros(n)\n        distances = np.zeros(n)\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    cd = crowding_distance(archive)\n    selected_idx = np.argmax(cd)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Decompose into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Hybrid 3-opt with cross-dimensional edge insertion\n    for seg in segments:\n        if len(seg) < 3:\n            continue\n        # Randomly select three edges to rearrange\n        i, j, k = np.random.choice(len(seg), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        # Calculate current and new costs in both objectives\n        current_cost1 = (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]] + distance_matrix_1[seg[k-1], seg[k]])\n        current_cost2 = (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]] + distance_matrix_2[seg[k-1], seg[k]])\n        # Rearrange the edges (3-opt)\n        temp_seg = seg.copy()\n        temp_seg[i:j+1] = temp_seg[i:j+1][::-1]\n        temp_seg[j:k+1] = temp_seg[j:k+1][::-1]\n        new_cost1 = (distance_matrix_1[temp_seg[i-1], temp_seg[i]] + distance_matrix_1[temp_seg[j-1], temp_seg[j]] + distance_matrix_1[temp_seg[k-1], temp_seg[k]])\n        new_cost2 = (distance_matrix_2[temp_seg[i-1], temp_seg[i]] + distance_matrix_2[temp_seg[j-1], temp_seg[j]] + distance_matrix_2[temp_seg[k-1], temp_seg[k]])\n        # Accept if both objectives improve\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i:j+1] = seg[i:j+1][::-1]\n            seg[j:k+1] = seg[j:k+1][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8691941748924419,
            2.195461928844452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto diversity (highest crowding distance)\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n        if n < 2:\n            return np.zeros(n)\n        distances = np.zeros(n)\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, n-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        return distances\n\n    cd = crowding_distance(archive)\n    selected_idx = np.argmax(cd)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Decompose into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Hybrid 3-opt with cross-dimensional edge insertion\n    for seg in segments:\n        if len(seg) < 3:\n            continue\n        # Randomly select three edges to rearrange\n        i, j, k = np.random.choice(len(seg), size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        # Calculate current and new costs in both objectives\n        current_cost1 = (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]] + distance_matrix_1[seg[k-1], seg[k]])\n        current_cost2 = (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]] + distance_matrix_2[seg[k-1], seg[k]])\n        # Rearrange the edges (3-opt)\n        temp_seg = seg.copy()\n        temp_seg[i:j+1] = temp_seg[i:j+1][::-1]\n        temp_seg[j:k+1] = temp_seg[j:k+1][::-1]\n        new_cost1 = (distance_matrix_1[temp_seg[i-1], temp_seg[i]] + distance_matrix_1[temp_seg[j-1], temp_seg[j]] + distance_matrix_1[temp_seg[k-1], temp_seg[k]])\n        new_cost2 = (distance_matrix_2[temp_seg[i-1], temp_seg[i]] + distance_matrix_2[temp_seg[j-1], temp_seg[j]] + distance_matrix_2[temp_seg[k-1], temp_seg[k]])\n        # Accept if both objectives improve\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i:j+1] = seg[i:j+1][::-1]\n            seg[j:k+1] = seg[j:k+1][::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Hybrid Segment Swap**, **Cross-Dimensional Validation**, **Pareto-Aware Selection**, **Structural Balance**\n- **Advice**: Use a novel **hybrid segment swap** (combining 3-opt with cross-dimensional edge insertion) to balance local and global improvements. Select solutions with **high Pareto diversity** (e.g., crowding distance > threshold) and validate feasibility across both objectives.\n- **Avoid**: Static 2-opt or greedy single-objective operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The hybrid operator ensures diverse exploration while maintaining feasibility, and Pareto-aware selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 77,
        "algorithm": "The algorithm selects high-diversity solutions from the archive (crowding distance > median) and applies a hybrid local search combining 3-opt with cross-dimensional edge insertion, ensuring feasibility by validating node uniqueness and edge existence across both objective spaces while prioritizing balanced objective trade-offs. The 3-opt operator (70% chance) reverses segments of the tour, while the edge insertion operator (30% chance) swaps edges between dimensions, with validity checks to maintain feasible tours. The method balances exploration (random selection) and exploitation (diversity-based selection) to navigate the Pareto front efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high Pareto diversity (crowding distance > median)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) < 2:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(objectives))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    median_crowding = np.median(crowding)\n    eligible = [i for i in range(len(archive)) if crowding[i] > median_crowding]\n\n    if not eligible:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(eligible)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with cross-dimensional edge insertion\n    if np.random.rand() < 0.7:  # 70% chance for 3-opt\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Perform 3-opt\n        new_solution[a:b] = base_solution[a:b][::-1]\n        new_solution[b:c] = base_solution[b:c][::-1]\n\n        # Cross-dimensional validation\n        valid = True\n        for i in range(n):\n            next_i = (i + 1) % n\n            if (distance_matrix_1[new_solution[i], new_solution[next_i]] > 2 * np.mean(distance_matrix_1) or\n                distance_matrix_2[new_solution[i], new_solution[next_i]] > 2 * np.mean(distance_matrix_2)):\n                valid = False\n                break\n\n        if not valid or len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n    else:  # Cross-dimensional edge insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Find edges in both spaces\n        edge1 = (base_solution[i], base_solution[(i+1)%n])\n        edge2 = (base_solution[j], base_solution[(j+1)%n])\n\n        # Insert edge2 before edge1\n        temp = new_solution.copy()\n        temp = np.delete(temp, j)\n        temp = np.insert(temp, i, base_solution[j])\n\n        if len(np.unique(temp)) == n:\n            new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9269591610426275,
            0.6152295470237732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high Pareto diversity (crowding distance > median)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) < 2:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(objectives))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(objectives)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    median_crowding = np.median(crowding)\n    eligible = [i for i in range(len(archive)) if crowding[i] > median_crowding]\n\n    if not eligible:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(eligible)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt with cross-dimensional edge insertion\n    if np.random.rand() < 0.7:  # 70% chance for 3-opt\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Perform 3-opt\n        new_solution[a:b] = base_solution[a:b][::-1]\n        new_solution[b:c] = base_solution[b:c][::-1]\n\n        # Cross-dimensional validation\n        valid = True\n        for i in range(n):\n            next_i = (i + 1) % n\n            if (distance_matrix_1[new_solution[i], new_solution[next_i]] > 2 * np.mean(distance_matrix_1) or\n                distance_matrix_2[new_solution[i], new_solution[next_i]] > 2 * np.mean(distance_matrix_2)):\n                valid = False\n                break\n\n        if not valid or len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n    else:  # Cross-dimensional edge insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Find edges in both spaces\n        edge1 = (base_solution[i], base_solution[(i+1)%n])\n        edge2 = (base_solution[j], base_solution[(j+1)%n])\n\n        # Insert edge2 before edge1\n        temp = new_solution.copy()\n        temp = np.delete(temp, j)\n        temp = np.insert(temp, i, base_solution[j])\n\n        if len(np.unique(temp)) == n:\n            new_solution = temp\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Hybrid Segment Swap**, **Cross-Dimensional Validation**, **Pareto-Aware Selection**, **Structural Balance**\n- **Advice**: Use a novel **hybrid segment swap** (combining 3-opt with cross-dimensional edge insertion) to balance local and global improvements. Select solutions with **high Pareto diversity** (e.g., crowding distance > threshold) and validate feasibility across both objectives.\n- **Avoid**: Static 2-opt or greedy single-objective operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The hybrid operator ensures diverse exploration while maintaining feasibility, and Pareto-aware selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 78,
        "algorithm": "The algorithm combines Pareto-aware selection with a hybrid local search that alternates between 3-opt and cross-dimensional edge insertion, prioritizing solutions with high crowding distance in the Pareto front. It ensures feasibility by validating structural constraints across both objective spaces and uses a balance-aware acceptance criterion to evaluate improvements in both objectives simultaneously. The algorithm dynamically switches between search strategies (3-opt and edge insertion) with a 60% probability for 3-opt, and maintains solution validity through structural checks and fallback to the original solution if constraints are violated.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high Pareto diversity (high crowding distance)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) < 2:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    fronts = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_idx = fronts[:, m]\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if np.random.rand() < 0.6:  # 3-opt with cross-dimensional validation\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Try all possible 3-opt configurations\n        configs = [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]\n\n        best_config = None\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for config in configs:\n            temp_sol = new_solution.copy()\n            temp_sol[config[0]:config[1]] = temp_sol[config[0]:config[1]][::-1]\n            temp_sol[config[1]:config[2]] = temp_sol[config[1]:config[2]][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for m in range(2):\n                dist_mat = distance_matrix_1 if m == 0 else distance_matrix_2\n                for l in range(n):\n                    next_l = (l + 1) % n\n                    if dist_mat[temp_sol[l], temp_sol[next_l]] > 2 * np.mean(dist_mat):\n                        valid = False\n                        break\n                if not valid:\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                cost1 = calculate_cost(temp_sol, distance_matrix_1)\n                cost2 = calculate_cost(temp_sol, distance_matrix_2)\n                if (cost1 < best_cost1 and cost2 < best_cost2) or (cost1 + cost2 < best_cost1 + best_cost2):\n                    best_config = config\n                    best_cost1, best_cost2 = cost1, cost2\n\n        if best_config is not None:\n            new_solution[best_config[0]:best_config[1]] = new_solution[best_config[0]:best_config[1]][::-1]\n            new_solution[best_config[1]:best_config[2]] = new_solution[best_config[1]:best_config[2]][::-1]\n    else:  # Cross-dimensional edge insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Find best insertion point in the other dimension\n        best_insert = None\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for k in range(n):\n            if k == i or k == (i+1)%n or k == j or k == (j+1)%n:\n                continue\n\n            # Try inserting edge (i,j) at position k\n            temp_sol = new_solution.copy()\n            temp_sol = np.concatenate([temp_sol[:k], [temp_sol[i]], [temp_sol[j]], temp_sol[k:]])\n\n            # Remove original edges and add new ones\n            cost1 = current_cost1 - distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] - distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]]\n            cost1 += distance_matrix_1[temp_sol[i], temp_sol[j]] + distance_matrix_1[temp_sol[(i+1)%n], temp_sol[(j+1)%n]]\n\n            cost2 = current_cost2 - distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] - distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]]\n            cost2 += distance_matrix_2[temp_sol[i], temp_sol[j]] + distance_matrix_2[temp_sol[(i+1)%n], temp_sol[(j+1)%n]]\n\n            if (cost1 < best_cost1 and cost2 < best_cost2) or (cost1 + cost2 < best_cost1 + best_cost2):\n                best_insert = k\n                best_cost1, best_cost2 = cost1, cost2\n\n        if best_insert is not None:\n            new_solution = np.concatenate([\n                new_solution[:best_insert],\n                [new_solution[i]],\n                [new_solution[j]],\n                new_solution[best_insert:]\n            ])\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.982968917799174,
            1.8278539776802063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high Pareto diversity (high crowding distance)\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) < 2:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    fronts = np.argsort(objectives, axis=0)\n    crowding = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_idx = fronts[:, m]\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if np.random.rand() < 0.6:  # 3-opt with cross-dimensional validation\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Try all possible 3-opt configurations\n        configs = [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]\n\n        best_config = None\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for config in configs:\n            temp_sol = new_solution.copy()\n            temp_sol[config[0]:config[1]] = temp_sol[config[0]:config[1]][::-1]\n            temp_sol[config[1]:config[2]] = temp_sol[config[1]:config[2]][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for m in range(2):\n                dist_mat = distance_matrix_1 if m == 0 else distance_matrix_2\n                for l in range(n):\n                    next_l = (l + 1) % n\n                    if dist_mat[temp_sol[l], temp_sol[next_l]] > 2 * np.mean(dist_mat):\n                        valid = False\n                        break\n                if not valid:\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                cost1 = calculate_cost(temp_sol, distance_matrix_1)\n                cost2 = calculate_cost(temp_sol, distance_matrix_2)\n                if (cost1 < best_cost1 and cost2 < best_cost2) or (cost1 + cost2 < best_cost1 + best_cost2):\n                    best_config = config\n                    best_cost1, best_cost2 = cost1, cost2\n\n        if best_config is not None:\n            new_solution[best_config[0]:best_config[1]] = new_solution[best_config[0]:best_config[1]][::-1]\n            new_solution[best_config[1]:best_config[2]] = new_solution[best_config[1]:best_config[2]][::-1]\n    else:  # Cross-dimensional edge insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Find best insertion point in the other dimension\n        best_insert = None\n        best_cost1, best_cost2 = current_cost1, current_cost2\n\n        for k in range(n):\n            if k == i or k == (i+1)%n or k == j or k == (j+1)%n:\n                continue\n\n            # Try inserting edge (i,j) at position k\n            temp_sol = new_solution.copy()\n            temp_sol = np.concatenate([temp_sol[:k], [temp_sol[i]], [temp_sol[j]], temp_sol[k:]])\n\n            # Remove original edges and add new ones\n            cost1 = current_cost1 - distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] - distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]]\n            cost1 += distance_matrix_1[temp_sol[i], temp_sol[j]] + distance_matrix_1[temp_sol[(i+1)%n], temp_sol[(j+1)%n]]\n\n            cost2 = current_cost2 - distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] - distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]]\n            cost2 += distance_matrix_2[temp_sol[i], temp_sol[j]] + distance_matrix_2[temp_sol[(i+1)%n], temp_sol[(j+1)%n]]\n\n            if (cost1 < best_cost1 and cost2 < best_cost2) or (cost1 + cost2 < best_cost1 + best_cost2):\n                best_insert = k\n                best_cost1, best_cost2 = cost1, cost2\n\n        if best_insert is not None:\n            new_solution = np.concatenate([\n                new_solution[:best_insert],\n                [new_solution[i]],\n                [new_solution[j]],\n                new_solution[best_insert:]\n            ])\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Hybrid Segment Swap**, **Cross-Dimensional Validation**, **Pareto-Aware Selection**, **Structural Balance**\n- **Advice**: Use a novel **hybrid segment swap** (combining 3-opt with cross-dimensional edge insertion) to balance local and global improvements. Select solutions with **high Pareto diversity** (e.g., crowding distance > threshold) and validate feasibility across both objectives.\n- **Avoid**: Static 2-opt or greedy single-objective operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The hybrid operator ensures diverse exploration while maintaining feasibility, and Pareto-aware selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 79,
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing Pareto-nondominated solutions with high crowding distance, then applies a hybrid local search: 60% of the time it performs a 3-opt move for exploitation, and 40% of the time it inserts a cross-dimensional edge for exploration, ensuring feasibility by validating node uniqueness. The selection balances objective trade-offs, while the local search alternates between exploitation and exploration to adaptively refine the Pareto front.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance and crowding distance selection\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.argmax(np.sum(objectives / np.max(objectives, axis=0), axis=1))\n    else:\n        crowding = np.zeros(len(nondominated))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[nondominated, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(nondominated) - 1):\n                crowding[sorted_idx[i]] += (objectives[nondominated[sorted_idx[i + 1]], m] - objectives[nondominated[sorted_idx[i - 1]], m]) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n        selected_idx = nondominated[np.argmax(crowding)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 3-opt with cross-dimensional edge insertion\n    if np.random.rand() < 0.6:  # 60% chance for 3-opt (exploitation)\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        # Reconnect edges (i,j), (j,k) to (i,k) and insert (j,k) elsewhere\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse segment\n        temp_solution[j:k+1] = temp_solution[j:k+1][::-1]  # Reverse segment\n        new_solution = temp_solution\n    else:  # 40% chance for cross-dimensional edge insertion (exploration)\n        # Select a random edge from the other objective space\n        i, j = np.random.choice(n, size=2, replace=False)\n        # Insert edge (i,j) into the tour\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:i+1], [temp_solution[j]], temp_solution[i+1:j], temp_solution[j+1:]])\n        new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.79715341676028,
            2.0240200757980347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance and crowding distance selection\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.argmax(np.sum(objectives / np.max(objectives, axis=0), axis=1))\n    else:\n        crowding = np.zeros(len(nondominated))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[nondominated, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(nondominated) - 1):\n                crowding[sorted_idx[i]] += (objectives[nondominated[sorted_idx[i + 1]], m] - objectives[nondominated[sorted_idx[i - 1]], m]) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n        selected_idx = nondominated[np.argmax(crowding)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 3-opt with cross-dimensional edge insertion\n    if np.random.rand() < 0.6:  # 60% chance for 3-opt (exploitation)\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n        # Reconnect edges (i,j), (j,k) to (i,k) and insert (j,k) elsewhere\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse segment\n        temp_solution[j:k+1] = temp_solution[j:k+1][::-1]  # Reverse segment\n        new_solution = temp_solution\n    else:  # 40% chance for cross-dimensional edge insertion (exploration)\n        # Select a random edge from the other objective space\n        i, j = np.random.choice(n, size=2, replace=False)\n        # Insert edge (i,j) into the tour\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:i+1], [temp_solution[j]], temp_solution[i+1:j], temp_solution[j+1:]])\n        new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 80,
        "algorithm": "The algorithm selects a promising solution from the archive by combining normalized objectives and diversity scores, then applies a hybrid local search (60% edge-swap, 40% constrained segment insertion) to generate a neighbor solution while ensuring feasibility through node uniqueness validation. It prioritizes multi-objective improvement in edge-swaps and allows occasional diversification in segment insertions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    scores = np.sum(normalized, axis=1) + 0.5 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: 60% edge-swap, 40% constrained segment insertion\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Constrained segment insertion\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b = sorted([a, b])\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9442062933891868,
            0.25356727838516235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    scores = np.sum(normalized, axis=1) + 0.5 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: 60% edge-swap, 40% constrained segment insertion\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Constrained segment insertion\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b = sorted([a, b])\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 81,
        "algorithm": "The algorithm selects a promising solution from an archive by prioritizing lower weighted scores (60% weight on first objective), then applies either constrained node insertion (60% chance) or limited-scope edge reversal (40% chance) to generate neighbors, accepting improvements or occasional worse solutions to escape local optima, while ensuring feasibility through node uniqueness validation. The hybrid operator balances exploration and exploitation by combining local and segment-based modifications, with segment length limited to prevent excessive disruption.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])  # Higher weight for the first objective\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)  # Select the solution with lowest weighted score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid operator: constrained node insertion (60%) or limited-scope edge swap (40%)\n    if np.random.rand() < 0.6:  # 60% chance for constrained node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        temp_solution = new_solution.copy()\n        node = temp_solution[i]\n        temp_solution = np.delete(temp_solution, i)\n        temp_solution = np.insert(temp_solution, j, node)\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:  # 40% chance for limited-scope edge swap\n        segment_length = min(4, n // 2)  # Limit the segment length\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7101799150725502,
            1.1848797798156738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted combination of objectives)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])  # Higher weight for the first objective\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)  # Select the solution with lowest weighted score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid operator: constrained node insertion (60%) or limited-scope edge swap (40%)\n    if np.random.rand() < 0.6:  # 60% chance for constrained node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        temp_solution = new_solution.copy()\n        node = temp_solution[i]\n        temp_solution = np.delete(temp_solution, i)\n        temp_solution = np.insert(temp_solution, j, node)\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:  # 40% chance for limited-scope edge swap\n        segment_length = min(4, n // 2)  # Limit the segment length\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive (prioritizing those with high normalized objective values) and applies either a constrained edge-swap (70% chance) or a partial tour reversal (30% chance) to generate a neighbor solution, ensuring feasibility by validating uniqueness of nodes. The edge-swap focuses on improving both objectives simultaneously, while the partial reversal allows exploration of alternative tour segments. The solution is reverted to the original if duplicates are detected, maintaining validity.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate current costs\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Dynamically choose between edge-swap and partial reversal\n    if np.random.rand() < 0.7:  # 70% chance for edge-swap (exploitation)\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:  # Allow some randomness\n            new_solution = temp_solution\n    else:  # 30% chance for partial reversal (exploration)\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Hybrid Segment Swap**, **Cross-Dimensional Validation**, **Pareto-Aware Selection**, **Structural Balance**\n- **Advice**: Use a novel **hybrid segment swap** (combining 3-opt with cross-dimensional edge insertion) to balance local and global improvements. Select solutions with **high Pareto diversity** (e.g., crowding distance > threshold) and validate feasibility across both objectives.\n- **Avoid**: Static 2-opt or greedy single-objective operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The hybrid operator ensures diverse exploration while maintaining feasibility, and Pareto-aware selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 82,
        "algorithm": "The algorithm selects a promising solution from the archive by filtering Pareto nondominated solutions with high crowding distance, then applies a hybrid local search (70% 3-opt, 30% cross-dimensional edge insertion) to generate neighbors while ensuring feasibility through node uniqueness validation. The approach prioritizes Pareto diversity and balances exploitation/exploration through the hybrid search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: filter nondominated solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated[i] = True\n                break\n\n    nondominated = [archive[i] for i in range(len(archive)) if not is_dominated[i]]\n    if not nondominated:\n        nondominated = archive.copy()\n\n    # Calculate crowding distance for Pareto diversity\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i + 1], m] - objectives[sorted_idx[i - 1], m])\n        return distances\n\n    distances = crowding_distance(nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt (70%) or cross-dimensional edge insertion (30%)\n    if np.random.rand() < 0.7:\n        # 3-opt: select three edges and swap them\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        # Validate feasibility\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n    else:\n        # Cross-dimensional edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_solution[j], temp_solution[k] = temp_solution[k], temp_solution[j]\n\n        # Validate feasibility\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.827064007255827,
            2.0163963437080383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection: filter nondominated solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated[i] = True\n                break\n\n    nondominated = [archive[i] for i in range(len(archive)) if not is_dominated[i]]\n    if not nondominated:\n        nondominated = archive.copy()\n\n    # Calculate crowding distance for Pareto diversity\n    def crowding_distance(solutions):\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i + 1], m] - objectives[sorted_idx[i - 1], m])\n        return distances\n\n    distances = crowding_distance(nondominated)\n    selected_idx = np.argmax(distances)\n    base_solution = nondominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: 3-opt (70%) or cross-dimensional edge insertion (30%)\n    if np.random.rand() < 0.7:\n        # 3-opt: select three edges and swap them\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        # Validate feasibility\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n    else:\n        # Cross-dimensional edge insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        temp_solution[j], temp_solution[k] = temp_solution[k], temp_solution[j]\n\n        # Validate feasibility\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\n\n        Adjusted long-term guide: - **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 83,
        "algorithm": "The algorithm selects promising solutions near the Pareto frontier from the archive, then applies an adaptive cross-dimensional swap operator combining segment reversal and edge contraction while ensuring feasibility through structural validation and prioritizing balanced objective improvements through diversity-aware acceptance criteria. It focuses on solutions with better combined objective values (top 20%) and uses random segment reversal and edge contraction operations, validating them against cross-dimensional distance constraints before accepting changes that either improve objectives or increase diversity between them. The heuristic balances exploration and exploitation by favoring solutions that show potential for multi-objective improvement while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20% in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_indices = np.argsort(np.sum(objectives, axis=1))[-max(1, len(archive)//5):]\n    selected_idx = np.random.choice(pareto_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive cross-dimensional swap operator\n    def calculate_cost(sol, dist_mat):\n        return sum(dist_mat[sol[k], sol[(k+1)%n]] for k in range(n))\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Segment reversal with cross-dimensional balance check\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = sorted([i, j])\n    segment_length = j - i\n\n    if segment_length > 1:\n        temp_sol = new_solution.copy()\n        temp_sol[i:j] = temp_sol[i:j][::-1]\n\n        # Validate cross-dimensional feasibility\n        valid = True\n        for k in range(n):\n            next_k = (k + 1) % n\n            dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n            dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n            if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                valid = False\n                break\n\n        if valid and len(np.unique(temp_sol)) == n:\n            new_solution = temp_sol\n\n    # Edge contraction with distance-based selection\n    k = np.random.randint(0, n)\n    l = (k + 2) % n\n    if l > k:\n        temp_sol = new_solution.copy()\n        temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n        if len(np.unique(temp_sol)) == n:\n            new_solution = temp_sol\n\n    # Diversity-aware acceptance\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9414966169169956,
            0.3884055018424988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20% in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_indices = np.argsort(np.sum(objectives, axis=1))[-max(1, len(archive)//5):]\n    selected_idx = np.random.choice(pareto_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive cross-dimensional swap operator\n    def calculate_cost(sol, dist_mat):\n        return sum(dist_mat[sol[k], sol[(k+1)%n]] for k in range(n))\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    # Segment reversal with cross-dimensional balance check\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = sorted([i, j])\n    segment_length = j - i\n\n    if segment_length > 1:\n        temp_sol = new_solution.copy()\n        temp_sol[i:j] = temp_sol[i:j][::-1]\n\n        # Validate cross-dimensional feasibility\n        valid = True\n        for k in range(n):\n            next_k = (k + 1) % n\n            dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n            dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n            if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                valid = False\n                break\n\n        if valid and len(np.unique(temp_sol)) == n:\n            new_solution = temp_sol\n\n    # Edge contraction with distance-based selection\n    k = np.random.randint(0, n)\n    l = (k + 2) % n\n    if l > k:\n        temp_sol = new_solution.copy()\n        temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n        if len(np.unique(temp_sol)) == n:\n            new_solution = temp_sol\n\n    # Diversity-aware acceptance\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the solution with the highest combined objective from the archive, then applies a hybrid local search using segment reversal, node relocation, and edge swapping, prioritizing improvements in the objective that is currently worse, while ensuring feasibility through multi-step validation. The search dynamically adapts operations based on objective imbalance and validates moves using distance matrices to guide improvements in both objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(3):  # Perform 3 operations per iteration\n        operation = np.random.choice(['reversal', 'relocation', 'swap'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                # Check if reversing improves obj1\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                # Check if reversing improves obj2\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'relocation':\n            # Node relocation with bias toward improving the prioritized objective\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                # Check if moving improves obj1\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                # Check if moving improves obj2\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'swap':\n            # Edge swap with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                # Check if swapping improves obj1\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Check if swapping improves obj2\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 84,
        "algorithm": "The algorithm selects promising solutions near the Pareto frontier, prioritizes improving the weaker objective, and applies a hybrid operator combining segment reversal (with objective-biased cost checks) and cross-dimensional edge contraction (with probabilistic node swaps), while ensuring feasibility through uniqueness validation. It dynamically balances local improvements across both objectives while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20%)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    pareto_front_size = max(1, len(sorted_archive) // 5)\n    pareto_front = sorted_archive[:pareto_front_size]\n    selected_idx = np.random.choice(len(pareto_front))\n    base_solution = pareto_front[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine which objective to prioritize\n    obj1, obj2 = pareto_front[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid operator: Segment reversal + cross-dimensional edge contraction\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Segment reversal with bias\n        segment = new_solution[i:j+1]\n        if prioritize_obj1:\n            original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = segment[::-1]\n\n        # Cross-dimensional edge contraction\n        if np.random.rand() < 0.3:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node_k = new_solution[k]\n            node_l = new_solution[l]\n            if prioritize_obj1:\n                original_cost = distance_matrix_1[new_solution[k-1], node_k] + distance_matrix_1[node_k, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[k-1], node_l] + distance_matrix_1[node_l, new_solution[(k+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[k] = node_l\n            else:\n                original_cost = distance_matrix_2[new_solution[k-1], node_k] + distance_matrix_2[node_k, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[k-1], node_l] + distance_matrix_2[node_l, new_solution[(k+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[k] = node_l\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7609515309788186,
            3.288431704044342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20%)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    pareto_front_size = max(1, len(sorted_archive) // 5)\n    pareto_front = sorted_archive[:pareto_front_size]\n    selected_idx = np.random.choice(len(pareto_front))\n    base_solution = pareto_front[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine which objective to prioritize\n    obj1, obj2 = pareto_front[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid operator: Segment reversal + cross-dimensional edge contraction\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Segment reversal with bias\n        segment = new_solution[i:j+1]\n        if prioritize_obj1:\n            original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = segment[::-1]\n        else:\n            original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = segment[::-1]\n\n        # Cross-dimensional edge contraction\n        if np.random.rand() < 0.3:\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node_k = new_solution[k]\n            node_l = new_solution[l]\n            if prioritize_obj1:\n                original_cost = distance_matrix_1[new_solution[k-1], node_k] + distance_matrix_1[node_k, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[k-1], node_l] + distance_matrix_1[node_l, new_solution[(k+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[k] = node_l\n            else:\n                original_cost = distance_matrix_2[new_solution[k-1], node_k] + distance_matrix_2[node_k, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[k-1], node_l] + distance_matrix_2[node_l, new_solution[(k+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[k] = node_l\n\n    # Check feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects the solution with the highest combined objective from the archive, then applies a hybrid local search using segment reversal, node relocation, and edge swapping, prioritizing improvements in the objective that is currently worse, while ensuring feasibility through multi-step validation. The search dynamically adapts operations based on objective imbalance and validates moves using distance matrices to guide improvements in both objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(3):  # Perform 3 operations per iteration\n        operation = np.random.choice(['reversal', 'relocation', 'swap'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                # Check if reversing improves obj1\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                # Check if reversing improves obj2\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'relocation':\n            # Node relocation with bias toward improving the prioritized objective\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                # Check if moving improves obj1\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                # Check if moving improves obj2\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'swap':\n            # Edge swap with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                # Check if swapping improves obj1\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Check if swapping improves obj2\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 85,
        "algorithm": "The algorithm selects high-potential solutions from the archive by prioritizing those near the Pareto frontier with high diversity, then applies a novel cross-dimensional swap operator that combines segment reversal with edge contraction, dynamically adapting to the worse-performing objective while maintaining feasibility through validation checks. It favors improvements in the weaker objective and includes a small randomness factor to escape local optima, ensuring valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution near the Pareto frontier with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    combined_scores = np.sum(normalized, axis=1)\n\n    # Calculate diversity (spread of nodes in both spaces)\n    diversity_scores = []\n    for sol, _ in archive:\n        coords = instance[sol]\n        x1_spread = np.max(coords[:, 0]) - np.min(coords[:, 0])\n        y1_spread = np.max(coords[:, 1]) - np.min(coords[:, 1])\n        x2_spread = np.max(coords[:, 2]) - np.min(coords[:, 2])\n        y2_spread = np.max(coords[:, 3]) - np.min(coords[:, 3])\n        diversity = (x1_spread + y1_spread + x2_spread + y2_spread) / 4\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    combined_scores = combined_scores * (diversity_scores / np.max(diversity_scores))\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine which objective to prioritize\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Cross-dimensional swap operator\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    while j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Segment reversal\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n\n    # Edge contraction (swap edges to maintain connectivity)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = reversed_segment\n\n    # Check feasibility and objective improvement\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    improvement1 = current_cost1 - new_cost1\n    improvement2 = current_cost2 - new_cost2\n\n    if prioritize_obj1:\n        accept = (improvement1 > 0 and improvement2 >= 0) or (np.random.rand() < 0.1)\n    else:\n        accept = (improvement2 > 0 and improvement1 >= 0) or (np.random.rand() < 0.1)\n\n    if accept:\n        new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9414033271389449,
            2.761399984359741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution near the Pareto frontier with high diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    combined_scores = np.sum(normalized, axis=1)\n\n    # Calculate diversity (spread of nodes in both spaces)\n    diversity_scores = []\n    for sol, _ in archive:\n        coords = instance[sol]\n        x1_spread = np.max(coords[:, 0]) - np.min(coords[:, 0])\n        y1_spread = np.max(coords[:, 1]) - np.min(coords[:, 1])\n        x2_spread = np.max(coords[:, 2]) - np.min(coords[:, 2])\n        y2_spread = np.max(coords[:, 3]) - np.min(coords[:, 3])\n        diversity = (x1_spread + y1_spread + x2_spread + y2_spread) / 4\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    combined_scores = combined_scores * (diversity_scores / np.max(diversity_scores))\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine which objective to prioritize\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Cross-dimensional swap operator\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    while j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Segment reversal\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n\n    # Edge contraction (swap edges to maintain connectivity)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = reversed_segment\n\n    # Check feasibility and objective improvement\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    improvement1 = current_cost1 - new_cost1\n    improvement2 = current_cost2 - new_cost2\n\n    if prioritize_obj1:\n        accept = (improvement1 > 0 and improvement2 >= 0) or (np.random.rand() < 0.1)\n    else:\n        accept = (improvement2 > 0 and improvement1 >= 0) or (np.random.rand() < 0.1)\n\n    if accept:\n        new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the solution with the highest combined objective from the archive, then applies a hybrid local search using segment reversal, node relocation, and edge swapping, prioritizing improvements in the objective that is currently worse, while ensuring feasibility through multi-step validation. The search dynamically adapts operations based on objective imbalance and validates moves using distance matrices to guide improvements in both objectives.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(3):  # Perform 3 operations per iteration\n        operation = np.random.choice(['reversal', 'relocation', 'swap'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                # Check if reversing improves obj1\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                # Check if reversing improves obj2\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'relocation':\n            # Node relocation with bias toward improving the prioritized objective\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                # Check if moving improves obj1\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                # Check if moving improves obj2\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'swap':\n            # Edge swap with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                # Check if swapping improves obj1\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Check if swapping improves obj2\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 86,
        "algorithm": "The algorithm selects a solution from the archive using a diversity-aware criterion (balancing exploration and exploitation) and applies a multi-phase local search combining adaptive edge insertion, biased node swapping, and dynamic segment optimization, prioritizing the objective with greater potential for improvement while ensuring feasibility. The selection prioritizes solutions with high diversity scores, and the local search adaptively focuses on the objective with higher imbalance, using novel operators to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel diversity-aware selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(normalized, axis=1) * np.prod(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine objective prioritization based on normalized imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    normalized_imbalance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-8)\n    prioritize_obj1 = obj1 > obj2 and normalized_imbalance > 0.3\n\n    # Multi-phase local search\n    for phase in range(2):  # Two distinct phases\n        for _ in range(2):  # Two operations per phase\n            if phase == 0:  # Phase 1: Adaptive edge insertion\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                if prioritize_obj1:\n                    if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                        new_solution = np.insert(new_solution, (i+1)%n, new_solution[j])\n                        new_solution = np.delete(new_solution, (j+2)%n if j > i else j)\n                else:\n                    if distance_matrix_2[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n                        new_solution = np.insert(new_solution, (i+1)%n, new_solution[j])\n                        new_solution = np.delete(new_solution, (j+2)%n if j > i else j)\n            else:  # Phase 2: Biased node swapping\n                i, j = np.random.choice(n, 2, replace=False)\n                if prioritize_obj1:\n                    delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                    if delta < 0:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                    if delta < 0:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment optimization\n    if n > 6:\n        segment_size = max(2, min(5, n // 4))\n        for _ in range(2):\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n            if prioritize_obj1:\n                original = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n                reversed = sum(distance_matrix_1[segment[(i+1)%segment_size], segment[i]] for i in range(segment_size))\n                if reversed < original:\n                    new_solution[start:start+segment_size] = segment[::-1]\n            else:\n                original = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n                reversed = sum(distance_matrix_2[segment[(i+1)%segment_size], segment[i]] for i in range(segment_size))\n                if reversed < original:\n                    new_solution[start:start+segment_size] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8308058173465642,
            0.361005961894989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel diversity-aware selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.sum(normalized, axis=1) * np.prod(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine objective prioritization based on normalized imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    normalized_imbalance = abs(obj1 - obj2) / (obj1 + obj2 + 1e-8)\n    prioritize_obj1 = obj1 > obj2 and normalized_imbalance > 0.3\n\n    # Multi-phase local search\n    for phase in range(2):  # Two distinct phases\n        for _ in range(2):  # Two operations per phase\n            if phase == 0:  # Phase 1: Adaptive edge insertion\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                if prioritize_obj1:\n                    if distance_matrix_1[new_solution[i], new_solution[j]] > distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                        new_solution = np.insert(new_solution, (i+1)%n, new_solution[j])\n                        new_solution = np.delete(new_solution, (j+2)%n if j > i else j)\n                else:\n                    if distance_matrix_2[new_solution[i], new_solution[j]] > distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n                        new_solution = np.insert(new_solution, (i+1)%n, new_solution[j])\n                        new_solution = np.delete(new_solution, (j+2)%n if j > i else j)\n            else:  # Phase 2: Biased node swapping\n                i, j = np.random.choice(n, 2, replace=False)\n                if prioritize_obj1:\n                    delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n                    if delta < 0:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                else:\n                    delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                    if delta < 0:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment optimization\n    if n > 6:\n        segment_size = max(2, min(5, n // 4))\n        for _ in range(2):\n            start = np.random.randint(0, n - segment_size)\n            segment = new_solution[start:start+segment_size]\n            if prioritize_obj1:\n                original = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n                reversed = sum(distance_matrix_1[segment[(i+1)%segment_size], segment[i]] for i in range(segment_size))\n                if reversed < original:\n                    new_solution[start:start+segment_size] = segment[::-1]\n            else:\n                original = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n                reversed = sum(distance_matrix_2[segment[(i+1)%segment_size], segment[i]] for i in range(segment_size))\n                if reversed < original:\n                    new_solution[start:start+segment_size] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the solution with the highest combined objective from the archive, then applies a hybrid local search using segment reversal, node relocation, and edge swapping, prioritizing improvements in the objective that is currently worse, while ensuring feasibility through multi-step validation. The search dynamically adapts operations based on objective imbalance and validates moves using distance matrices to guide improvements in both objectives.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(3):  # Perform 3 operations per iteration\n        operation = np.random.choice(['reversal', 'relocation', 'swap'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                # Check if reversing improves obj1\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                # Check if reversing improves obj2\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'relocation':\n            # Node relocation with bias toward improving the prioritized objective\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                # Check if moving improves obj1\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                # Check if moving improves obj2\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'swap':\n            # Edge swap with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                # Check if swapping improves obj1\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Check if swapping improves obj2\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 87,
        "algorithm": "The algorithm selects a solution with the highest imbalance between objectives, then applies a hybrid local search using alternating path reversal, node insertion, and edge crossover, prioritizing improvements in the worse-performing objective while ensuring feasibility through multi-step validation and dynamic objective balancing. It uses adaptive operations based on the current imbalance, with alternating path reversal (30% chance), node insertion (40% chance), and edge crossover (30% chance) to explore the solution space. The method dynamically adjusts which objective to prioritize during each operation, accepting moves that improve the worse objective or make small improvements to the better one.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high imbalance between objectives\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(4):  # More operations per iteration\n        operation = np.random.choice(['alternate_reversal', 'insertion', 'crossover'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'alternate_reversal':\n            # Alternating path reversal with dynamic objective balancing\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                delta = reversed_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                delta = reversed_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with dynamic objective balancing\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'crossover':\n            # Edge crossover with dynamic objective balancing\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7134028069619692,
            0.311981737613678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high imbalance between objectives\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(4):  # More operations per iteration\n        operation = np.random.choice(['alternate_reversal', 'insertion', 'crossover'], p=[0.3, 0.4, 0.3])\n\n        if operation == 'alternate_reversal':\n            # Alternating path reversal with dynamic objective balancing\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                delta = reversed_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                delta = reversed_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'insertion':\n            # Node insertion with dynamic objective balancing\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'crossover':\n            # Edge crossover with dynamic objective balancing\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                delta = new_cost - original_cost\n                if delta < 0 or (delta < 0.1 * abs(obj1 - obj2)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest combined objective from the archive, then applies a hybrid local search using segment reversal, node relocation, and edge swapping, prioritizing improvements in the objective that is currently worse, while ensuring feasibility through multi-step validation. The search dynamically adapts operations based on objective imbalance and validates moves using distance matrices to guide improvements in both objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest combined objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Determine which objective to prioritize based on current imbalance\n    obj1, obj2 = archive[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search with adaptive operations\n    for _ in range(3):  # Perform 3 operations per iteration\n        operation = np.random.choice(['reversal', 'relocation', 'swap'], p=[0.4, 0.4, 0.2])\n\n        if operation == 'reversal':\n            # Segment reversal with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                # Check if reversing improves obj1\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                # Check if reversing improves obj2\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'relocation':\n            # Node relocation with bias toward improving the prioritized objective\n            k = np.random.randint(0, n)\n            l = np.random.randint(0, n)\n            while l == k or l == (k + 1) % n:\n                l = np.random.randint(0, n)\n\n            node = new_solution[k]\n            if prioritize_obj1:\n                # Check if moving improves obj1\n                original_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_1[new_solution[l-1], node] + distance_matrix_1[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n            else:\n                # Check if moving improves obj2\n                original_cost = distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n                new_cost = distance_matrix_2[new_solution[l-1], node] + distance_matrix_2[node, new_solution[(l+1)%n]]\n                if new_cost < original_cost:\n                    new_solution = np.delete(new_solution, k)\n                    new_solution = np.insert(new_solution, l, node)\n\n        elif operation == 'swap':\n            # Edge swap with bias toward improving the prioritized objective\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            while j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            if prioritize_obj1:\n                # Check if swapping improves obj1\n                original_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Check if swapping improves obj2\n                original_cost = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n                if new_cost < original_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            - **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 88,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select from top 20% of solutions near Pareto frontier based on combined objective\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_idx = np.random.choice(len(selection_pool))\n    base_solution = selection_pool[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine objective imbalance for adaptive prioritization\n    obj1, obj2 = selection_pool[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search combining cross-dimensional operations\n    for _ in range(5):\n        operation = np.random.choice(['cross_swap', 'segment_reversal', 'edge_contraction'], p=[0.5, 0.3, 0.2])\n\n        if operation == 'cross_swap':\n            # Cross-dimensional swap prioritizing the worse objective\n            i, j = np.random.choice(n, 2, replace=False)\n            if prioritize_obj1:\n                if distance_matrix_1[new_solution[i], new_solution[j]] < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if distance_matrix_2[new_solution[i], new_solution[j]] < distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'segment_reversal':\n            # Segment reversal with cross-dimensional validation\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'edge_contraction':\n            # Edge contraction with cross-dimensional feasibility check\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i+1)%n:\n                j = np.random.randint(0, n)\n\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            # Validate in both objective spaces\n            valid = True\n            for k in range(n):\n                if (distance_matrix_1[temp[k], temp[(k+1)%n]] == 0 or\n                    distance_matrix_2[temp[k], temp[(k+1)%n]] == 0):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp)) == n:\n                new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7607782374930107,
            0.36020803451538086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select from top 20% of solutions near Pareto frontier based on combined objective\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selection_pool = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_idx = np.random.choice(len(selection_pool))\n    base_solution = selection_pool[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Determine objective imbalance for adaptive prioritization\n    obj1, obj2 = selection_pool[selected_idx][1]\n    prioritize_obj1 = obj1 > obj2\n\n    # Hybrid local search combining cross-dimensional operations\n    for _ in range(5):\n        operation = np.random.choice(['cross_swap', 'segment_reversal', 'edge_contraction'], p=[0.5, 0.3, 0.2])\n\n        if operation == 'cross_swap':\n            # Cross-dimensional swap prioritizing the worse objective\n            i, j = np.random.choice(n, 2, replace=False)\n            if prioritize_obj1:\n                if distance_matrix_1[new_solution[i], new_solution[j]] < distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                if distance_matrix_2[new_solution[i], new_solution[j]] < distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'segment_reversal':\n            # Segment reversal with cross-dimensional validation\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j+1]\n            if prioritize_obj1:\n                original_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_1[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n            else:\n                original_cost = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n                reversed_cost = sum(distance_matrix_2[segment[(k+1)%len(segment)], segment[k]] for k in range(len(segment)))\n                if reversed_cost < original_cost:\n                    new_solution[i:j+1] = segment[::-1]\n\n        elif operation == 'edge_contraction':\n            # Edge contraction with cross-dimensional feasibility check\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i+1)%n:\n                j = np.random.randint(0, n)\n\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            # Validate in both objective spaces\n            valid = True\n            for k in range(n):\n                if (distance_matrix_1[temp[k], temp[(k+1)%n]] == 0 or\n                    distance_matrix_2[temp[k], temp[(k+1)%n]] == 0):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp)) == n:\n                new_solution = temp\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 7 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by combining normalized objectives and diversity scores, then applies a hybrid local search (60% edge-swap, 40% constrained segment insertion) to generate a neighbor solution while ensuring feasibility through node uniqueness validation. It prioritizes multi-objective improvement in edge-swaps and allows occasional diversification in segment insertions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    scores = np.sum(normalized, axis=1) + 0.5 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: 60% edge-swap, 40% constrained segment insertion\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Constrained segment insertion\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b = sorted([a, b])\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 89,
        "algorithm": "The algorithm selects nondominated solutions with high crowding distance, then applies a hybrid local search combining 3-opt and cross-dimensional edge insertion, ensuring feasibility by validating structural constraints and prioritizing balanced objective improvements. It alternates between 3-opt moves and cross-dimensional edge insertions, with a 20% chance to accept a move even if it doesn't strictly improve both objectives, while always checking for feasibility and reverting to the original solution if invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                           (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n\n    # Calculate crowding distance for nondominated solutions\n    front = objectives[nondominated_indices]\n    crowding_distance = np.zeros(len(front))\n\n    for m in range(2):\n        sorted_indices = np.argsort(front[:, m])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(front)-1):\n            crowding_distance[sorted_indices[i]] += (front[sorted_indices[i+1], m] - front[sorted_indices[i-1], m]) / (front[sorted_indices[-1], m] - front[sorted_indices[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = nondominated_indices[np.argmax(crowding_distance)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Alternate between 3-opt and cross-dimensional edge insertion\n    if np.random.rand() < 0.5:\n        # 3-opt move\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Cross-dimensional edge insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Check cross-dimensional feasibility\n        valid = True\n        for k in range(n):\n            next_k = (k + 1) % n\n            dist1 = distance_matrix_1[temp_solution[k], temp_solution[next_k]]\n            dist2 = distance_matrix_2[temp_solution[k], temp_solution[next_k]]\n            if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                valid = False\n                break\n\n        if valid and len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n\n    # Step 3: Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7574349734822183,
            12.316453158855438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                           (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                is_dominated[i] = True\n                break\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n\n    # Calculate crowding distance for nondominated solutions\n    front = objectives[nondominated_indices]\n    crowding_distance = np.zeros(len(front))\n\n    for m in range(2):\n        sorted_indices = np.argsort(front[:, m])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(front)-1):\n            crowding_distance[sorted_indices[i]] += (front[sorted_indices[i+1], m] - front[sorted_indices[i-1], m]) / (front[sorted_indices[-1], m] - front[sorted_indices[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = nondominated_indices[np.argmax(crowding_distance)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Alternate between 3-opt and cross-dimensional edge insertion\n    if np.random.rand() < 0.5:\n        # 3-opt move\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Cross-dimensional edge insertion\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        # Check cross-dimensional feasibility\n        valid = True\n        for k in range(n):\n            next_k = (k + 1) % n\n            dist1 = distance_matrix_1[temp_solution[k], temp_solution[next_k]]\n            dist2 = distance_matrix_2[temp_solution[k], temp_solution[next_k]]\n            if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                valid = False\n                break\n\n        if valid and len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n\n    # Step 3: Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 5 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 3 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 4 algorithm and the corresponding code are:\nThe algorithm selects promising solutions from the archive based on a weighted combination of normalized objective values (70% first objective, 30% second objective), then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are duplicated or skipped. The selection prioritizes solutions with better trade-offs between objectives, and the local search diversifies the solution space through non-adjacent segment reversals and random edge insertions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.7 + normalized[:, 1] * 0.3  # Weighted sum for selection\n\n    # Select top 30% of solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion\n    if n > 4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_pos = np.random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution), \"Invalid neighbor: length mismatch\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor: duplicate nodes\"\n\n    return new_solution\n\nNo. 5 algorithm and the corresponding code are:\nThe heuristic selects a solution with high crowding distance from the archive to focus on diverse, potentially improvable regions, then applies a hybrid local search combining randomized 3-opt moves with segment reversals to escape local optima while ensuring feasibility. It prioritizes exploration by randomizing 3-opt configurations and balances exploitation with segment reversals, using objective-space diversity to guide selection. The algorithm emphasizes both objective-space diversity and novel neighborhood exploration to generate high-quality solutions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n\n        # Extract objectives\n        objectives = np.array([obj for _, obj in solutions])\n        n = len(objectives)\n\n        # Normalize objectives\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(2)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(2):\n            for j in range(1, n-1):\n                idx = sorted_indices[i][j]\n                prev_idx = sorted_indices[i][j-1]\n                next_idx = sorted_indices[i][j+1]\n                distances[idx] += normalized[next_idx, i] - normalized[prev_idx, i]\n\n        # Handle edge cases\n        for i in range(2):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 3-opt with segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Randomly choose one of 8 possible 3-opt configurations\n    config = np.random.randint(8)\n    if config == 0:\n        new_solution[i:k] = np.concatenate([segment1, segment2])\n    elif config == 1:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n    elif config == 2:\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    elif config == 3:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1])\n    elif config == 4:\n        new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    elif config == 5:\n        new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n    elif config == 6:\n        new_solution[i:k] = np.concatenate([segment2, segment1[::-1]])\n    else:\n        new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply segment reversal with probability 0.5\n    if np.random.rand() < 0.5:\n        rev_start = np.random.randint(n)\n        rev_end = np.random.randint(rev_start + 1, n + 1)\n        new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n\n\nAnalyze the logic of all the given code snippets carefully. Then identify the two code snippets whose logic is most different from each other\nand create a new algorithm that totally different in logic and form from both of them.\n1. First, describe your new algorithm and main steps in one long, detail sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nCheck syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 90,
        "algorithm": "The algorithm selects a promising solution from the archive by balancing trade-off scores (60% weight) and geometric diversity (40% weight), then applies a hybrid local search combining geometric-aware edge swaps (targeting edges with large objective cost differences) and objective-balanced segment reversals (optimizing segments with balanced contributions). It ensures feasibility by reverting to the original solution if any operation violates constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with good geometric diversity and objective trade-off\n    def geometric_diversity(solution, instance):\n        coords = instance[solution]\n        centroid1 = np.mean(coords[:, :2], axis=0)\n        centroid2 = np.mean(coords[:, 2:], axis=0)\n        diversity = np.linalg.norm(centroid1 - centroid2)\n        return diversity\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    tradeoff_scores = np.abs(normalized[:, 0] - normalized[:, 1])  # Prefer solutions with balanced trade-offs\n\n    diversity_scores = np.array([geometric_diversity(sol, instance) for sol, _ in archive])\n    combined_scores = tradeoff_scores * 0.6 + diversity_scores * 0.4  # Combine trade-off and diversity\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Geometric-aware edge swapping + Objective-balanced segment reversal\n    if n > 3:\n        # Step 1: Geometric-aware edge swapping\n        coords = instance[new_solution]\n        for _ in range(min(3, n//2)):\n            # Find edges with large difference in objective contributions\n            edge_costs1 = np.array([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n            edge_costs2 = np.array([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n            cost_diff = np.abs(edge_costs1 - edge_costs2)\n            candidate_edges = np.argsort(cost_diff)[-min(5, n//2):]\n\n            if len(candidate_edges) > 1:\n                i, j = np.random.choice(candidate_edges, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n                # Swap edges while maintaining tour validity\n                if not (i == 0 and j == n-1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Objective-balanced segment reversal\n        if np.random.rand() < 0.7:  # Higher probability to apply this operation\n            # Find segments with balanced objective contributions\n            segment_length = max(2, n//5)\n            possible_starts = range(n - segment_length + 1)\n            segment_scores = []\n\n            for start in possible_starts:\n                end = start + segment_length\n                segment_nodes = new_solution[start:end]\n                segment_cost1 = sum(distance_matrix_1[segment_nodes[i], segment_nodes[(i+1)%len(segment_nodes)]] for i in range(len(segment_nodes)))\n                segment_cost2 = sum(distance_matrix_2[segment_nodes[i], segment_nodes[(i+1)%len(segment_nodes)]] for i in range(len(segment_nodes)))\n                score = 1 - abs(segment_cost1 - segment_cost2) / (segment_cost1 + segment_cost2 + 1e-10)\n                segment_scores.append(score)\n\n            if segment_scores:\n                best_segment = np.argmax(segment_scores)\n                start = best_segment\n                end = start + segment_length\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7909073849463224,
            0.6218918561935425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with good geometric diversity and objective trade-off\n    def geometric_diversity(solution, instance):\n        coords = instance[solution]\n        centroid1 = np.mean(coords[:, :2], axis=0)\n        centroid2 = np.mean(coords[:, 2:], axis=0)\n        diversity = np.linalg.norm(centroid1 - centroid2)\n        return diversity\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    tradeoff_scores = np.abs(normalized[:, 0] - normalized[:, 1])  # Prefer solutions with balanced trade-offs\n\n    diversity_scores = np.array([geometric_diversity(sol, instance) for sol, _ in archive])\n    combined_scores = tradeoff_scores * 0.6 + diversity_scores * 0.4  # Combine trade-off and diversity\n\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Geometric-aware edge swapping + Objective-balanced segment reversal\n    if n > 3:\n        # Step 1: Geometric-aware edge swapping\n        coords = instance[new_solution]\n        for _ in range(min(3, n//2)):\n            # Find edges with large difference in objective contributions\n            edge_costs1 = np.array([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n            edge_costs2 = np.array([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n            cost_diff = np.abs(edge_costs1 - edge_costs2)\n            candidate_edges = np.argsort(cost_diff)[-min(5, n//2):]\n\n            if len(candidate_edges) > 1:\n                i, j = np.random.choice(candidate_edges, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n                # Swap edges while maintaining tour validity\n                if not (i == 0 and j == n-1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Objective-balanced segment reversal\n        if np.random.rand() < 0.7:  # Higher probability to apply this operation\n            # Find segments with balanced objective contributions\n            segment_length = max(2, n//5)\n            possible_starts = range(n - segment_length + 1)\n            segment_scores = []\n\n            for start in possible_starts:\n                end = start + segment_length\n                segment_nodes = new_solution[start:end]\n                segment_cost1 = sum(distance_matrix_1[segment_nodes[i], segment_nodes[(i+1)%len(segment_nodes)]] for i in range(len(segment_nodes)))\n                segment_cost2 = sum(distance_matrix_2[segment_nodes[i], segment_nodes[(i+1)%len(segment_nodes)]] for i in range(len(segment_nodes)))\n                score = 1 - abs(segment_cost1 - segment_cost2) / (segment_cost1 + segment_cost2 + 1e-10)\n                segment_scores.append(score)\n\n            if segment_scores:\n                best_segment = np.argmax(segment_scores)\n                start = best_segment\n                end = start + segment_length\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive using a hybrid criterion combining objective values and diversity, then applies a segment-based local search with relaxed bi-objective edge-swaps to generate a neighbor solution while ensuring feasibility through validation. It prioritizes solutions with better overall performance and diversity, decomposes the tour into overlapping segments, and optimizes each segment by accepting swaps that improve at least one objective, finally reconstructing and validating the solution.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.std([sum(obj) for _, obj in archive])\n    weights = objectives + diversity * 0.5\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Decompose into overlapping segments\n    segment_size = max(2, n // 3)\n    segments = []\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Step 2: Optimize each segment with relaxed bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Relaxed improvement: accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 91,
        "algorithm": "The algorithm selects nondominated solutions with high crowding distance from the archive to prioritize diversity, then applies an alternating 3-opt and edge contraction operator on random segments to explore the solution space while ensuring feasibility through node uniqueness checks. The method balances exploitation and exploration by dynamically switching between local search strategies and reconstructing the tour with structural validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n    nondominated = [i for i in range(len(archive)) if not is_dominated[i]]\n    if not nondominated:\n        selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    else:\n        crowding_distances = []\n        for i in nondominated:\n            neighbors = [j for j in nondominated if j != i]\n            if not neighbors:\n                crowding_distances.append(0)\n                continue\n            distances = [np.linalg.norm(objectives[i] - objectives[j]) for j in neighbors]\n            crowding_distances.append(np.mean(distances))\n        selected_idx = nondominated[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-dimensional segment reversal\n    segment_size = max(2, n // 4)\n    for _ in range(2):  # Alternate between 3-opt and edge contraction\n        i = np.random.randint(0, n - segment_size)\n        segment = new_solution[i:i+segment_size]\n\n        if np.random.rand() < 0.5:  # 3-opt\n            a, b, c = np.random.choice(len(segment), size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n            new_segment = np.concatenate([segment[:a], segment[b:c+1][::-1], segment[a:b], segment[c+1:]])\n            if len(np.unique(new_segment)) == len(segment):\n                new_solution[i:i+segment_size] = new_segment\n        else:  # Edge contraction\n            a, b = np.random.choice(len(segment), size=2, replace=False)\n            a, b = min(a, b), max(a, b)\n            new_segment = np.concatenate([segment[:a], segment[b:], segment[a:b]])\n            if len(np.unique(new_segment)) == len(segment):\n                new_solution[i:i+segment_size] = new_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.830331397054826,
            1.724216878414154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n    nondominated = [i for i in range(len(archive)) if not is_dominated[i]]\n    if not nondominated:\n        selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    else:\n        crowding_distances = []\n        for i in nondominated:\n            neighbors = [j for j in nondominated if j != i]\n            if not neighbors:\n                crowding_distances.append(0)\n                continue\n            distances = [np.linalg.norm(objectives[i] - objectives[j]) for j in neighbors]\n            crowding_distances.append(np.mean(distances))\n        selected_idx = nondominated[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-dimensional segment reversal\n    segment_size = max(2, n // 4)\n    for _ in range(2):  # Alternate between 3-opt and edge contraction\n        i = np.random.randint(0, n - segment_size)\n        segment = new_solution[i:i+segment_size]\n\n        if np.random.rand() < 0.5:  # 3-opt\n            a, b, c = np.random.choice(len(segment), size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n            new_segment = np.concatenate([segment[:a], segment[b:c+1][::-1], segment[a:b], segment[c+1:]])\n            if len(np.unique(new_segment)) == len(segment):\n                new_solution[i:i+segment_size] = new_segment\n        else:  # Edge contraction\n            a, b = np.random.choice(len(segment), size=2, replace=False)\n            a, b = min(a, b), max(a, b)\n            new_segment = np.concatenate([segment[:a], segment[b:], segment[a:b]])\n            if len(np.unique(new_segment)) == len(segment):\n                new_solution[i:i+segment_size] = new_segment\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a promising solution from the archive using a hybrid criterion combining objective values and diversity, then applies a segment-based local search with relaxed bi-objective edge-swaps to generate a neighbor solution while ensuring feasibility through validation. It prioritizes solutions with better overall performance and diversity, decomposes the tour into overlapping segments, and optimizes each segment by accepting swaps that improve at least one objective, finally reconstructing and validating the solution.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.std([sum(obj) for _, obj in archive])\n    weights = objectives + diversity * 0.5\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Decompose into overlapping segments\n    segment_size = max(2, n // 3)\n    segments = []\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Step 2: Optimize each segment with relaxed bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Relaxed improvement: accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 92,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n    pareto_indices = np.where(~is_dominated)[0]\n\n    if len(pareto_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from Pareto frontier with higher crowding distance\n        crowding = np.zeros(len(pareto_indices))\n        sorted_indices = np.argsort(objectives[pareto_indices, 0])\n        crowding[sorted_indices[1:-1]] += objectives[pareto_indices[sorted_indices[2:]], 0] - objectives[pareto_indices[sorted_indices[:-2]], 0]\n        sorted_indices = np.argsort(objectives[pareto_indices, 1])\n        crowding[sorted_indices[1:-1]] += objectives[pareto_indices[sorted_indices[2:]], 1] - objectives[pareto_indices[sorted_indices[:-2]], 1]\n        selected_idx = pareto_indices[np.argmax(crowding)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Apply adaptive cross-dimensional swap\n    # First, perform a 3-opt move\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Then, perform cross-dimensional edge insertion\n    if n >= 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if insertion improves at least one objective\n        current_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        current_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7884082479851906,
            0.4017595052719116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions near the Pareto frontier\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n    pareto_indices = np.where(~is_dominated)[0]\n\n    if len(pareto_indices) == 0:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from Pareto frontier with higher crowding distance\n        crowding = np.zeros(len(pareto_indices))\n        sorted_indices = np.argsort(objectives[pareto_indices, 0])\n        crowding[sorted_indices[1:-1]] += objectives[pareto_indices[sorted_indices[2:]], 0] - objectives[pareto_indices[sorted_indices[:-2]], 0]\n        sorted_indices = np.argsort(objectives[pareto_indices, 1])\n        crowding[sorted_indices[1:-1]] += objectives[pareto_indices[sorted_indices[2:]], 1] - objectives[pareto_indices[sorted_indices[:-2]], 1]\n        selected_idx = pareto_indices[np.argmax(crowding)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Apply adaptive cross-dimensional swap\n    # First, perform a 3-opt move\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Then, perform cross-dimensional edge insertion\n    if n >= 4:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if insertion improves at least one objective\n        current_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        current_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive using a hybrid criterion combining objective values and diversity, then applies a segment-based local search with relaxed bi-objective edge-swaps to generate a neighbor solution while ensuring feasibility through validation. It prioritizes solutions with better overall performance and diversity, decomposes the tour into overlapping segments, and optimizes each segment by accepting swaps that improve at least one objective, finally reconstructing and validating the solution.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.std([sum(obj) for _, obj in archive])\n    weights = objectives + diversity * 0.5\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Decompose into overlapping segments\n    segment_size = max(2, n // 3)\n    segments = []\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Step 2: Optimize each segment with relaxed bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Relaxed improvement: accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 93,
        "algorithm": "The algorithm selects a solution from the archive using a weighted combination of objective values and diversity, then applies a segment-based local search that dynamically adjusts weights between objectives to accept edge swaps that improve at least one objective while ensuring feasibility. It processes overlapping segments of the tour, randomly swapping edges within segments if the weighted cost improvement is positive, and validates the solution to maintain tour validity. The dynamic weight adjustment prioritizes objectives based on their relative performance in the archive, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    diversity = np.std(objectives)\n    weights = objectives + diversity * 0.3\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic weight adjustment based on current objectives\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    weight1 = obj2_avg / (obj1_avg + obj2_avg)\n    weight2 = obj1_avg / (obj1_avg + obj2_avg)\n\n    # Segment-based local search with dynamic weights\n    segment_size = max(3, n // 4)\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 3:\n            continue\n\n        # Randomly select two edges to swap\n        a, b = np.random.choice(len(segment) - 1, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[segment[a-1], segment[a]] + distance_matrix_1[segment[b-1], segment[b]]\n        current_cost2 = distance_matrix_2[segment[a-1], segment[a]] + distance_matrix_2[segment[b-1], segment[b]]\n        new_cost1 = distance_matrix_1[segment[a-1], segment[b]] + distance_matrix_1[segment[b-1], segment[a]]\n        new_cost2 = distance_matrix_2[segment[a-1], segment[b]] + distance_matrix_2[segment[b-1], segment[a]]\n\n        # Dynamic weight-based improvement criterion\n        if (weight1 * (new_cost1 - current_cost1) + weight2 * (new_cost2 - current_cost2)) < 0:\n            segment[a], segment[b] = segment[b], segment[a]\n            new_solution[i:i+segment_size] = segment\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7391783558050982,
            0.3245890140533447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    diversity = np.std(objectives)\n    weights = objectives + diversity * 0.3\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic weight adjustment based on current objectives\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    weight1 = obj2_avg / (obj1_avg + obj2_avg)\n    weight2 = obj1_avg / (obj1_avg + obj2_avg)\n\n    # Segment-based local search with dynamic weights\n    segment_size = max(3, n // 4)\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 3:\n            continue\n\n        # Randomly select two edges to swap\n        a, b = np.random.choice(len(segment) - 1, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[segment[a-1], segment[a]] + distance_matrix_1[segment[b-1], segment[b]]\n        current_cost2 = distance_matrix_2[segment[a-1], segment[a]] + distance_matrix_2[segment[b-1], segment[b]]\n        new_cost1 = distance_matrix_1[segment[a-1], segment[b]] + distance_matrix_1[segment[b-1], segment[a]]\n        new_cost2 = distance_matrix_2[segment[a-1], segment[b]] + distance_matrix_2[segment[b-1], segment[a]]\n\n        # Dynamic weight-based improvement criterion\n        if (weight1 * (new_cost1 - current_cost1) + weight2 * (new_cost2 - current_cost2)) < 0:\n            segment[a], segment[b] = segment[b], segment[a]\n            new_solution[i:i+segment_size] = segment\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a promising solution from the archive using a hybrid criterion combining objective values and diversity, then applies a segment-based local search with relaxed bi-objective edge-swaps to generate a neighbor solution while ensuring feasibility through validation. It prioritizes solutions with better overall performance and diversity, decomposes the tour into overlapping segments, and optimizes each segment by accepting swaps that improve at least one objective, finally reconstructing and validating the solution.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.std([sum(obj) for _, obj in archive])\n    weights = objectives + diversity * 0.5\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Decompose into overlapping segments\n    segment_size = max(2, n // 3)\n    segments = []\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Step 2: Optimize each segment with relaxed bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Relaxed improvement: accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 94,
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted combination of objective values and solution length, then applies a segment-based local search with adaptive sizes and an aggressive bi-objective improvement criterion to generate a neighbor solution, ensuring feasibility through careful reconstruction and validation. It prioritizes solutions with better combined objectives and shorter lengths, uses overlapping segments for local optimization, and accepts moves that improve both objectives or significantly improve at least one, with fallback to the original solution if reconstruction fails.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection: prioritize solutions with better combined objectives and shorter length\n    objectives = np.array([(obj[0] + obj[1]) / (1 + len(sol)) for sol, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment sizes based on solution length\n    segment_size = max(2, n // 4)\n    overlap = segment_size // 2\n    segments = []\n    for i in range(0, n - segment_size + 1, overlap):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Optimize each segment with aggressive bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        for _ in range(2):  # Multiple attempts per segment\n            i, j = np.random.choice(len(seg), size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n            current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n            new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n            new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n            # Aggressive improvement: accept if both objectives improve or at least one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n                seg[i], seg[j] = seg[j], seg[i]\n\n    # Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8598498592854101,
            0.3878330588340759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection: prioritize solutions with better combined objectives and shorter length\n    objectives = np.array([(obj[0] + obj[1]) / (1 + len(sol)) for sol, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment sizes based on solution length\n    segment_size = max(2, n // 4)\n    overlap = segment_size // 2\n    segments = []\n    for i in range(0, n - segment_size + 1, overlap):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Optimize each segment with aggressive bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        for _ in range(2):  # Multiple attempts per segment\n            i, j = np.random.choice(len(seg), size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n            current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n            new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n            new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n            # Aggressive improvement: accept if both objectives improve or at least one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n                seg[i], seg[j] = seg[j], seg[i]\n\n    # Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 3 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using a hybrid criterion combining objective values and diversity, then applies a segment-based local search with relaxed bi-objective edge-swaps to generate a neighbor solution while ensuring feasibility through validation. It prioritizes solutions with better overall performance and diversity, decomposes the tour into overlapping segments, and optimizes each segment by accepting swaps that improve at least one objective, finally reconstructing and validating the solution.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective values and diversity\n    objectives = np.array([sum(obj) for _, obj in archive])\n    diversity = np.std([sum(obj) for _, obj in archive])\n    weights = objectives + diversity * 0.5\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Decompose into overlapping segments\n    segment_size = max(2, n // 3)\n    segments = []\n    for i in range(0, n - segment_size + 1, segment_size // 2):\n        segments.append(base_solution[i:i+segment_size])\n\n    # Step 2: Optimize each segment with relaxed bi-objective criterion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Relaxed improvement: accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct and validate\n    new_solution = np.concatenate(segments)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a high-potential solution from the archive (prioritizing those with higher combined objective costs) and decomposes it into segments, optimizing each segment independently via a multi-objective edge-swap that only accepts swaps improving both objectives. It reconstructs the solution while ensuring feasibility, reverting to the original if invalid. The key innovation is segment-wise optimization with a strict bi-objective improvement criterion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Decompose the solution into non-overlapping segments\n    segment_size = max(2, n // 4)\n    segments = [base_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Step 2: Optimize each segment independently using a multi-objective edge-swap\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n        # Randomly select two edges in the segment to swap\n        i, j = np.random.choice(len(seg), size=2, replace=False)\n        # Ensure the swap is valid (avoid revisiting nodes)\n        if i > j:\n            i, j = j, i\n        # Calculate cost difference in both objectives\n        current_cost1 = distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]]\n        current_cost2 = distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]]\n        new_cost1 = distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[i]]\n        new_cost2 = distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[i]]\n        # Accept swap if it improves both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            seg[i], seg[j] = seg[j], seg[i]\n\n    # Step 3: Reconstruct the solution from optimized segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe heuristic selects a solution from the archive prioritizing those with higher combined objective values (sum of costs), then applies a hybrid local search combining edge insertion and node relocation to explore diverse neighborhoods while ensuring feasibility. It randomly selects nodes to swap and relocate, validating the new solution to avoid duplicates, and returns the improved neighbor. The algorithm balances exploration (random selection) and exploitation (local search) while maintaining feasibility.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or Pareto dominance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small instances\n\n    # Step 1: Edge insertion (insert a node between two existing edges)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Ensure the insertion is valid (avoid revisiting nodes)\n    temp = new_solution.copy()\n    temp[i], temp[j] = temp[j], temp[i]\n\n    # Step 2: Node relocation (move a node to a new position)\n    k = np.random.randint(0, n)\n    while k == i or k == j:\n        k = np.random.randint(0, n)\n\n    temp[i], temp[k] = temp[k], temp[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 95,
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those near the Pareto frontier with high crowding distance, then applies a hybrid local search combining segment-wise 3-opt (for exploitation) and cross-dimensional edge insertion (for exploration), adaptively balancing exploration and exploitation to generate high-quality, feasible neighbors. The segment-wise 3-opt optimizes overlapping segments by swapping three nodes if it improves at least one objective, while cross-dimensional edge insertion randomly relocates a node between edges in either space, ensuring feasibility through validation checks. The process repeats for a fixed number of iterations to refine solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions near the Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    else:\n        # Prioritize high crowding distance within Pareto front\n        front_objectives = objectives[pareto_front]\n        crowding_distances = np.zeros(len(front_objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = crowding_distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(sorted_idx)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m])\n        selected_idx = pareto_front[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search\n    for _ in range(10):  # Fixed iterations for balance\n        if np.random.rand() < 0.7:  # 70% chance for 3-opt (exploitation)\n            # Segment-wise 3-opt\n            segment_size = max(3, n // 4)\n            segments = []\n            for i in range(0, n - segment_size + 1, segment_size // 2):\n                segments.append(base_solution[i:i+segment_size])\n\n            for seg in segments:\n                if len(seg) < 3:\n                    continue\n                i, j, k = np.random.choice(len(seg), size=3, replace=False)\n                if i > j:\n                    i, j = j, i\n                if j > k:\n                    j, k = k, j\n                if i > j:\n                    i, j = j, i\n\n                # Calculate current and new costs\n                current_cost1 = (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]] + distance_matrix_1[seg[k-1], seg[k]])\n                current_cost2 = (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]] + distance_matrix_2[seg[k-1], seg[k]])\n                new_cost1 = (distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[k]] + distance_matrix_1[seg[k-1], seg[i]])\n                new_cost2 = (distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[k]] + distance_matrix_2[seg[k-1], seg[i]])\n\n                if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                    seg[i], seg[j], seg[k] = seg[j], seg[k], seg[i]\n\n            new_solution = np.concatenate(segments)\n        else:  # 30% chance for cross-dimensional edge insertion (exploration)\n            # Randomly select a node and insert between two edges in either space\n            node_idx = np.random.randint(0, n)\n            space = np.random.choice([0, 1])  # 0 for space 1, 1 for space 2\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            temp[node_idx] = new_solution[node_idx]\n\n            # Validate feasibility\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n        # Check feasibility in both objective spaces\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8597930536392081,
            1.3020435571670532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions near the Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    else:\n        # Prioritize high crowding distance within Pareto front\n        front_objectives = objectives[pareto_front]\n        crowding_distances = np.zeros(len(front_objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = crowding_distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(sorted_idx)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m])\n        selected_idx = pareto_front[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search\n    for _ in range(10):  # Fixed iterations for balance\n        if np.random.rand() < 0.7:  # 70% chance for 3-opt (exploitation)\n            # Segment-wise 3-opt\n            segment_size = max(3, n // 4)\n            segments = []\n            for i in range(0, n - segment_size + 1, segment_size // 2):\n                segments.append(base_solution[i:i+segment_size])\n\n            for seg in segments:\n                if len(seg) < 3:\n                    continue\n                i, j, k = np.random.choice(len(seg), size=3, replace=False)\n                if i > j:\n                    i, j = j, i\n                if j > k:\n                    j, k = k, j\n                if i > j:\n                    i, j = j, i\n\n                # Calculate current and new costs\n                current_cost1 = (distance_matrix_1[seg[i-1], seg[i]] + distance_matrix_1[seg[j-1], seg[j]] + distance_matrix_1[seg[k-1], seg[k]])\n                current_cost2 = (distance_matrix_2[seg[i-1], seg[i]] + distance_matrix_2[seg[j-1], seg[j]] + distance_matrix_2[seg[k-1], seg[k]])\n                new_cost1 = (distance_matrix_1[seg[i-1], seg[j]] + distance_matrix_1[seg[j-1], seg[k]] + distance_matrix_1[seg[k-1], seg[i]])\n                new_cost2 = (distance_matrix_2[seg[i-1], seg[j]] + distance_matrix_2[seg[j-1], seg[k]] + distance_matrix_2[seg[k-1], seg[i]])\n\n                if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                    seg[i], seg[j], seg[k] = seg[j], seg[k], seg[i]\n\n            new_solution = np.concatenate(segments)\n        else:  # 30% chance for cross-dimensional edge insertion (exploration)\n            # Randomly select a node and insert between two edges in either space\n            node_idx = np.random.randint(0, n)\n            space = np.random.choice([0, 1])  # 0 for space 1, 1 for space 2\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n            temp[node_idx] = new_solution[node_idx]\n\n            # Validate feasibility\n            if len(np.unique(temp)) == n:\n                new_solution = temp\n\n        # Check feasibility in both objective spaces\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 7 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by combining normalized objectives and diversity scores, then applies a hybrid local search (60% edge-swap, 40% constrained segment insertion) to generate a neighbor solution while ensuring feasibility through node uniqueness validation. It prioritizes multi-objective improvement in edge-swaps and allows occasional diversification in segment insertions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    scores = np.sum(normalized, axis=1) + 0.5 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: 60% edge-swap, 40% constrained segment insertion\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Constrained segment insertion\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b = sorted([a, b])\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 96,
        "algorithm": "The algorithm selects solutions from the Pareto frontier (top 20% of non-dominated solutions) and applies a hybrid local search combining adaptive cross-dimensional segment reversals and edge contractions, prioritizing feasibility validation and balanced improvements across objectives. It uses cross-dimensional distance checks to ensure valid swaps and structural validation to maintain tour feasibility. The method balances exploration (random selection) and exploitation (focus on promising regions) while ensuring solution quality through adaptive neighborhood structures.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select from Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(nondominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: adaptive cross-dimensional swap\n    if np.random.rand() < 0.7:\n        # Cross-dimensional segment reversal\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        temp_sol = new_solution.copy()\n        temp_sol[a:b] = temp_sol[a:b][::-1]\n\n        # Check cross-dimensional feasibility\n        valid = True\n        for i in range(a, b):\n            node1 = temp_sol[i]\n            node2 = temp_sol[(i+1)%n]\n            if distance_matrix_1[node1, node2] > 2 * np.median(distance_matrix_1) or distance_matrix_2[node1, node2] > 2 * np.median(distance_matrix_2):\n                valid = False\n                break\n\n        if valid and len(np.unique(temp_sol)) == n:\n            new_solution = temp_sol\n    else:\n        # Edge contraction with cross-dimensional balance\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8435362335111692,
            9.27761310338974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select from Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(archive)):\n        is_dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(nondominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: adaptive cross-dimensional swap\n    if np.random.rand() < 0.7:\n        # Cross-dimensional segment reversal\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        temp_sol = new_solution.copy()\n        temp_sol[a:b] = temp_sol[a:b][::-1]\n\n        # Check cross-dimensional feasibility\n        valid = True\n        for i in range(a, b):\n            node1 = temp_sol[i]\n            node2 = temp_sol[(i+1)%n]\n            if distance_matrix_1[node1, node2] > 2 * np.median(distance_matrix_1) or distance_matrix_2[node1, node2] > 2 * np.median(distance_matrix_2):\n                valid = False\n                break\n\n        if valid and len(np.unique(temp_sol)) == n:\n            new_solution = temp_sol\n    else:\n        # Edge contraction with cross-dimensional balance\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 97,
        "algorithm": "The algorithm selects a solution from the Pareto frontier with high crowding distance to prioritize diversity, then applies a novel cross-dimensional 3-opt operator that alternates between reversing segments in one objective space and contracting edges in the other while ensuring feasibility by validating node uniqueness and edge existence across both spaces. The method balances exploitation and exploration by focusing on solutions with balanced objective trade-offs, using intelligent random selection to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the Pareto frontier with high crowding distance\n    solutions = [s[0] for s in archive]\n    objectives = np.array([s[1] for s in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n    pareto_indices = np.where(~is_dominated)[0]\n    if len(pareto_indices) == 0:\n        pareto_indices = np.arange(len(archive))\n\n    crowding_distances = np.zeros(len(pareto_indices))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[pareto_indices, m])\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(pareto_indices)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[pareto_indices[sorted_indices[i+1]], m] - objectives[pareto_indices[sorted_indices[i-1]], m])\n\n    selected_idx = pareto_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Cross-dimensional 3-opt\n        a, b, c = np.random.choice(n, 3, replace=False)\n        if a > b:\n            a, b = b, a\n        if b > c:\n            b, c = c, b\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment in one space and contract edges in the other\n        temp = new_solution.copy()\n        temp[a:b+1] = temp[a:b+1][::-1]  # Reverse segment in space 1\n        temp[b:c+1] = np.roll(temp[b:c+1], 1)  # Contract edges in space 2\n\n        # Validate feasibility\n        if len(np.unique(temp)) == n:\n            # Check edge existence in both spaces\n            valid = True\n            for i in range(n-1):\n                u, v = temp[i], temp[(i+1) % n]\n                if distance_matrix_1[u, v] == np.inf or distance_matrix_2[u, v] == np.inf:\n                    valid = False\n                    break\n            if valid:\n                new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8036725842168275,
            0.40253108739852905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the Pareto frontier with high crowding distance\n    solutions = [s[0] for s in archive]\n    objectives = np.array([s[1] for s in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n    pareto_indices = np.where(~is_dominated)[0]\n    if len(pareto_indices) == 0:\n        pareto_indices = np.arange(len(archive))\n\n    crowding_distances = np.zeros(len(pareto_indices))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[pareto_indices, m])\n        crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(pareto_indices)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[pareto_indices[sorted_indices[i+1]], m] - objectives[pareto_indices[sorted_indices[i-1]], m])\n\n    selected_idx = pareto_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Cross-dimensional 3-opt\n        a, b, c = np.random.choice(n, 3, replace=False)\n        if a > b:\n            a, b = b, a\n        if b > c:\n            b, c = c, b\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment in one space and contract edges in the other\n        temp = new_solution.copy()\n        temp[a:b+1] = temp[a:b+1][::-1]  # Reverse segment in space 1\n        temp[b:c+1] = np.roll(temp[b:c+1], 1)  # Contract edges in space 2\n\n        # Validate feasibility\n        if len(np.unique(temp)) == n:\n            # Check edge existence in both spaces\n            valid = True\n            for i in range(n-1):\n                u, v = temp[i], temp[(i+1) % n]\n                if distance_matrix_1[u, v] == np.inf or distance_matrix_2[u, v] == np.inf:\n                    valid = False\n                    break\n            if valid:\n                new_solution = temp\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 98,
        "algorithm": "The algorithm combines adaptive selection of Pareto-frontier solutions with a dynamic local search operator that alternates between segment reversal and edge contraction, prioritizing solutions with high crowding distance while ensuring feasibility through cross-dimensional structural checks. It balances exploration and exploitation by favoring segment reversal (70%) and validating moves by verifying node uniqueness and edge existence in both objective spaces. The selection process emphasizes solutions near the Pareto frontier, while the local search dynamically adapts between structural modifications to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution near the Pareto frontier with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Compute crowding distance\n        sorted_idx = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_idx]\n        crowding = np.zeros(len(objectives_sorted))\n        crowding[1:-1] = (objectives_sorted[2:, 0] - objectives_sorted[:-2, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        # Select top 20% with highest crowding distance\n        selected_idx = sorted_idx[np.argsort(crowding)[-max(1, len(crowding) // 5):]]\n        selected_idx = np.random.choice(selected_idx)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 3:\n        # Dynamic segment contraction operator\n        if np.random.rand() < 0.7:  # 70% chance for segment reversal\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:  # 30% chance for edge contraction\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Contract edges by removing one node and inserting it elsewhere\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Cross-dimensional feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        # Check edge existence in both objective spaces\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            if distance_matrix_1[u, v] == np.inf or distance_matrix_2[u, v] == np.inf:\n                new_solution = base_solution.copy()\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8269255496386269,
            0.23486608266830444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution near the Pareto frontier with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Compute crowding distance\n        sorted_idx = np.argsort(objectives[:, 0])\n        objectives_sorted = objectives[sorted_idx]\n        crowding = np.zeros(len(objectives_sorted))\n        crowding[1:-1] = (objectives_sorted[2:, 0] - objectives_sorted[:-2, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0])\n        # Select top 20% with highest crowding distance\n        selected_idx = sorted_idx[np.argsort(crowding)[-max(1, len(crowding) // 5):]]\n        selected_idx = np.random.choice(selected_idx)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 3:\n        # Dynamic segment contraction operator\n        if np.random.rand() < 0.7:  # 70% chance for segment reversal\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:  # 30% chance for edge contraction\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Contract edges by removing one node and inserting it elsewhere\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Cross-dimensional feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        # Check edge existence in both objective spaces\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            if distance_matrix_1[u, v] == np.inf or distance_matrix_2[u, v] == np.inf:\n                new_solution = base_solution.copy()\n                break\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 99,
        "algorithm": "The algorithm selects a promising solution from the archive by balancing objective values and diversity, then applies a novel \"cross-space segment exchange\" operator that swaps segments between two randomly chosen positions while ensuring feasibility through dynamic checks and rollback mechanisms. The selection prioritizes solutions with good objective values (70%) and diversity (30%), while the segment exchange operation uses variable-length segments (2-4 nodes) to explore the solution space creatively. The algorithm dynamically reverts to simpler operations (like swapping two nodes) if the segment exchange leads to infeasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with good potential: balance between objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = np.linalg.norm(norm_obj[:, None] - norm_obj, axis=2).sum(axis=1)\n    combined_score = 0.7 * norm_obj.mean(axis=1) + 0.3 * diversity\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Cross-space segment exchange\n        segment_length = np.random.randint(2, min(5, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Extract segments from both spaces\n        seg1 = base_solution[start1:start1+segment_length]\n        seg2 = base_solution[start2:start2+segment_length]\n\n        # Swap segments\n        new_solution[start1:start1+segment_length] = seg2\n        new_solution[start2:start2+segment_length] = seg1\n\n        # Dynamic feasibility check\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original with probability 0.5\n            if np.random.rand() < 0.5:\n                new_solution = base_solution.copy()\n            else:\n                # Else perform a different operation\n                i, j = np.random.choice(n, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8678515022568727,
            0.6004924774169922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with good potential: balance between objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = np.linalg.norm(norm_obj[:, None] - norm_obj, axis=2).sum(axis=1)\n    combined_score = 0.7 * norm_obj.mean(axis=1) + 0.3 * diversity\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Cross-space segment exchange\n        segment_length = np.random.randint(2, min(5, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Extract segments from both spaces\n        seg1 = base_solution[start1:start1+segment_length]\n        seg2 = base_solution[start2:start2+segment_length]\n\n        # Swap segments\n        new_solution[start1:start1+segment_length] = seg2\n        new_solution[start2:start2+segment_length] = seg1\n\n        # Dynamic feasibility check\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original with probability 0.5\n            if np.random.rand() < 0.5:\n                new_solution = base_solution.copy()\n            else:\n                # Else perform a different operation\n                i, j = np.random.choice(n, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 100,
        "algorithm": "The algorithm selects a promising solution from the archive using tournament selection, then applies a hybrid local search combining cross-space edge swapping (randomly swapping edges between nodes in both objective spaces) and adaptive segment inversion (randomly reversing segments of the tour), ensuring feasibility by validating the generated tour. The selection prioritizes solutions with better combined objective values, while the local search balances exploration (randomness in edge swaps and segment lengths) with exploitation (adaptive segment lengths based on tour size).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection: pick 3 random solutions and select the one with best combined objective\n    tournament_size = min(3, len(archive))\n    candidates = np.random.choice(len(archive), tournament_size, replace=False)\n    selected_idx = min(candidates, key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Phase 1: Cross-space edge swapping\n        i, j = np.random.choice(n, 2, replace=False)\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n\n        # Swap edges in both spaces\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Phase 2: Adaptive segment inversion\n        segment_length = max(2, n // 4)\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.847383647638551,
            0.2052331566810608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection: pick 3 random solutions and select the one with best combined objective\n    tournament_size = min(3, len(archive))\n    candidates = np.random.choice(len(archive), tournament_size, replace=False)\n    selected_idx = min(candidates, key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Phase 1: Cross-space edge swapping\n        i, j = np.random.choice(n, 2, replace=False)\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n\n        # Swap edges in both spaces\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Phase 2: Adaptive segment inversion\n        segment_length = max(2, n // 4)\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from the archive, applies a hybrid local search combining edge insertion and multi-segment reversal, and ensures feasibility by reverting to the original solution if invalid. It prioritizes exploration by randomly choosing segments and insertion points, balancing exploitation through the archive selection. The design emphasizes dynamic operator selection and feasibility checks to navigate the solution space effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: cross-space edge insertion and multi-segment reversal\n    if n >= 4:\n        # Phase 1: Cross-space edge insertion\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position in the other space\n        k = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, k, base_solution[i])\n\n        # Phase 2: Multi-segment reversal\n        segments = sorted(np.random.choice(n, size=min(4, n//2), replace=False))\n        for s in range(0, len(segments)-1, 2):\n            a, b = segments[s], segments[s+1]\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 101,
        "algorithm": "The algorithm selects a promising solution from the Pareto frontier (top 20% of non-dominated solutions) and applies a hybrid local search that alternates between a cross-dimensional 3-opt (reversing segments and combining edge contractions) and a cross-space edge insertion operator, ensuring feasibility by validating node uniqueness and prioritizing balanced objective trade-offs for improved exploration. The selection prioritizes solutions from the Pareto frontier, while the local search balances between segment reversal and edge insertion to escape local optima while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select from Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = np.random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Alternate between cross-dimensional 3-opt and edge insertion\n        if np.random.random() < 0.5:\n            # Cross-dimensional 3-opt\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n        else:\n            # Cross-space edge insertion\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            k = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, k, base_solution[i])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.938873042451682,
            0.6714102029800415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select from Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = np.random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Alternate between cross-dimensional 3-opt and edge insertion\n        if np.random.random() < 0.5:\n            # Cross-dimensional 3-opt\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n        else:\n            # Cross-space edge insertion\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            k = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, k, base_solution[i])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 7 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by combining normalized objectives and diversity scores, then applies a hybrid local search (60% edge-swap, 40% constrained segment insertion) to generate a neighbor solution while ensuring feasibility through node uniqueness validation. It prioritizes multi-objective improvement in edge-swaps and allows occasional diversification in segment insertions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    scores = np.sum(normalized, axis=1) + 0.5 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: 60% edge-swap, 40% constrained segment insertion\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Constrained segment insertion\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b = sorted([a, b])\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 102,
        "algorithm": "The algorithm selects high-potential solutions from the Pareto frontier using crowding distance, then applies a hybrid local search combining cross-dimensional segment reversal and edge contraction to generate neighbors while ensuring feasibility through node uniqueness validation and edge existence checks in both objective spaces. It prioritizes solutions with balanced objective improvements by alternating between segment reversal and edge contraction operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions near the Pareto frontier with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from top 20% in crowding distance\n        distances = []\n        for i in nondominated:\n            obj = objectives[i]\n            left = np.min(objectives[objectives[:, 0] < obj[0]], axis=0) if np.any(objectives[:, 0] < obj[0]) else obj\n            right = np.max(objectives[objectives[:, 0] > obj[0]], axis=0) if np.any(objectives[:, 0] > obj[0]) else obj\n            distance = np.abs(right[1] - left[1]) + np.abs(right[0] - left[0])\n            distances.append(distance)\n        selected_idx = nondominated[np.argmax(distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search (alternate between segment reversal and edge contraction)\n    if np.random.rand() < 0.5:\n        # Cross-dimensional segment reversal\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        temp_sol = new_solution.copy()\n        temp_sol[a:b] = temp_sol[a:b][::-1]\n\n        # Validate feasibility\n        if len(np.unique(temp_sol)) == n:\n            # Check edge existence in both spaces\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                if (distance_matrix_1[temp_sol[k], temp_sol[next_k]] == 0 or\n                    distance_matrix_2[temp_sol[k], temp_sol[next_k]] == 0):\n                    valid = False\n                    break\n            if valid:\n                new_solution = temp_sol\n    else:\n        # Edge contraction with cross-dimensional balance\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                # Check edge existence in both spaces\n                valid = True\n                for k in range(n):\n                    next_k = (k + 1) % n\n                    if (distance_matrix_1[temp_sol[k], temp_sol[next_k]] == 0 or\n                        distance_matrix_2[temp_sol[k], temp_sol[next_k]] == 0):\n                        valid = False\n                        break\n                if valid:\n                    new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            -0.7147031905436935,
            11.469539761543274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions near the Pareto frontier with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select from top 20% in crowding distance\n        distances = []\n        for i in nondominated:\n            obj = objectives[i]\n            left = np.min(objectives[objectives[:, 0] < obj[0]], axis=0) if np.any(objectives[:, 0] < obj[0]) else obj\n            right = np.max(objectives[objectives[:, 0] > obj[0]], axis=0) if np.any(objectives[:, 0] > obj[0]) else obj\n            distance = np.abs(right[1] - left[1]) + np.abs(right[0] - left[0])\n            distances.append(distance)\n        selected_idx = nondominated[np.argmax(distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Hybrid local search (alternate between segment reversal and edge contraction)\n    if np.random.rand() < 0.5:\n        # Cross-dimensional segment reversal\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        temp_sol = new_solution.copy()\n        temp_sol[a:b] = temp_sol[a:b][::-1]\n\n        # Validate feasibility\n        if len(np.unique(temp_sol)) == n:\n            # Check edge existence in both spaces\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                if (distance_matrix_1[temp_sol[k], temp_sol[next_k]] == 0 or\n                    distance_matrix_2[temp_sol[k], temp_sol[next_k]] == 0):\n                    valid = False\n                    break\n            if valid:\n                new_solution = temp_sol\n    else:\n        # Edge contraction with cross-dimensional balance\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                # Check edge existence in both spaces\n                valid = True\n                for k in range(n):\n                    next_k = (k + 1) % n\n                    if (distance_matrix_1[temp_sol[k], temp_sol[next_k]] == 0 or\n                        distance_matrix_2[temp_sol[k], temp_sol[next_k]] == 0):\n                        valid = False\n                        break\n                if valid:\n                    new_solution = temp_sol\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 103,
        "algorithm": "The algorithm prioritizes high-potential solutions near the Pareto frontier (top 20%) for selection, then applies a hybrid local search alternating between segment reversal (60% chance) and cross-dimensional edge contraction (40% chance) to generate neighbors, ensuring feasibility by validating node uniqueness. The method balances local and global improvements while maintaining structural diversity to avoid premature convergence.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n    if not nondominated:\n        nondominated = list(range(len(archive)))\n    selected_idx = np.random.choice(nondominated)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternate between segment reversal and cross-dimensional edge contraction\n    if np.random.random() < 0.6:\n        # Segment reversal with probabilistic constraints\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Cross-dimensional edge contraction\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(k - l) < 2:\n            l = np.random.randint(0, n)\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        # Contract edges by replacing the segment between k and l with a direct edge\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7920587049243303,
            1.752661645412445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20%)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append(i)\n    if not nondominated:\n        nondominated = list(range(len(archive)))\n    selected_idx = np.random.choice(nondominated)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternate between segment reversal and cross-dimensional edge contraction\n    if np.random.random() < 0.6:\n        # Segment reversal with probabilistic constraints\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Cross-dimensional edge contraction\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(k - l) < 2:\n            l = np.random.randint(0, n)\n        node_k = new_solution[k]\n        node_l = new_solution[l]\n        # Contract edges by replacing the segment between k and l with a direct edge\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[l:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 104,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20% in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front[i] = True\n    if not np.any(pareto_front):\n        pareto_front = np.ones(len(archive), dtype=bool)\n    selected_idx = np.random.choice(np.where(pareto_front)[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search combining cross-dimensional segment reversal and edge contraction\n    # Step 1: Cross-dimensional segment reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Edge contraction with probabilistic constraint\n    if np.random.random() < 0.4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            # Contract the segment between i and j\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Step 3: Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8496297229528904,
            1.2596967816352844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near the Pareto frontier (top 20% in objective space)\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front[i] = True\n    if not np.any(pareto_front):\n        pareto_front = np.ones(len(archive), dtype=bool)\n    selected_idx = np.random.choice(np.where(pareto_front)[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search combining cross-dimensional segment reversal and edge contraction\n    # Step 1: Cross-dimensional segment reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Edge contraction with probabilistic constraint\n    if np.random.random() < 0.4:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            # Contract the segment between i and j\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Step 3: Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 105,
        "algorithm": "The algorithm intelligently selects a solution from the archive by prioritizing those with lower individual objective values, then applies a hybrid local search combining partial cycle reversal and adaptive node relocation with dynamic probability constraints to generate a neighbor solution while ensuring feasibility through validation checks. The selection prioritizes solutions with better combined normalized objectives, and the local search adapts its operations based on the solution's quality, with higher probabilities for better solutions. The algorithm maintains feasibility by validating the solution after modifications.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower individual objectives\n    objectives = np.array([(obj[0], obj[1]) for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    combined_scores = norm_objectives[:, 0] + norm_objectives[:, 1]\n    probabilities = 1 / (combined_scores + 1e-6)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with dynamic probabilities\n    # Step 1: Partial cycle reversal with dynamic probability\n    reversal_prob = min(0.9, 0.5 + (1 - sum(archive[selected_idx][1]) / (sum(archive[0][1]) + 1e-6)) * 0.4)\n    if np.random.random() < reversal_prob:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Adaptive node relocation with dynamic probability\n    relocation_prob = min(0.7, 0.3 + (1 - archive[selected_idx][1][0] / (archive[0][1][0] + 1e-6)) * 0.4)\n    if np.random.random() < relocation_prob:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(l - k) < 2 or l == k:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9051543739923193,
            0.3583438992500305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower individual objectives\n    objectives = np.array([(obj[0], obj[1]) for _, obj in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    combined_scores = norm_objectives[:, 0] + norm_objectives[:, 1]\n    probabilities = 1 / (combined_scores + 1e-6)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with dynamic probabilities\n    # Step 1: Partial cycle reversal with dynamic probability\n    reversal_prob = min(0.9, 0.5 + (1 - sum(archive[selected_idx][1]) / (sum(archive[0][1]) + 1e-6)) * 0.4)\n    if np.random.random() < reversal_prob:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Adaptive node relocation with dynamic probability\n    relocation_prob = min(0.7, 0.3 + (1 - archive[selected_idx][1][0] / (archive[0][1][0] + 1e-6)) * 0.4)\n    if np.random.random() < relocation_prob:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(l - k) < 2 or l == k:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 106,
        "algorithm": "The algorithm selects a solution from the archive using a weighted random selection based on combined objective values and solution distances, then applies a hybrid local search combining edge swaps and node reinsertions with adaptive probabilities. The selection prioritizes solutions with lower combined objective and distance metrics, while the local search dynamically adjusts operator probabilities based on solution quality and distance, ensuring feasibility through validation checks.\n\n(Note: The description is concise and directly references the key design ideas from the given code, highlighting the weighted selection and adaptive local search approach.)",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and distance metrics\n    objectives = np.array([sum(obj) for _, obj in archive])\n    distances = np.array([np.sum(distance_matrix_1[archive[i][0][:-1], archive[i][0][1:]]) + np.sum(distance_matrix_2[archive[i][0][:-1], archive[i][0][1:]]) for i in range(len(archive))])\n    combined = objectives + distances * 0.3\n    probabilities = 1 / (combined + 1e-6)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive probabilities\n    # Step 1: Edge swap with probability based on solution quality\n    if np.random.random() < 0.6 + min(0.3, objectives[selected_idx] / (np.max(objectives) + 1e-6)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node reinsertion with probability based on distance\n    if np.random.random() < 0.4 + min(0.4, distances[selected_idx] / (np.max(distances) + 1e-6)):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8777641956903373,
            0.4369714856147766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined objective and distance metrics\n    objectives = np.array([sum(obj) for _, obj in archive])\n    distances = np.array([np.sum(distance_matrix_1[archive[i][0][:-1], archive[i][0][1:]]) + np.sum(distance_matrix_2[archive[i][0][:-1], archive[i][0][1:]]) for i in range(len(archive))])\n    combined = objectives + distances * 0.3\n    probabilities = 1 / (combined + 1e-6)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with adaptive probabilities\n    # Step 1: Edge swap with probability based on solution quality\n    if np.random.random() < 0.6 + min(0.3, objectives[selected_idx] / (np.max(objectives) + 1e-6)):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node reinsertion with probability based on distance\n    if np.random.random() < 0.4 + min(0.4, distances[selected_idx] / (np.max(distances) + 1e-6)):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with probabilistic constraints to generate a neighbor solution while ensuring feasibility through validation checks.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with lower combined objectives\n    objectives = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with probabilistic constraints\n    # Step 1: Segment reversal with probability\n    if np.random.random() < 0.7:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion with probability\n    if np.random.random() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects a solution from the archive by random choice, then applies a hybrid local search combining edge exchange (randomly reversing a segment) and node insertion (moving a node to a new position) to generate a neighbor solution while ensuring feasibility through validity checks. The method prioritizes exploration of the solution space by randomly perturbing the tour structure, with fallback to the original solution if feasibility is violated.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with good potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Random edge exchange\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that is inspired by all the above algorithms and the long-term reflection, aiming to achieve objective values lower than any of them.\n\n            1. Firstly, list some ideas in the provided algorithms and the long-term reflection that are clearly helpful for designing a better algorithm.\n            2. Secondly, based on the listed ideas, describe the design idea and main steps of your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the idea in the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax, code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 107,
        "algorithm": "The algorithm selects promising solutions from the archive by prioritizing those near the Pareto frontier (top 20% in combined objective space) and applies a hybrid local search that alternates between 3-opt (for local exploitation) and cross-dimensional edge insertion (for global exploration), ensuring feasibility by validating node uniqueness. Solutions are chosen with probabilities inversely proportional to their combined objectives, and the operator probabilistically switches between segment reversal and node reinsertion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near Pareto frontier (top 20%)\n    objectives = np.array([sum(obj) for _, obj in archive])\n    sorted_indices = np.argsort(objectives)\n    top_20_percent = max(1, len(archive) // 5)\n    candidate_indices = sorted_indices[:top_20_percent]\n\n    # Prioritize lower combined objectives\n    candidate_objectives = objectives[candidate_indices]\n    probabilities = 1 / (candidate_objectives + 1e-6)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(candidate_indices, p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternate between 3-opt and cross-dimensional edge insertion\n    if np.random.random() < 0.6:  # 3-opt for exploitation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:  # Cross-dimensional edge insertion for exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.840339837769682,
            0.23679906129837036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions near Pareto frontier (top 20%)\n    objectives = np.array([sum(obj) for _, obj in archive])\n    sorted_indices = np.argsort(objectives)\n    top_20_percent = max(1, len(archive) // 5)\n    candidate_indices = sorted_indices[:top_20_percent]\n\n    # Prioritize lower combined objectives\n    candidate_objectives = objectives[candidate_indices]\n    probabilities = 1 / (candidate_objectives + 1e-6)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(candidate_indices, p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: alternate between 3-opt and cross-dimensional edge insertion\n    if np.random.random() < 0.6:  # 3-opt for exploitation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n    else:  # Cross-dimensional edge insertion for exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "s1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 8 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects a random solution from an archive, applies a hybrid 3-opt move to it, and then has a 50% chance to perform a novel edge-swap between two non-adjacent edges while ensuring the tour remains valid. The method prioritizes diversity by combining standard 3-opt with a custom edge-swap heuristic to explore the solution space more effectively.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Perform a 3-opt move (swap edges)\n    new_solution[a:b] = selected_solution[a:b][::-1]\n    new_solution[b:c] = selected_solution[b:c][::-1]\n\n    # Novel edge-swap: Swap two edges that cross in one space but are non-crossing in the other\n    if np.random.rand() < 0.5:  # 50% chance to apply the novel operator\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Check if swapping these edges would create a valid tour\n        if not (i == 0 and j == n-1):  # Avoid swapping the first and last edges\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with high potential for improvement (highest sum of normalized objective values) and applies a hybrid local search combining partial tour reversal and a constrained edge swap, ensuring feasibility by validating the tour structure and avoiding node duplicates. The edge swap is conditioned on improving both objectives, with a small randomness factor to escape local optima. The solution prioritizes exploration of promising regions while maintaining validity, moving beyond standard operators to balance exploitation and exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Partial tour reversal (explore a segment of the tour)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([a, b])\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Constrained edge swap: swap edges only if it improves both objectives\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Check if swapping edges i and j improves both objectives\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:  # Allow some randomness\n        new_solution = temp_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a solution from the archive with the highest variance in objectives (indicating diverse exploration potential) and applies a hybrid local search combining edge reversal and segment inversion, ensuring feasibility by validating node uniqueness and tour continuity. The method prioritizes solutions with high objective disparities and uses randomized segment reversals to explore the solution space while maintaining TSP feasibility. The key design ideas are: (1) objective diversity-based selection and (2) a hybrid local search operator that combines edge reversal and segment inversion.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives (diverse exploration potential)\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine edge reversal and segment inversion\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n    start, end = min(a, b), max(a, b)\n\n    # Edge reversal between start and end\n    temp = new_solution.copy()\n    temp[start:end+1] = temp[start:end+1][::-1]\n\n    # Segment inversion (reverse a random segment)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    temp[seg_start:seg_end+1] = temp[seg_start:seg_end+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm intelligently selects promising solutions from the archive by prioritizing those with balanced objective improvement potential, then applies a dynamic hybrid local search that adaptively switches between partial tour reversal and constrained node relocation based on objective dominance, ensuring feasibility through rigorous validation and incorporating small randomness to escape local optima.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with balanced objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    dominance = np.prod(normalized, axis=1)  # Product of normalized objectives\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic hybrid local search\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Determine operator based on objective dominance\n    if current_cost1 > current_cost2:\n        # Prioritize reversal for dominant objective\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Prioritize node relocation for balanced improvement\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Validate feasibility and objective improvement\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n    else:\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n        if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() < 0.3:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects solutions with high objective diversity from an archive, then applies a hybrid local search combining segment reversal (with cross-dimensional balance checks) and edge contraction (with feasibility validation), ensuring the neighbor solution maintains feasibility while prioritizing balanced objective improvements through a diversity-aware acceptance criterion. It alternates between global exploration (segment reversal) and local optimization (edge contraction), with random selection between the two strategies.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select solutions with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Calculate cross-dimensional segment importance\n    def segment_importance(i, j):\n        segment_length1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        segment_length2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(i, j))\n        return segment_length1 + segment_length2\n\n    # Step 3: Hybrid local search\n    if np.random.rand() < 0.5:  # Segment reversal with cross-dimensional constraint\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = sorted([i, j])\n        segment_length = j - i\n\n        # Check if reversal maintains cross-dimensional balance\n        if segment_length > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp_sol[k], temp_sol[next_k]]\n                dist2 = distance_matrix_2[temp_sol[k], temp_sol[next_k]]\n                if dist1 > 2 * np.mean(distance_matrix_1) or dist2 > 2 * np.mean(distance_matrix_2):\n                    valid = False\n                    break\n\n            if valid and len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n    else:  # Edge contraction with distance-based selection\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        if l > k:\n            temp_sol = new_solution.copy()\n            temp_sol[k:l] = [temp_sol[l]] + temp_sol[k:l-1]\n\n            # Validate feasibility\n            if len(np.unique(temp_sol)) == n:\n                new_solution = temp_sol\n\n    # Step 4: Diversity-aware acceptance\n    current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Accept if either objective improves or if diversity increases\n    if not ((new_cost1 < current_cost1 or new_cost2 < current_cost2) or\n            (abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm selects the solution with the highest sum of normalized objectives from the archive and applies a hybrid local search operator that combines random node swaps and segment rotations to generate a neighbor solution, ensuring feasibility by validating node uniqueness while preserving the TSP tour structure. The method prioritizes high-cost solutions and uses randomized segment shifts to explore the solution space efficiently.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high sum of objectives (high total cost)\n    sums = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(sums)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: combine node swaps and segment rotation\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    while b == a:\n        b = np.random.randint(0, n)\n\n    # Node swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment rotation (shift a segment forward by one position)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n    while d == c:\n        d = np.random.randint(0, n)\n    seg_start, seg_end = min(c, d), max(c, d)\n    segment = new_solution[seg_start:seg_end+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[seg_start:seg_end+1] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n\nNo. 7 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive by combining normalized objectives and diversity scores, then applies a hybrid local search (60% edge-swap, 40% constrained segment insertion) to generate a neighbor solution while ensuring feasibility through node uniqueness validation. It prioritizes multi-objective improvement in edge-swaps and allows occasional diversification in segment insertions.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    diversity = np.std(normalized, axis=0)\n    scores = np.sum(normalized, axis=1) + 0.5 * np.sum(diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_cost(sol, dist_mat):\n        cost = 0\n        for k in range(n):\n            cost += dist_mat[sol[k], sol[(k+1)%n]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    # Hybrid local search: 60% edge-swap, 40% constrained segment insertion\n    if np.random.rand() < 0.6:\n        # Edge-swap with multi-objective improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n        new_cost1 = calculate_cost(temp_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(temp_solution, distance_matrix_2)\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution = temp_solution\n    else:\n        # Constrained segment insertion\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b = sorted([a, b])\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 8 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using tournament selection, then applies a hybrid local search combining cross-space edge swapping (randomly swapping edges between nodes in both objective spaces) and adaptive segment inversion (randomly reversing segments of the tour), ensuring feasibility by validating the generated tour. The selection prioritizes solutions with better combined objective values, while the local search balances exploration (randomness in edge swaps and segment lengths) with exploitation (adaptive segment lengths based on tour size).\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection: pick 3 random solutions and select the one with best combined objective\n    tournament_size = min(3, len(archive))\n    candidates = np.random.choice(len(archive), tournament_size, replace=False)\n    selected_idx = min(candidates, key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Phase 1: Cross-space edge swapping\n        i, j = np.random.choice(n, 2, replace=False)\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n\n        # Swap edges in both spaces\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Phase 2: Adaptive segment inversion\n        segment_length = max(2, n // 4)\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 108,
        "algorithm": "The algorithm selects nondominated solutions with high crowding distance to prioritize diverse, high-quality candidates, then applies a hybrid local search combining adaptive 3-opt and cross-dimensional edge insertion to generate neighbors while ensuring feasibility through validation. It balances exploration (via crowding distance) and exploitation (via local search) while maintaining TSP feasibility through node uniqueness checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n\n    # Calculate crowding distance for nondominated solutions\n    crowding_distances = np.zeros(len(nondominated_indices))\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[nondominated_indices, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(sorted_indices)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[nondominated_indices[sorted_indices[i+1]], m] - objectives[nondominated_indices[sorted_indices[i-1]], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = nondominated_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Step 2: Hybrid local search\n        if np.random.rand() < 0.7:  # 70% chance for adaptive 3-opt\n            # Select three distinct edges\n            a, b, c = np.random.choice(n, size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Perform 3-opt move\n            new_solution[a:b] = base_solution[a:b][::-1]\n            new_solution[b:c] = base_solution[b:c][::-1]\n        else:  # Cross-dimensional edge insertion\n            # Select two edges from different spaces\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            # Insert edge from first space into second space\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp[k], temp[next_k]]\n                dist2 = distance_matrix_2[temp[k], temp[next_k]]\n                if dist1 == 0 or dist2 == 0 or np.isnan(dist1) or np.isnan(dist2):\n                    valid = False\n                    break\n\n            if valid:\n                new_solution = temp\n\n    # Step 3: Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7727179268981559,
            0.6189595460891724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select nondominated solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n\n    nondominated_indices = np.where(~is_dominated)[0]\n    if len(nondominated_indices) == 0:\n        nondominated_indices = np.arange(len(archive))\n\n    # Calculate crowding distance for nondominated solutions\n    crowding_distances = np.zeros(len(nondominated_indices))\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[nondominated_indices, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(sorted_indices)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[nondominated_indices[sorted_indices[i+1]], m] - objectives[nondominated_indices[sorted_indices[i-1]], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = nondominated_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n >= 4:\n        # Step 2: Hybrid local search\n        if np.random.rand() < 0.7:  # 70% chance for adaptive 3-opt\n            # Select three distinct edges\n            a, b, c = np.random.choice(n, size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n\n            # Perform 3-opt move\n            new_solution[a:b] = base_solution[a:b][::-1]\n            new_solution[b:c] = base_solution[b:c][::-1]\n        else:  # Cross-dimensional edge insertion\n            # Select two edges from different spaces\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n:\n                j = np.random.randint(0, n)\n\n            # Insert edge from first space into second space\n            temp = new_solution.copy()\n            temp[i], temp[j] = temp[j], temp[i]\n\n            # Validate cross-dimensional feasibility\n            valid = True\n            for k in range(n):\n                next_k = (k + 1) % n\n                dist1 = distance_matrix_1[temp[k], temp[next_k]]\n                dist2 = distance_matrix_2[temp[k], temp[next_k]]\n                if dist1 == 0 or dist2 == 0 or np.isnan(dist1) or np.isnan(dist2):\n                    valid = False\n                    break\n\n            if valid:\n                new_solution = temp\n\n    # Step 3: Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize structurally balanced and nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate structural balance (low variance in segment lengths)\n    segment_vars = []\n    for sol in solutions:\n        segments = []\n        for i in range(len(sol)):\n            segments.append(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]])\n        segment_vars.append(np.var(segments))\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Combine structural balance and nondominated status\n    scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            scores[i] = 1 / (1 + segment_vars[i])\n\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive operator selection\n    if np.random.random() < 0.5:\n        # Segment-based reversal\n        segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Distance-aware node relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 109,
        "algorithm": "The algorithm combines adaptive Pareto-frontier selection with a novel cross-dimensional segment inversion operator, prioritizing solutions with high crowding distance for local improvement through segment reversal while ensuring feasibility through validation and fallback mechanisms. It dynamically adjusts segment size and prioritizes structurally balanced regions for exploration, alternating between exploiting high-quality solutions and ensuring valid TSP tours. The selection process emphasizes crowding distance to focus on diverse Pareto-optimal solutions, while the local search operator alternates between segment inversion and single-node relocation to maintain feasibility and explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions near the Pareto frontier with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Calculate crowding distance for Pareto-frontier solutions\n    crowding_distances = np.zeros(len(archive))\n    for obj_idx in [0, 1]:\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if not is_dominated[sorted_idx[i]]:\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-dimensional segment inversion operator\n    segment_size = min(5, max(2, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment in both objective spaces\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: single node relocation if inversion causes duplicates\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k-1)%n or l == (k+1)%n:\n            l = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, base_solution[k])\n\n    return new_solution\n\n",
        "score": [
            -0.966283156104834,
            0.7822537422180176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions near the Pareto frontier with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Calculate crowding distance for Pareto-frontier solutions\n    crowding_distances = np.zeros(len(archive))\n    for obj_idx in [0, 1]:\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if not is_dominated[sorted_idx[i]]:\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Cross-dimensional segment inversion operator\n    segment_size = min(5, max(2, int(np.random.normal(n/4, n/8))))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment in both objective spaces\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback: single node relocation if inversion causes duplicates\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k-1)%n or l == (k+1)%n:\n            l = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, base_solution[k])\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n            I have 2 existing algorithms with their codes as follows:\n            No. 1 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive with high potential for improvement (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized = objectives / max_obj\n    selected_idx = np.argmax(np.sum(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate node importance based on both objectives\n    def node_importance(node_idx):\n        contrib1 = distance_matrix_1[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_1[node_idx, base_solution[(node_idx+1)%n]]\n        contrib2 = distance_matrix_2[node_idx, base_solution[(node_idx-1)%n]] + distance_matrix_2[node_idx, base_solution[(node_idx+1)%n]]\n        return contrib1 + contrib2\n\n    importance = [node_importance(i) for i in range(n)]\n    sorted_nodes = np.argsort(importance)[::-1]\n\n    # Hybrid local search combining cross-dimensional node relocation and adaptive edge swap\n    for i in range(min(3, n//2)):\n        node = sorted_nodes[i]\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                continue\n\n            temp_sol = new_solution.copy()\n            temp_sol = np.delete(temp_sol, node)\n            temp_sol = np.insert(temp_sol, pos, base_solution[node])\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, best_pos)\n            new_solution = np.insert(new_solution, best_pos, base_solution[node])\n\n    # Adaptive edge swap with multi-objective validation\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1_new = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2_new = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost1_old = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        cost2_old = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1_new <= cost1_old and cost2_new <= cost2_old) or np.random.rand() < 0.15:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\nNone\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize structurally balanced and nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate structural balance (low variance in segment lengths)\n    segment_vars = []\n    for sol in solutions:\n        segments = []\n        for i in range(len(sol)):\n            segments.append(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]])\n        segment_vars.append(np.var(segments))\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Combine structural balance and nondominated status\n    scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            scores[i] = 1 / (1 + segment_vars[i])\n\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive operator selection\n    if np.random.random() < 0.5:\n        # Segment-based reversal\n        segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Distance-aware node relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n            Additionally, here is a long-term reflection that provides higher-level guidance for improvement:\n            Here\u2019s the refined heuristic design based on effective self-reflection:\n\n- **Keywords**: **Adaptive Cross-Dimensional Swap**, **Pareto-Frontier Selection**, **Structural Feasibility Check**, **Balanced Objective Exploration**\n- **Advice**: Use a **novel cross-dimensional swap operator** (combining segment reversal with edge contraction) to balance local and global improvements. Select solutions near the **Pareto frontier** (e.g., top 20% in objective space) and validate feasibility by checking node uniqueness and edge existence in both objective spaces.\n- **Avoid**: Static 2-opt or single-objective greedy operators. Ignore cross-dimensional structural balance checks.\n- **Explanation**: The adaptive operator ensures diverse exploration while maintaining feasibility, and Pareto-frontier selection focuses improvement on high-potential regions, preventing premature convergence.\n\n*(99 words, meets the tip.)*\n\n### Step-by-Step Design:\n1. **Selection**: Filter nondominated solutions with high crowding distance (e.g., > median).\n2. **Local Search**: Alternate between 3-opt (exploitation) and cross-dimensional edge insertion (exploration).\n3. **Feasibility**: Validate tours via node uniqueness and edge existence in both objective spaces.\n4. **Balance**: Prioritize solutions with balanced objective trade-offs via Pareto dominance checks.\n\nThis design balances exploitation/exploration while ensuring feasibility and diversity.\n\n            Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them and the above long-term reflection.\n            1. Firstly, identify the common backbone idea in the provided algorithms.\n            2. Secondly, based on both the backbone idea and the long-term reflection, describe your new algorithm in one long, detailed sentence. The description must be enclosed within boxed {}.\n            3. Thirdly, implement the following Python function:\n            def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n\n            Check syntax and code carefully before returning the final function. Do not give any additional explanations.\n            ",
        "sample_order": 110,
        "algorithm": "The algorithm combines adaptive Pareto-frontier selection with a hybrid local search strategy that alternates between 3-opt moves and cross-dimensional segment inversions, prioritizing solutions with high crowding distance on the Pareto frontier while ensuring feasibility through structural validation checks. It dynamically balances local and global improvements by evaluating both individual and combined objective trade-offs, with a focus on solutions near the Pareto frontier for better multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Filter Pareto-frontier solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    pareto_indices = [i for i in range(len(archive)) if not is_dominated[i]]\n    if not pareto_indices:\n        pareto_indices = list(range(len(archive)))\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    # Select solution with highest crowding distance\n    selected_idx = pareto_indices[np.argmax(crowding[pareto_indices])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Alternate between 3-opt and cross-dimensional segment inversion\n    for _ in range(3):\n        if np.random.random() < 0.5:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n            if i == 0 and k == n-1:\n                continue\n\n            # Generate all possible 3-opt configurations\n            candidates = []\n            for a in [i, j, k]:\n                for b in [i, j, k]:\n                    if a != b:\n                        candidates.append((a, b))\n\n            best_cost = float('inf')\n            best_config = None\n\n            for a, b in candidates:\n                temp_sol = new_solution.copy()\n                if a < b:\n                    temp_sol[a:b+1] = temp_sol[a:b+1][::-1]\n                else:\n                    temp_sol[a:] = temp_sol[a:][::-1]\n                    temp_sol[:b+1] = temp_sol[:b+1][::-1]\n\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_config = temp_sol\n\n            if best_config is not None:\n                new_solution = best_config\n        else:\n            # Cross-dimensional segment inversion\n            segment_size = min(5, max(2, int(np.random.normal(n/4, n/8))))\n            start = np.random.randint(0, n - segment_size)\n            end = start + segment_size\n\n            # Calculate segment cost in both dimensions\n            seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n            seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n\n            # Calculate alternative configurations\n            temp_sol = new_solution.copy()\n            temp_sol[start:end+1] = temp_sol[start:end+1][::-1]\n\n            alt_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(start, end+1))\n            alt_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(start, end+1))\n\n            # Accept if both objectives improve or if one improves significantly\n            if (alt_cost1 < seg_cost1 and alt_cost2 < seg_cost2) or \\\n               (alt_cost1 < seg_cost1 and (alt_cost2 - seg_cost2) < 0.1 * seg_cost2) or \\\n               (alt_cost2 < seg_cost2 and (alt_cost1 - seg_cost1) < 0.1 * seg_cost1):\n                new_solution = temp_sol\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9005255628045432,
            6.181189715862274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Filter Pareto-frontier solutions with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    pareto_indices = [i for i in range(len(archive)) if not is_dominated[i]]\n    if not pareto_indices:\n        pareto_indices = list(range(len(archive)))\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    # Select solution with highest crowding distance\n    selected_idx = pareto_indices[np.argmax(crowding[pareto_indices])]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Alternate between 3-opt and cross-dimensional segment inversion\n    for _ in range(3):\n        if np.random.random() < 0.5:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n            if i == 0 and k == n-1:\n                continue\n\n            # Generate all possible 3-opt configurations\n            candidates = []\n            for a in [i, j, k]:\n                for b in [i, j, k]:\n                    if a != b:\n                        candidates.append((a, b))\n\n            best_cost = float('inf')\n            best_config = None\n\n            for a, b in candidates:\n                temp_sol = new_solution.copy()\n                if a < b:\n                    temp_sol[a:b+1] = temp_sol[a:b+1][::-1]\n                else:\n                    temp_sol[a:] = temp_sol[a:][::-1]\n                    temp_sol[:b+1] = temp_sol[:b+1][::-1]\n\n                cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_config = temp_sol\n\n            if best_config is not None:\n                new_solution = best_config\n        else:\n            # Cross-dimensional segment inversion\n            segment_size = min(5, max(2, int(np.random.normal(n/4, n/8))))\n            start = np.random.randint(0, n - segment_size)\n            end = start + segment_size\n\n            # Calculate segment cost in both dimensions\n            seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n            seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end+1))\n\n            # Calculate alternative configurations\n            temp_sol = new_solution.copy()\n            temp_sol[start:end+1] = temp_sol[start:end+1][::-1]\n\n            alt_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(start, end+1))\n            alt_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(start, end+1))\n\n            # Accept if both objectives improve or if one improves significantly\n            if (alt_cost1 < seg_cost1 and alt_cost2 < seg_cost2) or \\\n               (alt_cost1 < seg_cost1 and (alt_cost2 - seg_cost2) < 0.1 * seg_cost2) or \\\n               (alt_cost2 < seg_cost2 and (alt_cost1 - seg_cost1) < 0.1 * seg_cost1):\n                new_solution = temp_sol\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "e2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        None\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize structurally balanced and nondominated solutions\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate structural balance (low variance in segment lengths)\n    segment_vars = []\n    for sol in solutions:\n        segments = []\n        for i in range(len(sol)):\n            segments.append(distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]])\n        segment_vars.append(np.var(segments))\n\n    # Identify nondominated solutions\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                is_dominated[i] = True\n                break\n\n    # Combine structural balance and nondominated status\n    scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if not is_dominated[i]:\n            scores[i] = 1 / (1 + segment_vars[i])\n\n    if np.sum(scores) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive operator selection\n    if np.random.random() < 0.5:\n        # Segment-based reversal\n        segment_size = min(4, max(2, int(np.random.normal(n/5, n/10))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Distance-aware node relocation\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Calculate relocation probabilities\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(n)\n        for l in range(n):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[l] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        probs /= probs.sum()\n        l = np.random.choice(n, p=probs)\n\n        if l != k and l != (k-1)%n and l != (k+1)%n:\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 111,
        "algorithm": "API_FAILED",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with diverse objectives and high potential\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate objective diversity (distance from ideal point)\n    ideal_point = objectives.min(axis=0)\n    diversity_scores = np.sum((objectives - ideal_point) ** 2, axis=1)\n\n    # Calculate solution quality (normalized objective values)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + np.sum(normalized_obj, axis=1))\n\n    # Combine diversity and quality\n    combined_scores = diversity_scores * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores/combined_scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator selection\n    operator_type = np.random.choice(['relocation', 'reversal', 'swap'], p=[0.4, 0.3, 0.3])\n\n    if operator_type == 'relocation':\n        # Distance-aware node relocation with adaptive step size\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        step_size = min(5, max(1, int(np.random.normal(n/8, n/16))))\n        candidates = [(k + i) % n for i in range(-step_size, step_size+1) if i != 0]\n\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(len(candidates))\n        for i, l in enumerate(candidates):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                probs[i] = 0\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[i] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        if np.sum(probs) > 0:\n            probs /= probs.sum()\n            l = candidates[np.random.choice(len(candidates), p=probs)]\n            if l != k and l != (k-1)%n and l != (k+1)%n:\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n    elif operator_type == 'reversal':\n        # Adaptive segment reversal with diversity consideration\n        segment_size = min(5, max(2, int(np.random.normal(n/6, n/12))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check segment diversity\n        segment_nodes = new_solution[start:end+1]\n        diversity = len(np.unique(segment_nodes)) / len(segment_nodes)\n\n        if diversity < 0.7:  # Low diversity segment, more likely to reverse\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    elif operator_type == 'swap':\n        # Distance-aware node swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) < 2:  # Don't swap adjacent nodes\n            return new_solution\n\n        current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_dist < current_dist:  # Only swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8672408217960452,
            239.5546117424965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: prioritize solutions with diverse objectives and high potential\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate objective diversity (distance from ideal point)\n    ideal_point = objectives.min(axis=0)\n    diversity_scores = np.sum((objectives - ideal_point) ** 2, axis=1)\n\n    # Calculate solution quality (normalized objective values)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + np.sum(normalized_obj, axis=1))\n\n    # Combine diversity and quality\n    combined_scores = diversity_scores * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores/combined_scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator selection\n    operator_type = np.random.choice(['relocation', 'reversal', 'swap'], p=[0.4, 0.3, 0.3])\n\n    if operator_type == 'relocation':\n        # Distance-aware node relocation with adaptive step size\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        step_size = min(5, max(1, int(np.random.normal(n/8, n/16))))\n        candidates = [(k + i) % n for i in range(-step_size, step_size+1) if i != 0]\n\n        current_dist = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n        probs = np.zeros(len(candidates))\n        for i, l in enumerate(candidates):\n            if l == k or l == (k-1)%n or l == (k+1)%n:\n                probs[i] = 0\n                continue\n            new_dist = (distance_matrix_1[new_solution[(l-1)%n], node] + distance_matrix_1[node, new_solution[l]] +\n                        distance_matrix_2[new_solution[(l-1)%n], node] + distance_matrix_2[node, new_solution[l]])\n            probs[i] = np.exp(-(new_dist - current_dist) / (current_dist + 1e-8))\n\n        if np.sum(probs) > 0:\n            probs /= probs.sum()\n            l = candidates[np.random.choice(len(candidates), p=probs)]\n            if l != k and l != (k-1)%n and l != (k+1)%n:\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n    elif operator_type == 'reversal':\n        # Adaptive segment reversal with diversity consideration\n        segment_size = min(5, max(2, int(np.random.normal(n/6, n/12))))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Check segment diversity\n        segment_nodes = new_solution[start:end+1]\n        diversity = len(np.unique(segment_nodes)) / len(segment_nodes)\n\n        if diversity < 0.7:  # Low diversity segment, more likely to reverse\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    elif operator_type == 'swap':\n        # Distance-aware node swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) < 2:  # Don't swap adjacent nodes\n            return new_solution\n\n        current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_dist = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_dist < current_dist:  # Only swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "m1"
    }
]