[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective cost from the archive and applies a hybrid local search combining random edge swaps and path reversals to generate neighbors, ensuring feasibility by checking for duplicates and falling back to a simple swap if needed. The algorithm prioritizes solutions with better combined performance and uses a creative, non-standard local search approach to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with path reversal\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform path reversal between two random points\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.035545407236826,
            0.22458416223526
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest product of the two objectives from the archive, then applies a hybrid local search combining segment reversal and a fallback swap to ensure feasibility. It prioritizes solutions with balanced objective values and uses a novel segment-based perturbation to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n\n    # Apply a hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(i, j)\n    new_solution[i:k] = new_solution[i:k][::-1]\n    new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9689691333391046,
            0.196405291557312
        ]
    },
    {
        "algorithm": "The heuristic function selects the solution from the archive with the lowest combined objective score and applies a hybrid local search operator that reverses two randomly selected non-adjacent segments in the tour, optionally swapping edges between them to improve solution quality while ensuring feasibility. The algorithm prioritizes solutions with better overall performance and uses a creative segment reversal strategy to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are not adjacent\n    while abs(a - b) <= 1 or abs(c - d) <= 1:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Optional: Perform edge swaps between segments\n    if random.random() < 0.5 and b < c:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8427200718500385,
            0.1953842043876648
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-aware epsilon-dominance, then applies a hybrid local search operator that dynamically inserts segments of the tour and conditionally refines edges based on multi-objective improvements, while ensuring feasibility through permutation checks and fallback mechanisms. It balances exploration and exploitation by randomizing segment lengths and refinement probabilities, prioritizing solutions near the Pareto front while maintaining diversity through dynamic operator depth and probabilistic edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with epsilon-dominance\n    epsilon = 0.1\n    selected = min(archive, key=lambda s: max(s[1]) - epsilon * min(s[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Segment insertion with adaptive edge refinement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 2:  # Ensure segment length >= 2\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Randomly select insertion point\n    c = np.random.randint(0, n)\n    while abs(c - a) <= 1 or abs(c - b) <= 1:  # Ensure non-adjacent\n        c = np.random.randint(0, n)\n\n    # Insert segment\n    segment = base_solution[a:b+1]\n    new_solution = np.concatenate([base_solution[:c], segment, np.delete(base_solution, slice(a, b+1))])\n\n    # Adaptive edge refinement\n    if np.random.random() < 0.3:  # Probabilistic refinement\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7594838300291855,
            0.06324100494384766
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects the worst-performing solution from the archive (based on the maximum of its two objectives) and applies a hybrid local search combining segment reversal and 3-opt-like adjustments to generate a neighbor solution, ensuring feasibility by validating node uniqueness and fallback to 2-opt if needed. The approach prioritizes diversification by targeting poorly performing solutions while using novel segment reversal to explore the search space beyond standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    worst_obj = max(archive, key=lambda x: max(x[1]))\n    base_solution = worst_obj[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(np.random.choice(N, 3, replace=False))\n\n    # Segment reversal (novel operator)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt style adjustment\n    if np.random.rand() < 0.5:\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != N:\n        # Fallback to simple 2-opt if needed\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.84403300160437,
            0.20488500595092773
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective cost from the archive, then generates a neighbor by applying a hybrid local search combining random segment reversals and edge swaps, with a fallback to simple inversion if feasibility is violated, ensuring the neighbor remains a valid TSP tour. The selection prioritizes high-cost solutions for improvement, while the hybrid operator balances exploration and exploitation for better multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined cost (opposite of previous approach)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform path reversal between two random points\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if reversal causes duplicates\n        new_solution = base_solution.copy()\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9508678707472352,
            0.24227094650268555
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-dominance-aware selection (prioritizing solutions with balanced objectives) and applies a hybrid local search combining adaptive segment reversals and conditional edge swaps to generate high-quality neighbors while ensuring feasibility through permutation validation. The selection criterion balances trade-offs between the two objectives, while the local search adaptively modifies segments of the tour and conditionally swaps edges to explore the solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance aware selection\n    selected_idx = np.argmin([max(obj) - 0.1 * min(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Adaptive segment reversal\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Conditional edge swap for multi-objective improvement\n    if np.random.random() < 0.3:\n        k, l = np.random.choice(n, 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8864458702466999,
            0.23854470252990723
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-scoring solution from the archive, applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by validating segment positions and insertion points. It prioritizes solutions with higher combined objective scores and uses random segment selection with constraints to avoid adjacent or overlapping segments, followed by conditional edge insertion to further refine the tour. The method balances exploration and exploitation by randomly choosing operations while maintaining feasibility through careful validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments are not adjacent and not overlapping\n    while (abs(a - b) <= 1 or abs(c - d) <= 1) or (a <= d <= b):\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Edge insertion strategy\n    if random.random() < 0.7:\n        # Select a node from one segment and insert it into another\n        segment1 = random.choice([a, c])\n        segment2 = random.choice([b, d])\n        node = new_solution[segment1]\n        new_solution = np.delete(new_solution, segment1)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8765893919237706,
            0.22919976711273193
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive based on the squared difference between its two objectives, then applies a hybrid local search combining adaptive three-segment reversals and conditional edge swaps, ensuring feasibility through permutation checks and randomized perturbations if needed. It prioritizes solutions with balanced objectives and adaptively modifies the tour by reversing segments and swapping edges based on their contribution to both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n\n    # Apply a three-segment reversal operator with adaptive depth\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices and sort them\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Reverse three segments: [i..j], [j..k], and [k..i] (circular reversal)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    new_solution[k:i+1] = new_solution[k:i+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback: random perturbation if invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], shift=np.random.randint(1, b-a+1))\n\n    # Conditional edge swap based on distance matrices\n    if np.random.rand() < 0.3:\n        u, v = sorted(np.random.choice(n, 2, replace=False))\n        # Swap edges if it reduces total cost in both objectives\n        old_cost = (distance_matrix_1[new_solution[u-1], new_solution[u]] + distance_matrix_2[new_solution[u-1], new_solution[u]] +\n                    distance_matrix_1[new_solution[v-1], new_solution[v]] + distance_matrix_2[new_solution[v-1], new_solution[v]])\n        new_cost = (distance_matrix_1[new_solution[u-1], new_solution[v]] + distance_matrix_2[new_solution[u-1], new_solution[v]] +\n                    distance_matrix_1[new_solution[v-1], new_solution[u]] + distance_matrix_2[new_solution[v-1], new_solution[u]])\n        if new_cost < old_cost:\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    return new_solution\n\n",
        "score": [
            -0.6078296473333982,
            0.2131110429763794
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on balanced objective performance, then applies a hybrid local search combining segment reversal and objective-aware edge swapping to generate a neighbor solution while ensuring feasibility through validation and fallback mechanisms. It prioritizes improvements in both objectives through probabilistic operations and dynamic edge selection, with segment-based operations given higher probability (70%) to explore the solution space more effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best balance between objectives\n    selected_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment-based operations with objective-aware edge selection\n    # Step 1: Select two non-adjacent segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n    while abs(a - b) <= 1 or abs(c - d) <= 1:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Step 2: Reverse segments with probability based on objective improvement\n    if random.random() < 0.7:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Calculate potential improvement in both objectives\n        def calculate_improvement(seg1, seg2):\n            # Original cost\n            original_cost1 = distance_matrix_1[seg1[-1], seg1[0]] + distance_matrix_1[seg2[-1], seg2[0]]\n            original_cost2 = distance_matrix_2[seg1[-1], seg1[0]] + distance_matrix_2[seg2[-1], seg2[0]]\n\n            # Reversed cost\n            reversed_cost1 = distance_matrix_1[seg1[0], seg1[-1]] + distance_matrix_1[seg2[0], seg2[-1]]\n            reversed_cost2 = distance_matrix_2[seg1[0], seg2[-1]] + distance_matrix_2[seg2[0], seg1[-1]]\n\n            return (original_cost1 - reversed_cost1, original_cost2 - reversed_cost2)\n\n        imp1, imp2 = calculate_improvement(segment1, segment2)\n\n        # Apply reversal if it improves at least one objective\n        if imp1 > 0 or imp2 > 0:\n            new_solution[a:b+1] = segment1[::-1]\n            new_solution[c:d+1] = segment2[::-1]\n\n    # Step 3: Objective-aware edge selection and swap\n    if random.random() < 0.5:\n        # Find edges with potential for improvement in both objectives\n        candidates = []\n        for i in range(n):\n            j = (i + 1) % n\n            for k in range(n):\n                if k != i and k != j and k != (i - 1) % n and k != (j + 1) % n:\n                    # Calculate potential improvement\n                    old_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n                    new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[(k+1)%n]]\n                    old_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n                    new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[(k+1)%n]]\n\n                    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n                       (new_cost1 < old_cost1 and random.random() < 0.3) or \\\n                       (new_cost2 < old_cost2 and random.random() < 0.3):\n                        candidates.append((i, j, k))\n\n        if candidates:\n            i, j, k = random.choice(candidates)\n            # Perform edge swap\n            new_solution[j], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if needed\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9333935532323302,
            1.0242191553115845
        ]
    }
]