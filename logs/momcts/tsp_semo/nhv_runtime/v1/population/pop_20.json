[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective cost from the archive and applies a hybrid local search combining random edge swaps and path reversals to generate neighbors, ensuring feasibility by checking for duplicates and falling back to a simple swap if needed. The algorithm prioritizes solutions with better combined performance and uses a creative, non-standard local search approach to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with path reversal\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform path reversal between two random points\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.035545407236826,
            0.22458416223526
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest product of the two objectives from the archive, then applies a hybrid local search combining segment reversal and a fallback swap to ensure feasibility. It prioritizes solutions with balanced objective values and uses a novel segment-based perturbation to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n\n    # Apply a hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(i, j)\n    new_solution[i:k] = new_solution[i:k][::-1]\n    new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9689691333391046,
            0.196405291557312
        ]
    },
    {
        "algorithm": "The heuristic function selects the solution from the archive with the lowest combined objective score and applies a hybrid local search operator that reverses two randomly selected non-adjacent segments in the tour, optionally swapping edges between them to improve solution quality while ensuring feasibility. The algorithm prioritizes solutions with better overall performance and uses a creative segment reversal strategy to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are not adjacent\n    while abs(a - b) <= 1 or abs(c - d) <= 1:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Optional: Perform edge swaps between segments\n    if random.random() < 0.5 and b < c:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8427200718500385,
            0.1953842043876648
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-aware epsilon-dominance, then applies a hybrid local search operator that dynamically inserts segments of the tour and conditionally refines edges based on multi-objective improvements, while ensuring feasibility through permutation checks and fallback mechanisms. It balances exploration and exploitation by randomizing segment lengths and refinement probabilities, prioritizing solutions near the Pareto front while maintaining diversity through dynamic operator depth and probabilistic edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with epsilon-dominance\n    epsilon = 0.1\n    selected = min(archive, key=lambda s: max(s[1]) - epsilon * min(s[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Segment insertion with adaptive edge refinement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 2:  # Ensure segment length >= 2\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Randomly select insertion point\n    c = np.random.randint(0, n)\n    while abs(c - a) <= 1 or abs(c - b) <= 1:  # Ensure non-adjacent\n        c = np.random.randint(0, n)\n\n    # Insert segment\n    segment = base_solution[a:b+1]\n    new_solution = np.concatenate([base_solution[:c], segment, np.delete(base_solution, slice(a, b+1))])\n\n    # Adaptive edge refinement\n    if np.random.random() < 0.3:  # Probabilistic refinement\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7594838300291855,
            0.06324100494384766
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective value from the archive, applies a hybrid local search combining segment inversion and node swaps, and ensures feasibility by validating the tour. It prioritizes solutions with higher combined costs (potentially non-dominated) and uses random segment inversion followed by conditional node swaps to explore neighbors, with a fallback to simple swaps if the tour becomes invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    target_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    N = len(target_solution)\n    new_solution = target_solution.copy()\n\n    # Hybrid local search: segment inversion + node swap\n    i, j = sorted(np.random.choice(N, 2, replace=False))\n    k = np.random.randint(0, N)\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node swap with probability\n    if np.random.rand() < 0.7:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Feasibility check\n    if len(set(new_solution)) != N:\n        # Fallback to simple swap if invalid\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -1.0017648199131555,
            0.21665334701538086
        ]
    },
    {
        "algorithm": "The algorithm selects the best-performing solution from the archive (based on the minimum of its two objectives) and applies a hybrid local search combining random node swaps and segment insertions, with a fallback to 2-opt if feasibility is violated. It prioritizes solutions with better objective values and ensures validity by checking for duplicate nodes. The structure alternates between random moves and deterministic corrections to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = min(archive, key=lambda x: min(x[1]))\n    base_solution = best_obj[0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: combine node swaps and segment insertions\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.7:\n        i, j, k = sorted(np.random.choice(N, 3, replace=False))\n        segment = new_solution[j:k+1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != N:\n        # Fallback to 2-opt\n        x, y = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9187426408911551,
            0.19742417335510254
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-aware epsilon-dominance, then applies a hybrid local search combining adaptive segment reversals, dynamic edge swaps, and probabilistic segment insertions, while ensuring feasibility through permutation validation and fallback mechanisms. It prioritizes multi-objective improvements in edge swaps and uses dynamic depth in segment reversals, with probabilistic segment insertions for exploration, while maintaining validity through feasibility checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with epsilon-dominance\n    epsilon = 0.1\n    selected = min(archive, key=lambda s: max(s[1]) - epsilon * min(s[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    depth = np.random.randint(1, min(4, n//2))  # Dynamic depth\n    for _ in range(depth):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Dynamic edge swap with multi-objective check\n    if np.random.random() < 0.4:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.3):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Probabilistic segment insertion\n    if np.random.random() < 0.3 and n > 5:\n        x, y = sorted(np.random.choice(n, 2, replace=False))\n        while y - x < 2:\n            x, y = sorted(np.random.choice(n, 2, replace=False))\n        z = np.random.randint(0, n)\n        while abs(z - x) <= 1 or abs(z - y) <= 1:\n            z = np.random.randint(0, n)\n        segment = new_solution[x:y+1]\n        new_solution = np.concatenate([new_solution[:z], segment, np.delete(new_solution, slice(x, y+1))])\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9323759469460582,
            0.2139185667037964
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective cost from the archive, then generates a neighbor by applying a hybrid local search combining random segment reversals and edge swaps, with a fallback to simple inversion if feasibility is violated, ensuring the neighbor remains a valid TSP tour. The selection prioritizes high-cost solutions for improvement, while the hybrid operator balances exploration and exploitation for better multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined cost (opposite of previous approach)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform path reversal between two random points\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if reversal causes duplicates\n        new_solution = base_solution.copy()\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9508678707472352,
            0.24227094650268555
        ]
    },
    {
        "algorithm": "The algorithm combines Pareto-aware selection with a dynamic hybrid operator that adaptively applies segment reversals and edge insertions, prioritizing solutions with balanced objectives while ensuring feasibility through multi-stage validation. It modulates perturbation intensity based on objective balance (higher weights on segment reversals when balanced, more insertions when imbalanced) and uses randomized operator sequences, with fallback mechanisms for repair when feasibility is compromised. The selection process weights the second objective (60%) over the first (40%), and perturbations are guided by cost improvements in both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with weighted trade-off consideration\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.array([0.4, 0.6])  # Biased towards second objective\n    scores = np.sum(normalized * weights, axis=1)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment-based perturbation with adaptive depth\n    obj_balance = abs(normalized[selected_idx][0] - normalized[selected_idx][1])\n    segment_length = max(2, int((1 - obj_balance) * n / 4))\n    num_perturbations = random.randint(1, min(4, max(1, int(obj_balance * 4))))\n\n    for _ in range(num_perturbations):\n        a = random.randint(0, n - segment_length)\n        b = a + segment_length\n        segment = new_solution[a:b]\n\n        # Segment reversal with cost consideration\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b%n]]\n        reversed_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b%n]]\n\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (reversed_cost1 < original_cost1 and random.random() < 0.4) or \\\n           (reversed_cost2 < original_cost2 and random.random() < 0.6):\n            new_solution[a:b] = segment[::-1]\n\n    # Probabilistic edge insertion with variable-length segments\n    insertion_prob = 0.3 * (1 - obj_balance)\n    if random.random() < insertion_prob:\n        for _ in range(random.randint(1, 3)):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n-1)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j]\n            if len(segment) > 1:\n                new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    # Multi-stage feasibility validation\n    if len(np.unique(new_solution)) != n:\n        # First fallback: probabilistic node swap\n        if random.random() < 0.6:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:\n            # Second fallback: cyclic permutation\n            shift = random.randint(1, n-1)\n            new_solution = np.roll(new_solution, shift)\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Create a valid permutation if still invalid\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n",
        "score": [
            -0.982747697345695,
            0.26674532890319824
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects the worst-performing solution from the archive (based on the maximum of its two objectives) and applies a hybrid local search combining segment reversal and 3-opt-like adjustments to generate a neighbor solution, ensuring feasibility by validating node uniqueness and fallback to 2-opt if needed. The approach prioritizes diversification by targeting poorly performing solutions while using novel segment reversal to explore the search space beyond standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    worst_obj = max(archive, key=lambda x: max(x[1]))\n    base_solution = worst_obj[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(np.random.choice(N, 3, replace=False))\n\n    # Segment reversal (novel operator)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt style adjustment\n    if np.random.rand() < 0.5:\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != N:\n        # Fallback to simple 2-opt if needed\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.84403300160437,
            0.20488500595092773
        ]
    }
]