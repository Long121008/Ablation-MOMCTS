[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective cost from the archive and applies a hybrid local search combining random edge swaps and path reversals to generate neighbors, ensuring feasibility by checking for duplicates and falling back to a simple swap if needed. The algorithm prioritizes solutions with better combined performance and uses a creative, non-standard local search approach to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined potential for improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with path reversal\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform path reversal between two random points\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.035545407236826,
            0.22458416223526
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest product of the two objectives from the archive, then applies a hybrid local search combining segment reversal and a fallback swap to ensure feasibility. It prioritizes solutions with balanced objective values and uses a novel segment-based perturbation to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n\n    # Apply a hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(i, j)\n    new_solution[i:k] = new_solution[i:k][::-1]\n    new_solution[k:j] = new_solution[k:j][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, fall back to a simple swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9689691333391046,
            0.196405291557312
        ]
    },
    {
        "algorithm": "The heuristic function selects the solution from the archive with the lowest combined objective score and applies a hybrid local search operator that reverses two randomly selected non-adjacent segments in the tour, optionally swapping edges between them to improve solution quality while ensuring feasibility. The algorithm prioritizes solutions with better overall performance and uses a creative segment reversal strategy to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are not adjacent\n    while abs(a - b) <= 1 or abs(c - d) <= 1:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Optional: Perform edge swaps between segments\n    if random.random() < 0.5 and b < c:\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8427200718500385,
            0.1953842043876648
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-aware epsilon-dominance, then applies a hybrid local search operator that dynamically inserts segments of the tour and conditionally refines edges based on multi-objective improvements, while ensuring feasibility through permutation checks and fallback mechanisms. It balances exploration and exploitation by randomizing segment lengths and refinement probabilities, prioritizing solutions near the Pareto front while maintaining diversity through dynamic operator depth and probabilistic edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-aware selection with epsilon-dominance\n    epsilon = 0.1\n    selected = min(archive, key=lambda s: max(s[1]) - epsilon * min(s[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Segment insertion with adaptive edge refinement\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    while b - a < 2:  # Ensure segment length >= 2\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # Randomly select insertion point\n    c = np.random.randint(0, n)\n    while abs(c - a) <= 1 or abs(c - b) <= 1:  # Ensure non-adjacent\n        c = np.random.randint(0, n)\n\n    # Insert segment\n    segment = base_solution[a:b+1]\n    new_solution = np.concatenate([base_solution[:c], segment, np.delete(base_solution, slice(a, b+1))])\n\n    # Adaptive edge refinement\n    if np.random.random() < 0.3:  # Probabilistic refinement\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swap improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.random() < 0.2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7594838300291855,
            0.06324100494384766
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective value from the archive, applies a hybrid local search combining segment inversion and node swaps, and ensures feasibility by validating the tour. It prioritizes solutions with higher combined costs (potentially non-dominated) and uses random segment inversion followed by conditional node swaps to explore neighbors, with a fallback to simple swaps if the tour becomes invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    target_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    N = len(target_solution)\n    new_solution = target_solution.copy()\n\n    # Hybrid local search: segment inversion + node swap\n    i, j = sorted(np.random.choice(N, 2, replace=False))\n    k = np.random.randint(0, N)\n\n    # Segment inversion\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node swap with probability\n    if np.random.rand() < 0.7:\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Feasibility check\n    if len(set(new_solution)) != N:\n        # Fallback to simple swap if invalid\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -1.0017648199131555,
            0.21665334701538086
        ]
    },
    {
        "algorithm": "The algorithm selects the best-performing solution from the archive (based on the minimum of its two objectives) and applies a hybrid local search combining random node swaps and segment insertions, with a fallback to 2-opt if feasibility is violated. It prioritizes solutions with better objective values and ensures validity by checking for duplicate nodes. The structure alternates between random moves and deterministic corrections to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = min(archive, key=lambda x: min(x[1]))\n    base_solution = best_obj[0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: combine node swaps and segment insertions\n    a, b = sorted(np.random.choice(N, 2, replace=False))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if np.random.rand() < 0.7:\n        i, j, k = sorted(np.random.choice(N, 3, replace=False))\n        segment = new_solution[j:k+1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[k+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != N:\n        # Fallback to 2-opt\n        x, y = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9187426408911551,
            0.19742417335510254
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the highest combined objective cost from the archive, then generates a neighbor by applying a hybrid local search combining random segment reversals and edge swaps, with a fallback to simple inversion if feasibility is violated, ensuring the neighbor remains a valid TSP tour. The selection prioritizes high-cost solutions for improvement, while the hybrid operator balances exploration and exploitation for better multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined cost (opposite of previous approach)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform path reversal between two random points\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge swap\n    if k != l:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if reversal causes duplicates\n        new_solution = base_solution.copy()\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9508678707472352,
            0.24227094650268555
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-cost solution from the archive and applies a hybrid local search, combining random segment rotations, edge swaps, and a novel node chain reordering operator, with a fallback to inversion if feasibility is violated. It prioritizes exploration of high-cost regions while ensuring valid TSP tours through careful feasibility checks. The selection of operators and their probabilities (e.g., 50% for edge swaps) balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined cost\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Random segment rotation\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    segment_length = j - i + 1\n    rotation = np.random.randint(1, segment_length)\n    new_solution[i:j+1] = np.roll(new_solution[i:j+1], rotation)\n\n    # Edge swap with probability\n    if np.random.random() < 0.5:\n        k, l = np.random.choice(n, 2, replace=False)\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Node chain reordering (novel operator)\n    if np.random.random() < 0.3:\n        chain_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        np.random.shuffle(chain)\n        new_solution[start:start+chain_length] = chain\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9362759183410292,
            0.2505272626876831
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects the worst-performing solution from the archive (based on the maximum of its two objectives) and applies a hybrid local search combining segment reversal and 3-opt-like adjustments to generate a neighbor solution, ensuring feasibility by validating node uniqueness and fallback to 2-opt if needed. The approach prioritizes diversification by targeting poorly performing solutions while using novel segment reversal to explore the search space beyond standard 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    worst_obj = max(archive, key=lambda x: max(x[1]))\n    base_solution = worst_obj[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(np.random.choice(N, 3, replace=False))\n\n    # Segment reversal (novel operator)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-opt style adjustment\n    if np.random.rand() < 0.5:\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != N:\n        # Fallback to simple 2-opt if needed\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.84403300160437,
            0.20488500595092773
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-scoring solution from the archive, applies a hybrid local search combining segment reversal and edge insertion, ensuring feasibility by validating segment positions and insertion points. It prioritizes solutions with higher combined objective scores and uses random segment selection with constraints to avoid adjacent or overlapping segments, followed by conditional edge insertion to further refine the tour. The method balances exploration and exploitation by randomly choosing operations while maintaining feasibility through careful validation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments are not adjacent and not overlapping\n    while (abs(a - b) <= 1 or abs(c - d) <= 1) or (a <= d <= b):\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse segments\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Edge insertion strategy\n    if random.random() < 0.7:\n        # Select a node from one segment and insert it into another\n        segment1 = random.choice([a, c])\n        segment2 = random.choice([b, d])\n        node = new_solution[segment1]\n        new_solution = np.delete(new_solution, segment1)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8765893919237706,
            0.22919976711273193
        ]
    }
]