[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive and applies a hybrid local search (70% 2-opt, 30% 3-opt) to generate a neighbor, ensuring feasibility by always reversing or reordering segments of the tour. The selection prioritizes solutions with minimal total cost, while the local search balances exploration (random segment selection) and exploitation (reversing segments) to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt or 3-opt based on a random choice\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt, else 3-opt\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.8028366341020267,
            0.34138243198394774
        ]
    },
    {
        "algorithm": "The algorithm dynamically identifies the least dominated objective, selects a high-crowding-distance solution from the archive, and applies an adaptive segment inversion operator that swaps variable-length segments (2-5 nodes) between worst-performing edges in the least dominated objective and best-performing edges in another randomly chosen objective, ensuring feasibility through careful boundary handling. The operator prioritizes underperforming objectives while balancing exploration and exploitation by adaptively adjusting segment lengths based on dominance and diversity in the archive.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n\n    # Select the least dominated objective\n    least_dominated_obj = np.argmin(dominance)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance in this objective\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Perform segment inversion\n            segment_length = np.random.randint(2, min(6, n//2))\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Invert segments\n            worst_segment_nodes = worst_segment_nodes[::-1]\n            best_segment_nodes = best_segment_nodes[::-1]\n\n            # Swap inverted segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                # Handle wrap-around cases\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                # Perform the swap\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7057904658048765,
            0.19627649784088136
        ]
    },
    {
        "algorithm": "The algorithm prioritizes the most diverse objective (highest standard deviation in objectives) and selects a high-crowding-distance solution from the archive, then applies an adaptive segment relinking operator that swaps segments between worst-performing edges in the most diverse objective and best-performing edges in another objective, using dynamic segment lengths based on objective diversity. The selection is based on crowding distance in the most diverse objective's space, while the relinking adapts segment sizes proportionally to diversity ratios.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Calculate diversity for each objective\n    diversity = np.std(objectives, axis=0)\n    most_diverse_obj = np.argmax(diversity)\n    selected_matrix = distance_matrices[most_diverse_obj]\n\n    # Calculate crowding distance in the most diverse objective's space\n    normalized_obj = (objectives[:, most_diverse_obj] - np.min(objectives[:, most_diverse_obj])) / (np.max(objectives[:, most_diverse_obj]) - np.min(objectives[:, most_diverse_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the most diverse objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != most_diverse_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Dynamic segment length based on objective diversity\n            segment_length = min(3, max(2, int(np.ceil(np.sqrt(n) * (diversity[most_diverse_obj] / np.sum(diversity))))))\n\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Relink segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7111454534642736,
            0.21573500633239745
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-objective local search using adaptive weight-based selection with hybrid perturbations (segment rotations, edge exchanges, and node insertions), prioritizing solutions with balanced objective improvements through dominance-aware perturbation selection and acceptance criteria that balance weighted improvements and trade-off awareness. It intelligently selects base solutions via weighted objective scores and applies targeted perturbations to edges or segments, with acceptance probabilities adjusted based on improvement magnitude and objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weight-based selection\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Dominance-aware perturbation selection\n    dominance_counts = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0)\n    perturbation_type = np.random.choice(['segment', 'edge', 'insertion'], p=[0.3, 0.4, 0.3])\n\n    if perturbation_type == 'segment':\n        segment_size = max(2, min(n//2, int(0.4 * n + np.random.randn() * 0.15 * n)))\n        i = np.random.randint(0, n - segment_size + 1)\n\n        # Objective-aware segment reversal\n        obj_values = []\n        for k in range(segment_size-1):\n            node1, node2 = new_solution[i+k], new_solution[i+k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        worst_obj = np.argmax(np.dot(np.array(obj_values), weights))\n        if np.random.rand() < 0.7:\n            new_solution[i+worst_obj:i+worst_obj+2] = new_solution[i+worst_obj+1], new_solution[i+worst_obj]\n        else:\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    elif perturbation_type == 'edge':\n        # Weighted edge replacement with 2-opt*\n        edge_weights = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            edge_weights.append([\n                weights[0] * distance_matrix_1[node1, node2],\n                weights[1] * distance_matrix_2[node1, node2],\n                weights[2] * distance_matrix_3[node1, node2]\n            ])\n\n        worst_edge = np.argmax(np.sum(edge_weights, axis=1))\n        i = worst_edge\n        j = (worst_edge + 1) % n\n\n        # Find alternative path\n        candidates = []\n        for k in range(n):\n            if k != i and k != j and (k+1)%n != i and (k+1)%n != j:\n                candidates.append(k)\n\n        if candidates:\n            k = np.random.choice(candidates)\n            if k < i:\n                new_solution[k+1:i+1] = new_solution[k+1:i+1][::-1]\n            else:\n                new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n    else:  # insertion perturbation\n        # Objective-aware node insertion\n        obj_values = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_values.append([\n                weights[0] * distance_matrix_1[node1, node2],\n                weights[1] * distance_matrix_2[node1, node2],\n                weights[2] * distance_matrix_3[node1, node2]\n            ])\n\n        worst_node = np.argmax(np.sum(obj_values, axis=1))\n        node_to_move = new_solution[worst_node]\n        new_solution = np.delete(new_solution, worst_node)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Acceptance criteria with trade-off awareness\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    weighted_improvement = sum((new - orig) * w for orig, new, w in zip(original_costs, new_costs, weights))\n    tradeoff_factor = np.std([(new - orig)/orig for orig, new in zip(original_costs, new_costs) if orig != 0])\n    accept_prob = 0.3 + 0.4 * (weighted_improvement / sum(original_costs)) - 0.2 * tradeoff_factor\n\n    if weighted_improvement > 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7863534661051702,
            1.6892656922340392
        ]
    },
    {
        "algorithm": "The algorithm dynamically identifies the least dominated objective and selects a high-crowding-distance solution from the archive, then applies an objective-biased segment swap to exchange segments between the worst-performing path and another objective's path, ensuring feasibility through careful boundary handling. It prioritizes underperforming objectives while maintaining tour validity through segment swaps of variable length (2-4 nodes). The method balances exploration and exploitation by focusing on both dominance and diversity in the archive.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n\n    # Select the least dominated objective\n    least_dominated_obj = np.argmin(dominance)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance in this objective\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Perform segment swap\n            segment_length = np.random.randint(2, min(5, n//3))\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Swap segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                # Handle wrap-around cases\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                # Perform the swap\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.5911691427935126,
            0.250174880027771
        ]
    },
    {
        "algorithm": "This algorithm implements a dynamic multi-objective local search for the Tri-objective TSP, prioritizing objectives based on their dominance in the archive while alternating between segment-based perturbations and edge exchanges. It uses a weighted diversity selection to choose promising solutions and employs objective-aware perturbations (60% segment-based, 40% edge-based) with a probabilistic acceptance criterion that favors solutions improving more objectives. The method balances exploration and exploitation by dynamically adjusting perturbation strategies based on objective priorities and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity using weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.std(normalized_obj, axis=0) + 1e-10)\n    diversity_scores = np.sum(weights * normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Dynamic objective prioritization\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    priority_order = np.argsort(obj_dominance)\n    current_obj = priority_order[np.random.choice(min(2, len(priority_order)))]\n\n    # Adaptive local search with objective-aware perturbations\n    if np.random.rand() < 0.6:  # 60% chance for segment-based perturbation\n        segment_size = max(2, int(0.4 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[i:i+segment_size]\n\n        # Objective-aware segment reversal\n        obj_values = []\n        for k in range(len(segment)-1):\n            node1, node2 = segment[k], segment[k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        if np.random.rand() < 0.7:  # 70% chance to reverse based on current objective\n            obj_values = np.array(obj_values)[:, current_obj]\n            worst_segment = np.argmax(obj_values)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Random segment reversal\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware edge exchange with 3-opt\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by current objective\n        obj_edges.sort(key=lambda x: x[current_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 3-opt move to replace worst edge\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Enhanced probabilistic acceptance\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    accept_prob = 0.3 + 0.4 * (improvement_count / 3)  # Base 30% + 40% per objective improved\n\n    if improvement_count == 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7560779850487018,
            0.4668965101242065
        ]
    },
    {
        "algorithm": "The algorithm first identifies the least improved objective by analyzing the archive's dominance structure, then selects a solution with high crowding distance in that objective, and applies a novel objective-aware segment swap that combines 2-opt with segment lengths determined by the objectives' performance ratios, ensuring feasibility through dominance-aware boundary handling and multi-objective segment scoring. The method prioritizes the least improved objective while balancing improvements across all three objectives through segment-based swaps and dynamic segment length adjustment based on performance ratios.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective statistics\n    objectives = np.array([obj for _, obj in archive])\n    obj_means = np.mean(objectives, axis=0)\n    obj_stds = np.std(objectives, axis=0)\n\n    # Select least improved objective (lowest mean relative to std)\n    selected_obj = np.argmin(obj_means / (obj_stds + 1e-8))\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[selected_obj]\n\n    # Calculate crowding distance in selected objective\n    obj_values = objectives[:, selected_obj]\n    sorted_idx = np.argsort(obj_values)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = obj_values[sorted_idx[i+1]] - obj_values[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate segment scores based on objective performance ratios\n    segment_scores = np.zeros(n)\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        segment_scores[i] = np.prod([m[node1, node2] / (obj_means[j] + 1e-8) for j, m in enumerate(distance_matrices)])\n\n    # Find worst and best segments\n    worst_segment = np.argmax(segment_scores)\n    other_objs = [i for i in range(3) if i != selected_obj]\n    best_segments = []\n    for obj in other_objs:\n        obj_scores = np.zeros(n)\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_scores[i] = distance_matrices[obj][node1, node2] / (obj_means[obj] + 1e-8)\n        best_segments.append(np.argmin(obj_scores))\n\n    # Determine segment length based on objective performance ratios\n    performance_ratios = obj_means / (obj_stds + 1e-8)\n    segment_length = max(2, min(5, int(3 * performance_ratios[selected_obj] + 1)))\n\n    # Perform objective-aware segment swap\n    for best_seg in best_segments:\n        # Extract segments\n        worst_end = (worst_segment + segment_length) % n\n        best_end = (best_seg + segment_length) % n\n\n        if worst_segment < worst_end:\n            worst_segment_nodes = new_solution[worst_segment:worst_end]\n        else:\n            worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n        if best_seg < best_end:\n            best_segment_nodes = new_solution[best_seg:best_end]\n        else:\n            best_segment_nodes = np.concatenate([new_solution[best_seg:], new_solution[:best_end]])\n\n        # Create new solution by swapping segments\n        if worst_segment < worst_end and best_seg < best_end:\n            new_solution = np.concatenate([\n                new_solution[:worst_segment],\n                best_segment_nodes,\n                new_solution[worst_end:best_seg],\n                worst_segment_nodes,\n                new_solution[best_end:]\n            ])\n        else:\n            # Handle wrap-around case\n            temp = np.concatenate([\n                new_solution[worst_segment:],\n                new_solution[:worst_end],\n                best_segment_nodes,\n                new_solution[best_end:best_seg],\n                worst_segment_nodes,\n                new_solution[best_seg:]\n            ])\n            new_solution = np.concatenate([temp[n-worst_segment:], temp[:n-worst_segment]])\n\n        # Ensure solution is valid\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7050617778058887,
            0.3354302644729614
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive based on objective diversity, then applies adaptive local search with dynamic perturbation intensity (ranging from small swaps to large segment reversals) based on the solution's dominance, while ensuring feasibility through probabilistic acceptance that prioritizes multi-objective improvement. It balances exploration and exploitation by varying perturbation intensity and accepting solutions probabilistically when improvements are marginal.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (not just minimal sum)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic perturbation intensity based on objective dominance\n        obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n        perturbation_intensity = 1 - np.mean(obj_dominance)  # Higher when less dominated\n\n        # Multi-objective local search with varying intensity\n        if np.random.rand() < perturbation_intensity:\n            # Large-scale perturbation: reverse a large segment\n            segment_size = max(2, int(perturbation_intensity * n))\n            i = np.random.randint(0, n - segment_size + 1)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Small-scale perturbation: swap or reverse small segments\n            if np.random.rand() < 0.5:\n                # Small swap\n                i, j = np.random.choice(n, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Small reverse\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Probabilistic acceptance based on multi-objective improvement\n        original_costs = [\n            sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        ]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n        if improvement_count < 2 and np.random.rand() > 0.3:  # Accept with 30% probability if only one objective improves\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.73888223731041,
            0.4111027121543884
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high crowding distance in the least dominated objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n    selected_obj = np.argmin(dominance)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[selected_obj]\n\n    # Calculate crowding distance in the selected objective's space\n    normalized_obj = (objectives[:, selected_obj] - np.min(objectives[:, selected_obj])) / (np.max(objectives[:, selected_obj]) - np.min(objectives[:, selected_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Perform objective-aware 4-opt local search\n    def calculate_segment_cost(segment, matrix):\n        cost = 0\n        for i in range(len(segment)-1):\n            cost += matrix[segment[i], segment[i+1]]\n        return cost\n\n    # Find worst segment in the selected objective\n    segment_length = max(2, min(4, int(0.3 * n)))\n    segment_costs = []\n    for i in range(n):\n        segment = new_solution[i:i+segment_length]\n        if len(segment) < segment_length:\n            segment = np.concatenate([segment, new_solution[:segment_length - len(segment)]])\n        segment_costs.append(calculate_segment_cost(segment, selected_matrix))\n\n    worst_segment_idx = np.argmax(segment_costs)\n    worst_segment = new_solution[worst_segment_idx:worst_segment_idx+segment_length]\n    if len(worst_segment) < segment_length:\n        worst_segment = np.concatenate([worst_segment, new_solution[:segment_length - len(worst_segment)]])\n\n    # Find best segment in other objectives\n    best_segments = []\n    other_objs = [i for i in range(3) if i != selected_obj]\n    for obj in other_objs:\n        obj_matrix = distance_matrices[obj]\n        obj_segment_costs = []\n        for i in range(n):\n            segment = new_solution[i:i+segment_length]\n            if len(segment) < segment_length:\n                segment = np.concatenate([segment, new_solution[:segment_length - len(segment)]])\n            obj_segment_costs.append(calculate_segment_cost(segment, obj_matrix))\n        best_segment_idx = np.argmin(obj_segment_costs)\n        best_segment = new_solution[best_segment_idx:best_segment_idx+segment_length]\n        if len(best_segment) < segment_length:\n            best_segment = np.concatenate([best_segment, new_solution[:segment_length - len(best_segment)]])\n        best_segments.append(best_segment)\n\n    # Replace worst segment with best segments from other objectives\n    for best_segment in best_segments:\n        # Find position to insert best segment\n        insert_pos = np.random.randint(0, n)\n        # Create new solution\n        if insert_pos + segment_length > n:\n            new_solution = np.concatenate([\n                new_solution[:worst_segment_idx],\n                best_segment,\n                new_solution[worst_segment_idx+segment_length:insert_pos],\n                worst_segment,\n                new_solution[insert_pos:]\n            ])\n        else:\n            new_solution = np.concatenate([\n                new_solution[:worst_segment_idx],\n                best_segment,\n                new_solution[worst_segment_idx+segment_length:insert_pos],\n                worst_segment,\n                new_solution[insert_pos:]\n            ])\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6289459293998515,
            0.30111687183380126
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with high crowding distance in the most improved objective, applies a hybrid local search combining 3-opt and segment reversal with adaptive segment lengths based on objective diversity, and ensures feasibility through dominance-aware segment selection and validation. It selects the most promising solution from the archive, identifies the worst segment based on the selected objective, and improves it by swapping with better segments from other objectives while maintaining tour validity. The segment length is dynamically adjusted based on objective diversity to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_obj = np.argmax(improvement)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[selected_obj]\n\n    normalized_obj = (objectives[:, selected_obj] - np.min(objectives[:, selected_obj])) / (np.max(objectives[:, selected_obj]) - np.min(objectives[:, selected_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    segment_scores = np.zeros(n)\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        segment_scores[i] = np.sum([m[node1, node2] for m in distance_matrices])\n\n    worst_segment = np.argmax(segment_scores)\n    other_objs = [i for i in range(3) if i != selected_obj]\n    best_segments = []\n    for obj in other_objs:\n        obj_scores = np.zeros(n)\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_scores[i] = distance_matrices[obj][node1, node2]\n        best_segments.append(np.argmin(obj_scores))\n\n    obj_diversity = np.std(objectives, axis=0)\n    segment_length = max(2, min(5, int(4 * (obj_diversity[selected_obj] / np.sum(obj_diversity)) + 2)))\n\n    for best_seg in best_segments:\n        worst_end = (worst_segment + segment_length) % n\n        best_end = (best_seg + segment_length) % n\n\n        if worst_segment < worst_end:\n            worst_segment_nodes = new_solution[worst_segment:worst_end]\n        else:\n            worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n        if best_seg < best_end:\n            best_segment_nodes = new_solution[best_seg:best_end]\n        else:\n            best_segment_nodes = np.concatenate([new_solution[best_seg:], new_solution[:best_end]])\n\n        if worst_segment < worst_end:\n            new_solution = np.concatenate([\n                new_solution[:worst_segment],\n                new_solution[best_seg:best_end],\n                new_solution[worst_segment:best_seg],\n                new_solution[best_end:worst_end],\n                new_solution[worst_end:]\n            ])\n        else:\n            temp = np.concatenate([\n                new_solution[worst_segment:],\n                new_solution[:worst_end],\n                new_solution[best_seg:best_end],\n                new_solution[worst_end:best_seg],\n                new_solution[best_end:]\n            ])\n            new_solution = np.concatenate([temp[n-worst_segment:], temp[:n-worst_segment]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6753376025598593,
            0.3242811679840088
        ]
    }
]