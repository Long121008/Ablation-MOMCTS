[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive and applies a hybrid local search (70% 2-opt, 30% 3-opt) to generate a neighbor, ensuring feasibility by always reversing or reordering segments of the tour. The selection prioritizes solutions with minimal total cost, while the local search balances exploration (random segment selection) and exploitation (reversing segments) to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt or 3-opt based on a random choice\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt, else 3-opt\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.8028366341020267,
            0.34138243198394774
        ]
    },
    {
        "algorithm": "The algorithm dynamically identifies the least dominated objective, selects a high-crowding-distance solution from the archive, and applies an adaptive segment inversion operator that swaps variable-length segments (2-5 nodes) between worst-performing edges in the least dominated objective and best-performing edges in another randomly chosen objective, ensuring feasibility through careful boundary handling. The operator prioritizes underperforming objectives while balancing exploration and exploitation by adaptively adjusting segment lengths based on dominance and diversity in the archive.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n\n    # Select the least dominated objective\n    least_dominated_obj = np.argmin(dominance)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance in this objective\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Perform segment inversion\n            segment_length = np.random.randint(2, min(6, n//2))\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Invert segments\n            worst_segment_nodes = worst_segment_nodes[::-1]\n            best_segment_nodes = best_segment_nodes[::-1]\n\n            # Swap inverted segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                # Handle wrap-around cases\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                # Perform the swap\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7057904658048765,
            0.19627649784088136
        ]
    },
    {
        "algorithm": "The algorithm prioritizes the most diverse objective (highest standard deviation in objectives) and selects a high-crowding-distance solution from the archive, then applies an adaptive segment relinking operator that swaps segments between worst-performing edges in the most diverse objective and best-performing edges in another objective, using dynamic segment lengths based on objective diversity. The selection is based on crowding distance in the most diverse objective's space, while the relinking adapts segment sizes proportionally to diversity ratios.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Calculate diversity for each objective\n    diversity = np.std(objectives, axis=0)\n    most_diverse_obj = np.argmax(diversity)\n    selected_matrix = distance_matrices[most_diverse_obj]\n\n    # Calculate crowding distance in the most diverse objective's space\n    normalized_obj = (objectives[:, most_diverse_obj] - np.min(objectives[:, most_diverse_obj])) / (np.max(objectives[:, most_diverse_obj]) - np.min(objectives[:, most_diverse_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the most diverse objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != most_diverse_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Dynamic segment length based on objective diversity\n            segment_length = min(3, max(2, int(np.ceil(np.sqrt(n) * (diversity[most_diverse_obj] / np.sum(diversity))))))\n\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Relink segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7111454534642736,
            0.21573500633239745
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with high crowding distance in the least dominated objective, then applies a hybrid local search that swaps segments between worst-performing edges in the least dominated objective and best-performing edges in other objectives, dynamically adjusting segment lengths based on objective diversity to ensure balanced multi-objective optimization while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Calculate dominance counts for each objective\n    dominance_counts = np.zeros(3)\n    for i in range(3):\n        for j in range(3):\n            if j != i:\n                if np.all(objectives[:, i] <= objectives[:, j]):\n                    dominance_counts[i] += 1\n\n    least_dominated_obj = np.argmin(dominance_counts)\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segments in other objectives\n        best_segments = []\n        for obj in range(3):\n            if obj != least_dominated_obj:\n                best_segment = None\n                best_score = np.inf\n                for i in range(n):\n                    node1, node2 = new_solution[i], new_solution[(i+1)%n]\n                    score = distance_matrices[obj][node1, node2]\n                    if score < best_score:\n                        best_score = score\n                        best_segment = i\n                if best_segment is not None:\n                    best_segments.append(best_segment)\n\n        if best_segments:\n            # Dynamic segment length based on objective diversity\n            obj_diversity = np.std(objectives, axis=0)\n            segment_length = max(2, min(5, int(3 * (obj_diversity[least_dominated_obj] / np.sum(obj_diversity)) + 2)))\n\n            for best_seg in best_segments:\n                worst_end = (worst_segment + segment_length) % n\n                best_end = (best_seg + segment_length) % n\n\n                # Extract segments\n                if worst_segment < worst_end:\n                    worst_segment_nodes = new_solution[worst_segment:worst_end]\n                else:\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n                if best_seg < best_end:\n                    best_segment_nodes = new_solution[best_seg:best_end]\n                else:\n                    best_segment_nodes = np.concatenate([new_solution[best_seg:], new_solution[:best_end]])\n\n                # Perform 3-opt style swap\n                if worst_segment < worst_end and best_seg < best_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                    new_solution[best_seg:best_end] = worst_segment_nodes\n                else:\n                    if worst_segment > worst_end:\n                        temp = worst_segment_nodes.copy()\n                        new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                        new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                    if best_seg > best_end:\n                        temp = best_segment_nodes.copy()\n                        new_solution[best_seg:] = temp[:len(new_solution[best_seg:])]\n                        new_solution[:best_end] = temp[len(new_solution[best_seg:]):]\n\n                    if worst_segment < worst_end:\n                        new_solution[worst_segment:worst_end] = best_segment_nodes\n                    if best_seg < best_end:\n                        new_solution[best_seg:best_end] = worst_segment_nodes\n\n                if len(np.unique(new_solution)) == n:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.721025833762664,
            0.23054473400115966
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in least dominated objective\n    objectives = np.array([obj for _, obj in archive])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Calculate dominance counts for each objective\n    dominance_counts = np.zeros(3)\n    for i in range(3):\n        for j in range(3):\n            if j != i:\n                if np.all(objectives[:, i] <= objectives[:, j]):\n                    dominance_counts[i] += 1\n\n    least_dominated_obj = np.argmin(dominance_counts)\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Adaptive segment length based on dominance\n    segment_length = max(2, min(5, int(3 * (dominance_counts[least_dominated_obj] / (sum(dominance_counts) + 1)) + 2)))\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective with adaptive scaling\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n\n        # Calculate objective scaling factor\n        obj_range = np.max(objectives[:, other_obj]) - np.min(objectives[:, other_obj])\n        scaling_factor = 1.0 + 0.2 * (obj_range / (np.max(objectives) - np.min(objectives) + 1e-8))\n\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2] * scaling_factor\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Exchange segments with dynamic length\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Perform segment exchange with feasibility check\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    # Hybrid 2-opt/3-opt move with probability based on dominance\n    dominance_ratio = dominance_counts[least_dominated_obj] / (sum(dominance_counts) + 1)\n    if np.random.rand() < 0.5 + 0.3 * dominance_ratio:\n        # 3-opt move with feasibility check\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        if (i+1) <= j and (j+1) <= k:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # 2-opt move with feasibility check\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if i+1 <= j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Enhanced acceptance criteria with multi-objective improvement\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    tradeoff_factor = 0.15 * np.sum([abs((new - orig)/orig) for orig, new in zip(original_costs, new_costs)])\n    accept_prob = 0.3 + 0.5 * (improvement_count / 3) - 0.25 * tradeoff_factor\n\n    if improvement_count == 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7305876212539583,
            0.29224362373352053
        ]
    },
    {
        "algorithm": "The algorithm prioritizes the least diverse objective (lowest standard deviation) to focus on stable regions, selects a solution with high crowding distance in that objective's space, then applies a dynamic 2-opt* operator that exchanges segments between worst-performing edges in the least diverse objective and best-performing edges in another objective, with segment lengths adaptively determined by the ratio of objective diversity.\n\nKey variables: The least diverse objective is identified by computing standard deviations of all objectives, and the solution with the highest crowding distance in that objective's space is selected. The 2-opt* operator dynamically adjusts segment lengths based on diversity ratios, ensuring feasible TSP tours while optimizing across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Calculate diversity for each objective\n    diversity = np.std(objectives, axis=0)\n    least_diverse_obj = np.argmin(diversity)\n    selected_matrix = distance_matrices[least_diverse_obj]\n\n    # Calculate crowding distance in the least diverse objective's space\n    normalized_obj = (objectives[:, least_diverse_obj] - np.min(objectives[:, least_diverse_obj])) / (np.max(objectives[:, least_diverse_obj]) - np.min(objectives[:, least_diverse_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least diverse objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_diverse_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Dynamic segment length based on objective diversity ratio\n            segment_length = min(4, max(2, int(np.ceil(np.sqrt(n) * (diversity[least_diverse_obj] / np.sum(diversity))))))\n\n            worst_start = worst_segment\n            worst_end = (worst_segment + segment_length) % n\n            best_start = best_segment\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_start < worst_end:\n                worst_segment_nodes = new_solution[worst_start:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_start:], new_solution[:worst_end]])\n\n            if best_start < best_end:\n                best_segment_nodes = new_solution[best_start:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_start:], new_solution[:best_end]])\n\n            # Perform 2-opt* exchange\n            if worst_start < worst_end and best_start < best_end:\n                new_solution[worst_start:worst_end] = best_segment_nodes[::-1]\n                new_solution[best_start:best_end] = worst_segment_nodes[::-1]\n            else:\n                if worst_start > worst_end:\n                    temp = worst_segment_nodes[::-1].copy()\n                    new_solution[worst_start:] = temp[:len(new_solution[worst_start:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_start:]):]\n\n                if best_start > best_end:\n                    temp = best_segment_nodes[::-1].copy()\n                    new_solution[best_start:] = temp[:len(new_solution[best_start:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_start:]):]\n\n                if worst_start < worst_end:\n                    new_solution[worst_start:worst_end] = best_segment_nodes[::-1]\n                if best_start < best_end:\n                    new_solution[best_start:best_end] = worst_segment_nodes[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6638537659017861,
            0.19781675338745117
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-objective local search using adaptive weight-based selection with hybrid perturbations (segment rotations, edge exchanges, and node insertions), prioritizing solutions with balanced objective improvements through dominance-aware perturbation selection and acceptance criteria that balance weighted improvements and trade-off awareness. It intelligently selects base solutions via weighted objective scores and applies targeted perturbations to edges or segments, with acceptance probabilities adjusted based on improvement magnitude and objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weight-based selection\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Dominance-aware perturbation selection\n    dominance_counts = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0)\n    perturbation_type = np.random.choice(['segment', 'edge', 'insertion'], p=[0.3, 0.4, 0.3])\n\n    if perturbation_type == 'segment':\n        segment_size = max(2, min(n//2, int(0.4 * n + np.random.randn() * 0.15 * n)))\n        i = np.random.randint(0, n - segment_size + 1)\n\n        # Objective-aware segment reversal\n        obj_values = []\n        for k in range(segment_size-1):\n            node1, node2 = new_solution[i+k], new_solution[i+k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        worst_obj = np.argmax(np.dot(np.array(obj_values), weights))\n        if np.random.rand() < 0.7:\n            new_solution[i+worst_obj:i+worst_obj+2] = new_solution[i+worst_obj+1], new_solution[i+worst_obj]\n        else:\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    elif perturbation_type == 'edge':\n        # Weighted edge replacement with 2-opt*\n        edge_weights = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            edge_weights.append([\n                weights[0] * distance_matrix_1[node1, node2],\n                weights[1] * distance_matrix_2[node1, node2],\n                weights[2] * distance_matrix_3[node1, node2]\n            ])\n\n        worst_edge = np.argmax(np.sum(edge_weights, axis=1))\n        i = worst_edge\n        j = (worst_edge + 1) % n\n\n        # Find alternative path\n        candidates = []\n        for k in range(n):\n            if k != i and k != j and (k+1)%n != i and (k+1)%n != j:\n                candidates.append(k)\n\n        if candidates:\n            k = np.random.choice(candidates)\n            if k < i:\n                new_solution[k+1:i+1] = new_solution[k+1:i+1][::-1]\n            else:\n                new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n    else:  # insertion perturbation\n        # Objective-aware node insertion\n        obj_values = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_values.append([\n                weights[0] * distance_matrix_1[node1, node2],\n                weights[1] * distance_matrix_2[node1, node2],\n                weights[2] * distance_matrix_3[node1, node2]\n            ])\n\n        worst_node = np.argmax(np.sum(obj_values, axis=1))\n        node_to_move = new_solution[worst_node]\n        new_solution = np.delete(new_solution, worst_node)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Acceptance criteria with trade-off awareness\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    weighted_improvement = sum((new - orig) * w for orig, new, w in zip(original_costs, new_costs, weights))\n    tradeoff_factor = np.std([(new - orig)/orig for orig, new in zip(original_costs, new_costs) if orig != 0])\n    accept_prob = 0.3 + 0.4 * (weighted_improvement / sum(original_costs)) - 0.2 * tradeoff_factor\n\n    if weighted_improvement > 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7863534661051702,
            1.6892656922340392
        ]
    },
    {
        "algorithm": "This algorithm implements a dynamic multi-objective local search for the Tri-objective TSP, prioritizing objectives based on their dominance in the archive while alternating between segment-based perturbations and edge exchanges. It uses a weighted diversity selection to choose promising solutions and employs objective-aware perturbations (60% segment-based, 40% edge-based) with a probabilistic acceptance criterion that favors solutions improving more objectives. The method balances exploration and exploitation by dynamically adjusting perturbation strategies based on objective priorities and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity using weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.std(normalized_obj, axis=0) + 1e-10)\n    diversity_scores = np.sum(weights * normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Dynamic objective prioritization\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    priority_order = np.argsort(obj_dominance)\n    current_obj = priority_order[np.random.choice(min(2, len(priority_order)))]\n\n    # Adaptive local search with objective-aware perturbations\n    if np.random.rand() < 0.6:  # 60% chance for segment-based perturbation\n        segment_size = max(2, int(0.4 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[i:i+segment_size]\n\n        # Objective-aware segment reversal\n        obj_values = []\n        for k in range(len(segment)-1):\n            node1, node2 = segment[k], segment[k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        if np.random.rand() < 0.7:  # 70% chance to reverse based on current objective\n            obj_values = np.array(obj_values)[:, current_obj]\n            worst_segment = np.argmax(obj_values)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Random segment reversal\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware edge exchange with 3-opt\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by current objective\n        obj_edges.sort(key=lambda x: x[current_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 3-opt move to replace worst edge\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Enhanced probabilistic acceptance\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    accept_prob = 0.3 + 0.4 * (improvement_count / 3)  # Base 30% + 40% per objective improved\n\n    if improvement_count == 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7560779850487018,
            0.4668965101242065
        ]
    },
    {
        "algorithm": "This algorithm selects a high-crowding-distance solution in the least dominated objective space, then applies a hybrid local search combining 2-opt and 3-opt moves with adaptive segment lengths, prioritizing dominance-aware optimization and feasibility checks. It dynamically balances exploration across objectives by favoring moves that improve the least dominated objective while considering segment diversity, ensuring multi-objective progress while maintaining tour validity.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Calculate dominance counts for each objective\n    dominance_counts = np.zeros(3)\n    for i in range(3):\n        for j in range(3):\n            if j != i:\n                if np.all(objectives[:, i] <= objectives[:, j]):\n                    dominance_counts[i] += 1\n\n    least_dominated_obj = np.argmin(dominance_counts)\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Dynamic segment length based on dominance and diversity\n            obj_diversity = np.std(objectives, axis=0)\n            segment_length = max(2, min(5, int(3 * (dominance_counts[least_dominated_obj] / (sum(dominance_counts) + 1)) + 2)))\n\n            # Decide between 2-opt and 3-opt based on dominance\n            if np.random.rand() < (dominance_counts[least_dominated_obj] / (sum(dominance_counts) + 1)):\n                # 2-opt move\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # 3-opt move with segment relinking\n                worst_end = (worst_segment + segment_length) % n\n                best_end = (best_segment + segment_length) % n\n\n                if worst_segment < worst_end:\n                    worst_segment_nodes = new_solution[worst_segment:worst_end]\n                else:\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n                if best_segment < best_end:\n                    best_segment_nodes = new_solution[best_segment:best_end]\n                else:\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n                if worst_segment < worst_end and best_segment < best_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n                else:\n                    if worst_segment > worst_end:\n                        temp = worst_segment_nodes.copy()\n                        new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                        new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                    if best_segment > best_end:\n                        temp = best_segment_nodes.copy()\n                        new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                        new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                    if worst_segment < worst_end:\n                        new_solution[worst_segment:worst_end] = best_segment_nodes\n                    if best_segment < best_end:\n                        new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7034183285849747,
            0.22789831161499025
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid crowding-dominance metric, then applies an objective-balanced segment inversion operator that adaptively inverts segments in the least dominated objective while preserving feasibility, combining segment inversion with dominance-aware edge selection to balance multi-objective optimization. It prioritizes the least dominated objective for segment selection and uses dominance metrics to determine segment lengths, ensuring high-quality neighbor solutions across all three objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n\n    # Calculate hybrid crowding-dominance metric\n    crowding_dominance = np.zeros(len(archive))\n    for m in range(3):\n        normalized_obj = (objectives[:, m] - np.min(objectives[:, m])) / (np.max(objectives[:, m]) - np.min(objectives[:, m]) + 1e-8)\n        sorted_idx = np.argsort(normalized_obj)\n        crowding_dist = np.zeros(len(archive))\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n        dominance = np.sum(objectives <= objectives[:, m:m+1], axis=0) / len(archive)\n        crowding_dominance += crowding_dist * (1 - dominance[m])\n\n    selected_idx = np.argmax(crowding_dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Objective-balanced segment inversion\n    least_dominated_obj = np.argmin(np.sum(objectives <= objectives[selected_idx], axis=0) / len(archive))\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Find worst segment in least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Adaptive segment length based on dominance\n            dominance = np.sum(objectives <= objectives[selected_idx], axis=0) / len(archive)\n            segment_length = int(np.clip(np.random.normal(3, 1), 2, min(6, n//2)))\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract and invert segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            worst_segment_nodes = worst_segment_nodes[::-1]\n            best_segment_nodes = best_segment_nodes[::-1]\n\n            # Swap inverted segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                # Handle wrap-around cases\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.740035414534395,
            0.3736379027366638
        ]
    }
]