[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive and applies a hybrid local search (70% 2-opt, 30% 3-opt) to generate a neighbor, ensuring feasibility by always reversing or reordering segments of the tour. The selection prioritizes solutions with minimal total cost, while the local search balances exploration (random segment selection) and exploitation (reversing segments) to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt or 3-opt based on a random choice\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt, else 3-opt\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.8028366341020267,
            0.34138243198394774
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive based on objective diversity, then applies adaptive local search with dynamic perturbation intensity (ranging from small swaps to large segment reversals) based on the solution's dominance, while ensuring feasibility through probabilistic acceptance that prioritizes multi-objective improvement. It balances exploration and exploitation by varying perturbation intensity and accepting solutions probabilistically when improvements are marginal.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (not just minimal sum)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic perturbation intensity based on objective dominance\n        obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n        perturbation_intensity = 1 - np.mean(obj_dominance)  # Higher when less dominated\n\n        # Multi-objective local search with varying intensity\n        if np.random.rand() < perturbation_intensity:\n            # Large-scale perturbation: reverse a large segment\n            segment_size = max(2, int(perturbation_intensity * n))\n            i = np.random.randint(0, n - segment_size + 1)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Small-scale perturbation: swap or reverse small segments\n            if np.random.rand() < 0.5:\n                # Small swap\n                i, j = np.random.choice(n, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Small reverse\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Probabilistic acceptance based on multi-objective improvement\n        original_costs = [\n            sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        ]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n        if improvement_count < 2 and np.random.rand() > 0.3:  # Accept with 30% probability if only one objective improves\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.73888223731041,
            0.4111027121543884
        ]
    },
    {
        "algorithm": "The algorithm selects the most under-optimized solution from the archive (based on objective ratios) and applies a hybrid local search (60% 3-opt, 40% 4-opt) to generate a neighbor, prioritizing exploration in the least optimized objective space. It intelligently adapts the search strategy to the problem size and ensures feasibility by maintaining valid TSP tours. The selection criteria and adaptive local search are key design choices for balancing exploration and exploitation across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate average objective costs across all solutions\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n    avg_obj3 = np.mean([obj[2] for _, obj in archive])\n\n    # Find the solution with the lowest objective in the least optimized space\n    min_ratios = []\n    for sol, obj in archive:\n        ratio1 = obj[0] / avg_obj1 if avg_obj1 > 0 else 0\n        ratio2 = obj[1] / avg_obj2 if avg_obj2 > 0 else 0\n        ratio3 = obj[2] / avg_obj3 if avg_obj3 > 0 else 0\n        min_ratios.append(min(ratio1, ratio2, ratio3))\n\n    selected_idx = np.argmin(min_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 60% probability, apply 3-opt, else 4-opt\n        if np.random.rand() < 0.6:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # 4-opt move (select 4 distinct indices and reorder segments)\n            a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            # Reorder segments in a different configuration\n            new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n\n    return new_solution\n\n",
        "score": [
            -0.43905360579104036,
            0.3563701272010803
        ]
    },
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive, then applies a multi-objective edge exchange by identifying the worst edges in each objective space and performing a 2-opt move between randomly chosen positions to generate a neighbor solution, ensuring feasibility by maintaining a valid tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply multi-objective edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform exchange\n\n    # Randomly select two edges from different objectives\n    obj1_edges = []\n    obj2_edges = []\n    obj3_edges = []\n\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        obj1_edges.append((node1, node2, distance_matrix_1[node1, node2]))\n        obj2_edges.append((node1, node2, distance_matrix_2[node1, node2]))\n        obj3_edges.append((node1, node2, distance_matrix_3[node1, node2]))\n\n    # Sort edges by their distance in each objective\n    obj1_edges.sort(key=lambda x: x[2])\n    obj2_edges.sort(key=lambda x: x[2])\n    obj3_edges.sort(key=lambda x: x[2])\n\n    # Select the worst edges from each objective\n    worst_edge1 = obj1_edges[-1][:2]\n    worst_edge2 = obj2_edges[-1][:2]\n    worst_edge3 = obj3_edges[-1][:2]\n\n    # Find positions of these edges in the tour\n    pos1 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge1 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge1]\n    pos2 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge2 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge2]\n    pos3 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge3 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge3]\n\n    # Select one position from each\n    if pos1 and pos2 and pos3:\n        pos1, pos2, pos3 = pos1[0], pos2[0], pos3[0]\n\n        # Swap nodes to create a new feasible tour\n        # This is a simplified version - a proper implementation would need more complex handling\n        # Here we just perform a 2-opt move between two random positions\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6673042935749989,
            0.4514923572540283
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest sum of objectives) and applies a hybrid local search combining 2-opt and 3-opt moves, randomly perturbing segments and reverting changes if they don't improve any objective. It prioritizes solutions with lower objective values and ensures feasibility by validating moves against all three distance matrices.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt moves across all three objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move if it improves at least one objective\n    if np.random.rand() < 0.5 and j - i >= 2:\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Check if the move improves at least one objective\n        original_cost1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        original_cost2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        original_cost3 = sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n        new_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2 and new_cost3 >= original_cost3):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    # Apply 3-opt move if it improves at least one objective\n    else:\n        if j - i >= 3:\n            segment = new_solution[i:j+1]\n            # Randomly shuffle the segment\n            np.random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n            # Check if the move improves at least one objective\n            original_cost1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            original_cost2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            original_cost3 = sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2 and new_cost3 >= original_cost3):\n                new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "score": [
            -0.6759595462724148,
            1.3288514852523803
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from an archive using crowding distance to prioritize well-distributed Pareto-optimal solutions, then applies a hybrid local search combining 2-opt moves with objective-specific edge swaps to generate improved neighbors while ensuring feasibility. The method intelligently balances exploration and exploitation by focusing on the worst edges in each objective space and performing targeted improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance\n    def crowding_distance(solutions, objectives):\n        n = len(solutions)\n        if n <= 2:\n            return [1.0] * n\n\n        # Normalize objectives\n        objectives = np.array(objectives)\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(3)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(3):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n            for j in range(1, n-1):\n                distances[sorted_indices[i][j]] += (normalized[sorted_indices[i][j+1], i] - normalized[sorted_indices[i][j-1], i])\n\n        return distances\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance(solutions, objectives)\n\n    # Select the solution with highest crowding distance\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Perform an objective-specific edge swap\n        obj_idx = np.random.randint(3)\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the worst edge in the current solution for this objective\n        worst_edge = -1\n        worst_cost = -1\n        for k in range(n):\n            u = new_solution[k]\n            v = new_solution[(k+1)%n]\n            cost = dm[u, v]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = k\n\n        # Try to replace the worst edge with a better one\n        if worst_edge != -1:\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%n]\n            # Find the best edge to replace it with\n            best_improvement = 0\n            best_i = -1\n            best_j = -1\n            for i in range(n):\n                for j in range(i+1, n):\n                    u1 = new_solution[i]\n                    v1 = new_solution[j]\n                    # Check if swapping edges (u,v) and (u1,v1) improves the solution\n                    old_cost = dm[u, v] + dm[u1, v1]\n                    new_cost = dm[u, u1] + dm[v, v1]\n                    if new_cost < old_cost:\n                        improvement = old_cost - new_cost\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_i = i\n                            best_j = j\n            if best_i != -1:\n                # Perform the swap\n                segment = new_solution[best_i:best_j+1]\n                new_solution[best_i:best_j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5417664452207885,
            0.8119198679924011
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive based on objective diversity, then applies a hybrid local search combining 2-opt with a multi-objective edge swap to generate a neighbor solution, ensuring feasibility while optimizing across all three objectives by prioritizing edges with lower combined cost across all spaces. The algorithm intelligently explores the solution space by focusing on high-diversity solutions and using a novel edge-swap mechanism tailored for multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap\n    for k in range(n):\n        if k == i or k == j or k == (i+1)%n or k == (j+1)%n:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        potential_cost = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                          distance_matrix_3[new_solution[k-1], new_solution[i]])\n\n        if potential_cost < current_cost:\n            new_solution[k], new_solution[i] = new_solution[i], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5534343111771481,
            1.617421281337738
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive (measured by objective variance) and applies a hybrid local search combining 2-opt, 3-opt, and a novel objective-weighted segment reversal, prioritizing edges with high combined distance across objectives. The selection emphasizes solutions with balanced objective values, while the local search intelligently reverses segments based on objective weights to improve multi-objective optimization. The method ensures feasibility by maintaining valid TSP tours throughout the process.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objective_variances = [np.var(obj) for _, obj in archive]\n    selected_idx = np.argmax(objective_variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Hybrid local search\n        rand_val = np.random.rand()\n        if rand_val < 0.5:\n            # 2-opt with objective-weighted edge selection\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            # Calculate combined distance for the edge to be reversed\n            edge_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]]) / 3\n            if edge_dist > 0.7 * np.mean(distance_matrix_1):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif rand_val < 0.8:\n            # 3-opt with segment length balancing\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            seg1_len = j - i\n            seg2_len = k - j\n            if abs(seg1_len - seg2_len) > 1:\n                segment1 = new_solution[i:j]\n                segment2 = new_solution[j:k]\n                new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # Objective-weighted segment reversal\n            weights = np.array([obj[0] + obj[1] + obj[2] for _, obj in archive])\n            weights = weights / np.sum(weights)\n            selected_obj = np.random.choice(len(weights), p=weights)\n            obj_weights = np.array(archive[selected_obj][1])\n            obj_weights = obj_weights / np.sum(obj_weights)\n\n            # Select segments based on objective weights\n            i = np.random.choice(n)\n            j = np.random.choice(n)\n            if i > j:\n                i, j = j, i\n            # Reverse segments with higher objective weights\n            if np.random.rand() < obj_weights[1]:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.42910141131118823,
            3.132574200630188
        ]
    }
]