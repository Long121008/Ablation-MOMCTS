[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive and applies a hybrid local search (70% 2-opt, 30% 3-opt) to generate a neighbor, ensuring feasibility by always reversing or reordering segments of the tour. The selection prioritizes solutions with minimal total cost, while the local search balances exploration (random segment selection) and exploitation (reversing segments) to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt or 3-opt based on a random choice\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt, else 3-opt\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.8028366341020267,
            0.34138243198394774
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive based on objective diversity, then applies adaptive local search with dynamic perturbation intensity (ranging from small swaps to large segment reversals) based on the solution's dominance, while ensuring feasibility through probabilistic acceptance that prioritizes multi-objective improvement. It balances exploration and exploitation by varying perturbation intensity and accepting solutions probabilistically when improvements are marginal.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (not just minimal sum)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic perturbation intensity based on objective dominance\n        obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n        perturbation_intensity = 1 - np.mean(obj_dominance)  # Higher when less dominated\n\n        # Multi-objective local search with varying intensity\n        if np.random.rand() < perturbation_intensity:\n            # Large-scale perturbation: reverse a large segment\n            segment_size = max(2, int(perturbation_intensity * n))\n            i = np.random.randint(0, n - segment_size + 1)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Small-scale perturbation: swap or reverse small segments\n            if np.random.rand() < 0.5:\n                # Small swap\n                i, j = np.random.choice(n, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Small reverse\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Probabilistic acceptance based on multi-objective improvement\n        original_costs = [\n            sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        ]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n        if improvement_count < 2 and np.random.rand() > 0.3:  # Accept with 30% probability if only one objective improves\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.73888223731041,
            0.4111027121543884
        ]
    },
    {
        "algorithm": "The algorithm selects the most under-optimized solution from the archive (based on objective ratios) and applies a hybrid local search (60% 3-opt, 40% 4-opt) to generate a neighbor, prioritizing exploration in the least optimized objective space. It intelligently adapts the search strategy to the problem size and ensures feasibility by maintaining valid TSP tours. The selection criteria and adaptive local search are key design choices for balancing exploration and exploitation across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate average objective costs across all solutions\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n    avg_obj3 = np.mean([obj[2] for _, obj in archive])\n\n    # Find the solution with the lowest objective in the least optimized space\n    min_ratios = []\n    for sol, obj in archive:\n        ratio1 = obj[0] / avg_obj1 if avg_obj1 > 0 else 0\n        ratio2 = obj[1] / avg_obj2 if avg_obj2 > 0 else 0\n        ratio3 = obj[2] / avg_obj3 if avg_obj3 > 0 else 0\n        min_ratios.append(min(ratio1, ratio2, ratio3))\n\n    selected_idx = np.argmin(min_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 60% probability, apply 3-opt, else 4-opt\n        if np.random.rand() < 0.6:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # 4-opt move (select 4 distinct indices and reorder segments)\n            a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            # Reorder segments in a different configuration\n            new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n\n    return new_solution\n\n",
        "score": [
            -0.43905360579104036,
            0.3563701272010803
        ]
    },
    {
        "algorithm": "This algorithm implements a dynamic multi-objective local search for the Tri-objective TSP, prioritizing objectives based on their dominance in the archive while alternating between segment-based perturbations and edge exchanges. It uses a weighted diversity selection to choose promising solutions and employs objective-aware perturbations (60% segment-based, 40% edge-based) with a probabilistic acceptance criterion that favors solutions improving more objectives. The method balances exploration and exploitation by dynamically adjusting perturbation strategies based on objective priorities and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity using weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.std(normalized_obj, axis=0) + 1e-10)\n    diversity_scores = np.sum(weights * normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Dynamic objective prioritization\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    priority_order = np.argsort(obj_dominance)\n    current_obj = priority_order[np.random.choice(min(2, len(priority_order)))]\n\n    # Adaptive local search with objective-aware perturbations\n    if np.random.rand() < 0.6:  # 60% chance for segment-based perturbation\n        segment_size = max(2, int(0.4 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[i:i+segment_size]\n\n        # Objective-aware segment reversal\n        obj_values = []\n        for k in range(len(segment)-1):\n            node1, node2 = segment[k], segment[k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        if np.random.rand() < 0.7:  # 70% chance to reverse based on current objective\n            obj_values = np.array(obj_values)[:, current_obj]\n            worst_segment = np.argmax(obj_values)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Random segment reversal\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware edge exchange with 3-opt\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by current objective\n        obj_edges.sort(key=lambda x: x[current_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 3-opt move to replace worst edge\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Enhanced probabilistic acceptance\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    accept_prob = 0.3 + 0.4 * (improvement_count / 3)  # Base 30% + 40% per objective improved\n\n    if improvement_count == 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7560779850487018,
            0.4668965101242065
        ]
    },
    {
        "algorithm": "The algorithm combines objective diversity selection with a hybrid local search that alternates between large-scale segment reversals and fine-grained edge exchanges, prioritizing the least-dominated objective for edge selection, while using a probabilistic acceptance criterion to balance multi-objective improvement. It dynamically adapts search strategies based on solution dominance and objective diversity, ensuring feasibility through constrained perturbations and 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate objective dominance\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    least_dominated_obj = np.argmin(obj_dominance)\n\n    # Hybrid local search with objective-aware perturbation\n    if np.random.rand() < 0.7:  # 70% chance for large-scale perturbation\n        segment_size = max(2, int(0.3 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware edge exchange\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by the least dominated objective\n        obj_edges.sort(key=lambda x: x[least_dominated_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 2-opt move to replace worst edge\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic acceptance based on multi-objective improvement\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    if improvement_count < 2 and np.random.rand() > 0.4:  # Accept with 60% probability if only one objective improves\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7220877380002139,
            0.42280006408691406
        ]
    },
    {
        "algorithm": "The algorithm combines objective diversity selection with a hybrid local search, prioritizing the least-dominated objective for edge selection while dynamically alternating between large-scale segment reversals and fine-grained segment exchanges. It ensures feasibility through constrained perturbations and uses a probabilistic acceptance criterion to balance multi-objective improvement, with a 60% chance of large-scale perturbations and a 50% chance of accepting solutions that improve only one objective.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate objective dominance\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    least_dominated_obj = np.argmin(obj_dominance)\n\n    # Hybrid local search with objective-aware perturbation\n    if np.random.rand() < 0.6:  # 60% chance for large-scale perturbation\n        segment_size = max(2, int(0.3 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware segment exchange\n        obj_segments = []\n        for i in range(n - 2):\n            segment = new_solution[i:i+3]\n            cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%3]] for j in range(3))\n            cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%3]] for j in range(3))\n            cost3 = sum(distance_matrix_3[segment[j], segment[(j+1)%3]] for j in range(3))\n            obj_segments.append((i, cost1, cost2, cost3))\n\n        # Sort segments by the least dominated objective\n        obj_segments.sort(key=lambda x: x[least_dominated_obj + 1])\n        worst_segment = obj_segments[-1][0]\n\n        # Exchange worst segment with another segment\n        j = np.random.randint(0, n - 2)\n        new_solution[worst_segment:worst_segment+3], new_solution[j:j+3] = new_solution[j:j+3].copy(), new_solution[worst_segment:worst_segment+3].copy()\n\n    # Probabilistic acceptance based on multi-objective improvement\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    if improvement_count < 2 and np.random.rand() > 0.5:  # Accept with 50% probability if only one objective improves\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7111803834567021,
            0.4264137506484985
        ]
    },
    {
        "algorithm": "The algorithm combines clustering with objective-aware local search, prioritizing under-represented objectives by selecting worst edges in the least-dominated objective space and applying targeted perturbations (edge swaps or segment reversals), while using dynamic acceptance thresholds to balance exploration and exploitation. It alternates between fine-grained (edge-based) and large-scale (segment-based) perturbations based on cluster-specific objective priorities.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Cluster solutions based on objective similarity\n    objectives = np.array([obj for _, obj in archive])\n    n_clusters = min(3, len(archive))\n    if n_clusters < 2:\n        base_solution = archive[0][0].copy()\n    else:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(objectives)\n        cluster_labels = kmeans.labels_\n        cluster_sizes = np.bincount(cluster_labels)\n\n        # Select cluster with most diverse solutions\n        selected_cluster = np.argmax(cluster_sizes)\n        cluster_indices = np.where(cluster_labels == selected_cluster)[0]\n        selected_idx = np.random.choice(cluster_indices)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate cluster-specific objective priorities\n    cluster_objectives = objectives[cluster_labels == selected_cluster]\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    least_dominated_obj = np.argmin(obj_dominance)\n\n    # Objective-aware edge selection\n    obj_edges = []\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        obj_edges.append((\n            i, node1, node2,\n            distance_matrix_1[node1, node2],\n            distance_matrix_2[node1, node2],\n            distance_matrix_3[node1, node2]\n        ))\n\n    # Sort edges by least dominated objective\n    obj_edges.sort(key=lambda x: x[least_dominated_obj + 3])\n    worst_edge_idx = obj_edges[-1][0]\n\n    # Perform cluster-specific perturbation\n    if np.random.rand() < 0.7:  # 70% chance for edge-based perturbation\n        # Exchange worst edge with a better edge\n        better_edges = obj_edges[:int(0.3 * len(obj_edges))]\n        if better_edges:\n            selected_edge = better_edges[np.random.randint(0, len(better_edges))]\n            pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == (selected_edge[1], selected_edge[2]) or\n                  (new_solution[(i+1)%n], new_solution[i]) == (selected_edge[1], selected_edge[2])]\n            if pos:\n                pos = pos[0]\n                new_solution[worst_edge_idx], new_solution[(worst_edge_idx+1)%n] = new_solution[pos], new_solution[(pos+1)%n]\n    else:\n        # Segment-based perturbation\n        segment_size = max(2, int(0.25 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    # Dynamic probabilistic acceptance\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    accept_threshold = 0.4 + 0.2 * (improvement_count / 3)  # Base 40% + 20% per objective improved\n\n    if improvement_count == 0 and np.random.rand() > accept_threshold:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7209448408120471,
            1.5830826878547668
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity and low combined objective value\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    combined_scores = np.sum(objectives, axis=1)\n    hybrid_scores = diversity_scores * 0.7 + combined_scores * 0.3  # Balance between diversity and quality\n    selected_idx = np.argmin(hybrid_scores)  # Select the most balanced solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate objective dominance\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    least_dominated_obj = np.argmin(obj_dominance)\n\n    # Adaptive hybrid local search\n    search_strategy = np.random.choice(['large_scale', 'fine_grained', 'multi_obj_edge'], p=[0.5, 0.3, 0.2])\n\n    if search_strategy == 'large_scale':\n        segment_size = max(2, int(0.3 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    elif search_strategy == 'fine_grained':\n        # Objective-aware segment exchange\n        obj_segments = []\n        for i in range(n - 2):\n            segment = new_solution[i:i+3]\n            cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%3]] for j in range(3))\n            cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%3]] for j in range(3))\n            cost3 = sum(distance_matrix_3[segment[j], segment[(j+1)%3]] for j in range(3))\n            obj_segments.append((i, cost1, cost2, cost3))\n\n        # Sort segments by the least dominated objective\n        obj_segments.sort(key=lambda x: x[least_dominated_obj + 1])\n        worst_segment = obj_segments[-1][0]\n\n        # Exchange worst segment with another segment\n        j = np.random.randint(0, n - 2)\n        new_solution[worst_segment:worst_segment+3], new_solution[j:j+3] = new_solution[j:j+3].copy(), new_solution[worst_segment:worst_segment+3].copy()\n    else:  # multi_obj_edge\n        # Multi-objective edge exchange\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by the least dominated objective\n        obj_edges.sort(key=lambda x: x[least_dominated_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 2-opt move to replace worst edge\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic acceptance based on multi-objective improvement\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    if improvement_count < 2 and np.random.rand() > 0.3:  # Accept with 70% probability if only one objective improves\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6910815957813717,
            1.4751302242279052
        ]
    },
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive, then applies a multi-objective edge exchange by identifying the worst edges in each objective space and performing a 2-opt move between randomly chosen positions to generate a neighbor solution, ensuring feasibility by maintaining a valid tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply multi-objective edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform exchange\n\n    # Randomly select two edges from different objectives\n    obj1_edges = []\n    obj2_edges = []\n    obj3_edges = []\n\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        obj1_edges.append((node1, node2, distance_matrix_1[node1, node2]))\n        obj2_edges.append((node1, node2, distance_matrix_2[node1, node2]))\n        obj3_edges.append((node1, node2, distance_matrix_3[node1, node2]))\n\n    # Sort edges by their distance in each objective\n    obj1_edges.sort(key=lambda x: x[2])\n    obj2_edges.sort(key=lambda x: x[2])\n    obj3_edges.sort(key=lambda x: x[2])\n\n    # Select the worst edges from each objective\n    worst_edge1 = obj1_edges[-1][:2]\n    worst_edge2 = obj2_edges[-1][:2]\n    worst_edge3 = obj3_edges[-1][:2]\n\n    # Find positions of these edges in the tour\n    pos1 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge1 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge1]\n    pos2 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge2 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge2]\n    pos3 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge3 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge3]\n\n    # Select one position from each\n    if pos1 and pos2 and pos3:\n        pos1, pos2, pos3 = pos1[0], pos2[0], pos3[0]\n\n        # Swap nodes to create a new feasible tour\n        # This is a simplified version - a proper implementation would need more complex handling\n        # Here we just perform a 2-opt move between two random positions\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6673042935749989,
            0.4514923572540283
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive (measured by the sum of pairwise distances across all three objectives) and combines it with segments from the best solutions in each objective space to create a new neighbor solution, ensuring feasibility by removing duplicates and shuffling remaining nodes. The diversity-based selection prioritizes exploration, while the segment combination leverages multi-objective information for exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (sum of pairwise distances)\n    def calculate_diversity(solution):\n        total_distance = 0\n        n = len(solution)\n        for i in range(n):\n            node1, node2 = solution[i], solution[(i+1)%n]\n            total_distance += distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]\n        return total_distance\n\n    selected_solution = max(archive, key=lambda x: calculate_diversity(x[0]))[0].copy()\n    best_solution1 = min(archive, key=lambda x: x[1][0])[0].copy()\n    best_solution2 = min(archive, key=lambda x: x[1][1])[0].copy()\n    best_solution3 = min(archive, key=lambda x: x[1][2])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments from best solutions\n    def get_segment(solution):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        return solution[i:j+1]\n\n    seg1 = get_segment(best_solution1)\n    seg2 = get_segment(best_solution2)\n    seg3 = get_segment(best_solution3)\n\n    # Combine segments to create new solution\n    new_solution = np.concatenate([seg1, seg2, seg3])\n\n    # Remove duplicates and fill missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure all nodes are visited exactly once\n    np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6784649800992073,
            1.3183825731277465
        ]
    }
]