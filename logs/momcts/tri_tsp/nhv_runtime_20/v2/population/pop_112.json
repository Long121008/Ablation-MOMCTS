[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive and applies a hybrid local search (70% 2-opt, 30% 3-opt) to generate a neighbor, ensuring feasibility by always reversing or reordering segments of the tour. The selection prioritizes solutions with minimal total cost, while the local search balances exploration (random segment selection) and exploitation (reversing segments) to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt or 3-opt based on a random choice\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt, else 3-opt\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.8028366341020267,
            0.34138243198394774
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive based on objective diversity, then applies adaptive local search with dynamic perturbation intensity (ranging from small swaps to large segment reversals) based on the solution's dominance, while ensuring feasibility through probabilistic acceptance that prioritizes multi-objective improvement. It balances exploration and exploitation by varying perturbation intensity and accepting solutions probabilistically when improvements are marginal.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (not just minimal sum)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic perturbation intensity based on objective dominance\n        obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n        perturbation_intensity = 1 - np.mean(obj_dominance)  # Higher when less dominated\n\n        # Multi-objective local search with varying intensity\n        if np.random.rand() < perturbation_intensity:\n            # Large-scale perturbation: reverse a large segment\n            segment_size = max(2, int(perturbation_intensity * n))\n            i = np.random.randint(0, n - segment_size + 1)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Small-scale perturbation: swap or reverse small segments\n            if np.random.rand() < 0.5:\n                # Small swap\n                i, j = np.random.choice(n, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Small reverse\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Probabilistic acceptance based on multi-objective improvement\n        original_costs = [\n            sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        ]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n        if improvement_count < 2 and np.random.rand() > 0.3:  # Accept with 30% probability if only one objective improves\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.73888223731041,
            0.4111027121543884
        ]
    },
    {
        "algorithm": "The algorithm selects the most under-optimized solution from the archive (based on objective ratios) and applies a hybrid local search (60% 3-opt, 40% 4-opt) to generate a neighbor, prioritizing exploration in the least optimized objective space. It intelligently adapts the search strategy to the problem size and ensures feasibility by maintaining valid TSP tours. The selection criteria and adaptive local search are key design choices for balancing exploration and exploitation across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate average objective costs across all solutions\n    avg_obj1 = np.mean([obj[0] for _, obj in archive])\n    avg_obj2 = np.mean([obj[1] for _, obj in archive])\n    avg_obj3 = np.mean([obj[2] for _, obj in archive])\n\n    # Find the solution with the lowest objective in the least optimized space\n    min_ratios = []\n    for sol, obj in archive:\n        ratio1 = obj[0] / avg_obj1 if avg_obj1 > 0 else 0\n        ratio2 = obj[1] / avg_obj2 if avg_obj2 > 0 else 0\n        ratio3 = obj[2] / avg_obj3 if avg_obj3 > 0 else 0\n        min_ratios.append(min(ratio1, ratio2, ratio3))\n\n    selected_idx = np.argmin(min_ratios)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 60% probability, apply 3-opt, else 4-opt\n        if np.random.rand() < 0.6:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            # 4-opt move (select 4 distinct indices and reorder segments)\n            a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            # Reorder segments in a different configuration\n            new_solution[a:d] = np.concatenate([segment2, segment1, segment3])\n\n    return new_solution\n\n",
        "score": [
            -0.43905360579104036,
            0.3563701272010803
        ]
    },
    {
        "algorithm": "The algorithm combines objective diversity selection with a hybrid local search that alternates between large-scale segment reversals and fine-grained edge exchanges, prioritizing the least-dominated objective for edge selection, while using a probabilistic acceptance criterion to balance multi-objective improvement. It dynamically adapts search strategies based on solution dominance and objective diversity, ensuring feasibility through constrained perturbations and 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate objective dominance\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    least_dominated_obj = np.argmin(obj_dominance)\n\n    # Hybrid local search with objective-aware perturbation\n    if np.random.rand() < 0.7:  # 70% chance for large-scale perturbation\n        segment_size = max(2, int(0.3 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware edge exchange\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by the least dominated objective\n        obj_edges.sort(key=lambda x: x[least_dominated_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 2-opt move to replace worst edge\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic acceptance based on multi-objective improvement\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    if improvement_count < 2 and np.random.rand() > 0.4:  # Accept with 60% probability if only one objective improves\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7220877380002139,
            0.42280006408691406
        ]
    },
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive, then applies a multi-objective edge exchange by identifying the worst edges in each objective space and performing a 2-opt move between randomly chosen positions to generate a neighbor solution, ensuring feasibility by maintaining a valid tour structure.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply multi-objective edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform exchange\n\n    # Randomly select two edges from different objectives\n    obj1_edges = []\n    obj2_edges = []\n    obj3_edges = []\n\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        obj1_edges.append((node1, node2, distance_matrix_1[node1, node2]))\n        obj2_edges.append((node1, node2, distance_matrix_2[node1, node2]))\n        obj3_edges.append((node1, node2, distance_matrix_3[node1, node2]))\n\n    # Sort edges by their distance in each objective\n    obj1_edges.sort(key=lambda x: x[2])\n    obj2_edges.sort(key=lambda x: x[2])\n    obj3_edges.sort(key=lambda x: x[2])\n\n    # Select the worst edges from each objective\n    worst_edge1 = obj1_edges[-1][:2]\n    worst_edge2 = obj2_edges[-1][:2]\n    worst_edge3 = obj3_edges[-1][:2]\n\n    # Find positions of these edges in the tour\n    pos1 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge1 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge1]\n    pos2 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge2 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge2]\n    pos3 = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge3 or (new_solution[(i+1)%n], new_solution[i]) == worst_edge3]\n\n    # Select one position from each\n    if pos1 and pos2 and pos3:\n        pos1, pos2, pos3 = pos1[0], pos2[0], pos3[0]\n\n        # Swap nodes to create a new feasible tour\n        # This is a simplified version - a proper implementation would need more complex handling\n        # Here we just perform a 2-opt move between two random positions\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6673042935749989,
            0.4514923572540283
        ]
    },
    {
        "algorithm": "The algorithm selects the most diverse solution from the archive (measured by the sum of pairwise distances across all three objectives) and combines it with segments from the best solutions in each objective space to create a new neighbor solution, ensuring feasibility by removing duplicates and shuffling remaining nodes. The diversity-based selection prioritizes exploration, while the segment combination leverages multi-objective information for exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (sum of pairwise distances)\n    def calculate_diversity(solution):\n        total_distance = 0\n        n = len(solution)\n        for i in range(n):\n            node1, node2 = solution[i], solution[(i+1)%n]\n            total_distance += distance_matrix_1[node1, node2] + distance_matrix_2[node1, node2] + distance_matrix_3[node1, node2]\n        return total_distance\n\n    selected_solution = max(archive, key=lambda x: calculate_diversity(x[0]))[0].copy()\n    best_solution1 = min(archive, key=lambda x: x[1][0])[0].copy()\n    best_solution2 = min(archive, key=lambda x: x[1][1])[0].copy()\n    best_solution3 = min(archive, key=lambda x: x[1][2])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select segments from best solutions\n    def get_segment(solution):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        return solution[i:j+1]\n\n    seg1 = get_segment(best_solution1)\n    seg2 = get_segment(best_solution2)\n    seg3 = get_segment(best_solution3)\n\n    # Combine segments to create new solution\n    new_solution = np.concatenate([seg1, seg2, seg3])\n\n    # Remove duplicates and fill missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    new_solution = np.concatenate([new_solution, missing_nodes])\n\n    # Ensure all nodes are visited exactly once\n    np.random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6784649800992073,
            1.3183825731277465
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from an archive using crowding distance to prioritize well-distributed Pareto-optimal solutions, then applies a hybrid local search combining 2-opt moves with objective-specific edge swaps to generate improved neighbors while ensuring feasibility. The method intelligently balances exploration and exploitation by focusing on the worst edges in each objective space and performing targeted improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest crowding distance\n    def crowding_distance(solutions, objectives):\n        n = len(solutions)\n        if n <= 2:\n            return [1.0] * n\n\n        # Normalize objectives\n        objectives = np.array(objectives)\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n        # Sort by each objective\n        sorted_indices = [np.argsort(normalized[:, i]) for i in range(3)]\n\n        # Calculate crowding distance\n        distances = np.zeros(n)\n        for i in range(3):\n            distances[sorted_indices[i][0]] = np.inf\n            distances[sorted_indices[i][-1]] = np.inf\n            for j in range(1, n-1):\n                distances[sorted_indices[i][j]] += (normalized[sorted_indices[i][j+1], i] - normalized[sorted_indices[i][j-1], i])\n\n        return distances\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance(solutions, objectives)\n\n    # Select the solution with highest crowding distance\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small tours\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        # Perform an objective-specific edge swap\n        obj_idx = np.random.randint(3)\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        # Find the worst edge in the current solution for this objective\n        worst_edge = -1\n        worst_cost = -1\n        for k in range(n):\n            u = new_solution[k]\n            v = new_solution[(k+1)%n]\n            cost = dm[u, v]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = k\n\n        # Try to replace the worst edge with a better one\n        if worst_edge != -1:\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%n]\n            # Find the best edge to replace it with\n            best_improvement = 0\n            best_i = -1\n            best_j = -1\n            for i in range(n):\n                for j in range(i+1, n):\n                    u1 = new_solution[i]\n                    v1 = new_solution[j]\n                    # Check if swapping edges (u,v) and (u1,v1) improves the solution\n                    old_cost = dm[u, v] + dm[u1, v1]\n                    new_cost = dm[u, u1] + dm[v, v1]\n                    if new_cost < old_cost:\n                        improvement = old_cost - new_cost\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_i = i\n                            best_j = j\n            if best_i != -1:\n                # Perform the swap\n                segment = new_solution[best_i:best_j+1]\n                new_solution[best_i:best_j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5417664452207885,
            0.8119198679924011
        ]
    },
    {
        "algorithm": "The algorithm selects the solution with the lowest combined objective value from the archive, identifies segments with high cumulative distance in each objective space, and performs a segment inversion on one of these high-distance segments to generate a neighbor solution. The method prioritizes improving the worst-performing segments across objectives while ensuring feasibility through careful segment selection and inversion.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate cumulative distances for segments in each objective\n    def calculate_segment_distances(solution, distance_matrix):\n        segment_distances = []\n        for i in range(n):\n            node1, node2 = solution[i], solution[(i+1)%n]\n            segment_distances.append((i, distance_matrix[node1, node2]))\n        return segment_distances\n\n    obj1_segments = calculate_segment_distances(new_solution, distance_matrix_1)\n    obj2_segments = calculate_segment_distances(new_solution, distance_matrix_2)\n    obj3_segments = calculate_segment_distances(new_solution, distance_matrix_3)\n\n    # Sort segments by distance in each objective\n    obj1_segments.sort(key=lambda x: x[1], reverse=True)\n    obj2_segments.sort(key=lambda x: x[1], reverse=True)\n    obj3_segments.sort(key=lambda x: x[1], reverse=True)\n\n    # Select top segments from each objective\n    top_segments = [obj1_segments[0][0], obj2_segments[0][0], obj3_segments[0][0]]\n    top_segments = list(set(top_segments))  # Remove duplicates\n\n    if not top_segments:\n        return new_solution\n\n    # Select a random segment to invert\n    segment_start = np.random.choice(top_segments)\n    segment_length = np.random.randint(2, min(5, n//2))\n\n    # Ensure the segment doesn't wrap around the tour\n    segment_end = (segment_start + segment_length) % n\n    if segment_end < segment_start:\n        segment_end = n - 1\n\n    # Perform segment inversion\n    if segment_start < segment_end:\n        new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n    else:\n        # Handle wrap-around case\n        segment_part1 = new_solution[segment_start:]\n        segment_part2 = new_solution[:segment_end+1]\n        inverted_segment = np.concatenate([segment_part1[::-1], segment_part2[::-1]])\n        new_solution = np.concatenate([inverted_segment[:len(segment_part2)], new_solution[len(segment_part2):len(segment_part1)], inverted_segment[len(segment_part2):]])\n\n    return new_solution\n\n",
        "score": [
            -0.6307189248888287,
            0.9885505437850952
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest sum of objectives) and applies a hybrid local search combining 2-opt and 3-opt moves, randomly perturbing segments and reverting changes if they don't improve any objective. It prioritizes solutions with lower objective values and ensures feasibility by validating moves against all three distance matrices.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt moves across all three objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move if it improves at least one objective\n    if np.random.rand() < 0.5 and j - i >= 2:\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Check if the move improves at least one objective\n        original_cost1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        original_cost2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        original_cost3 = sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n        new_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2 and new_cost3 >= original_cost3):\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    # Apply 3-opt move if it improves at least one objective\n    else:\n        if j - i >= 3:\n            segment = new_solution[i:j+1]\n            # Randomly shuffle the segment\n            np.random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n            # Check if the move improves at least one objective\n            original_cost1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            original_cost2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            original_cost3 = sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            new_cost3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2 and new_cost3 >= original_cost3):\n                new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "score": [
            -0.6759595462724148,
            1.3288514852523803
        ]
    },
    {
        "algorithm": "The heuristic selects a solution from the archive based on objective diversity, then applies a hybrid local search combining 2-opt with a multi-objective edge swap to generate a neighbor solution, ensuring feasibility while optimizing across all three objectives by prioritizing edges with lower combined cost across all spaces. The algorithm intelligently explores the solution space by focusing on high-diversity solutions and using a novel edge-swap mechanism tailored for multi-objective optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap\n    for k in range(n):\n        if k == i or k == j or k == (i+1)%n or k == (j+1)%n:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        potential_cost = (distance_matrix_1[new_solution[k-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[i]] +\n                          distance_matrix_3[new_solution[k-1], new_solution[i]])\n\n        if potential_cost < current_cost:\n            new_solution[k], new_solution[i] = new_solution[i], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5534343111771481,
            1.617421281337738
        ]
    }
]