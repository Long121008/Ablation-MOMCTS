[
    {
        "algorithm": "The heuristic selects the solution with the lowest combined objective value from the archive and applies a hybrid local search (70% 2-opt, 30% 3-opt) to generate a neighbor, ensuring feasibility by always reversing or reordering segments of the tour. The selection prioritizes solutions with minimal total cost, while the local search balances exploration (random segment selection) and exploitation (reversing segments) to improve multi-objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt or 3-opt based on a random choice\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 70% probability, apply 2-opt, else 3-opt\n        if np.random.rand() < 0.7:\n            # 2-opt move\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.8028366341020267,
            0.34138243198394774
        ]
    },
    {
        "algorithm": "The algorithm dynamically identifies the least dominated objective, selects a high-crowding-distance solution from the archive, and applies an adaptive segment inversion operator that swaps variable-length segments (2-5 nodes) between worst-performing edges in the least dominated objective and best-performing edges in another randomly chosen objective, ensuring feasibility through careful boundary handling. The operator prioritizes underperforming objectives while balancing exploration and exploitation by adaptively adjusting segment lengths based on dominance and diversity in the archive.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n\n    # Select the least dominated objective\n    least_dominated_obj = np.argmin(dominance)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance in this objective\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Perform segment inversion\n            segment_length = np.random.randint(2, min(6, n//2))\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Invert segments\n            worst_segment_nodes = worst_segment_nodes[::-1]\n            best_segment_nodes = best_segment_nodes[::-1]\n\n            # Swap inverted segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                # Handle wrap-around cases\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                # Perform the swap\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.7057904658048765,
            0.19627649784088136
        ]
    },
    {
        "algorithm": "The algorithm selects solutions from the archive based on objective diversity, then applies adaptive local search with dynamic perturbation intensity (ranging from small swaps to large segment reversals) based on the solution's dominance, while ensuring feasibility through probabilistic acceptance that prioritizes multi-objective improvement. It balances exploration and exploitation by varying perturbation intensity and accepting solutions probabilistically when improvements are marginal.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (not just minimal sum)\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Dynamic perturbation intensity based on objective dominance\n        obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n        perturbation_intensity = 1 - np.mean(obj_dominance)  # Higher when less dominated\n\n        # Multi-objective local search with varying intensity\n        if np.random.rand() < perturbation_intensity:\n            # Large-scale perturbation: reverse a large segment\n            segment_size = max(2, int(perturbation_intensity * n))\n            i = np.random.randint(0, n - segment_size + 1)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Small-scale perturbation: swap or reverse small segments\n            if np.random.rand() < 0.5:\n                # Small swap\n                i, j = np.random.choice(n, 2, replace=False)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                # Small reverse\n                i, j = sorted(np.random.choice(n, 2, replace=False))\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Probabilistic acceptance based on multi-objective improvement\n        original_costs = [\n            sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        ]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n        if improvement_count < 2 and np.random.rand() > 0.3:  # Accept with 30% probability if only one objective improves\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.73888223731041,
            0.4111027121543884
        ]
    },
    {
        "algorithm": "This algorithm implements a dynamic multi-objective local search for the Tri-objective TSP, prioritizing objectives based on their dominance in the archive while alternating between segment-based perturbations and edge exchanges. It uses a weighted diversity selection to choose promising solutions and employs objective-aware perturbations (60% segment-based, 40% edge-based) with a probabilistic acceptance criterion that favors solutions improving more objectives. The method balances exploration and exploitation by dynamically adjusting perturbation strategies based on objective priorities and solution quality.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity using weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    weights = 1 / (np.std(normalized_obj, axis=0) + 1e-10)\n    diversity_scores = np.sum(weights * normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Dynamic objective prioritization\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    priority_order = np.argsort(obj_dominance)\n    current_obj = priority_order[np.random.choice(min(2, len(priority_order)))]\n\n    # Adaptive local search with objective-aware perturbations\n    if np.random.rand() < 0.6:  # 60% chance for segment-based perturbation\n        segment_size = max(2, int(0.4 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[i:i+segment_size]\n\n        # Objective-aware segment reversal\n        obj_values = []\n        for k in range(len(segment)-1):\n            node1, node2 = segment[k], segment[k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        if np.random.rand() < 0.7:  # 70% chance to reverse based on current objective\n            obj_values = np.array(obj_values)[:, current_obj]\n            worst_segment = np.argmax(obj_values)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n        else:\n            # Random segment reversal\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware edge exchange with 3-opt\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by current objective\n        obj_edges.sort(key=lambda x: x[current_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 3-opt move to replace worst edge\n            i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Enhanced probabilistic acceptance\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    accept_prob = 0.3 + 0.4 * (improvement_count / 3)  # Base 30% + 40% per objective improved\n\n    if improvement_count == 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7560779850487018,
            0.4668965101242065
        ]
    },
    {
        "algorithm": "The algorithm implements a multi-objective local search using adaptive weight-based selection with hybrid perturbations (segment rotations, edge exchanges, and node insertions), prioritizing solutions with balanced objective improvements through dominance-aware perturbation selection and acceptance criteria that balance weighted improvements and trade-off awareness. It intelligently selects base solutions via weighted objective scores and applies targeted perturbations to edges or segments, with acceptance probabilities adjusted based on improvement magnitude and objective trade-offs.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weight-based selection\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(3))\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Dominance-aware perturbation selection\n    dominance_counts = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0)\n    perturbation_type = np.random.choice(['segment', 'edge', 'insertion'], p=[0.3, 0.4, 0.3])\n\n    if perturbation_type == 'segment':\n        segment_size = max(2, min(n//2, int(0.4 * n + np.random.randn() * 0.15 * n)))\n        i = np.random.randint(0, n - segment_size + 1)\n\n        # Objective-aware segment reversal\n        obj_values = []\n        for k in range(segment_size-1):\n            node1, node2 = new_solution[i+k], new_solution[i+k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        worst_obj = np.argmax(np.dot(np.array(obj_values), weights))\n        if np.random.rand() < 0.7:\n            new_solution[i+worst_obj:i+worst_obj+2] = new_solution[i+worst_obj+1], new_solution[i+worst_obj]\n        else:\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    elif perturbation_type == 'edge':\n        # Weighted edge replacement with 2-opt*\n        edge_weights = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            edge_weights.append([\n                weights[0] * distance_matrix_1[node1, node2],\n                weights[1] * distance_matrix_2[node1, node2],\n                weights[2] * distance_matrix_3[node1, node2]\n            ])\n\n        worst_edge = np.argmax(np.sum(edge_weights, axis=1))\n        i = worst_edge\n        j = (worst_edge + 1) % n\n\n        # Find alternative path\n        candidates = []\n        for k in range(n):\n            if k != i and k != j and (k+1)%n != i and (k+1)%n != j:\n                candidates.append(k)\n\n        if candidates:\n            k = np.random.choice(candidates)\n            if k < i:\n                new_solution[k+1:i+1] = new_solution[k+1:i+1][::-1]\n            else:\n                new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n\n    else:  # insertion perturbation\n        # Objective-aware node insertion\n        obj_values = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_values.append([\n                weights[0] * distance_matrix_1[node1, node2],\n                weights[1] * distance_matrix_2[node1, node2],\n                weights[2] * distance_matrix_3[node1, node2]\n            ])\n\n        worst_node = np.argmax(np.sum(obj_values, axis=1))\n        node_to_move = new_solution[worst_node]\n        new_solution = np.delete(new_solution, worst_node)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Acceptance criteria with trade-off awareness\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    weighted_improvement = sum((new - orig) * w for orig, new, w in zip(original_costs, new_costs, weights))\n    tradeoff_factor = np.std([(new - orig)/orig for orig, new in zip(original_costs, new_costs) if orig != 0])\n    accept_prob = 0.3 + 0.4 * (weighted_improvement / sum(original_costs)) - 0.2 * tradeoff_factor\n\n    if weighted_improvement > 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7863534661051702,
            1.6892656922340392
        ]
    },
    {
        "algorithm": "The algorithm dynamically identifies the least dominated objective and selects a high-crowding-distance solution from the archive, then applies an objective-biased segment swap to exchange segments between the worst-performing path and another objective's path, ensuring feasibility through careful boundary handling. It prioritizes underperforming objectives while maintaining tour validity through segment swaps of variable length (2-4 nodes). The method balances exploration and exploitation by focusing on both dominance and diversity in the archive.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n\n    # Select the least dominated objective\n    least_dominated_obj = np.argmin(dominance)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance in this objective\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Find worst segment in the least dominated objective\n    worst_segment = None\n    worst_score = -np.inf\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        score = selected_matrix[node1, node2]\n        if score > worst_score:\n            worst_score = score\n            worst_segment = i\n\n    if worst_segment is not None:\n        # Find best segment in another objective\n        best_segment = None\n        best_score = np.inf\n        other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n        other_matrix = distance_matrices[other_obj]\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = other_matrix[node1, node2]\n            if score < best_score:\n                best_score = score\n                best_segment = i\n\n        if best_segment is not None:\n            # Perform segment swap\n            segment_length = np.random.randint(2, min(5, n//3))\n            worst_end = (worst_segment + segment_length) % n\n            best_end = (best_segment + segment_length) % n\n\n            # Extract segments\n            if worst_segment < worst_end:\n                worst_segment_nodes = new_solution[worst_segment:worst_end]\n            else:\n                worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n            if best_segment < best_end:\n                best_segment_nodes = new_solution[best_segment:best_end]\n            else:\n                best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n            # Swap segments\n            if worst_segment < worst_end and best_segment < best_end:\n                new_solution[worst_segment:worst_end] = best_segment_nodes\n                new_solution[best_segment:best_end] = worst_segment_nodes\n            else:\n                # Handle wrap-around cases\n                if worst_segment > worst_end:\n                    temp = worst_segment_nodes.copy()\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n                    new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                    new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                if best_segment > best_end:\n                    temp = best_segment_nodes.copy()\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n                    new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                    new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                # Perform the swap\n                if worst_segment < worst_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                if best_segment < best_end:\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.5911691427935126,
            0.250174880027771
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive by prioritizing those with high crowding distance in the least improved objective, then applies a multi-objective segment insertion that combines 2-opt and Or-opt moves with segment lengths determined by objective performance, ensuring feasibility through careful boundary handling and dominance-aware segment selection. It prioritizes the least improved objective while considering all three objectives in segment scoring, using segment lengths proportional to objective performance to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance and improvement potential for each objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n    improvement_potential = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n\n    # Select the least improved objective with highest potential\n    selected_obj = np.argmax(improvement_potential * (1 - dominance))\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[selected_obj]\n\n    # Calculate crowding distance in the selected objective's space\n    normalized_obj = (objectives[:, selected_obj] - np.min(objectives[:, selected_obj])) / (np.max(objectives[:, selected_obj]) - np.min(objectives[:, selected_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance in this objective\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate segment scores based on all objectives\n    segment_scores = np.zeros(n)\n    for i in range(n):\n        node1, node2 = new_solution[i], new_solution[(i+1)%n]\n        segment_scores[i] = np.mean([m[node1, node2] for m in distance_matrices])\n\n    # Find worst and best segments\n    worst_segment = np.argmax(segment_scores)\n    other_objs = [i for i in range(3) if i != selected_obj]\n    best_segments = []\n    for obj in other_objs:\n        obj_scores = np.zeros(n)\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_scores[i] = distance_matrices[obj][node1, node2]\n        best_segments.append(np.argmin(obj_scores))\n\n    # Determine segment length based on objective performance\n    obj_performance = np.array([np.mean(objectives[:, i]) for i in range(3)])\n    segment_length = max(2, min(4, int(3 * (1 - obj_performance[selected_obj]) + 1)))\n\n    # Perform multi-objective segment insertion\n    for best_seg in best_segments:\n        # Extract segments\n        worst_end = (worst_segment + segment_length) % n\n        best_end = (best_seg + segment_length) % n\n\n        if worst_segment < worst_end:\n            worst_segment_nodes = new_solution[worst_segment:worst_end]\n        else:\n            worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n        if best_seg < best_end:\n            best_segment_nodes = new_solution[best_seg:best_end]\n        else:\n            best_segment_nodes = np.concatenate([new_solution[best_seg:], new_solution[:best_end]])\n\n        # Create new solution by inserting best segment after worst segment\n        if worst_segment < worst_end:\n            new_solution = np.concatenate([\n                new_solution[:worst_segment],\n                best_segment_nodes,\n                new_solution[worst_segment:best_seg],\n                worst_segment_nodes,\n                new_solution[best_end:]\n            ])\n        else:\n            # Handle wrap-around case\n            temp = np.concatenate([\n                new_solution[worst_segment:],\n                new_solution[:worst_end],\n                best_segment_nodes,\n                new_solution[worst_end:best_seg],\n                worst_segment_nodes,\n                new_solution[best_end:]\n            ])\n            new_solution = np.concatenate([temp[n-worst_segment:], temp[:n-worst_segment]])\n\n        # Ensure solution is valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5993978341946157,
            0.33865811824798586
        ]
    },
    {
        "algorithm": "The algorithm combines objective diversity selection with a hybrid local search that alternates between large-scale segment reversals and fine-grained edge exchanges, prioritizing the least-dominated objective for edge selection, while using a probabilistic acceptance criterion to balance multi-objective improvement. It dynamically adapts search strategies based on solution dominance and objective diversity, ensuring feasibility through constrained perturbations and 2-opt moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges * objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Calculate objective dominance\n    obj_dominance = np.sum([obj <= archive[selected_idx][1] for _, obj in archive], axis=0) / len(archive)\n    least_dominated_obj = np.argmin(obj_dominance)\n\n    # Hybrid local search with objective-aware perturbation\n    if np.random.rand() < 0.7:  # 70% chance for large-scale perturbation\n        segment_size = max(2, int(0.3 * n))\n        i = np.random.randint(0, n - segment_size + 1)\n        new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n    else:\n        # Objective-aware edge exchange\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                node1, node2,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        # Sort edges by the least dominated objective\n        obj_edges.sort(key=lambda x: x[least_dominated_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find position of worst edge\n        pos = [i for i in range(n) if (new_solution[i], new_solution[(i+1)%n]) == worst_edge or\n              (new_solution[(i+1)%n], new_solution[i]) == worst_edge]\n\n        if pos:\n            pos = pos[0]\n            # Perform 2-opt move to replace worst edge\n            i, j = sorted(np.random.choice(range(n), 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic acceptance based on multi-objective improvement\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    if improvement_count < 2 and np.random.rand() > 0.4:  # Accept with 60% probability if only one objective improves\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7220877380002139,
            0.42280006408691406
        ]
    },
    {
        "algorithm": "This algorithm implements a multi-objective local search that combines adaptive objective prioritization with novel perturbation strategies (node swaps, segment rotations, and adaptive 2-opt operations), using dynamic selection to balance exploration and exploitation through objective-aware perturbation probabilities and probabilistic acceptance criteria. It prioritizes objectives probabilistically (with base weights of 0.3, 0.3, and 0.4 for the three objectives) and applies perturbations tailored to the selected objective, while ensuring feasibility through dynamic acceptance criteria that favor solutions improving multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection with objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_obj * (1 - normalized_obj), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Objective prioritization with adaptive weights\n    obj_weights = np.array([0.3, 0.3, 0.4])  # Base weights\n    obj_weights += 0.2 * np.random.rand(3)   # Add random variation\n    obj_weights = obj_weights / np.sum(obj_weights)\n    current_obj = np.random.choice(3, p=obj_weights)\n\n    # Adaptive perturbation strategy selection\n    perturbation_probs = [0.3, 0.4, 0.3]  # Base probabilities\n    perturbation_probs[current_obj] += 0.2  # Boost current objective's probability\n    perturbation_probs = perturbation_probs / np.sum(perturbation_probs)\n    perturbation_type = np.random.choice(['swap', 'segment', 'adaptive_2opt'], p=perturbation_probs)\n\n    if perturbation_type == 'swap':\n        # Objective-aware node swap\n        obj_scores = []\n        for i in range(n):\n            node1 = new_solution[i]\n            node2 = new_solution[(i+1)%n]\n            obj_scores.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        obj_scores = np.array(obj_scores)[:, current_obj]\n        worst_edges = np.argsort(obj_scores)[-min(3, n//2):]\n\n        if worst_edges.size > 0:\n            i = np.random.choice(worst_edges)\n            j = np.random.randint(0, n)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = np.random.randint(0, n)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif perturbation_type == 'segment':\n        # Objective-aware segment rotation\n        segment_size = max(2, min(n//3, int(0.25 * n + np.random.randn() * 0.1 * n)))\n        i = np.random.randint(0, n - segment_size + 1)\n        segment = new_solution[i:i+segment_size]\n\n        obj_values = []\n        for k in range(len(segment)-1):\n            node1, node2 = segment[k], segment[k+1]\n            obj_values.append([\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ])\n\n        obj_values = np.array(obj_values)[:, current_obj]\n        if np.random.rand() < 0.7:\n            worst_segment = np.argmax(obj_values)\n            rotation = np.random.randint(1, len(segment))\n            new_solution[i:i+segment_size] = np.roll(segment, rotation)\n        else:\n            rotation = np.random.randint(1, len(segment))\n            new_solution[i:i+segment_size] = np.roll(new_solution[i:i+segment_size], rotation)\n\n    else:  # adaptive_2opt\n        # Objective-aware adaptive 2-opt\n        obj_edges = []\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            obj_edges.append((\n                i, (i+1)%n,\n                distance_matrix_1[node1, node2],\n                distance_matrix_2[node1, node2],\n                distance_matrix_3[node1, node2]\n            ))\n\n        obj_edges.sort(key=lambda x: x[current_obj + 2])\n        worst_edge = obj_edges[-1][:2]\n\n        # Find alternative edges with adaptive search depth\n        search_depth = min(10, max(2, int(n * 0.1)))\n        candidates = []\n        for i in range(n):\n            for j in range(i+2, min(i+search_depth, n)):\n                if j != (i+1)%n and (j+1)%n != i:\n                    candidates.append((i, j))\n\n        if candidates:\n            i, j = candidates[np.random.choice(len(candidates))]\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Dynamic acceptance criteria\n    original_costs = [\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n    ]\n    new_costs = [\n        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n        sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    ]\n\n    improvement_count = sum(1 for orig, new in zip(original_costs, new_costs) if new < orig)\n    tradeoff_factor = 0.15 * np.sum([abs((new - orig)/orig) for orig, new in zip(original_costs, new_costs)])\n    accept_prob = 0.3 + 0.4 * (improvement_count / 3) - 0.2 * tradeoff_factor\n\n    if improvement_count == 0 and np.random.rand() > accept_prob:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7493782684052661,
            0.6593082427978516
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a solution from the archive by prioritizing the least dominated objective and highest crowding distance, then applies a hybrid local search combining 3-opt moves (60%) and objective-biased segment swaps (40%) to improve multi-objective performance while ensuring feasibility. The segment swaps focus on swapping worst-performing edges in the least dominated objective with best-performing edges in another randomly chosen objective, while maintaining tour validity. The selection strategy balances exploration of under-represented objectives with exploitation of crowded regions in the Pareto front.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance for each objective\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.sum(objectives <= objectives, axis=0) / len(archive)\n\n    # Select the least dominated objective\n    least_dominated_obj = np.argmin(dominance)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[least_dominated_obj]\n\n    # Calculate crowding distance in the least dominated objective's space\n    normalized_obj = (objectives[:, least_dominated_obj] - np.min(objectives[:, least_dominated_obj])) / (np.max(objectives[:, least_dominated_obj]) - np.min(objectives[:, least_dominated_obj]) + 1e-8)\n    sorted_idx = np.argsort(normalized_obj)\n    crowding_dist = np.zeros(len(archive))\n    crowding_dist[sorted_idx[0]] = np.inf\n    crowding_dist[sorted_idx[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_dist[sorted_idx[i]] = normalized_obj[sorted_idx[i+1]] - normalized_obj[sorted_idx[i-1]]\n\n    # Select solution with highest crowding distance in this objective\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Apply hybrid local search: 60% 3-opt, 40% objective-biased segment swap\n    if np.random.rand() < 0.6:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Objective-biased segment swap\n        worst_segment = None\n        worst_score = -np.inf\n        for i in range(n):\n            node1, node2 = new_solution[i], new_solution[(i+1)%n]\n            score = selected_matrix[node1, node2]\n            if score > worst_score:\n                worst_score = score\n                worst_segment = i\n\n        if worst_segment is not None:\n            best_segment = None\n            best_score = np.inf\n            other_obj = np.random.choice([i for i in range(3) if i != least_dominated_obj])\n            other_matrix = distance_matrices[other_obj]\n            for i in range(n):\n                node1, node2 = new_solution[i], new_solution[(i+1)%n]\n                score = other_matrix[node1, node2]\n                if score < best_score:\n                    best_score = score\n                    best_segment = i\n\n            if best_segment is not None:\n                segment_length = np.random.randint(2, min(5, n//3))\n                worst_end = (worst_segment + segment_length) % n\n                best_end = (best_segment + segment_length) % n\n\n                if worst_segment < worst_end:\n                    worst_segment_nodes = new_solution[worst_segment:worst_end]\n                else:\n                    worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n\n                if best_segment < best_end:\n                    best_segment_nodes = new_solution[best_segment:best_end]\n                else:\n                    best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n\n                if worst_segment < worst_end and best_segment < best_end:\n                    new_solution[worst_segment:worst_end] = best_segment_nodes\n                    new_solution[best_segment:best_end] = worst_segment_nodes\n                else:\n                    if worst_segment > worst_end:\n                        temp = worst_segment_nodes.copy()\n                        worst_segment_nodes = np.concatenate([new_solution[worst_segment:], new_solution[:worst_end]])\n                        new_solution[worst_segment:] = temp[:len(new_solution[worst_segment:])]\n                        new_solution[:worst_end] = temp[len(new_solution[worst_segment:]):]\n\n                    if best_segment > best_end:\n                        temp = best_segment_nodes.copy()\n                        best_segment_nodes = np.concatenate([new_solution[best_segment:], new_solution[:best_end]])\n                        new_solution[best_segment:] = temp[:len(new_solution[best_segment:])]\n                        new_solution[:best_end] = temp[len(new_solution[best_segment:]):]\n\n                    if worst_segment < worst_end:\n                        new_solution[worst_segment:worst_end] = best_segment_nodes\n                    if best_segment < best_end:\n                        new_solution[best_segment:best_end] = worst_segment_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.5331356787292956,
            0.30147955417633054
        ]
    }
]