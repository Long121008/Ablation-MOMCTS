[
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using adaptive weighting\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Adaptive weighting: prioritize solutions with balanced performance\n        hybrid_weight = norm1 * norm2 * norm3\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between objective-space 2-opt and random swaps\n    if n >= 4:\n        # Randomly choose between 2-opt and random swap\n        if np.random.rand() < 0.5:\n            # Objective-space 2-opt: select a segment and reverse it\n            i = np.random.randint(n)\n            j = np.random.randint(n)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Random swap of three non-consecutive nodes\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            if a + 1 == b or b + 1 == c:\n                b = (b + 1) % n\n                c = (c + 1) % n\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8161627693280897,
            0.3719721794128418
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize solutions with balanced performance\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Boost solutions with balanced performance\n        hybrid_weight = norm1 * norm2 * norm3\n        if (norm1 < 0.5 and norm2 < 0.5) or (norm1 < 0.5 and norm3 < 0.5) or (norm2 < 0.5 and norm3 < 0.5):\n            hybrid_weight *= 1.5\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between objective-space 2-opt and edge-swap\n    if n >= 4:\n        if np.random.rand() < 0.7:  # 70% chance for 2-opt\n            # Select objective space based on under-optimization\n            norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n            norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n            norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n            if norm1 < norm2 and norm1 < norm3:\n                dist_matrix = distance_matrix_1\n            elif norm2 < norm1 and norm2 < norm3:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            # Perform 2-opt in the selected objective space\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:  # 30% chance for edge-swap\n            # Find the worst edge in a random objective space\n            swap_obj_space = np.random.randint(3)\n            if swap_obj_space == 0:\n                swap_dist_matrix = distance_matrix_1\n            elif swap_obj_space == 1:\n                swap_dist_matrix = distance_matrix_2\n            else:\n                swap_dist_matrix = distance_matrix_3\n\n            worst_edge = -1\n            worst_cost = -1\n            for k in range(n):\n                u = new_solution[k]\n                v = new_solution[(k+1)%n]\n                cost = swap_dist_matrix[u, v]\n                if cost > worst_cost:\n                    worst_cost = cost\n                    worst_edge = k\n\n            if worst_edge != -1:\n                u = new_solution[worst_edge]\n                v = new_solution[(worst_edge+1)%n]\n                candidates = [i for i in range(n) if i != u and i != v]\n\n                if candidates:\n                    best_candidate = None\n                    best_improvement = 0\n\n                    for candidate in candidates:\n                        new_cost = swap_dist_matrix[u, candidate] + swap_dist_matrix[candidate, v] - swap_dist_matrix[u, v]\n                        if new_cost < best_improvement:\n                            best_improvement = new_cost\n                            best_candidate = candidate\n\n                    if best_candidate is not None:\n                        new_solution = np.delete(new_solution, np.where(new_solution == best_candidate)[0][0])\n                        pos = (worst_edge + 1) % n\n                        new_solution = np.insert(new_solution, pos, best_candidate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8615108052922789,
            0.4888777256011963
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top 20% of the archive (based on normalized objective sums) and applies a hybrid local search: first performing a 3-opt move in a randomly chosen objective space, then with 40% probability applying a node-insertion in a different objective space to improve the worst edge, prioritizing under-optimized objectives dynamically. It ensures feasibility by validating the solution and reverting to the original if invalid.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_20_percent = max(1, len(archive) // 5)\n    top_indices = sorted_indices[:top_20_percent]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    obj_space = np.random.randint(3)\n    if obj_space == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    if np.random.rand() < 0.4:\n        swap_obj_space = np.random.choice([o for o in range(3) if o != obj_space])\n        if swap_obj_space == 0:\n            swap_dist_matrix = distance_matrix_1\n        elif swap_obj_space == 1:\n            swap_dist_matrix = distance_matrix_2\n        else:\n            swap_dist_matrix = distance_matrix_3\n\n        worst_edge = -1\n        worst_cost = -1\n        for m in range(n):\n            u = new_solution[m]\n            v = new_solution[(m+1)%n]\n            cost = swap_dist_matrix[u, v]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = m\n\n        if worst_edge != -1:\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%n]\n            candidates = [i for i in range(n) if i != u and i != v]\n\n            if candidates:\n                best_candidate = None\n                best_improvement = 0\n\n                for candidate in candidates:\n                    new_cost = swap_dist_matrix[u, candidate] + swap_dist_matrix[candidate, v] - swap_dist_matrix[u, v]\n                    if new_cost < best_improvement:\n                        best_improvement = new_cost\n                        best_candidate = candidate\n\n                if best_candidate is not None:\n                    pos = (worst_edge + 1) % n\n                    new_solution = np.delete(new_solution, np.where(new_solution == best_candidate)[0][0])\n                    new_solution = np.insert(new_solution, pos, best_candidate)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7235541113914264,
            0.34502803087234496
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with under-optimized objectives (boosting weights for solutions where at least one objective is below 50% of its normalized range), then applies a hybrid local search: 70% probability of 2-opt in a randomly chosen objective space and 30% probability of adaptive 3-opt that targets the least-improved objective (rearranging three nodes to improve the worst-performing objective). The solution is validated for feasibility before returning.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize solutions with under-optimized objectives\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        hybrid_weight = norm1 * norm2 * norm3\n        if norm1 < 0.5 or norm2 < 0.5 or norm3 < 0.5:\n            hybrid_weight *= 1.5  # Boost weight for solutions with under-optimized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 70% 2-opt in a random objective space, 30% adaptive 3-opt\n    if np.random.rand() < 0.7:\n        # 2-opt in a random objective space\n        obj_space = np.random.randint(3)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Adaptive 3-opt targeting the least-improved objective\n        if n >= 4:\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            if a + 1 == b or b + 1 == c:\n                b = (b + 1) % n\n                c = (c + 1) % n\n\n            norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n            norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n            norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n            if norm1 < norm2 and norm1 < norm3:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n            elif norm2 < norm1 and norm2 < norm3:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n            else:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8612716444059171,
            0.3995390772819519
        ]
    },
    {
        "algorithm": "This algorithm dynamically prioritizes local search operations based on objective-space performance, focusing 65% of the time on the least-improved objective via 2-opt, while using 35% of the time for multi-space edge operations. It includes a 10% chance of randomized edge swaps to escape local optima, with aggressive feasibility checks that revert to the original solution if any infeasibility is detected. The selection strategy prioritizes high-performing solutions (top 30%) 70% of the time, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with a 70% chance from the top 30% of the archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    if random.random() < 0.7 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Dynamic local search\n    if random.random() < 0.65:  # 65% chance for 2-opt in least-improved space\n        if norm1 <= norm2 and norm1 <= norm3:\n            dist_matrix = distance_matrix_1\n        elif norm2 <= norm1 and norm2 <= norm3:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # 2-opt in selected space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 35% chance for multi-space edge swap\n        # Select edges from different spaces with weighted probability\n        space1_edges = []\n        space2_edges = []\n        space3_edges = []\n\n        for k in range(n-1):\n            i, j = new_solution[k], new_solution[k+1]\n            space1_edges.append((i, j, distance_matrix_1[i, j]))\n            space2_edges.append((i, j, distance_matrix_2[i, j]))\n            space3_edges.append((i, j, distance_matrix_3[i, j]))\n\n        # Weighted selection based on edge distances\n        all_edges = space1_edges + space2_edges + space3_edges\n        all_edges.sort(key=lambda x: x[2])\n        top_edges = all_edges[:max(1, len(all_edges)//5)]\n\n        if top_edges:\n            # Select edge with weighted probability (shorter edges more likely)\n            edge_weights = [1.0 / (1.0 + e[2]) for e in top_edges]\n            edge_to_swap = random.choices(top_edges, weights=edge_weights, k=1)[0]\n            i, j = edge_to_swap[:2]\n\n            # Find positions in the solution\n            pos_i = np.where(new_solution == i)[0][0]\n            pos_j = np.where(new_solution == j)[0][0]\n\n            # Swap the edges\n            if pos_i < pos_j:\n                new_solution[pos_i:pos_j+1] = new_solution[pos_i:pos_j+1][::-1]\n\n    # Ensure feasibility with aggressive rollback\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    # Increased randomized edge perturbation (10% chance)\n    if random.random() < 0.1 and n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8466893402692914,
            0.3886641263961792
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the top 30% of the archive (70% chance) or randomly (30% chance), then applies a hybrid local search: 70% 2-opt in the least-improved objective space, 20% 3-opt, and 10% random swaps, ensuring feasibility by reverting to the original solution if invalid. It prioritizes exploitation of high-performing solutions while balancing exploration through diverse local search operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with a 70% chance from the top 30% of the archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    if random.random() < 0.7 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Hybrid local search\n    if random.random() < 0.7:  # 70% chance for 2-opt in least-improved space\n        if norm1 <= norm2 and norm1 <= norm3:\n            dist_matrix = distance_matrix_1\n        elif norm2 <= norm1 and norm2 <= norm3:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # 2-opt in selected space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif random.random() < 0.2:  # 20% chance for 3-opt\n        # Select three non-consecutive nodes\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n    else:  # 10% chance for random swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8068874115734523,
            0.3590510725975037
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution (70% from top 30% of archive, 30% random) and applies a hybrid local search: 60% objective-targeted 2-opt in the least-improved space, 25% 3-opt with objective-prioritized reordering, and 15% random edge swaps, always ensuring feasibility through strict checks. Objective prioritization is adaptive based on normalized objective values, with the least-improved space driving the 2-opt operation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with a 70% chance from the top 30% of the archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    if random.random() < 0.7 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Hybrid local search\n    if random.random() < 0.6:  # 60% chance for objective-targeted 2-opt\n        if norm1 <= norm2 and norm1 <= norm3:\n            dist_matrix = distance_matrix_1\n        elif norm2 <= norm1 and norm2 <= norm3:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # 2-opt in selected space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif random.random() < 0.25:  # 25% chance for 3-opt\n        # Select three non-consecutive nodes\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes based on objective priorities\n        if norm1 <= norm2 and norm1 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 <= norm1 and norm2 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n    else:  # 15% chance for random edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7946938534124196,
            0.3527204871177673
        ]
    },
    {
        "algorithm": "The algorithm selects top-performing solutions from the archive (top 10% by normalized objective sums) and applies a hybrid local search: 2-opt in the least-improved objective space for refinement, followed by adaptive 3-opt with 40% probability to further optimize the worst-performing objective, ensuring feasibility through validation checks. The method prioritizes objectives based on normalized performance and adaptively targets the least-improved space for optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Top 10% of solutions based on normalized objective sums\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_10_percent = max(1, len(archive) // 10)\n    top_indices = sorted_indices[:top_10_percent]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate normalized objectives for the selected solution\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    all_obj1 = [obj[0] for _, obj in archive]\n    all_obj2 = [obj[1] for _, obj in archive]\n    all_obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(all_obj1), min(all_obj1)\n    max_obj2, min_obj2 = max(all_obj2), min(all_obj2)\n    max_obj3, min_obj3 = max(all_obj3), min(all_obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1, max_obj1, min_obj1)\n    norm2 = normalize(obj2, max_obj2, min_obj2)\n    norm3 = normalize(obj3, max_obj3, min_obj3)\n\n    # Determine least-improved objective\n    least_improved = np.argmin([norm1, norm2, norm3])\n\n    # Hybrid local search\n    if least_improved == 0:\n        dist_matrix = distance_matrix_1\n    elif least_improved == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # First apply 2-opt in the least-improved objective space\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_tour = new_solution.copy()\n        new_tour[i:j+1] = new_tour[i:j+1][::-1]\n        if len(np.unique(new_tour)) == n:\n            new_solution = new_tour\n\n    # With 40% probability, apply adaptive 3-opt\n    if np.random.rand() < 0.4 and n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Apply 3-opt to improve the least-improved objective\n        if least_improved == 0:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif least_improved == 1:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8097677879580758,
            0.4051970839500427
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective weight combining normalized values of all three objectives, then applies a novel 3-opt local search that randomly reorders three non-consecutive nodes to explore a diverse neighborhood while ensuring feasibility. It prioritizes solutions with balanced performance across all objectives and uses a weighted random selection to guide the search toward potentially high-quality regions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine normalized objectives to find promising solutions\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        hybrid_weight = norm1 * norm2 * norm3  # Combine normalized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel 3-opt local search operator\n    if n >= 4:\n        # Select three non-consecutive nodes\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes to explore new connections\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6924314595760842,
            0.3549174427986145
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a hybrid weight that combines normalized objective values and prioritizes solutions with under-optimized objectives, then applies a novel 3-opt local search that adaptively reorders three non-consecutive nodes to improve the most under-optimized objective while ensuring feasibility. The selection process boosts weights for solutions with at least one normalized objective below 0.5, and the local search prioritizes reordering based on which objective is least optimized.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine normalized objectives and track under-optimized objectives\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Combine with adaptive targeting: prioritize solutions with at least one under-optimized objective\n        hybrid_weight = norm1 * norm2 * norm3\n        if norm1 < 0.5 or norm2 < 0.5 or norm3 < 0.5:\n            hybrid_weight *= 2  # Boost weight for solutions with under-optimized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel 3-opt local search with adaptive targeting\n    if n >= 4:\n        # Select three non-consecutive nodes\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes with adaptive targeting\n        # Check which objectives are under-optimized and prioritize improving them\n        norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n        norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n        norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n        if norm1 < norm2 and norm1 < norm3:  # Objective 1 is under-optimized\n            # Reorder to improve objective 1\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 < norm1 and norm2 < norm3:  # Objective 2 is under-optimized\n            # Reorder to improve objective 2\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:  # Objective 3 is under-optimized\n            # Reorder to improve objective 3\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7854781667624621,
            0.3697004675865173
        ]
    }
]