[
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective weight combining normalized values of all three objectives, then applies a novel 3-opt local search that randomly reorders three non-consecutive nodes to explore a diverse neighborhood while ensuring feasibility. It prioritizes solutions with balanced performance across all objectives and uses a weighted random selection to guide the search toward potentially high-quality regions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine normalized objectives to find promising solutions\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        hybrid_weight = norm1 * norm2 * norm3  # Combine normalized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel 3-opt local search operator\n    if n >= 4:\n        # Select three non-consecutive nodes\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes to explore new connections\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6924314595760842,
            0.3549174427986145
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the top 30% of the archive (based on normalized objective sums) and applies a hybrid local search: it first performs a 2-opt move in a randomly chosen objective space, followed by a 30% chance of an edge-swap in a different objective space to improve the worst edge. It prioritizes under-optimized objectives dynamically and ensures feasibility by validating the solution, falling back to the original if invalid. The search balances exploration (random objective selection) and exploitation (edge-swap for worst edges) while maintaining TSP feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the top 30% of the archive based on normalized objective sums\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: alternate between 2-opt and edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select an objective space for 2-opt\n    obj_space = np.random.randint(3)\n    if obj_space == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_space == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt in the selected objective space\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # With 30% probability, perform an edge-swap in a different objective space\n    if np.random.rand() < 0.3:\n        swap_obj_space = np.random.choice([o for o in range(3) if o != obj_space])\n        if swap_obj_space == 0:\n            swap_dist_matrix = distance_matrix_1\n        elif swap_obj_space == 1:\n            swap_dist_matrix = distance_matrix_2\n        else:\n            swap_dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the swap objective space\n        worst_edge = -1\n        worst_cost = -1\n        for k in range(n):\n            u = new_solution[k]\n            v = new_solution[(k+1)%n]\n            cost = swap_dist_matrix[u, v]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = k\n\n        # Swap nodes to improve the worst edge\n        if worst_edge != -1:\n            u = new_solution[worst_edge]\n            v = new_solution[(worst_edge+1)%n]\n            candidates = [i for i in range(n) if i != u and i != v]\n\n            if candidates:\n                best_candidate = None\n                best_improvement = 0\n\n                for candidate in candidates:\n                    new_cost = swap_dist_matrix[u, candidate] + swap_dist_matrix[candidate, v] - swap_dist_matrix[u, v]\n                    if new_cost < best_improvement:\n                        best_improvement = new_cost\n                        best_candidate = candidate\n\n                if best_candidate is not None:\n                    new_solution = np.delete(new_solution, np.where(new_solution == best_candidate)[0][0])\n                    pos = (worst_edge + 1) % n\n                    new_solution = np.insert(new_solution, pos, best_candidate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7435331769323067,
            0.356395947933197
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using a hybrid weight that combines normalized objective values and prioritizes solutions with under-optimized objectives, then applies a novel 3-opt local search that adaptively reorders three non-consecutive nodes to improve the most under-optimized objective while ensuring feasibility. The selection process boosts weights for solutions with at least one normalized objective below 0.5, and the local search prioritizes reordering based on which objective is least optimized.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine normalized objectives and track under-optimized objectives\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Combine with adaptive targeting: prioritize solutions with at least one under-optimized objective\n        hybrid_weight = norm1 * norm2 * norm3\n        if norm1 < 0.5 or norm2 < 0.5 or norm3 < 0.5:\n            hybrid_weight *= 2  # Boost weight for solutions with under-optimized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel 3-opt local search with adaptive targeting\n    if n >= 4:\n        # Select three non-consecutive nodes\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes with adaptive targeting\n        # Check which objectives are under-optimized and prioritize improving them\n        norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n        norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n        norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n        if norm1 < norm2 and norm1 < norm3:  # Objective 1 is under-optimized\n            # Reorder to improve objective 1\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 < norm1 and norm2 < norm3:  # Objective 2 is under-optimized\n            # Reorder to improve objective 2\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:  # Objective 3 is under-optimized\n            # Reorder to improve objective 3\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7854781667624621,
            0.3697004675865173
        ]
    },
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using adaptive weighting\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Adaptive weighting: prioritize solutions with balanced performance\n        hybrid_weight = norm1 * norm2 * norm3\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between objective-space 2-opt and random swaps\n    if n >= 4:\n        # Randomly choose between 2-opt and random swap\n        if np.random.rand() < 0.5:\n            # Objective-space 2-opt: select a segment and reverse it\n            i = np.random.randint(n)\n            j = np.random.randint(n)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Random swap of three non-consecutive nodes\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            if a + 1 == b or b + 1 == c:\n                b = (b + 1) % n\n                c = (c + 1) % n\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8161627693280897,
            0.3719721794128418
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement by randomly weighting solutions based on their total objective values, then applies a 2-opt local search operator to reverse a random segment of the tour while ensuring the solution remains feasible (all nodes visited exactly once). The selection prioritizes solutions with higher total objective values, and the 2-opt move is applied to explore a diverse neighborhood while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: perform 2-opt across all three objectives\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to modify\n    i = np.random.randint(n)\n    j = np.random.randint(n)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move (reverse the segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7922190456063145,
            0.38539648056030273
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the lowest sum of objectives) and applies a hybrid local search combining 2-opt moves and a multi-objective perturbation step. It first randomly reverses a segment of the tour (2-opt), then identifies the worst edge in a randomly chosen objective space and attempts to improve it by inserting a better node, ensuring feasibility. The method prioritizes solutions with lower objective sums and adaptively targets specific objectives for improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives (promising for improvement)\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: 2-opt + multi-objective perturbation\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: randomly select an objective and perform a swap\n    obj_idx = np.random.randint(3)\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = -1\n    worst_cost = -1\n    for k in range(n):\n        u = new_solution[k]\n        v = new_solution[(k+1)%n]\n        cost = dist_matrix[u, v]\n        if cost > worst_cost:\n            worst_cost = cost\n            worst_edge = k\n\n    # Swap nodes to improve the worst edge\n    if worst_edge != -1:\n        u = new_solution[worst_edge]\n        v = new_solution[(worst_edge+1)%n]\n        candidates = [i for i in range(n) if i != u and i != v]\n\n        if candidates:\n            best_candidate = None\n            best_improvement = 0\n\n            for candidate in candidates:\n                # Try inserting candidate between u and v\n                new_cost = dist_matrix[u, candidate] + dist_matrix[candidate, v] - dist_matrix[u, v]\n                if new_cost < best_improvement:\n                    best_improvement = new_cost\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                # Perform the insertion\n                new_solution = np.delete(new_solution, np.where(new_solution == best_candidate)[0][0])\n                pos = (worst_edge + 1) % n\n                new_solution = np.insert(new_solution, pos, best_candidate)\n\n    return new_solution\n\n",
        "score": [
            -0.6777166189724759,
            0.3804415464401245
        ]
    },
    {
        "algorithm": "The algorithm adaptively selects a solution from an archive by prioritizing those with under-optimized objectives (identified via normalized weights) and applies a hybrid local search: 70% 2-opt in a randomly chosen objective space and 30% adaptive 3-opt targeting the most under-optimized objective to improve solution quality while ensuring feasibility. The method dynamically balances exploration (random selection) and exploitation (targeted improvement) across objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: combine normalized objectives and track under-optimized objectives\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Combine with adaptive targeting: prioritize solutions with at least one under-optimized objective\n        hybrid_weight = norm1 * norm2 * norm3\n        if norm1 < 0.5 or norm2 < 0.5 or norm3 < 0.5:\n            hybrid_weight *= 1.5  # Boost weight for solutions with under-optimized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between 2-opt and adaptive 3-opt\n    if np.random.rand() < 0.7:  # 70% chance for 2-opt\n        # Select an objective space for 2-opt\n        obj_space = np.random.randint(3)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Perform 2-opt in the selected objective space\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for adaptive 3-opt\n        if n >= 4:\n            # Select three non-consecutive nodes\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n                b = (b + 1) % n\n                c = (c + 1) % n\n\n            # Reorder the selected nodes with adaptive targeting\n            norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n            norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n            norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n            if norm1 < norm2 and norm1 < norm3:  # Objective 1 is under-optimized\n                # Reorder to improve objective 1\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n            elif norm2 < norm1 and norm2 < norm3:  # Objective 2 is under-optimized\n                # Reorder to improve objective 2\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n            else:  # Objective 3 is under-optimized\n                # Reorder to improve objective 3\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.784990666275168,
            0.39758005142211916
        ]
    },
    {
        "algorithm": "The algorithm combines adaptive objective-space targeting with a hybrid local search, selecting solutions based on objective diversity and optimization gaps, then applying either segment inversions (for trade-off exploration) or node reordering (for critical node optimization) while ensuring feasibility through strict validation. It prioritizes balanced but imperfect objectives, dynamically alternating between diversification and intensification to balance the Pareto front.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective gaps and diversity\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n    obj3 = [obj[2] for obj in objectives]\n\n    # Normalize objectives\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    # Calculate selection weights based on objective gaps and diversity\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n\n        # Calculate gap scores (how far each objective is from its ideal)\n        gap1 = norm1\n        gap2 = norm2\n        gap3 = norm3\n\n        # Combine gap scores with diversity\n        diversity = (max(gap1, gap2, gap3) - min(gap1, gap2, gap3)) / (gap1 + gap2 + gap3 + 1e-10)\n        weight = diversity * (1 - (gap1 * gap2 * gap3))  # Prioritize solutions with balanced but not perfect objectives\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Decide between segment inversion or node reordering\n    if np.random.random() < 0.5 or n < 4:  # Segment inversion for smaller tours or 50% chance\n        # Select a segment to invert\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate original and inverted segment costs\n        orig_costs = []\n        for k in range(i, j):\n            cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n            cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n            cost3 = distance_matrix_3[new_solution[k], new_solution[k+1]]\n            orig_costs.append((cost1, cost2, cost3))\n\n        reversed_costs = orig_costs[::-1]\n        improvement = False\n\n        # Check if inversion improves at least one objective while not worsening others\n        for orig, rev in zip(orig_costs, reversed_costs):\n            if any(r <= o for r, o in zip(rev, orig)) and all(r <= o for r, o in zip(rev, orig) if r != o):\n                improvement = True\n                break\n\n        if improvement:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # Node reordering for larger tours\n        # Select three non-consecutive nodes\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes to explore new connections\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7737521713495877,
            0.5828560590744019
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive using adaptive weighting that prioritizes balanced performance across objectives, then applies a hybrid local search combining objective-space 2-opt with targeted 3-opt moves to improve under-optimized objectives while ensuring feasibility. It normalizes objective values to balance their influence and alternates between standard 2-opt and 3-opt moves, reordering nodes to enhance the most underperforming objective. The selection process favors solutions with balanced objective values, while the local search intelligently targets specific objectives for improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize solutions with balanced performance\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Balance objectives: prioritize solutions with balanced performance\n        hybrid_weight = (1 - abs(norm1 - norm2)) * (1 - abs(norm2 - norm3)) * (1 - abs(norm3 - norm1))\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between objective-space 2-opt and targeted 3-opt\n    if n >= 4:\n        if np.random.rand() < 0.5:\n            # Objective-space 2-opt: select a segment and reverse it\n            i = np.random.randint(n)\n            j = np.random.randint(n)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Targeted 3-opt: improve the most under-optimized objective\n            norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n            norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n            norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            if a + 1 == b or b + 1 == c:\n                b = (b + 1) % n\n                c = (c + 1) % n\n\n            if norm1 < norm2 and norm1 < norm3:\n                # Reorder to improve objective 1\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n            elif norm2 < norm1 and norm2 < norm3:\n                # Reorder to improve objective 2\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n            else:\n                # Reorder to improve objective 3\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6734760383828359,
            0.4000345230102539
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on the average of normalized objective values, then applies a hybrid local search (50% 3-opt moves and 50% random segment reversals) to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with better overall performance across objectives and explores diverse neighborhoods to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on average normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    avg_objectives = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.random.choice(len(archive), p=avg_objectives / np.sum(avg_objectives))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt or random segment reversal\n    if np.random.rand() < 0.5:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Random segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7614249097823522,
            0.4022602677345276
        ]
    }
]