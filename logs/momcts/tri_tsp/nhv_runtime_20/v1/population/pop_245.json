[
    {
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize solutions with balanced performance\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        # Boost solutions with balanced performance\n        hybrid_weight = norm1 * norm2 * norm3\n        if (norm1 < 0.5 and norm2 < 0.5) or (norm1 < 0.5 and norm3 < 0.5) or (norm2 < 0.5 and norm3 < 0.5):\n            hybrid_weight *= 1.5\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between objective-space 2-opt and edge-swap\n    if n >= 4:\n        if np.random.rand() < 0.7:  # 70% chance for 2-opt\n            # Select objective space based on under-optimization\n            norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n            norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n            norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n            if norm1 < norm2 and norm1 < norm3:\n                dist_matrix = distance_matrix_1\n            elif norm2 < norm1 and norm2 < norm3:\n                dist_matrix = distance_matrix_2\n            else:\n                dist_matrix = distance_matrix_3\n\n            # Perform 2-opt in the selected objective space\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:  # 30% chance for edge-swap\n            # Find the worst edge in a random objective space\n            swap_obj_space = np.random.randint(3)\n            if swap_obj_space == 0:\n                swap_dist_matrix = distance_matrix_1\n            elif swap_obj_space == 1:\n                swap_dist_matrix = distance_matrix_2\n            else:\n                swap_dist_matrix = distance_matrix_3\n\n            worst_edge = -1\n            worst_cost = -1\n            for k in range(n):\n                u = new_solution[k]\n                v = new_solution[(k+1)%n]\n                cost = swap_dist_matrix[u, v]\n                if cost > worst_cost:\n                    worst_cost = cost\n                    worst_edge = k\n\n            if worst_edge != -1:\n                u = new_solution[worst_edge]\n                v = new_solution[(worst_edge+1)%n]\n                candidates = [i for i in range(n) if i != u and i != v]\n\n                if candidates:\n                    best_candidate = None\n                    best_improvement = 0\n\n                    for candidate in candidates:\n                        new_cost = swap_dist_matrix[u, candidate] + swap_dist_matrix[candidate, v] - swap_dist_matrix[u, v]\n                        if new_cost < best_improvement:\n                            best_improvement = new_cost\n                            best_candidate = candidate\n\n                    if best_candidate is not None:\n                        new_solution = np.delete(new_solution, np.where(new_solution == best_candidate)[0][0])\n                        pos = (worst_edge + 1) % n\n                        new_solution = np.insert(new_solution, pos, best_candidate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8615108052922789,
            0.4888777256011963
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with under-optimized objectives (boosting weights for solutions where at least one objective is below 50% of its normalized range), then applies a hybrid local search: 70% probability of 2-opt in a randomly chosen objective space and 30% probability of adaptive 3-opt that targets the least-improved objective (rearranging three nodes to improve the worst-performing objective). The solution is validated for feasibility before returning.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: prioritize solutions with under-optimized objectives\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        hybrid_weight = norm1 * norm2 * norm3\n        if norm1 < 0.5 or norm2 < 0.5 or norm3 < 0.5:\n            hybrid_weight *= 1.5  # Boost weight for solutions with under-optimized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 70% 2-opt in a random objective space, 30% adaptive 3-opt\n    if np.random.rand() < 0.7:\n        # 2-opt in a random objective space\n        obj_space = np.random.randint(3)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Adaptive 3-opt targeting the least-improved objective\n        if n >= 4:\n            a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n            if a + 1 == b or b + 1 == c:\n                b = (b + 1) % n\n                c = (c + 1) % n\n\n            norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n            norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n            norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n            if norm1 < norm2 and norm1 < norm3:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n            elif norm2 < norm1 and norm2 < norm3:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n            else:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8612716444059171,
            0.3995390772819519
        ]
    },
    {
        "algorithm": "This algorithm dynamically prioritizes local search operations based on objective-space performance, focusing 65% of the time on the least-improved objective via 2-opt, while using 35% of the time for multi-space edge operations. It includes a 10% chance of randomized edge swaps to escape local optima, with aggressive feasibility checks that revert to the original solution if any infeasibility is detected. The selection strategy prioritizes high-performing solutions (top 30%) 70% of the time, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with a 70% chance from the top 30% of the archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    if random.random() < 0.7 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Dynamic local search\n    if random.random() < 0.65:  # 65% chance for 2-opt in least-improved space\n        if norm1 <= norm2 and norm1 <= norm3:\n            dist_matrix = distance_matrix_1\n        elif norm2 <= norm1 and norm2 <= norm3:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # 2-opt in selected space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 35% chance for multi-space edge swap\n        # Select edges from different spaces with weighted probability\n        space1_edges = []\n        space2_edges = []\n        space3_edges = []\n\n        for k in range(n-1):\n            i, j = new_solution[k], new_solution[k+1]\n            space1_edges.append((i, j, distance_matrix_1[i, j]))\n            space2_edges.append((i, j, distance_matrix_2[i, j]))\n            space3_edges.append((i, j, distance_matrix_3[i, j]))\n\n        # Weighted selection based on edge distances\n        all_edges = space1_edges + space2_edges + space3_edges\n        all_edges.sort(key=lambda x: x[2])\n        top_edges = all_edges[:max(1, len(all_edges)//5)]\n\n        if top_edges:\n            # Select edge with weighted probability (shorter edges more likely)\n            edge_weights = [1.0 / (1.0 + e[2]) for e in top_edges]\n            edge_to_swap = random.choices(top_edges, weights=edge_weights, k=1)[0]\n            i, j = edge_to_swap[:2]\n\n            # Find positions in the solution\n            pos_i = np.where(new_solution == i)[0][0]\n            pos_j = np.where(new_solution == j)[0][0]\n\n            # Swap the edges\n            if pos_i < pos_j:\n                new_solution[pos_i:pos_j+1] = new_solution[pos_i:pos_j+1][::-1]\n\n    # Ensure feasibility with aggressive rollback\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    # Increased randomized edge perturbation (10% chance)\n    if random.random() < 0.1 and n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8466893402692914,
            0.3886641263961792
        ]
    },
    {
        "algorithm": "The algorithm selects high-potential solutions (top 30% with 70% probability) and applies a hybrid local search with adaptive 3-opt (60% chance) targeting the least-improved objective, objective-space 2-opt (30% chance), or random edge swaps (10% chance), while ensuring feasibility through validation checks. The selection prioritizes solutions with better normalized objective values, and the local search adaptively optimizes based on objective performance.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with a 70% chance from the top 30% of the archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    if random.random() < 0.7 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Hybrid local search\n    if random.random() < 0.6:  # 60% chance for adaptive 3-opt\n        # Select three non-consecutive nodes\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder based on least-improved objective\n        if norm1 <= norm2 and norm1 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 <= norm1 and norm2 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n    elif random.random() < 0.3:  # 30% chance for objective-space 2-opt\n        # Select objective space based on least-improved\n        if norm1 <= norm2 and norm1 <= norm3:\n            dist_matrix = distance_matrix_1\n        elif norm2 <= norm1 and norm2 <= norm3:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Perform 2-opt in selected space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 10% chance for random edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8322793064880312,
            0.313012433052063
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions (top 20% with 80% probability) and applies a dynamic hybrid local search: 50% 4-opt targeting the most-improved objective space, 30% 2-opt in the least-improved space, and 20% random 3-edge swaps, while ensuring feasibility through validation checks. The selection prioritizes high-performing solutions, and the local search adaptively focuses on improving the most and least improved objectives, with fallback to random swaps for diversification.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with 80% probability from top 20% of archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_20_percent = max(1, len(archive) // 5)\n    top_indices = sorted_indices[:top_20_percent]\n    if random.random() < 0.8 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify most and least improved objective spaces\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Dynamic hybrid local search\n    if random.random() < 0.5:  # 50% chance for 4-opt targeting most improved space\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if norm1 >= norm2 and norm1 >= norm3:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n        elif norm2 >= norm1 and norm2 >= norm3:\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[b], new_solution[a], new_solution[d], new_solution[c]\n        else:\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n    elif random.random() < 0.3:  # 30% chance for 2-opt in least improved space\n        if norm1 <= norm2 and norm1 <= norm3:\n            dist_matrix = distance_matrix_1\n        elif norm2 <= norm1 and norm2 <= norm3:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 20% chance for random 3-edge swap\n        a, b, c = sorted(random.sample(range(n), 3))\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7040928664111173,
            0.3011666893959045
        ]
    },
    {
        "algorithm": "The algorithm implements a tri-objective TSP local search by prioritizing the least-improved objective (60% 3-opt), occasionally performing 2-opt in random spaces (30%), and occasionally random swaps (10%). It selects promising solutions (top 40% with 80% probability) and ensures feasibility through validation checks. The least-improved objective is identified by normalizing and comparing the three objective values, guiding the search toward balancing all objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with 80% probability from top 40% of archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_40_percent = max(1, len(archive) // 2)\n    top_indices = sorted_indices[:top_40_percent]\n    if random.random() < 0.8 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Dynamic hybrid local search\n    if random.random() < 0.6:  # 60% chance for 3-opt targeting least-improved space\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        if norm1 <= norm2 and norm1 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 <= norm1 and norm2 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n    elif random.random() < 0.3:  # 30% chance for 2-opt in random space\n        obj_space = random.randint(0, 2)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 10% chance for random edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8310774797201713,
            0.30362194776535034
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted random approach that prioritizes solutions with balanced objective gaps and diversity, then applies a hybrid local search with a 60/30/10 probability split between 3-opt targeting the least-improved objective, 2-opt for focused improvement in a random objective space, and random edge swaps for exploration, while dynamically adapting the search and ensuring feasibility through strict validation checks. The selection weights are calculated based on normalized objective values and objective diversity, while the local search operators are chosen probabilistically to balance exploitation and exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine adaptive objective-space targeting with hybrid weighting\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n    obj3 = [obj[2] for obj in objectives]\n\n    # Normalize objectives\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    # Calculate selection weights based on objective gaps and diversity\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n\n        # Calculate gap scores (how far each objective is from its ideal)\n        gap1 = norm1\n        gap2 = norm2\n        gap3 = norm3\n\n        # Combine gap scores with diversity and hybrid weighting\n        diversity = (max(gap1, gap2, gap3) - min(gap1, gap2, gap3)) / (gap1 + gap2 + gap3 + 1e-10)\n        hybrid_weight = diversity * (1 - (gap1 * gap2 * gap3)) * (norm1 * norm2 * norm3)\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Dynamic hybrid local search (60/30/10 split)\n    if np.random.random() < 0.6:  # 60% chance for 3-opt targeting least-improved space\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        if norm1 <= norm2 and norm1 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 <= norm1 and norm2 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n    elif np.random.random() < 0.3:  # 30% chance for 2-opt in random space\n        obj_space = np.random.randint(0, 3)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 10% chance for random edge swap\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility with aggressive rollback\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.835752148282527,
            0.42635698318481446
        ]
    },
    {
        "algorithm": "This algorithm implements a tri-objective TSP local search that prioritizes the most-improved objective space (60% of operations targeting it with 3-opt), balances optimization across all spaces (30% of operations using 2-opt), and includes diversification (10% of operations with random 4-edge swaps). It selects promising solutions from the top 30% of the archive with 70% probability, dynamically adapts its search based on normalized objective values, and ensures feasibility through validation. The algorithm's hybrid approach balances exploitation of the best-performing objective with exploration of other spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with 70% probability from top 30% of archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    if random.random() < 0.7 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify most-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Dynamic hybrid local search\n    if random.random() < 0.6:  # 60% chance for 3-opt targeting most-improved space\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        if norm1 >= norm2 and norm1 >= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 >= norm1 and norm2 >= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n    elif random.random() < 0.3:  # 30% chance for 2-opt in all spaces\n        for dist_matrix in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 10% chance for random 4-edge swap\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[b], new_solution[c], new_solution[d], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7146843577062358,
            0.3075128674507141
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions (top 30% or random) from the archive and applies a hybrid local search: 65% objective-targeted 2-opt in the least-improved space, 25% adaptive 3-opt with objective-prioritized reordering, and 10% random edge swaps, ensuring feasibility through validation checks. The selection prioritizes solutions with better normalized objective values, while the local search dynamically balances improvements across all three objectives. The algorithm maintains feasibility by reverting to the original solution if a neighbor violates the TSP constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with a 70% chance from the top 30% of the archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_30_percent = max(1, len(archive) // 3)\n    top_indices = sorted_indices[:top_30_percent]\n    if random.random() < 0.7 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Hybrid local search\n    if random.random() < 0.65:  # 65% chance for objective-targeted 2-opt\n        if norm1 <= norm2 and norm1 <= norm3:\n            dist_matrix = distance_matrix_1\n        elif norm2 <= norm1 and norm2 <= norm3:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # 2-opt in selected space\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif random.random() < 0.25:  # 25% chance for adaptive 3-opt\n        # Select three non-consecutive nodes\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder based on objective priorities\n        if norm1 <= norm2 and norm1 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 <= norm1 and norm2 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n    else:  # 10% chance for random edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8245348270858868,
            0.34775620698928833
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions (top 40% with 80% probability) and applies a dynamic hybrid local search: 60% chance for 3-opt targeting the least-improved objective space, 30% for 2-opt in a random space, and 10% for random edge swaps, while ensuring feasibility through validation checks. It prioritizes objectives with worse normalized performance and dynamically adapts the search based on the current solution's strengths.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with 80% probability from top 40% of archive\n    objectives = [sum(obj) for _, obj in archive]\n    sorted_indices = np.argsort(objectives)\n    top_40_percent = max(1, len(archive) // 2)\n    top_indices = sorted_indices[:top_40_percent]\n    if random.random() < 0.8 and len(top_indices) > 0:\n        selected_idx = random.choice(top_indices)\n    else:\n        selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify least-improved objective space\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    norm1 = normalize(obj1[selected_idx], max_obj1, min_obj1)\n    norm2 = normalize(obj2[selected_idx], max_obj2, min_obj2)\n    norm3 = normalize(obj3[selected_idx], max_obj3, min_obj3)\n\n    # Dynamic hybrid local search\n    if random.random() < 0.6:  # 60% chance for 3-opt targeting least-improved space\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a + 1 == b or b + 1 == c:\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        if norm1 <= norm2 and norm1 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n        elif norm2 <= norm1 and norm2 <= norm3:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[a], new_solution[b]\n        else:\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[c], new_solution[b], new_solution[a]\n    elif random.random() < 0.3:  # 30% chance for 2-opt in random space\n        obj_space = random.randint(0, 2)\n        if obj_space == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_space == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 10% chance for random edge swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8093029231247202,
            0.3111863017082214
        ]
    }
]