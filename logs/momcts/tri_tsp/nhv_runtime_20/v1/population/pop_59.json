[
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement by randomly weighting solutions based on their total objective values, then applies a 2-opt local search operator to reverse a random segment of the tour while ensuring the solution remains feasible (all nodes visited exactly once). The selection prioritizes solutions with higher total objective values, and the 2-opt move is applied to explore a diverse neighborhood while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [sum(obj) for _, obj in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: perform 2-opt across all three objectives\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to modify\n    i = np.random.randint(n)\n    j = np.random.randint(n)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move (reverse the segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (all nodes visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7922190456063145,
            0.38539648056030273
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid objective weight combining normalized values of all three objectives, then applies a novel 3-opt local search that randomly reorders three non-consecutive nodes to explore a diverse neighborhood while ensuring feasibility. It prioritizes solutions with balanced performance across all objectives and uses a weighted random selection to guide the search toward potentially high-quality regions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine normalized objectives to find promising solutions\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    obj3 = [obj[2] for _, obj in archive]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n    max_obj3, min_obj3 = max(obj3), min(obj3)\n\n    def normalize(value, max_val, min_val):\n        if max_val == min_val:\n            return 1.0\n        return (value - min_val) / (max_val - min_val)\n\n    weights = []\n    for i in range(len(archive)):\n        norm1 = normalize(obj1[i], max_obj1, min_obj1)\n        norm2 = normalize(obj2[i], max_obj2, min_obj2)\n        norm3 = normalize(obj3[i], max_obj3, min_obj3)\n        hybrid_weight = norm1 * norm2 * norm3  # Combine normalized objectives\n        weights.append(hybrid_weight)\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_weights = [w / total_weight for w in weights]\n        selected_idx = np.random.choice(len(archive), p=normalized_weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel 3-opt local search operator\n    if n >= 4:\n        # Select three non-consecutive nodes\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        if a + 1 == b or b + 1 == c:  # Ensure non-consecutive\n            b = (b + 1) % n\n            c = (c + 1) % n\n\n        # Reorder the selected nodes to explore new connections\n        new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6924314595760842,
            0.3549174427986145
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on the average of normalized objective values, then applies a hybrid local search (50% 3-opt moves and 50% random segment reversals) to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with better overall performance across objectives and explores diverse neighborhoods to escape local optima.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on average normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    avg_objectives = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.random.choice(len(archive), p=avg_objectives / np.sum(avg_objectives))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 3-opt or random segment reversal\n    if np.random.rand() < 0.5:\n        # 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        # Random segment reversal\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7614249097823522,
            0.4022602677345276
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive (based on the lowest sum of objectives) and applies a hybrid local search combining 2-opt moves and a multi-objective perturbation step. It first randomly reverses a segment of the tour (2-opt), then identifies the worst edge in a randomly chosen objective space and attempts to improve it by inserting a better node, ensuring feasibility. The method prioritizes solutions with lower objective sums and adaptively targets specific objectives for improvement.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives (promising for improvement)\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Hybrid local search: 2-opt + multi-objective perturbation\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt move\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: randomly select an objective and perform a swap\n    obj_idx = np.random.randint(3)\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = -1\n    worst_cost = -1\n    for k in range(n):\n        u = new_solution[k]\n        v = new_solution[(k+1)%n]\n        cost = dist_matrix[u, v]\n        if cost > worst_cost:\n            worst_cost = cost\n            worst_edge = k\n\n    # Swap nodes to improve the worst edge\n    if worst_edge != -1:\n        u = new_solution[worst_edge]\n        v = new_solution[(worst_edge+1)%n]\n        candidates = [i for i in range(n) if i != u and i != v]\n\n        if candidates:\n            best_candidate = None\n            best_improvement = 0\n\n            for candidate in candidates:\n                # Try inserting candidate between u and v\n                new_cost = dist_matrix[u, candidate] + dist_matrix[candidate, v] - dist_matrix[u, v]\n                if new_cost < best_improvement:\n                    best_improvement = new_cost\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                # Perform the insertion\n                new_solution = np.delete(new_solution, np.where(new_solution == best_candidate)[0][0])\n                pos = (worst_edge + 1) % n\n                new_solution = np.insert(new_solution, pos, best_candidate)\n\n    return new_solution\n\n",
        "score": [
            -0.6777166189724759,
            0.3804415464401245
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from an archive by identifying those with the highest total distance across three objectives, then applies a 2-opt local search to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with larger total distances, while the 2-opt operator performs a simple edge swap to explore the solution space. The method balances exploration and exploitation by focusing on high-potential solutions and using a standard local search heuristic.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the total distance for each solution in the archive\n    total_distances = []\n    for sol in archive_solutions:\n        dist1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        dist2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        dist3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_3[sol[-1], sol[0]]\n        total_distances.append((dist1, dist2, dist3))\n\n    # Find the solution with the highest potential for improvement (e.g., largest total distance)\n    max_total = max(sum(d) for d in total_distances)\n    candidate_indices = [i for i, d in enumerate(total_distances) if sum(d) == max_total]\n    selected_index = np.random.choice(candidate_indices)\n    base_solution = archive_solutions[selected_index]\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n\n    # Select two random edges to swap (2-opt)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform the 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    assert len(set(new_solution)) == len(new_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7061353800779911,
            3.1323493838310243
        ]
    },
    {
        "algorithm": "The algorithm selects a high-performing solution from the archive (top 30% by normalized objective sums) and applies a hybrid local search combining 2-opt in a random objective space with an adaptive edge swap targeting the least-improved objective, ensuring feasibility and balancing exploration and exploitation. It prioritizes solutions with better overall performance while adaptively refining the tour based on the objective space that needs most improvement. The approach ensures the generated neighbor remains a valid TSP tour by verifying uniqueness of nodes.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the top 30% of the archive\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_30 = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = np.random.randint(len(top_30))\n    base_solution = top_30[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    n = len(new_solution)\n\n    # 1. 2-opt in a random objective space\n    obj_idx = np.random.randint(3)\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Adaptive edge swap targeting the least-improved objective\n    objectives = [sum(x[1]) for x in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    least_improved_obj = np.argmin(avg_objectives)\n\n    if least_improved_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif least_improved_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    worst_edge = -1\n    worst_cost = -1\n    for k in range(n):\n        u = new_solution[k]\n        v = new_solution[(k+1) % n]\n        cost = dist_matrix[u, v]\n        if cost > worst_cost:\n            worst_cost = cost\n            worst_edge = k\n\n    if worst_edge != -1:\n        u = new_solution[worst_edge]\n        v = new_solution[(worst_edge + 1) % n]\n        candidates = [i for i in range(n) if i != u and i != v]\n\n        if candidates:\n            best_candidate = None\n            best_improvement = 0\n            for candidate in candidates:\n                new_cost = dist_matrix[u, candidate] + dist_matrix[candidate, v] - dist_matrix[u, v]\n                if new_cost < best_improvement:\n                    best_improvement = new_cost\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                pos = (worst_edge + 1) % n\n                new_solution = np.delete(new_solution, np.where(new_solution == best_candidate)[0][0])\n                new_solution = np.insert(new_solution, pos, best_candidate)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6532366482974389,
            0.41195461750030515
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a random solution from the archive and applies a hybrid local search combining 2-opt edge swaps and path relinking to merge segments from other solutions, ensuring feasibility by validating node uniqueness and completeness. The method prioritizes exploration through random edge selection and exploitation via path relinking, balancing diversity and improvement potential across the three objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with path relinking\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Randomly select two edges to swap (2-opt)\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Path relinking: merge with another solution in the archive\n        if len(archive) > 1:\n            other_solution = archive[np.random.choice(len(archive))][0]\n            # Find common segments to merge\n            common = np.intersect1d(new_solution, other_solution)\n            if len(common) > 2:\n                # Merge the common segments\n                mask = np.isin(new_solution, common)\n                new_solution[mask] = other_solution[np.isin(other_solution, common)]\n\n        # Ensure feasibility (no duplicates, all nodes visited)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6120159429983857,
            2.601220631599426
        ]
    },
    {
        "algorithm": "The algorithm selects a diverse solution from the archive based on objective value spread, then applies an objective-aware segment inversion by reversing a segment if it improves at least one objective, while ensuring feasibility. It prioritizes solutions with high diversity in objectives and uses segment inversion to explore trade-offs between the three objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = []\n    for obj in objectives:\n        diversity = (max(obj) - min(obj)) / (sum(obj) + 1e-10)\n        diversity_scores.append(diversity)\n\n    max_diversity = max(diversity_scores)\n    candidate_indices = [i for i, score in enumerate(diversity_scores) if score == max_diversity]\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Objective-aware segment inversion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a segment to reverse based on objective trade-offs\n    i = np.random.randint(n)\n    j = np.random.randint(n)\n    if i > j:\n        i, j = j, i\n\n    # Calculate the cost of the segment in each objective\n    segment_costs = []\n    for k in range(i, j):\n        cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n        cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n        cost3 = distance_matrix_3[new_solution[k], new_solution[k+1]]\n        segment_costs.append((cost1, cost2, cost3))\n\n    # Reverse the segment if it improves at least one objective\n    reversed_costs = segment_costs[::-1]\n    improvement = False\n    for orig, rev in zip(segment_costs, reversed_costs):\n        if any(r <= o for r, o in zip(rev, orig)):\n            improvement = True\n            break\n\n    if improvement:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4529754806284839,
            0.47455564737319944
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining 2-opt and 3-opt moves across all three objective spaces, ensuring feasibility by reversing segments and checking if the move improves all objectives. The process iterates 10 times, prioritizing solutions that dominate in all objectives while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt moves across all three objectives\n    n = len(base_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two distinct positions for 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the move improves any objective\n        old_costs = archive[selected_idx][1]\n        new_costs = (\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        if all(new_costs[k] <= old_costs[k] for k in range(3)):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n        # Randomly select three distinct positions for 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Apply 3-opt (reverse segments)\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n        # Check if the move improves any objective\n        new_costs = (\n            sum(distance_matrix_1[new_solution[l-1], new_solution[l]] for l in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[l-1], new_solution[l]] for l in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[l-1], new_solution[l]] for l in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        if all(new_costs[k] <= old_costs[k] for k in range(3)):\n            base_solution = new_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.5424866469897938,
            3.229469192028046
        ]
    }
]