[
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4691559122976757,
            0.2596275210380554
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    diversity_scores = []\n    for i, (sol_i, _) in enumerate(archive):\n        avg_dist = 0\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j:\n                # Compare route structures\n                common_customers = set()\n                for route in sol_i:\n                    common_customers.update(route[1:-1])\n                for route in sol_j:\n                    common_customers.intersection_update(route[1:-1])\n                avg_dist += len(common_customers)\n        diversity_scores.append(avg_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8830453666745885,
            1.5841413736343384
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4691559122976757,
            0.2596275210380554
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest total distance and lowest makespan ratio, then applies a hybrid local search combining route splitting and customer reinsertion with demand-aware optimizations to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([(sol[1][0] / (sol[1][1] + 1e-6)) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: split long routes and reinsert customers with demand-aware optimizations\n    for route in new_solution:\n        if len(route) > 3:  # Only consider routes with more than 2 customers\n            # Split the route into two parts at a random position\n            split_pos = np.random.randint(1, len(route) - 1)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n\n            # Check if splitting is feasible\n            if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                # Create new routes\n                new_route1 = part1.copy()\n                new_route2 = part2.copy()\n\n                # Try to reinsert customers from the longer route into the shorter one\n                for i in range(len(new_route2) - 2, 0, -1):\n                    customer = new_route2[i]\n                    # Find best insertion position in new_route1\n                    best_pos = 0\n                    best_cost = float('inf')\n                    for j in range(1, len(new_route1)):\n                        # Calculate insertion cost\n                        cost = (distance_matrix[new_route1[j-1], customer] +\n                                distance_matrix[customer, new_route1[j]] -\n                                distance_matrix[new_route1[j-1], new_route1[j]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = j\n                    # Check if insertion is feasible\n                    if np.sum(demand[new_route1[1:-1]]) + demand[customer] <= capacity:\n                        new_route1 = np.insert(new_route1, best_pos, customer)\n                        new_route2 = np.delete(new_route2, i)\n\n                # Update the solution\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                if len(new_route1) > 2:\n                    new_solution.append(new_route1)\n                if len(new_route2) > 2:\n                    new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.8487900587426402,
            1.3511261940002441
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel hybrid local search combining intra-route segment reversal with inter-route demand-aware merging to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(dist + span) / (1 + np.random.uniform(0.5, 1.5)) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: Demand-aware segment reversal with route merging\n    if len(new_solution) > 1:\n        # Select two routes with high demand utilization\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_indices = sorted(range(len(route_demands)), key=lambda i: route_demands[i], reverse=True)[:2]\n\n        # Reverse a high-demand segment in one route\n        route_idx = route_indices[0]\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Find segment with highest demand\n            segment_lengths = [len(route[i:i+3]) for i in range(1, len(route)-3)]\n            segment_idx = np.argmax(segment_lengths)\n            i, j = segment_idx + 1, segment_idx + 3\n\n            # Reverse the segment\n            new_segment = route[i:j+1][::-1]\n            new_route = np.concatenate([route[:i], new_segment, route[j+1:]])\n\n            # Check feasibility\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n        # Merge the two selected routes if demand allows\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Find best connection point\n            best_cost = float('inf')\n            best_merge = None\n\n            # Try connecting route2 to route1 at different positions\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    cost = (distance_matrix[route1[i-1], route2[j]] +\n                           distance_matrix[route2[j], route1[i]] -\n                           distance_matrix[route1[i-1], route1[i]] -\n                           distance_matrix[route2[j-1], route2[j]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_merge = (i, j)\n\n            if best_merge:\n                i, j = best_merge\n                merged_route = np.concatenate([\n                    route1[:i],\n                    route2[j:],\n                    route2[:j],\n                    route1[i:]\n                ])\n                new_solution[route_indices[0]] = merged_route\n                del new_solution[route_indices[1]]\n\n    # Final feasibility check and repair\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Split route at the point where demand exceeds capacity\n            cumulative_demand = np.cumulative_sum(demand[route[1:-1]])\n            split_idx = np.argmax(cumulative_demand > capacity) + 1\n            new_route1 = route[:split_idx+1]\n            new_route2 = np.concatenate([[0], route[split_idx+1:]])\n\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.6699021614792291,
            0.2746742069721222
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware criterion, then applies a novel route transformation that combines demand-aware clustering with adaptive route merging, followed by a limited cross-route segment relocation to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.mean(norm_obj, axis=1) * (1 - np.max(norm_obj, axis=1))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Demand-aware clustering: group customers with similar demand patterns\n    if len(new_solution) > 1:\n        # Find the most demanding route\n        route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        target_route_idx = np.argmax(route_demands)\n        target_route = new_solution[target_route_idx]\n\n        # Find the least demanding route\n        least_demand_idx = np.argmin(route_demands)\n        least_demand_route = new_solution[least_demand_idx]\n\n        # Move customers from target route to least demand route if feasible\n        for i in range(1, len(target_route)-1):\n            customer = target_route[i]\n            if (np.sum(demand[least_demand_route[1:-1]]) + demand[customer] <= capacity and\n                np.sum(demand[target_route[1:-1]]) - demand[customer] <= capacity):\n\n                # Find best insertion position in least demand route\n                best_pos = 1\n                min_cost = float('inf')\n                for j in range(1, len(least_demand_route)):\n                    cost = (distance_matrix[least_demand_route[j-1], customer] +\n                           distance_matrix[customer, least_demand_route[j]] -\n                           distance_matrix[least_demand_route[j-1], least_demand_route[j]])\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = j\n\n                # Perform the move\n                least_demand_route = np.insert(least_demand_route, best_pos, customer)\n                target_route = np.delete(target_route, i)\n\n                # Update routes\n                new_solution[least_demand_idx] = least_demand_route\n                new_solution[target_route_idx] = target_route\n                break\n\n    # Adaptive route merging: merge routes with low demand utilization\n    if len(new_solution) > 1:\n        route_utilization = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n        underutilized_routes = [i for i, util in enumerate(route_utilization) if util < 0.5]\n\n        if len(underutilized_routes) > 1:\n            # Select two underutilized routes to merge\n            route1_idx, route2_idx = random.sample(underutilized_routes, 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Merge routes by connecting the second route to the first\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Limited cross-route segment relocation for makespan improvement\n    if len(new_solution) > 1:\n        # Find the longest route\n        route_lengths = [np.sum([distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)])\n                        for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        longest_route = new_solution[longest_route_idx]\n\n        # Find the shortest route\n        shortest_route_idx = np.argmin(route_lengths)\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Select a random segment from the longest route\n        if len(longest_route) > 3:\n            segment_start = random.randint(1, len(longest_route)-3)\n            segment_end = random.randint(segment_start, len(longest_route)-2)\n            segment = longest_route[segment_start:segment_end+1]\n\n            # Check if relocation is feasible\n            if (np.sum(demand[shortest_route[1:-1]]) + np.sum(demand[segment[1:-1]]) <= capacity and\n                np.sum(demand[longest_route[1:-1]]) - np.sum(demand[segment[1:-1]]) <= capacity):\n\n                # Find best insertion position in shortest route\n                best_pos = 1\n                min_cost = float('inf')\n                for j in range(1, len(shortest_route)):\n                    cost = (distance_matrix[shortest_route[j-1], segment[0]] +\n                           distance_matrix[segment[-1], shortest_route[j]] -\n                           distance_matrix[shortest_route[j-1], shortest_route[j]])\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = j\n\n                # Perform the relocation\n                new_shortest_route = np.concatenate([\n                    shortest_route[:best_pos],\n                    segment,\n                    shortest_route[best_pos:]\n                ])\n                new_longest_route = np.concatenate([\n                    longest_route[:segment_start],\n                    longest_route[segment_end+1:]\n                ])\n\n                # Update routes\n                new_solution[shortest_route_idx] = new_shortest_route\n                new_solution[longest_route_idx] = new_longest_route\n\n    return new_solution\n\n",
        "score": [
            -0.7221711233982888,
            0.46835508942604065
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    diversity_scores = []\n    for i, (sol_i, _) in enumerate(archive):\n        avg_dist = 0\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j:\n                # Compare route structures\n                common_customers = set()\n                for route in sol_i:\n                    common_customers.update(route[1:-1])\n                for route in sol_j:\n                    common_customers.intersection_update(route[1:-1])\n                avg_dist += len(common_customers)\n        diversity_scores.append(avg_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8830453666745885,
            1.5841413736343384
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4691559122976757,
            0.2596275210380554
        ]
    }
]