[
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4691559122976757,
            0.2596275210380554
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects the solution with the highest makespan from the archive, then applies a novel \"route merging and customer reinsertion\" local search operator that combines routes with sufficient capacity and reinserts customers from the merged route back into the solution while optimizing both distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmax([span for _, (_, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging and customer reinsertion\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        total_demand = np.sum(demand[route1]) + np.sum(demand[route2])\n        if total_demand <= capacity:\n            # Merge the routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Remove the original routes\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n\n            # Add the merged route\n            new_solution.append(merged_route)\n\n            # Reinsert customers from the merged route back into the solution\n            customers_to_reinsert = merged_route[1:-1]\n            random.shuffle(customers_to_reinsert)\n\n            for customer in customers_to_reinsert:\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_insert_cost = float('inf')\n\n                # Find the best route and position to insert the customer\n                for i, route in enumerate(new_solution):\n                    for pos in range(1, len(route)):\n                        # Try inserting after route[pos-1] and before route[pos]\n                        new_demand = np.sum(demand[route]) + demand[customer]\n                        if new_demand > capacity:\n                            continue\n\n                        # Calculate insertion cost (distance increase)\n                        cost = (distance_matrix[route[pos-1], customer] +\n                                distance_matrix[customer, route[pos]] -\n                                distance_matrix[route[pos-1], route[pos]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                # Perform the best insertion\n                if best_route_idx != -1:\n                    new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n                else:\n                    # If no feasible insertion found, create a new route\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7381911227734024,
            0.10858073830604553
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel hybrid local search operator that combines intra-route segment reversal with inter-route segment swapping, followed by a capacity-aware route merging step to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: intra-route segment reversal with inter-route segment swapping\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Intra-route segment reversal for route1\n        if len(route1) > 3:\n            start, end = sorted(random.sample(range(1, len(route1)-1), 2))\n            reversed_segment = route1[start:end+1][::-1]\n            new_route1 = np.concatenate([route1[:start], reversed_segment, route1[end+1:]])\n        else:\n            new_route1 = route1.copy()\n\n        # Inter-route segment swapping\n        if len(route2) > 2:\n            segment_start = random.randint(1, len(route2)-2)\n            segment_end = random.randint(segment_start, len(route2)-2)\n            segment = route2[segment_start:segment_end+1]\n\n            # Check demand feasibility\n            if (np.sum(demand[new_route1]) - np.sum(demand[segment]) + np.sum(demand[segment])) <= capacity:\n                new_route1 = np.concatenate([new_route1[:-1], segment, [0]])\n                new_route2 = np.concatenate([route2[:segment_start], route2[segment_end+1:]])\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Capacity-aware route merging\n    if len(new_solution) > 2:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if (np.sum(demand[route1]) + np.sum(demand[route2])) <= capacity:\n            # Merge routes by removing one depot\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.600043717826733,
            0.07306703925132751
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a rank-based selection metric, then applies a hybrid route transformation that combines partial route reversal with a demand-aware customer exchange to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        ranks[sorted_idx] = np.arange(len(archive))\n\n    total_rank = np.sum(ranks)\n    selected_idx = np.argmin(total_rank)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid route transformation: partial route reversal with demand-aware exchange\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to exchange a customer with another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3 and len(new_route) > 3:  # Can exchange customers\n                        # Select a customer to exchange from each route\n                        customer_pos1 = random.randint(1, len(new_route)-2)\n                        customer1 = new_route[customer_pos1]\n                        customer_pos2 = random.randint(1, len(other_route)-2)\n                        customer2 = other_route[customer_pos2]\n\n                        # Check demand feasibility\n                        new_route_demand = np.sum(demand[new_route[1:-1]]) - demand[customer1] + demand[customer2]\n                        other_route_demand = np.sum(demand[other_route[1:-1]]) - demand[customer2] + demand[customer1]\n\n                        if new_route_demand <= capacity and other_route_demand <= capacity:\n                            # Perform the exchange\n                            new_route_exchanged = new_route.copy()\n                            new_route_exchanged[customer_pos1] = customer2\n                            other_route_exchanged = other_route.copy()\n                            other_route_exchanged[customer_pos2] = customer1\n\n                            new_solution[route_idx] = new_route_exchanged\n                            new_solution[other_idx] = other_route_exchanged\n\n    return new_solution\n\n",
        "score": [
            -0.8511150859454952,
            0.13223952054977417
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = []\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances\n    total_crowding = np.sum(crowding_distances, axis=0)\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9086425958447003,
            0.17228755354881287
        ]
    }
]