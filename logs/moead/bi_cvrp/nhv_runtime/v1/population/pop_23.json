[
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4691559122976757,
            0.2596275210380554
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score that balances both distance and makespan, then applies a novel local search operator that combines route merging with demand-aware customer reallocation to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(dist + 0.5 * span) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search: route merging with demand-aware reallocation\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Calculate total demand and check feasibility\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n        else:\n            # If not feasible, try reallocating customers between routes\n            customers1 = route1[1:-1]\n            customers2 = route2[1:-1]\n\n            # Find customers to move from route1 to route2\n            for customer in customers1:\n                if (np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity and\n                    np.sum(demand[route1[1:-1]]) - demand[customer] <= capacity):\n                    # Find best insertion position in route2\n                    min_cost = float('inf')\n                    best_pos = -1\n                    for i in range(1, len(route2)):\n                        cost = (distance_matrix[route2[i-1], customer] +\n                                distance_matrix[customer, route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = i\n\n                    # Perform the move\n                    route2 = np.insert(route2, best_pos, customer)\n                    route1 = route1[route1 != customer]\n\n                    # Update the solution\n                    new_solution[route1_idx] = np.concatenate([[0], route1, [0]])\n                    new_solution[route2_idx] = route2\n                    break\n\n    # Additional optimization: customer reallocation between routes\n    if len(new_solution) > 1:\n        # Select a random route to try to remove a customer\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Can remove a customer\n            # Select a customer to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Try to find a better route for this customer\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    for j in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[j-1], customer] +\n                                distance_matrix[customer, other_route[j]] -\n                                distance_matrix[other_route[j-1], other_route[j]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route_idx = i\n                            best_pos = j\n\n            if best_route_idx != -1:\n                # Perform the move\n                other_route = new_solution[best_route_idx]\n                other_route = np.insert(other_route, best_pos, customer)\n                route = np.delete(route, customer_pos)\n\n                # Update the solution\n                new_solution[route_idx] = route\n                new_solution[best_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.9099405906073201,
            0.22178658843040466
        ]
    }
]