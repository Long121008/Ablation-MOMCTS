[
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4691559122976757,
            0.2596275210380554
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1/len(archive) for _ in range(len(archive))])\n    selected_solution = archive[selected_idx][0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: merge two short routes if possible\n    if len(new_solution) > 1:\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Merge routes by connecting the second route to the first\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_indices[0]] = merged_route\n            del new_solution[route_indices[1]]\n\n    # Reallocate a random customer from a long route to a short route if feasible\n    long_route_idx = np.argmax([len(route) for route in new_solution])\n    if len(new_solution) > 1 and len(new_solution[long_route_idx]) > 3:\n        long_route = new_solution[long_route_idx]\n        short_route_idx = np.argmin([len(route) for route in new_solution])\n        short_route = new_solution[short_route_idx]\n\n        # Select a random customer to move\n        customer_idx = np.random.randint(1, len(long_route)-1)\n        customer = long_route[customer_idx]\n\n        # Check if reallocation is feasible\n        if sum(demand[short_route[1:-1]]) + demand[customer] <= capacity:\n            # Find the best insertion point in the short route\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(1, len(short_route)):\n                cost = distance_matrix[short_route[i-1], customer] + distance_matrix[customer, short_route[i]] - distance_matrix[short_route[i-1], short_route[i]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            # Insert the customer\n            new_short_route = np.insert(short_route, best_pos, customer)\n            new_solution[short_route_idx] = new_short_route\n\n            # Remove the customer from the long route\n            new_long_route = np.delete(long_route, customer_idx)\n            new_solution[long_route_idx] = new_long_route\n\n    # Apply a limited 2-opt for intra-route optimization\n    for route in new_solution:\n        if len(route) > 4:\n            i, j = np.random.choice(range(1, len(route)-1), size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            # Reverse the segment between i and j\n            new_segment = route[i:j+1][::-1]\n            new_route = np.concatenate([route[:i], new_segment, route[j+1:]])\n            # Check if the new route is feasible\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                route[:] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.5227333132434248,
            0.3569796681404114
        ]
    }
]