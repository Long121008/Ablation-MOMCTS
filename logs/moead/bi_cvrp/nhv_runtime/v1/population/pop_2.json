[
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n",
        "score": [
            -0.4691559122976757,
            0.2596275210380554
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel route transformation that combines partial route reversal with demand-constrained customer insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    diversity_scores = []\n    for i, (sol_i, _) in enumerate(archive):\n        avg_dist = 0\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j:\n                # Compare route structures\n                common_customers = set()\n                for route in sol_i:\n                    common_customers.update(route[1:-1])\n                for route in sol_j:\n                    common_customers.intersection_update(route[1:-1])\n                avg_dist += len(common_customers)\n        diversity_scores.append(avg_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation: partial route reversal with demand-constrained insertion\n    if len(new_solution) > 1:\n        # Select a random route and a random segment to reverse\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Need at least 4 nodes to reverse a segment\n            # Select a segment to reverse\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            segment = route[start:end+1][::-1]\n\n            # Create new route with reversed segment\n            new_route = np.concatenate([route[:start], segment, route[end+1:]])\n\n            # Check if demand is feasible\n            if np.sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = new_route\n\n                # Try to insert a customer from another route if possible\n                other_routes = [i for i in range(len(new_solution)) if i != route_idx]\n                if other_routes:\n                    other_idx = random.choice(other_routes)\n                    other_route = new_solution[other_idx]\n\n                    if len(other_route) > 3:  # Can remove a customer\n                        # Select a customer to move\n                        customer_pos = random.randint(1, len(other_route)-2)\n                        customer = other_route[customer_pos]\n\n                        # Find best insertion point in the new route\n                        min_cost = float('inf')\n                        best_pos = -1\n                        for i in range(1, len(new_route)):\n                            cost = (distance_matrix[new_route[i-1], customer] +\n                                    distance_matrix[customer, new_route[i]] -\n                                    distance_matrix[new_route[i-1], new_route[i]])\n                            if cost < min_cost:\n                                min_cost = cost\n                                best_pos = i\n\n                        # Check demand feasibility\n                        if (np.sum(demand[new_route[1:-1]]) + demand[customer] <= capacity and\n                            np.sum(demand[other_route[1:-1]]) - demand[customer] <= capacity):\n\n                            # Perform the insertion\n                            new_route_inserted = np.insert(new_route, best_pos, customer)\n                            new_solution[route_idx] = new_route_inserted\n\n                            # Remove customer from original route\n                            new_other_route = np.delete(other_route, customer_pos)\n                            new_solution[other_idx] = new_other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8830453666745885,
            1.5841413736343384
        ]
    }
]