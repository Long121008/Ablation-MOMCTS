[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective score that balances both distance and makespan, then applies a novel local search operator that combines route merging with demand-aware customer reallocation to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(dist + 0.5 * span) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search: route merging with demand-aware reallocation\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Calculate total demand and check feasibility\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n        else:\n            # If not feasible, try reallocating customers between routes\n            customers1 = route1[1:-1]\n            customers2 = route2[1:-1]\n\n            # Find customers to move from route1 to route2\n            for customer in customers1:\n                if (np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity and\n                    np.sum(demand[route1[1:-1]]) - demand[customer] <= capacity):\n                    # Find best insertion position in route2\n                    min_cost = float('inf')\n                    best_pos = -1\n                    for i in range(1, len(route2)):\n                        cost = (distance_matrix[route2[i-1], customer] +\n                                distance_matrix[customer, route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = i\n\n                    # Perform the move\n                    route2 = np.insert(route2, best_pos, customer)\n                    route1 = route1[route1 != customer]\n\n                    # Update the solution\n                    new_solution[route1_idx] = np.concatenate([[0], route1, [0]])\n                    new_solution[route2_idx] = route2\n                    break\n\n    # Additional optimization: customer reallocation between routes\n    if len(new_solution) > 1:\n        # Select a random route to try to remove a customer\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Can remove a customer\n            # Select a customer to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Try to find a better route for this customer\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    for j in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[j-1], customer] +\n                                distance_matrix[customer, other_route[j]] -\n                                distance_matrix[other_route[j-1], other_route[j]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route_idx = i\n                            best_pos = j\n\n            if best_route_idx != -1:\n                # Perform the move\n                other_route = new_solution[best_route_idx]\n                other_route = np.insert(other_route, best_pos, customer)\n                route = np.delete(route, customer_pos)\n\n                # Update the solution\n                new_solution[route_idx] = route\n                new_solution[best_route_idx] = other_route\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a hybrid objective score that balances both distance and makespan, then applies a novel local search operator that combines route merging with demand-aware customer reallocation to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(dist + 0.5 * span) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search: route merging with demand-aware reallocation\n    if len(new_solution) > 1:\n        # Select two routes to potentially merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Calculate total demand and check feasibility\n        total_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n        if total_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            new_solution.pop(route2_idx)\n        else:\n            # If not feasible, try reallocating customers between routes\n            customers1 = route1[1:-1]\n            customers2 = route2[1:-1]\n\n            # Find customers to move from route1 to route2\n            for customer in customers1:\n                if (np.sum(demand[route2[1:-1]]) + demand[customer] <= capacity and\n                    np.sum(demand[route1[1:-1]]) - demand[customer] <= capacity):\n                    # Find best insertion position in route2\n                    min_cost = float('inf')\n                    best_pos = -1\n                    for i in range(1, len(route2)):\n                        cost = (distance_matrix[route2[i-1], customer] +\n                                distance_matrix[customer, route2[i]] -\n                                distance_matrix[route2[i-1], route2[i]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = i\n\n                    # Perform the move\n                    route2 = np.insert(route2, best_pos, customer)\n                    route1 = route1[route1 != customer]\n\n                    # Update the solution\n                    new_solution[route1_idx] = np.concatenate([[0], route1, [0]])\n                    new_solution[route2_idx] = route2\n                    break\n\n    # Additional optimization: customer reallocation between routes\n    if len(new_solution) > 1:\n        # Select a random route to try to remove a customer\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Can remove a customer\n            # Select a customer to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Try to find a better route for this customer\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    for j in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[j-1], customer] +\n                                distance_matrix[customer, other_route[j]] -\n                                distance_matrix[other_route[j-1], other_route[j]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route_idx = i\n                            best_pos = j\n\n            if best_route_idx != -1:\n                # Perform the move\n                other_route = new_solution[best_route_idx]\n                other_route = np.insert(other_route, best_pos, customer)\n                route = np.delete(route, customer_pos)\n\n                # Update the solution\n                new_solution[route_idx] = route\n                new_solution[best_route_idx] = other_route\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score that balances both distance and makespan, then applies a novel local search operator that combines route splitting with capacity-aware customer redistribution to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(dist + 0.5 * span) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search: route splitting with capacity-aware redistribution\n    if len(new_solution) < len(demand) - 1:  # Can potentially split routes\n        # Select a random route to potentially split\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Can split into at least two routes\n            # Find the best split point that minimizes the increase in total distance\n            best_split_pos = -1\n            best_cost = float('inf')\n\n            for split_pos in range(2, len(route)-2):\n                # Calculate the cost of splitting at this position\n                cost = (distance_matrix[route[split_pos-1], 0] +  # Return to depot from first part\n                        distance_matrix[0, route[split_pos]] +    # Start second part from depot\n                        distance_matrix[route[-2], 0] -          # Original return trip\n                        distance_matrix[route[split_pos-1], route[-2]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_split_pos = split_pos\n\n            if best_split_pos != -1:\n                # Split the route\n                first_part = route[:best_split_pos]\n                second_part = route[best_split_pos-1:]\n\n                # Check capacity constraints\n                first_demand = np.sum(demand[first_part[1:-1]])\n                second_demand = np.sum(demand[second_part[1:-1]])\n\n                if first_demand <= capacity and second_demand <= capacity:\n                    # Perform the split\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n\n    # Additional optimization: customer redistribution between routes\n    if len(new_solution) > 1:\n        # Select a random route to try to remove a customer\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Can remove a customer\n            # Select a customer to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Try to find a better route for this customer\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    for j in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[j-1], customer] +\n                                distance_matrix[customer, other_route[j]] -\n                                distance_matrix[other_route[j-1], other_route[j]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route_idx = i\n                            best_pos = j\n\n            if best_route_idx != -1:\n                # Perform the move\n                other_route = new_solution[best_route_idx]\n                other_route = np.insert(other_route, best_pos, customer)\n                route = np.delete(route, customer_pos)\n\n                # Update the solution\n                new_solution[route_idx] = route\n                new_solution[best_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8921509338105598,
            0.13782986998558044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(dist + 0.5 * span) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search: route splitting with capacity-aware redistribution\n    if len(new_solution) < len(demand) - 1:  # Can potentially split routes\n        # Select a random route to potentially split\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 4:  # Can split into at least two routes\n            # Find the best split point that minimizes the increase in total distance\n            best_split_pos = -1\n            best_cost = float('inf')\n\n            for split_pos in range(2, len(route)-2):\n                # Calculate the cost of splitting at this position\n                cost = (distance_matrix[route[split_pos-1], 0] +  # Return to depot from first part\n                        distance_matrix[0, route[split_pos]] +    # Start second part from depot\n                        distance_matrix[route[-2], 0] -          # Original return trip\n                        distance_matrix[route[split_pos-1], route[-2]])\n\n                if cost < best_cost:\n                    best_cost = cost\n                    best_split_pos = split_pos\n\n            if best_split_pos != -1:\n                # Split the route\n                first_part = route[:best_split_pos]\n                second_part = route[best_split_pos-1:]\n\n                # Check capacity constraints\n                first_demand = np.sum(demand[first_part[1:-1]])\n                second_demand = np.sum(demand[second_part[1:-1]])\n\n                if first_demand <= capacity and second_demand <= capacity:\n                    # Perform the split\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n\n    # Additional optimization: customer redistribution between routes\n    if len(new_solution) > 1:\n        # Select a random route to try to remove a customer\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Can remove a customer\n            # Select a customer to move\n            customer_pos = random.randint(1, len(route)-2)\n            customer = route[customer_pos]\n\n            # Try to find a better route for this customer\n            best_route_idx = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    for j in range(1, len(other_route)):\n                        cost = (distance_matrix[other_route[j-1], customer] +\n                                distance_matrix[customer, other_route[j]] -\n                                distance_matrix[other_route[j-1], other_route[j]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route_idx = i\n                            best_pos = j\n\n            if best_route_idx != -1:\n                # Perform the move\n                other_route = new_solution[best_route_idx]\n                other_route = np.insert(other_route, best_pos, customer)\n                route = np.delete(route, customer_pos)\n\n                # Update the solution\n                new_solution[route_idx] = route\n                new_solution[best_route_idx] = other_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines route-segment swapping with demand-balanced route splitting to generate a high-quality neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = np.argmin([(dist + span) for _, (dist, span) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route-segment swap with demand balancing\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        # Find segments to swap\n        segment1_start = random.randint(1, len(route1) - 2)\n        segment1_end = random.randint(segment1_start, len(route1) - 2)\n        segment1 = route1[segment1_start:segment1_end + 1]\n\n        segment2_start = random.randint(1, len(route2) - 2)\n        segment2_end = random.randint(segment2_start, len(route2) - 2)\n        segment2 = route2[segment2_start:segment2_end + 1]\n\n        # Check demand feasibility after swap\n        demand1_after = (np.sum(demand[route1]) - np.sum(demand[segment1]) + np.sum(demand[segment2])) <= capacity\n        demand2_after = (np.sum(demand[route2]) - np.sum(demand[segment2]) + np.sum(demand[segment1])) <= capacity\n\n        if demand1_after and demand2_after:\n            # Perform the swap\n            new_route1 = np.concatenate([route1[:segment1_start], segment2, route1[segment1_end + 1:]])\n            new_route2 = np.concatenate([route2[:segment2_start], segment1, route2[segment2_end + 1:]])\n\n            # Update the solution\n            new_solution[route1_idx] = new_route1\n            new_solution[route2_idx] = new_route2\n\n    # Demand-balanced route splitting\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find split point where demand is balanced\n            cumulative_demand = np.cumulative_sum(demand[route])\n            split_idx = np.argmax(cumulative_demand <= capacity) + 1\n\n            # Create new route\n            new_route1 = route[:split_idx]\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n\n            # Update the solution\n            new_solution[i] = new_route1\n            new_solution.append(new_route2)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search operator that combines route merging with strategic customer reallocation to balance demand and reduce makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on distance to encourage diverse exploration\n    scores = [(dist * weights[0] + span * weights[1]) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging with strategic customer reallocation\n    if len(new_solution) > 1:\n        # Select two routes with similar total demand\n        demands = [np.sum(demand[route]) for route in new_solution]\n        mean_demand = np.mean(demands)\n        candidate_pairs = [(i, j) for i in range(len(new_solution))\n                         for j in range(i+1, len(new_solution))\n                         if abs(demands[i] + demands[j] - 2*mean_demand) < 0.3*mean_demand]\n\n        if candidate_pairs:\n            i, j = random.choice(candidate_pairs)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Check if merging is feasible\n            if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                # Reallocate customers based on spatial proximity\n                customers1 = route1[1:-1]\n                customers2 = route2[1:-1]\n                all_customers = np.concatenate([customers1, customers2])\n\n                # Create new route by selecting customers in order of proximity to depot\n                depot_coords = coords[0]\n                dist_to_depot = np.linalg.norm(coords[all_customers] - depot_coords, axis=1)\n                sorted_customers = all_customers[np.argsort(dist_to_depot)]\n\n                # Build new route incrementally\n                new_route = [0]\n                current_demand = 0\n                for customer in sorted_customers:\n                    if current_demand + demand[customer] <= capacity:\n                        new_route.append(customer)\n                        current_demand += demand[customer]\n\n                new_route.append(0)\n                new_solution[i] = np.array(new_route)\n                del new_solution[j]\n\n    # Demand-balanced customer insertion\n    for route in new_solution:\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find customers to remove and reinsert\n            excess_demand = route_demand - capacity\n            customers = route[1:-1]\n            sorted_customers = sorted(customers, key=lambda x: demand[x], reverse=True)\n\n            # Remove customers until demand is within capacity\n            for customer in sorted_customers:\n                if excess_demand <= 0:\n                    break\n                excess_demand -= demand[customer]\n                route = route[route != customer]\n\n            # Reinsert removed customers into other routes or new routes\n            removed_customers = customers[np.isin(customers, route[1:-1], invert=True)]\n            for customer in removed_customers:\n                inserted = False\n                for other_route in new_solution:\n                    if other_route is not route and np.sum(demand[other_route]) + demand[customer] <= capacity:\n                        # Insert at position that minimizes additional distance\n                        insertion_costs = []\n                        for pos in range(1, len(other_route)):\n                            prev_node = other_route[pos-1]\n                            next_node = other_route[pos]\n                            cost = (distance_matrix[prev_node, customer] +\n                                  distance_matrix[customer, next_node] -\n                                  distance_matrix[prev_node, next_node])\n                            insertion_costs.append(cost)\n\n                        best_pos = np.argmin(insertion_costs) + 1\n                        other_route = np.insert(other_route, best_pos, customer)\n                        inserted = True\n                        break\n\n                if not inserted:\n                    # Create new route if no suitable existing route\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6580152605246117,
            3.348449170589447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.7, 0.3]  # More weight on distance to encourage diverse exploration\n    scores = [(dist * weights[0] + span * weights[1]) for _, (dist, span) in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging with strategic customer reallocation\n    if len(new_solution) > 1:\n        # Select two routes with similar total demand\n        demands = [np.sum(demand[route]) for route in new_solution]\n        mean_demand = np.mean(demands)\n        candidate_pairs = [(i, j) for i in range(len(new_solution))\n                         for j in range(i+1, len(new_solution))\n                         if abs(demands[i] + demands[j] - 2*mean_demand) < 0.3*mean_demand]\n\n        if candidate_pairs:\n            i, j = random.choice(candidate_pairs)\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Check if merging is feasible\n            if np.sum(demand[route1]) + np.sum(demand[route2]) <= capacity:\n                # Reallocate customers based on spatial proximity\n                customers1 = route1[1:-1]\n                customers2 = route2[1:-1]\n                all_customers = np.concatenate([customers1, customers2])\n\n                # Create new route by selecting customers in order of proximity to depot\n                depot_coords = coords[0]\n                dist_to_depot = np.linalg.norm(coords[all_customers] - depot_coords, axis=1)\n                sorted_customers = all_customers[np.argsort(dist_to_depot)]\n\n                # Build new route incrementally\n                new_route = [0]\n                current_demand = 0\n                for customer in sorted_customers:\n                    if current_demand + demand[customer] <= capacity:\n                        new_route.append(customer)\n                        current_demand += demand[customer]\n\n                new_route.append(0)\n                new_solution[i] = np.array(new_route)\n                del new_solution[j]\n\n    # Demand-balanced customer insertion\n    for route in new_solution:\n        route_demand = np.sum(demand[route])\n        if route_demand > capacity:\n            # Find customers to remove and reinsert\n            excess_demand = route_demand - capacity\n            customers = route[1:-1]\n            sorted_customers = sorted(customers, key=lambda x: demand[x], reverse=True)\n\n            # Remove customers until demand is within capacity\n            for customer in sorted_customers:\n                if excess_demand <= 0:\n                    break\n                excess_demand -= demand[customer]\n                route = route[route != customer]\n\n            # Reinsert removed customers into other routes or new routes\n            removed_customers = customers[np.isin(customers, route[1:-1], invert=True)]\n            for customer in removed_customers:\n                inserted = False\n                for other_route in new_solution:\n                    if other_route is not route and np.sum(demand[other_route]) + demand[customer] <= capacity:\n                        # Insert at position that minimizes additional distance\n                        insertion_costs = []\n                        for pos in range(1, len(other_route)):\n                            prev_node = other_route[pos-1]\n                            next_node = other_route[pos]\n                            cost = (distance_matrix[prev_node, customer] +\n                                  distance_matrix[customer, next_node] -\n                                  distance_matrix[prev_node, next_node])\n                            insertion_costs.append(cost)\n\n                        best_pos = np.argmin(insertion_costs) + 1\n                        other_route = np.insert(other_route, best_pos, customer)\n                        inserted = True\n                        break\n\n                if not inserted:\n                    # Create new route if no suitable existing route\n                    new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    }
]