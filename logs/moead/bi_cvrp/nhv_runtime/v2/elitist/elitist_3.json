[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective ratio to prioritize solutions with balanced improvement potential in both objectives, then applies a novel adaptive route merging and customer redistribution strategy that dynamically adjusts split points and considers spatial clustering to generate high-quality neighbors while maintaining feasibility through rigorous capacity checks and demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmin(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) > 1:\n        # Calculate route scores based on distance and demand balance\n        route_scores = []\n        for route in base_solution:\n            customers = route[1:-1]\n            route_demand = np.sum(demand[customers])\n            route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n            score = route_distance * (1 + 0.1 * abs(route_demand - capacity/2))\n            route_scores.append(score)\n\n        # Select routes to merge based on spatial proximity\n        sorted_indices = np.argsort(route_scores)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n        route1, route2 = base_solution[route1_idx], base_solution[route2_idx]\n\n        # Calculate centroids for spatial analysis\n        def get_centroid(route):\n            customers = route[1:-1]\n            if len(customers) == 0:\n                return coords[0]\n            return np.mean(coords[customers], axis=0)\n\n        centroid1, centroid2 = get_centroid(route1), get_centroid(route2)\n        centroid_dist = np.linalg.norm(centroid1 - centroid2)\n\n        # Determine split point based on spatial clustering\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n        all_customers = np.concatenate([customers1, customers2])\n        if len(all_customers) > 0:\n            cluster_center = np.mean(coords[all_customers], axis=0)\n            dist_to_center = np.linalg.norm(coords[all_customers] - cluster_center, axis=1)\n            split_pos = np.argmin(dist_to_center)\n\n            # Create new routes by splitting at the cluster center\n            if split_pos < len(customers1):\n                part1 = np.concatenate(([0], customers1[:split_pos+1], [0]))\n                part2 = np.concatenate(([0], customers1[split_pos+1:], customers2, [0]))\n            else:\n                part1 = np.concatenate(([0], customers1, customers2[:split_pos-len(customers1)+1], [0]))\n                part2 = np.concatenate(([0], customers2[split_pos-len(customers1)+1:], [0]))\n\n            # Validate capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity and\n                np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution = [r for i, r in enumerate(base_solution)\n                               if i not in (route1_idx, route2_idx)]\n                new_solution.extend([part1, part2])\n            else:\n                new_solution = base_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8923663452625354,
            0.6838812530040741
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route splitting and demand-based rebalancing, where we randomly select a route from the solution, split it into two segments based on demand balance, and then insert the second segment into another route in the solution, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select a route to split\n    i = random.choice(range(len(selected_solution)))\n    route = selected_solution[i]\n\n    # Calculate cumulative demand\n    customers = route[1:-1]\n    cumulative_demand = np.cumsum(demand[customers])\n\n    # Find feasible split points based on demand balance\n    feasible_splits = []\n    for k in range(1, len(customers)):\n        if cumulative_demand[k-1] <= capacity and cumulative_demand[-1] - cumulative_demand[k-1] <= capacity:\n            feasible_splits.append(k)\n\n    if not feasible_splits:\n        return selected_solution\n\n    # Choose a random split point\n    split_point = random.choice(feasible_splits)\n\n    # Split the route into two segments\n    segment1 = route[:split_point+1]\n    segment2 = np.concatenate([[0], route[split_point+1:]])\n\n    # Randomly select another route to insert the second segment\n    j = random.choice([x for x in range(len(selected_solution)) if x != i])\n    target_route = selected_solution[j]\n\n    # Find feasible insertion positions in the target route\n    feasible_insertions = []\n    for pos in range(1, len(target_route)):\n        # Check if inserting segment2 at position pos is feasible\n        temp_route = np.concatenate([target_route[:pos], segment2[1:-1], target_route[pos:]])\n        temp_demand = sum(demand[temp_route[1:-1]])\n        if temp_demand <= capacity:\n            feasible_insertions.append(pos)\n\n    if not feasible_insertions:\n        # If no feasible insertion, just replace the original route\n        selected_solution[i] = segment1\n        selected_solution[j] = segment2\n    else:\n        # Insert segment2 at a random feasible position\n        insert_pos = random.choice(feasible_insertions)\n        new_target_route = np.concatenate([target_route[:insert_pos], segment2[1:-1], target_route[insert_pos:]])\n        selected_solution[i] = segment1\n        selected_solution[j] = new_target_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7512851592615626,
            0.0778336226940155
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives, using a different parameter setting for the score function that prioritizes makespan reduction over total distance reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n            makespan = max(dist1, dist2)\n\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = 0.3 * makespan + 0.7 * total_dist + 0.1 * demand_balance\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.8043855842513625,
            0.2764167785644531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective ratio to prioritize solutions with balanced improvement potential in both objectives, then applies a novel adaptive route merging and customer redistribution strategy that dynamically adjusts split points and considers spatial clustering to generate high-quality neighbors while maintaining feasibility through rigorous capacity checks and demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmin(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) > 1:\n        # Calculate route scores based on distance and demand balance\n        route_scores = []\n        for route in base_solution:\n            customers = route[1:-1]\n            route_demand = np.sum(demand[customers])\n            route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n            score = route_distance * (1 + 0.1 * abs(route_demand - capacity/2))\n            route_scores.append(score)\n\n        # Select routes to merge based on spatial proximity\n        sorted_indices = np.argsort(route_scores)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n        route1, route2 = base_solution[route1_idx], base_solution[route2_idx]\n\n        # Calculate centroids for spatial analysis\n        def get_centroid(route):\n            customers = route[1:-1]\n            if len(customers) == 0:\n                return coords[0]\n            return np.mean(coords[customers], axis=0)\n\n        centroid1, centroid2 = get_centroid(route1), get_centroid(route2)\n        centroid_dist = np.linalg.norm(centroid1 - centroid2)\n\n        # Determine split point based on spatial clustering\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n        all_customers = np.concatenate([customers1, customers2])\n        if len(all_customers) > 0:\n            cluster_center = np.mean(coords[all_customers], axis=0)\n            dist_to_center = np.linalg.norm(coords[all_customers] - cluster_center, axis=1)\n            split_pos = np.argmin(dist_to_center)\n\n            # Create new routes by splitting at the cluster center\n            if split_pos < len(customers1):\n                part1 = np.concatenate(([0], customers1[:split_pos+1], [0]))\n                part2 = np.concatenate(([0], customers1[split_pos+1:], customers2, [0]))\n            else:\n                part1 = np.concatenate(([0], customers1, customers2[:split_pos-len(customers1)+1], [0]))\n                part2 = np.concatenate(([0], customers2[split_pos-len(customers1)+1:], [0]))\n\n            # Validate capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity and\n                np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution = [r for i, r in enumerate(base_solution)\n                               if i not in (route1_idx, route2_idx)]\n                new_solution.extend([part1, part2])\n            else:\n                new_solution = base_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8923663452625354,
            0.6838812530040741
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and cross-route insertion, where we randomly select a route and reverse its customer sequence, then identify the best insertion point in another route to minimize distance increase while maintaining capacity constraints, balancing both objectives through a multi-criteria scoring function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    i = random.choice(range(len(selected_solution)))\n    route_to_reverse = selected_solution[i].copy()\n\n    # Reverse the customer sequence (excluding depots)\n    reversed_route = np.concatenate([[0], route_to_reverse[-2:0:-1], [0]])\n\n    # Calculate the demand of the reversed route\n    reversed_demand = sum(demand[reversed_route[1:-1]])\n\n    # Find the best route to insert into\n    best_route_idx = -1\n    best_insert_pos = -1\n    best_score = float('inf')\n\n    for j in range(len(selected_solution)):\n        if j == i:\n            continue\n\n        target_route = selected_solution[j]\n        target_demand = sum(demand[target_route[1:-1]])\n\n        # Try inserting the reversed route into target_route\n        for k in range(1, len(target_route)):\n            # Insert reversed_route between target_route[k-1] and target_route[k]\n            new_demand = reversed_demand + target_demand\n            if new_demand > capacity:\n                continue\n\n            # Calculate the distance change\n            old_dist = (distance_matrix[target_route[k-1]][target_route[k]] +\n                       distance_matrix[reversed_route[-2]][target_route[k-1]] +\n                       distance_matrix[target_route[k]][reversed_route[1]])\n\n            new_dist = (distance_matrix[target_route[k-1]][reversed_route[1]] +\n                       distance_matrix[reversed_route[-2]][target_route[k]] +\n                       sum(distance_matrix[reversed_route[m]][reversed_route[m+1]] for m in range(1, len(reversed_route)-1)))\n\n            dist_change = new_dist - old_dist\n\n            # Calculate makespan change (approximation)\n            original_length = sum(distance_matrix[target_route[n]][target_route[n+1]] for n in range(len(target_route)-1))\n            new_length = original_length - distance_matrix[target_route[k-1]][target_route[k]] + new_dist\n            makespan_change = new_length - original_length\n\n            # Score combines distance change and makespan change\n            score = dist_change + 0.5 * makespan_change\n\n            if score < best_score:\n                best_score = score\n                best_route_idx = j\n                best_insert_pos = k\n\n    if best_route_idx != -1 and best_insert_pos != -1:\n        # Perform the insertion\n        target_route = selected_solution[best_route_idx]\n        new_route = np.concatenate([\n            target_route[:best_insert_pos],\n            reversed_route[1:-1],\n            target_route[best_insert_pos:]\n        ])\n        selected_solution[best_route_idx] = new_route\n        selected_solution[i] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7608265123157905,
            0.137344092130661
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search that combines route splitting with adaptive customer relocation, where customers are moved between routes based on both distance and makespan improvements while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip routes with 0 or 1 customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    # Adaptive customer relocation between routes\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a customer from route1 to move to route2\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Remove customer from route1\n            new_route1 = np.concatenate((route1[:customer_idx], route1[customer_idx+1:]))\n\n            # Try to insert customer into route2 at the best position\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(1, len(route2)):\n                # Insert customer between i-1 and i\n                temp_route = np.insert(route2, i, customer)\n\n                # Check capacity constraint\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Calculate score combining distance and makespan improvements\n                    distance_improvement = (distance_matrix[temp_route[i-1], customer] +\n                                          distance_matrix[customer, temp_route[i+1]] -\n                                          distance_matrix[temp_route[i-1], temp_route[i+1]])\n\n                    # Calculate new makespan for both routes\n                    def calculate_makespan(r):\n                        dist = 0\n                        for j in range(len(r) - 1):\n                            dist += distance_matrix[r[j], r[j+1]]\n                        return dist\n\n                    original_makespan = max(calculate_makespan(route1), calculate_makespan(route2))\n                    new_makespan1 = calculate_makespan(new_route1)\n                    new_makespan2 = calculate_makespan(temp_route)\n                    new_makespan = max(new_makespan1, new_makespan2)\n\n                    # Combine objectives with weights\n                    score = 0.7 * distance_improvement + 0.3 * (original_makespan - new_makespan)\n\n                    if score < best_score:\n                        best_pos = i\n                        best_score = score\n\n            if best_pos != -1:\n                # Perform the best insertion\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7615025862652105,
            0.22665131092071533
        ]
    }
]