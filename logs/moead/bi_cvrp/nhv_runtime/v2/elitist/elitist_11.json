[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based splitting, where we randomly select a route, reverse a segment of it to explore different sequences, then intelligently split the reversed route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to modify\n    route_idx = random.randint(0, len(selected_solution) - 1)\n    route = selected_solution[route_idx]\n\n    if len(route) <= 3:  # Too short to reverse\n        return selected_solution\n\n    # Randomly select a segment to reverse\n    start = random.randint(1, len(route) - 3)\n    end = random.randint(start + 1, len(route) - 2)\n    reversed_segment = route[start:end][::-1]\n\n    # Create a new route with the reversed segment\n    new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n    # Calculate cumulative demand\n    customers = new_route[1:-1]\n    cumulative_demand = np.cumsum(demand[customers])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If reversed route exceeds capacity, try to split it\n        feasible_splits = []\n        for k in range(1, len(customers)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], customers[:k], [0]])\n            split2 = np.concatenate([[0], customers[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], customers[:best_split], [0]])\n            new_route2 = np.concatenate([[0], customers[best_split:], [0]])\n\n            # Replace the original route with the new ones\n            selected_solution[route_idx] = new_route1\n            selected_solution.append(new_route2)\n\n    else:\n        # Update the route if no split is needed\n        selected_solution[route_idx] = new_route\n\n    return selected_solution\n\n",
        "score": [
            -0.8503036085309459,
            0.1028304398059845
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-aware insertion, where we randomly select a route, reverse its customer sequence to explore alternative paths, and then intelligently reinsert customers from the reversed route into other routes or the original route based on demand feasibility and distance improvement, ensuring feasibility and potentially reducing both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.randint(0, len(selected_solution) - 1)\n    selected_route = selected_solution[route_idx].copy()\n\n    # Reverse the customer sequence (excluding depots)\n    reversed_customers = selected_route[1:-1][::-1]\n    reversed_route = np.concatenate([[0], reversed_customers, [0]])\n\n    # Calculate demand of the reversed route\n    reversed_demand = sum(demand[reversed_customers])\n\n    # Check if the reversed route is feasible\n    if reversed_demand <= capacity:\n        # Replace the original route with the reversed one\n        selected_solution[route_idx] = reversed_route\n    else:\n        # If not feasible, attempt to reinsert customers into other routes or split\n        customers_to_insert = reversed_customers.tolist()\n\n        # Try to insert customers into other routes\n        for customer in customers_to_insert:\n            best_route_idx = -1\n            best_position = -1\n            best_distance = float('inf')\n\n            for i in range(len(selected_solution)):\n                if i == route_idx:\n                    continue\n\n                current_route = selected_solution[i]\n                current_demand = sum(demand[current_route[1:-1]])\n\n                for j in range(1, len(current_route)):\n                    # Try inserting customer at position j\n                    new_route = np.concatenate([current_route[:j], [customer], current_route[j:]])\n                    new_demand = sum(demand[new_route[1:-1]])\n\n                    if new_demand <= capacity:\n                        # Calculate new distance\n                        new_dist = sum(distance_matrix[new_route[k]][new_route[k+1]] for k in range(len(new_route)-1))\n                        old_dist = sum(distance_matrix[current_route[k]][current_route[k+1]] for k in range(len(current_route)-1))\n\n                        if new_dist < best_distance:\n                            best_distance = new_dist\n                            best_route_idx = i\n                            best_position = j\n\n            if best_route_idx != -1:\n                # Perform the best insertion\n                current_route = selected_solution[best_route_idx]\n                new_route = np.concatenate([current_route[:best_position], [customer], current_route[best_position:]])\n                selected_solution[best_route_idx] = new_route\n\n        # Update the original route by removing inserted customers\n        remaining_customers = [c for c in selected_route[1:-1] if c not in customers_to_insert]\n        if remaining_customers:\n            selected_solution[route_idx] = np.concatenate([[0], remaining_customers, [0]])\n        else:\n            # Remove the route if no customers remain\n            selected_solution.pop(route_idx)\n\n    return selected_solution\n\n",
        "score": [
            -0.7664981772278436,
            0.09909877181053162
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-balanced splitting, where we randomly select a route, reverse its sequence of customers, and then intelligently split the reversed route into two new routes by evaluating potential split points based on both demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    i = random.randint(0, len(selected_solution) - 1)\n    route = selected_solution[i]\n\n    # Reverse the route (excluding depots)\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[reversed_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If reversed route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(reversed_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], reversed_route[1:k+1], [0]])\n            split2 = np.concatenate([[0], reversed_route[k+1:-1], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.2 * demand_balance  # Weight demand balance slightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], reversed_route[1:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], reversed_route[best_split+1:-1], [0]])\n\n            # Replace the original route with the new ones\n            selected_solution[i] = new_route1\n            selected_solution.append(new_route2)\n\n    return selected_solution\n\n",
        "score": [
            -0.7908924089932019,
            0.09976571798324585
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective ratio to prioritize solutions with balanced improvement potential in both objectives, then applies a novel adaptive route merging and customer redistribution strategy that dynamically adjusts split points and considers spatial clustering to generate high-quality neighbors while maintaining feasibility through rigorous capacity checks and demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmin(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) > 1:\n        # Calculate route scores based on distance and demand balance\n        route_scores = []\n        for route in base_solution:\n            customers = route[1:-1]\n            route_demand = np.sum(demand[customers])\n            route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n            score = route_distance * (1 + 0.1 * abs(route_demand - capacity/2))\n            route_scores.append(score)\n\n        # Select routes to merge based on spatial proximity\n        sorted_indices = np.argsort(route_scores)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n        route1, route2 = base_solution[route1_idx], base_solution[route2_idx]\n\n        # Calculate centroids for spatial analysis\n        def get_centroid(route):\n            customers = route[1:-1]\n            if len(customers) == 0:\n                return coords[0]\n            return np.mean(coords[customers], axis=0)\n\n        centroid1, centroid2 = get_centroid(route1), get_centroid(route2)\n        centroid_dist = np.linalg.norm(centroid1 - centroid2)\n\n        # Determine split point based on spatial clustering\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n        all_customers = np.concatenate([customers1, customers2])\n        if len(all_customers) > 0:\n            cluster_center = np.mean(coords[all_customers], axis=0)\n            dist_to_center = np.linalg.norm(coords[all_customers] - cluster_center, axis=1)\n            split_pos = np.argmin(dist_to_center)\n\n            # Create new routes by splitting at the cluster center\n            if split_pos < len(customers1):\n                part1 = np.concatenate(([0], customers1[:split_pos+1], [0]))\n                part2 = np.concatenate(([0], customers1[split_pos+1:], customers2, [0]))\n            else:\n                part1 = np.concatenate(([0], customers1, customers2[:split_pos-len(customers1)+1], [0]))\n                part2 = np.concatenate(([0], customers2[split_pos-len(customers1)+1:], [0]))\n\n            # Validate capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity and\n                np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution = [r for i, r in enumerate(base_solution)\n                               if i not in (route1_idx, route2_idx)]\n                new_solution.extend([part1, part2])\n            else:\n                new_solution = base_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8923663452625354,
            0.6838812530040741
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and route balance, then applies a novel route transformation strategy that combines spatial clustering analysis with adaptive demand redistribution to generate high-quality neighbors while maintaining feasibility through dynamic capacity validation and multi-objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(objectives / (diversity_scores + 1e-6), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) < 2:\n        return base_solution\n\n    # Calculate route features for spatial and demand analysis\n    route_features = []\n    for route in base_solution:\n        customers = route[1:-1]\n        if len(customers) == 0:\n            route_features.append((0, 0, 0, 0))\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n        route_demand = np.sum(demand[customers])\n        route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n        spatial_variance = np.mean(np.linalg.norm(coords[customers] - centroid, axis=1))\n\n        route_features.append((centroid[0], centroid[1], route_demand, spatial_variance))\n\n    route_features = np.array(route_features)\n\n    # Cluster routes based on spatial and demand characteristics\n    if len(route_features) > 1:\n        from sklearn.cluster import KMeans\n        kmeans = KMeans(n_clusters=min(3, len(route_features)), random_state=42)\n        clusters = kmeans.fit_predict(route_features[:, :2])\n\n        # Select routes from different clusters for transformation\n        unique_clusters = np.unique(clusters)\n        if len(unique_clusters) > 1:\n            selected_clusters = np.random.choice(unique_clusters, size=2, replace=False)\n            route_indices = [np.where(clusters == c)[0][0] for c in selected_clusters]\n            route1, route2 = base_solution[route_indices[0]], base_solution[route_indices[1]]\n\n            # Combine routes and find optimal split point\n            combined_customers = np.concatenate([route1[1:-1], route2[1:-1]])\n            if len(combined_customers) > 0:\n                # Calculate cumulative demand and distances\n                cumulative_demand = np.cumsum(demand[combined_customers])\n                total_demand = cumulative_demand[-1]\n\n                if total_demand <= capacity:\n                    # If combined route is feasible, create a single route\n                    new_route = np.concatenate([[0], combined_customers, [0]])\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.append(new_route)\n                    return new_solution\n\n                # If combined route exceeds capacity, find optimal split\n                best_split = None\n                best_score = float('inf')\n\n                for k in range(1, len(combined_customers)):\n                    if cumulative_demand[k] <= capacity:\n                        # Split into two routes\n                        split1 = np.concatenate([[0], combined_customers[:k], [0]])\n                        split2 = np.concatenate([[0], combined_customers[k:], [0]])\n\n                        # Calculate distances\n                        dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n                        dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n                        total_dist = dist1 + dist2\n                        max_dist = max(dist1, dist2)\n\n                        # Score based on multi-objective criteria\n                        demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n                        score = 0.7 * total_dist + 0.3 * max_dist + 0.1 * demand_balance\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = k\n\n                if best_split is not None:\n                    # Create new routes\n                    new_route1 = np.concatenate([[0], combined_customers[:best_split], [0]])\n                    new_route2 = np.concatenate([[0], combined_customers[best_split:], [0]])\n\n                    # Replace original routes\n                    new_solution = [r for i, r in enumerate(base_solution) if i not in route_indices]\n                    new_solution.extend([new_route1, new_route2])\n                    return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9364291537929945,
            3.209461659193039
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective ratio to prioritize solutions with balanced improvement potential in both objectives, then applies a novel adaptive route merging and customer redistribution strategy that dynamically adjusts split points and considers spatial clustering to generate high-quality neighbors while maintaining feasibility through rigorous capacity checks and demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmin(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) > 1:\n        # Calculate route scores based on distance and demand balance\n        route_scores = []\n        for route in base_solution:\n            customers = route[1:-1]\n            route_demand = np.sum(demand[customers])\n            route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n            score = route_distance * (1 + 0.1 * abs(route_demand - capacity/2))\n            route_scores.append(score)\n\n        # Select routes to merge based on spatial proximity\n        sorted_indices = np.argsort(route_scores)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n        route1, route2 = base_solution[route1_idx], base_solution[route2_idx]\n\n        # Calculate centroids for spatial analysis\n        def get_centroid(route):\n            customers = route[1:-1]\n            if len(customers) == 0:\n                return coords[0]\n            return np.mean(coords[customers], axis=0)\n\n        centroid1, centroid2 = get_centroid(route1), get_centroid(route2)\n        centroid_dist = np.linalg.norm(centroid1 - centroid2)\n\n        # Determine split point based on spatial clustering\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n        all_customers = np.concatenate([customers1, customers2])\n        if len(all_customers) > 0:\n            cluster_center = np.mean(coords[all_customers], axis=0)\n            dist_to_center = np.linalg.norm(coords[all_customers] - cluster_center, axis=1)\n            split_pos = np.argmin(dist_to_center)\n\n            # Create new routes by splitting at the cluster center\n            if split_pos < len(customers1):\n                part1 = np.concatenate(([0], customers1[:split_pos+1], [0]))\n                part2 = np.concatenate(([0], customers1[split_pos+1:], customers2, [0]))\n            else:\n                part1 = np.concatenate(([0], customers1, customers2[:split_pos-len(customers1)+1], [0]))\n                part2 = np.concatenate(([0], customers2[split_pos-len(customers1)+1:], [0]))\n\n            # Validate capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity and\n                np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution = [r for i, r in enumerate(base_solution)\n                               if i not in (route1_idx, route2_idx)]\n                new_solution.extend([part1, part2])\n            else:\n                new_solution = base_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8923663452625354,
            0.6838812530040741
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route splitting and demand-based rebalancing, where we randomly select a route from the solution, split it into two segments based on demand balance, and then insert the second segment into another route in the solution, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select a route to split\n    i = random.choice(range(len(selected_solution)))\n    route = selected_solution[i]\n\n    # Calculate cumulative demand\n    customers = route[1:-1]\n    cumulative_demand = np.cumsum(demand[customers])\n\n    # Find feasible split points based on demand balance\n    feasible_splits = []\n    for k in range(1, len(customers)):\n        if cumulative_demand[k-1] <= capacity and cumulative_demand[-1] - cumulative_demand[k-1] <= capacity:\n            feasible_splits.append(k)\n\n    if not feasible_splits:\n        return selected_solution\n\n    # Choose a random split point\n    split_point = random.choice(feasible_splits)\n\n    # Split the route into two segments\n    segment1 = route[:split_point+1]\n    segment2 = np.concatenate([[0], route[split_point+1:]])\n\n    # Randomly select another route to insert the second segment\n    j = random.choice([x for x in range(len(selected_solution)) if x != i])\n    target_route = selected_solution[j]\n\n    # Find feasible insertion positions in the target route\n    feasible_insertions = []\n    for pos in range(1, len(target_route)):\n        # Check if inserting segment2 at position pos is feasible\n        temp_route = np.concatenate([target_route[:pos], segment2[1:-1], target_route[pos:]])\n        temp_demand = sum(demand[temp_route[1:-1]])\n        if temp_demand <= capacity:\n            feasible_insertions.append(pos)\n\n    if not feasible_insertions:\n        # If no feasible insertion, just replace the original route\n        selected_solution[i] = segment1\n        selected_solution[j] = segment2\n    else:\n        # Insert segment2 at a random feasible position\n        insert_pos = random.choice(feasible_insertions)\n        new_target_route = np.concatenate([target_route[:insert_pos], segment2[1:-1], target_route[insert_pos:]])\n        selected_solution[i] = segment1\n        selected_solution[j] = new_target_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7512851592615626,
            0.0778336226940155
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective ratio to prioritize solutions with balanced improvement potential in both objectives, then applies a novel adaptive route merging and customer redistribution strategy that dynamically adjusts split points and considers spatial clustering to generate high-quality neighbors while maintaining feasibility through rigorous capacity checks and demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmin(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) > 1:\n        # Calculate route scores based on distance and demand balance\n        route_scores = []\n        for route in base_solution:\n            customers = route[1:-1]\n            route_demand = np.sum(demand[customers])\n            route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n            score = route_distance * (1 + 0.1 * abs(route_demand - capacity/2))\n            route_scores.append(score)\n\n        # Select routes to merge based on spatial proximity\n        sorted_indices = np.argsort(route_scores)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n        route1, route2 = base_solution[route1_idx], base_solution[route2_idx]\n\n        # Calculate centroids for spatial analysis\n        def get_centroid(route):\n            customers = route[1:-1]\n            if len(customers) == 0:\n                return coords[0]\n            return np.mean(coords[customers], axis=0)\n\n        centroid1, centroid2 = get_centroid(route1), get_centroid(route2)\n        centroid_dist = np.linalg.norm(centroid1 - centroid2)\n\n        # Determine split point based on spatial clustering\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n        all_customers = np.concatenate([customers1, customers2])\n        if len(all_customers) > 0:\n            cluster_center = np.mean(coords[all_customers], axis=0)\n            dist_to_center = np.linalg.norm(coords[all_customers] - cluster_center, axis=1)\n            split_pos = np.argmin(dist_to_center)\n\n            # Create new routes by splitting at the cluster center\n            if split_pos < len(customers1):\n                part1 = np.concatenate(([0], customers1[:split_pos+1], [0]))\n                part2 = np.concatenate(([0], customers1[split_pos+1:], customers2, [0]))\n            else:\n                part1 = np.concatenate(([0], customers1, customers2[:split_pos-len(customers1)+1], [0]))\n                part2 = np.concatenate(([0], customers2[split_pos-len(customers1)+1:], [0]))\n\n            # Validate capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity and\n                np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution = [r for i, r in enumerate(base_solution)\n                               if i not in (route1_idx, route2_idx)]\n                new_solution.extend([part1, part2])\n            else:\n                new_solution = base_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8923663452625354,
            0.6838812530040741
        ]
    }
]