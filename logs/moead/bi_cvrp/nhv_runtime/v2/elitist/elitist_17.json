[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route merging and demand-based customer redistribution, where we randomly select two routes, merge them into a single route, and then redistribute customers between the merged route and other routes to balance demand and reduce total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select two routes to merge\n    route_idx1, route_idx2 = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[route_idx1].copy()\n    route2 = selected_solution[route_idx2].copy()\n\n    # Merge the two routes\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n    merged_demand = np.cumsum(demand[merged_route])\n    total_demand = merged_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and redistribute customers\n        overload_start = None\n        for k in range(1, len(merged_route)):\n            if merged_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif merged_demand[k] <= capacity and overload_start is not None:\n                # Redistribute customers from overload_start to k-1\n                customers_to_redistribute = merged_route[overload_start:k]\n                current_capacity = merged_demand[overload_start-1]\n\n                # Try to redistribute to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx in (route_idx1, route_idx2):\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_redistribute]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_redistribute[0]] +\n                            distance_matrix[customers_to_redistribute[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_redistribute,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove redistributed customers from merged route\n                        mask = np.ones(len(merged_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        merged_route = merged_route[mask]\n\n                        # Update demand and check for further overload\n                        merged_demand = np.cumsum(demand[merged_route])\n                        total_demand = merged_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original routes with the processed merged route\n    selected_solution[route_idx1] = merged_route\n    del selected_solution[route_idx2]\n\n    return selected_solution\n\n",
        "score": [
            -0.7808253271567144,
            0.03320986032485962
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route splitting and demand-aware customer reallocation, where we randomly select a route, split it into two segments at a demand-balanced point, and then reallocate customers between segments or to other routes to optimize both total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n\n    if len(route) <= 3:\n        return selected_solution\n\n    cumulative_demand = np.cumsum(demand[route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand <= capacity:\n        return selected_solution\n\n    split_candidates = []\n    for k in range(1, len(route)-1):\n        if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n            split_candidates.append(k)\n\n    if not split_candidates:\n        return selected_solution\n\n    best_split = min(split_candidates, key=lambda k: abs(cumulative_demand[k] - (total_demand - cumulative_demand[k])))\n\n    segment1 = np.concatenate([[0], route[1:best_split+1], [0]])\n    segment2 = np.concatenate([[0], route[best_split+1:-1], [0]])\n\n    new_solution = selected_solution.copy()\n    new_solution[route_idx] = segment1\n    new_solution.insert(route_idx+1, segment2)\n\n    for i in range(len(new_solution)):\n        current_route = new_solution[i]\n        if len(current_route) <= 3:\n            continue\n\n        current_demand = sum(demand[current_route[1:-1]])\n        if current_demand > capacity:\n            excess = current_demand - capacity\n            customers = current_route[1:-1]\n            random.shuffle(customers)\n\n            for customer in customers:\n                if excess <= 0:\n                    break\n                best_route = None\n                best_pos = None\n                best_savings = -float('inf')\n\n                for j in range(len(new_solution)):\n                    if j == i:\n                        continue\n                    other_route = new_solution[j]\n                    other_demand = sum(demand[other_route[1:-1]])\n\n                    if other_demand + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(other_route)):\n                        savings = (distance_matrix[other_route[pos-1]][customer] +\n                                 distance_matrix[customer][other_route[pos]] -\n                                 distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        if savings > best_savings:\n                            best_savings = savings\n                            best_route = j\n                            best_pos = pos\n\n                if best_route is not None and best_pos is not None:\n                    new_route = np.concatenate([\n                        new_solution[best_route][:best_pos],\n                        [customer],\n                        new_solution[best_route][best_pos:]\n                    ])\n                    new_solution[best_route] = new_route\n\n                    mask = new_solution[i] != customer\n                    new_solution[i] = new_solution[i][mask]\n\n                    excess -= demand[customer]\n\n    return new_solution\n\n",
        "score": [
            -0.8007911220269432,
            0.0988086462020874
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    }
]