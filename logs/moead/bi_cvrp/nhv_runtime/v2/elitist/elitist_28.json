[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route splitting and demand-aware customer reallocation, where we randomly select a route, split it into two segments, and then reallocate customers between segments or to other routes based on demand balance and proximity to reduce total distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to split\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n\n    if len(route) <= 2:  # Skip if route has no customers\n        return selected_solution\n\n    # Randomly choose a split point\n    split_pos = random.randint(1, len(route) - 2)\n\n    # Split the route into two segments\n    segment1 = route[:split_pos + 1]\n    segment2 = np.concatenate([[0], route[split_pos + 1:]])\n\n    # Calculate demands for both segments\n    demand1 = sum(demand[segment1[1:-1]])\n    demand2 = sum(demand[segment2[1:-1]])\n\n    # Reallocate customers to balance demand and reduce distance\n    for i in range(1, len(segment1) - 1):\n        customer = segment1[i]\n        if demand1 - demand[customer] >= 0 and demand2 + demand[customer] <= capacity:\n            # Check if moving customer to segment2 reduces total distance\n            if (distance_matrix[segment1[i-1]][segment1[i+1]] -\n                distance_matrix[segment1[i-1]][customer] -\n                distance_matrix[customer][segment1[i+1]]) > 0:\n                # Move customer to segment2\n                segment1 = np.concatenate([segment1[:i], segment1[i+1:]])\n                segment2 = np.concatenate([segment2[:-1], [customer], [0]])\n\n    # Update the route in the solution\n    selected_solution[route_idx] = segment1\n    selected_solution.append(segment2)\n\n    return selected_solution\n\n",
        "score": [
            -0.8387177712743565,
            0.032716840505599976
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    }
]