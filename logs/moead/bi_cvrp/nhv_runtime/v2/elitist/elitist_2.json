[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized Pareto front distance to balance objectives, then applies a hybrid local search combining route splitting and intelligent customer reallocation while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-6)\n\n    # Select solution with minimum Pareto front distance\n    distances = np.min(normalized, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: split a long route and reallocate customers\n    if len(base_solution) > 1:\n        # Find the longest route\n        route_lengths = [distance_matrix[r[-2], 0] + np.sum(distance_matrix[r[:-1], r[1:]]) for r in base_solution]\n        longest_idx = np.argmax(route_lengths)\n        longest_route = base_solution[longest_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos+1]\n        part2 = np.concatenate(([0], longest_route[split_pos:]))\n\n        # Remove the original route and add the two new parts\n        new_solution = [r for i, r in enumerate(base_solution) if i != longest_idx]\n        new_solution.extend([part1, part2])\n\n        # Reallocate customers between the two new routes\n        for route in new_solution:\n            if len(route) > 3:  # Only process if route has more than 2 customers\n                # Try to move a customer to the other new route\n                customer_idx = random.randint(1, len(route) - 2)\n                customer = route[customer_idx]\n\n                # Check if moving this customer to the other route is feasible\n                for other_route in new_solution:\n                    if not np.array_equal(other_route, route):\n                        # Check capacity constraint\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate potential improvement\n                            old_dist = (distance_matrix[route[customer_idx-1], customer] +\n                                      distance_matrix[customer, route[customer_idx+1]])\n                            new_dist = (distance_matrix[route[customer_idx-1], route[customer_idx+1]] +\n                                      distance_matrix[other_route[-2], customer] +\n                                      distance_matrix[customer, 0])\n\n                            if new_dist < old_dist:\n                                # Perform the move\n                                new_route = np.concatenate((route[:customer_idx], route[customer_idx+1:]))\n                                new_other_route = np.insert(other_route, -1, customer)\n\n                                # Update solution\n                                new_solution = [r if not np.array_equal(r, route) else new_route for r in new_solution]\n                                new_solution = [r if not np.array_equal(r, other_route) else new_other_route for r in new_solution]\n                                break\n\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8627499822612408,
            0.827190101146698
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and cross-route insertion, where we randomly select a route and reverse its customer sequence, then identify the best insertion point in another route to minimize distance increase while maintaining capacity constraints, balancing both objectives through a multi-criteria scoring function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    i = random.choice(range(len(selected_solution)))\n    route_to_reverse = selected_solution[i].copy()\n\n    # Reverse the customer sequence (excluding depots)\n    reversed_route = np.concatenate([[0], route_to_reverse[-2:0:-1], [0]])\n\n    # Calculate the demand of the reversed route\n    reversed_demand = sum(demand[reversed_route[1:-1]])\n\n    # Find the best route to insert into\n    best_route_idx = -1\n    best_insert_pos = -1\n    best_score = float('inf')\n\n    for j in range(len(selected_solution)):\n        if j == i:\n            continue\n\n        target_route = selected_solution[j]\n        target_demand = sum(demand[target_route[1:-1]])\n\n        # Try inserting the reversed route into target_route\n        for k in range(1, len(target_route)):\n            # Insert reversed_route between target_route[k-1] and target_route[k]\n            new_demand = reversed_demand + target_demand\n            if new_demand > capacity:\n                continue\n\n            # Calculate the distance change\n            old_dist = (distance_matrix[target_route[k-1]][target_route[k]] +\n                       distance_matrix[reversed_route[-2]][target_route[k-1]] +\n                       distance_matrix[target_route[k]][reversed_route[1]])\n\n            new_dist = (distance_matrix[target_route[k-1]][reversed_route[1]] +\n                       distance_matrix[reversed_route[-2]][target_route[k]] +\n                       sum(distance_matrix[reversed_route[m]][reversed_route[m+1]] for m in range(1, len(reversed_route)-1)))\n\n            dist_change = new_dist - old_dist\n\n            # Calculate makespan change (approximation)\n            original_length = sum(distance_matrix[target_route[n]][target_route[n+1]] for n in range(len(target_route)-1))\n            new_length = original_length - distance_matrix[target_route[k-1]][target_route[k]] + new_dist\n            makespan_change = new_length - original_length\n\n            # Score combines distance change and makespan change\n            score = dist_change + 0.5 * makespan_change\n\n            if score < best_score:\n                best_score = score\n                best_route_idx = j\n                best_insert_pos = k\n\n    if best_route_idx != -1 and best_insert_pos != -1:\n        # Perform the insertion\n        target_route = selected_solution[best_route_idx]\n        new_route = np.concatenate([\n            target_route[:best_insert_pos],\n            reversed_route[1:-1],\n            target_route[best_insert_pos:]\n        ])\n        selected_solution[best_route_idx] = new_route\n        selected_solution[i] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7608265123157905,
            0.137344092130661
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search that combines route splitting with adaptive customer relocation, where customers are moved between routes based on both distance and makespan improvements while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = []\n\n    for route in base_solution:\n        if len(route) <= 3:  # Skip routes with 0 or 1 customer\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check capacity constraints for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1.copy(), part2.copy()])\n        else:\n            new_solution.append(route.copy())\n\n    # Adaptive customer relocation between routes\n    if len(new_solution) > 1:\n        # Select two different routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a customer from route1 to move to route2\n            customer_idx = random.randint(1, len(route1) - 2)\n            customer = route1[customer_idx]\n\n            # Remove customer from route1\n            new_route1 = np.concatenate((route1[:customer_idx], route1[customer_idx+1:]))\n\n            # Try to insert customer into route2 at the best position\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(1, len(route2)):\n                # Insert customer between i-1 and i\n                temp_route = np.insert(route2, i, customer)\n\n                # Check capacity constraint\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Calculate score combining distance and makespan improvements\n                    distance_improvement = (distance_matrix[temp_route[i-1], customer] +\n                                          distance_matrix[customer, temp_route[i+1]] -\n                                          distance_matrix[temp_route[i-1], temp_route[i+1]])\n\n                    # Calculate new makespan for both routes\n                    def calculate_makespan(r):\n                        dist = 0\n                        for j in range(len(r) - 1):\n                            dist += distance_matrix[r[j], r[j+1]]\n                        return dist\n\n                    original_makespan = max(calculate_makespan(route1), calculate_makespan(route2))\n                    new_makespan1 = calculate_makespan(new_route1)\n                    new_makespan2 = calculate_makespan(temp_route)\n                    new_makespan = max(new_makespan1, new_makespan2)\n\n                    # Combine objectives with weights\n                    score = 0.7 * distance_improvement + 0.3 * (original_makespan - new_makespan)\n\n                    if score < best_score:\n                        best_pos = i\n                        best_score = score\n\n            if best_pos != -1:\n                # Perform the best insertion\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                # Update the solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    return new_solution\n\n",
        "score": [
            -0.7615025862652105,
            0.22665131092071533
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized Pareto front distance to balance objectives, then applies a hybrid local search combining route splitting and intelligent customer reallocation while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-6)\n\n    # Select solution with minimum Pareto front distance\n    distances = np.min(normalized, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: split a long route and reallocate customers\n    if len(base_solution) > 1:\n        # Find the longest route\n        route_lengths = [distance_matrix[r[-2], 0] + np.sum(distance_matrix[r[:-1], r[1:]]) for r in base_solution]\n        longest_idx = np.argmax(route_lengths)\n        longest_route = base_solution[longest_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos+1]\n        part2 = np.concatenate(([0], longest_route[split_pos:]))\n\n        # Remove the original route and add the two new parts\n        new_solution = [r for i, r in enumerate(base_solution) if i != longest_idx]\n        new_solution.extend([part1, part2])\n\n        # Reallocate customers between the two new routes\n        for route in new_solution:\n            if len(route) > 3:  # Only process if route has more than 2 customers\n                # Try to move a customer to the other new route\n                customer_idx = random.randint(1, len(route) - 2)\n                customer = route[customer_idx]\n\n                # Check if moving this customer to the other route is feasible\n                for other_route in new_solution:\n                    if not np.array_equal(other_route, route):\n                        # Check capacity constraint\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate potential improvement\n                            old_dist = (distance_matrix[route[customer_idx-1], customer] +\n                                      distance_matrix[customer, route[customer_idx+1]])\n                            new_dist = (distance_matrix[route[customer_idx-1], route[customer_idx+1]] +\n                                      distance_matrix[other_route[-2], customer] +\n                                      distance_matrix[customer, 0])\n\n                            if new_dist < old_dist:\n                                # Perform the move\n                                new_route = np.concatenate((route[:customer_idx], route[customer_idx+1:]))\n                                new_other_route = np.insert(other_route, -1, customer)\n\n                                # Update solution\n                                new_solution = [r if not np.array_equal(r, route) else new_route for r in new_solution]\n                                new_solution = [r if not np.array_equal(r, other_route) else new_other_route for r in new_solution]\n                                break\n\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8627499822612408,
            0.827190101146698
        ]
    }
]