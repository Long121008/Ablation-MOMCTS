[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route splitting and insertion, where we randomly select a route from the solution, split it into two parts at a feasible point, and then insert the split parts into other routes while evaluating potential insertion points based on distance reduction and demand balance, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i = random.choice(range(len(selected_solution)))\n    route = selected_solution[i]\n\n    if len(route) <= 3:\n        return selected_solution\n\n    cumulative_demand = np.cumsum(demand[route])\n    total_demand = cumulative_demand[-1]\n\n    feasible_splits = []\n    for k in range(1, len(route)-1):\n        if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n            feasible_splits.append(k)\n\n    if not feasible_splits:\n        return selected_solution\n\n    best_split = random.choice(feasible_splits)\n    split1 = np.concatenate([[0], route[:best_split], [0]])\n    split2 = np.concatenate([[0], route[best_split:], [0]])\n\n    selected_solution[i] = split1\n    selected_solution.append(split2)\n\n    for _ in range(2):\n        if len(selected_solution) < 2:\n            break\n\n        a, b = random.sample(range(len(selected_solution)), 2)\n        route_a = selected_solution[a]\n        route_b = selected_solution[b]\n\n        if len(route_a) <= 3 or len(route_b) <= 3:\n            continue\n\n        for pos in range(1, len(route_a)-1):\n            node = route_a[pos]\n            if demand[node] + sum(demand[route_b]) - demand[route_b[0]] - demand[route_b[-1]] <= capacity:\n                new_route_b = np.concatenate([route_b[:-1], [node], [0]])\n                new_route_a = np.delete(route_a, pos)\n                new_route_a = np.concatenate([new_route_a[:pos], new_route_a[pos+1:]])\n\n                if len(new_route_a) > 2:\n                    selected_solution[a] = new_route_a\n                    selected_solution[b] = new_route_b\n                    break\n\n    return selected_solution\n\n",
        "score": [
            -0.770310971269162,
            0.08754435181617737
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-balanced splitting, where we randomly select a route, reverse its sequence of customers, and then intelligently split the reversed route into two new routes by evaluating potential split points based on both demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    i = random.randint(0, len(selected_solution) - 1)\n    route = selected_solution[i]\n\n    # Reverse the route (excluding depots)\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[reversed_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If reversed route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(reversed_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], reversed_route[1:k+1], [0]])\n            split2 = np.concatenate([[0], reversed_route[k+1:-1], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.2 * demand_balance  # Weight demand balance slightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], reversed_route[1:best_split+1], [0]])\n            new_route2 = np.concatenate([[0], reversed_route[best_split+1:-1], [0]])\n\n            # Replace the original route with the new ones\n            selected_solution[i] = new_route1\n            selected_solution.append(new_route2)\n\n    return selected_solution\n\n",
        "score": [
            -0.7908924089932019,
            0.09976571798324585
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route splitting and demand-based rebalancing, where we randomly select a route from the solution, split it into two segments based on demand balance, and then insert the second segment into another route in the solution, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    # Randomly select a route to split\n    i = random.choice(range(len(selected_solution)))\n    route = selected_solution[i]\n\n    # Calculate cumulative demand\n    customers = route[1:-1]\n    cumulative_demand = np.cumsum(demand[customers])\n\n    # Find feasible split points based on demand balance\n    feasible_splits = []\n    for k in range(1, len(customers)):\n        if cumulative_demand[k-1] <= capacity and cumulative_demand[-1] - cumulative_demand[k-1] <= capacity:\n            feasible_splits.append(k)\n\n    if not feasible_splits:\n        return selected_solution\n\n    # Choose a random split point\n    split_point = random.choice(feasible_splits)\n\n    # Split the route into two segments\n    segment1 = route[:split_point+1]\n    segment2 = np.concatenate([[0], route[split_point+1:]])\n\n    # Randomly select another route to insert the second segment\n    j = random.choice([x for x in range(len(selected_solution)) if x != i])\n    target_route = selected_solution[j]\n\n    # Find feasible insertion positions in the target route\n    feasible_insertions = []\n    for pos in range(1, len(target_route)):\n        # Check if inserting segment2 at position pos is feasible\n        temp_route = np.concatenate([target_route[:pos], segment2[1:-1], target_route[pos:]])\n        temp_demand = sum(demand[temp_route[1:-1]])\n        if temp_demand <= capacity:\n            feasible_insertions.append(pos)\n\n    if not feasible_insertions:\n        # If no feasible insertion, just replace the original route\n        selected_solution[i] = segment1\n        selected_solution[j] = segment2\n    else:\n        # Insert segment2 at a random feasible position\n        insert_pos = random.choice(feasible_insertions)\n        new_target_route = np.concatenate([target_route[:insert_pos], segment2[1:-1], target_route[insert_pos:]])\n        selected_solution[i] = segment1\n        selected_solution[j] = new_target_route\n\n    return selected_solution\n\n",
        "score": [
            -0.7512851592615626,
            0.0778336226940155
        ]
    }
]