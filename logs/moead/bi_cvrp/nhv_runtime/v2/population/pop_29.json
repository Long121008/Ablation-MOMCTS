[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines route reversal and demand-based relocation, where we randomly select a route, reverse it, and then relocate customers from overloaded segments to other routes or positions within the same route to balance demand and reduce total distance and makespan, ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    if len(selected_solution) < 1:\n        return selected_solution\n\n    # Randomly select a route to reverse\n    route_idx = random.choice(range(len(selected_solution)))\n    route = selected_solution[route_idx].copy()\n    reversed_route = np.concatenate([[0], route[1:-1][::-1], [0]])\n\n    # Calculate cumulative demand for the reversed route\n    reversed_demand = np.cumsum(demand[reversed_route])\n    total_demand = reversed_demand[-1]\n\n    if total_demand > capacity:\n        # Find overload segments and relocate customers\n        overload_start = None\n        for k in range(1, len(reversed_route)):\n            if reversed_demand[k] > capacity and overload_start is None:\n                overload_start = k\n            elif reversed_demand[k] <= capacity and overload_start is not None:\n                # Relocate customers from overload_start to k-1\n                customers_to_relocate = reversed_route[overload_start:k]\n                current_capacity = reversed_demand[overload_start-1]\n\n                # Try to relocate to other routes\n                for other_route_idx in range(len(selected_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = selected_solution[other_route_idx].copy()\n                    other_demand = np.cumsum(demand[other_route])\n\n                    # Find feasible insertion points\n                    feasible_inserts = []\n                    for pos in range(1, len(other_route)):\n                        if other_demand[pos-1] + sum(demand[customers_to_relocate]) <= capacity:\n                            feasible_inserts.append(pos)\n\n                    if feasible_inserts:\n                        # Choose the best insertion point (minimize distance increase)\n                        best_pos = min(feasible_inserts, key=lambda pos:\n                            distance_matrix[other_route[pos-1]][customers_to_relocate[0]] +\n                            distance_matrix[customers_to_relocate[-1]][other_route[pos]] -\n                            distance_matrix[other_route[pos-1]][other_route[pos]])\n\n                        # Insert customers\n                        new_other_route = np.concatenate([\n                            other_route[:best_pos],\n                            customers_to_relocate,\n                            other_route[best_pos:]\n                        ])\n                        selected_solution[other_route_idx] = new_other_route\n\n                        # Remove relocated customers from original route\n                        mask = np.ones(len(reversed_route), dtype=bool)\n                        mask[overload_start:k] = False\n                        reversed_route = reversed_route[mask]\n\n                        # Update demand and check for further overload\n                        reversed_demand = np.cumsum(demand[reversed_route])\n                        total_demand = reversed_demand[-1]\n                        overload_start = None\n                        break\n\n                if overload_start is None:\n                    break\n\n    # Replace the original route with the processed reversed route\n    selected_solution[route_idx] = reversed_route\n\n    return selected_solution\n\n",
        "score": [
            -0.9781355878741347,
            0.09982573986053467
        ]
    }
]