[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized Pareto front distance to balance objectives, then applies a hybrid local search combining route splitting and intelligent customer reallocation while ensuring feasibility through demand checks and capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-6)\n\n    # Select solution with minimum Pareto front distance\n    distances = np.min(normalized, axis=1)\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: split a long route and reallocate customers\n    if len(base_solution) > 1:\n        # Find the longest route\n        route_lengths = [distance_matrix[r[-2], 0] + np.sum(distance_matrix[r[:-1], r[1:]]) for r in base_solution]\n        longest_idx = np.argmax(route_lengths)\n        longest_route = base_solution[longest_idx]\n\n        # Split the longest route into two parts\n        split_pos = len(longest_route) // 2\n        part1 = longest_route[:split_pos+1]\n        part2 = np.concatenate(([0], longest_route[split_pos:]))\n\n        # Remove the original route and add the two new parts\n        new_solution = [r for i, r in enumerate(base_solution) if i != longest_idx]\n        new_solution.extend([part1, part2])\n\n        # Reallocate customers between the two new routes\n        for route in new_solution:\n            if len(route) > 3:  # Only process if route has more than 2 customers\n                # Try to move a customer to the other new route\n                customer_idx = random.randint(1, len(route) - 2)\n                customer = route[customer_idx]\n\n                # Check if moving this customer to the other route is feasible\n                for other_route in new_solution:\n                    if not np.array_equal(other_route, route):\n                        # Check capacity constraint\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate potential improvement\n                            old_dist = (distance_matrix[route[customer_idx-1], customer] +\n                                      distance_matrix[customer, route[customer_idx+1]])\n                            new_dist = (distance_matrix[route[customer_idx-1], route[customer_idx+1]] +\n                                      distance_matrix[other_route[-2], customer] +\n                                      distance_matrix[customer, 0])\n\n                            if new_dist < old_dist:\n                                # Perform the move\n                                new_route = np.concatenate((route[:customer_idx], route[customer_idx+1:]))\n                                new_other_route = np.insert(other_route, -1, customer)\n\n                                # Update solution\n                                new_solution = [r if not np.array_equal(r, route) else new_route for r in new_solution]\n                                new_solution = [r if not np.array_equal(r, other_route) else new_other_route for r in new_solution]\n                                break\n\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8627499822612408,
            0.827190101146698
        ]
    }
]