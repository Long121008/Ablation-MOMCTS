[
    {
        "algorithm": "{The novel local search strategy combines route merging and split insertion, where we randomly select two routes from the solution, merge them into a single route, and then intelligently split the merged route into two new routes by evaluating potential split points based on demand balance and distance reduction, ensuring feasibility and improved objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Randomly select two routes to merge\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    i, j = random.sample(range(len(selected_solution)), 2)\n    route1 = selected_solution[i]\n    route2 = selected_solution[j]\n\n    # Merge the two routes (excluding depots)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Calculate cumulative demand and distance\n    cumulative_demand = np.cumsum(demand[merged_route])\n    total_demand = cumulative_demand[-1]\n\n    if total_demand > capacity:\n        # If merged route exceeds capacity, split at a feasible point\n        feasible_splits = []\n        for k in range(1, len(merged_route)):\n            if cumulative_demand[k] <= capacity and cumulative_demand[k-1] < cumulative_demand[k]:\n                feasible_splits.append(k)\n\n        if not feasible_splits:\n            return selected_solution\n\n        # Evaluate splits based on distance reduction and demand balance\n        best_split = None\n        best_score = float('inf')\n\n        for k in feasible_splits:\n            # Split into two routes\n            split1 = np.concatenate([[0], merged_route[:k], [0]])\n            split2 = np.concatenate([[0], merged_route[k:], [0]])\n\n            # Calculate total distance for the new routes\n            dist1 = sum(distance_matrix[split1[i]][split1[i+1]] for i in range(len(split1)-1))\n            dist2 = sum(distance_matrix[split2[i]][split2[i+1]] for i in range(len(split2)-1))\n            total_dist = dist1 + dist2\n\n            # Score based on distance and demand balance\n            demand_balance = abs(cumulative_demand[k] - (total_demand - cumulative_demand[k]))\n            score = total_dist + 0.1 * demand_balance  # Weight demand balance lightly\n\n            if score < best_score:\n                best_score = score\n                best_split = k\n\n        if best_split is not None:\n            # Create new routes\n            new_route1 = np.concatenate([[0], merged_route[:best_split], [0]])\n            new_route2 = np.concatenate([[0], merged_route[best_split:], [0]])\n\n            # Replace the original routes with the new ones\n            selected_solution[i] = new_route1\n            selected_solution[j] = new_route2\n\n    return selected_solution\n\n",
        "score": [
            -0.7193613217144657,
            0.29126399755477905
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective ratio to prioritize solutions with balanced improvement potential in both objectives, then applies a novel adaptive route merging and customer redistribution strategy that dynamically adjusts split points and considers spatial clustering to generate high-quality neighbors while maintaining feasibility through rigorous capacity checks and demand validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)\n    selected_idx = np.argmin(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    if len(base_solution) > 1:\n        # Calculate route scores based on distance and demand balance\n        route_scores = []\n        for route in base_solution:\n            customers = route[1:-1]\n            route_demand = np.sum(demand[customers])\n            route_distance = distance_matrix[route[-2], 0] + np.sum(distance_matrix[route[:-1], route[1:]])\n            score = route_distance * (1 + 0.1 * abs(route_demand - capacity/2))\n            route_scores.append(score)\n\n        # Select routes to merge based on spatial proximity\n        sorted_indices = np.argsort(route_scores)\n        route1_idx, route2_idx = sorted_indices[0], sorted_indices[1]\n        route1, route2 = base_solution[route1_idx], base_solution[route2_idx]\n\n        # Calculate centroids for spatial analysis\n        def get_centroid(route):\n            customers = route[1:-1]\n            if len(customers) == 0:\n                return coords[0]\n            return np.mean(coords[customers], axis=0)\n\n        centroid1, centroid2 = get_centroid(route1), get_centroid(route2)\n        centroid_dist = np.linalg.norm(centroid1 - centroid2)\n\n        # Determine split point based on spatial clustering\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n        all_customers = np.concatenate([customers1, customers2])\n        if len(all_customers) > 0:\n            cluster_center = np.mean(coords[all_customers], axis=0)\n            dist_to_center = np.linalg.norm(coords[all_customers] - cluster_center, axis=1)\n            split_pos = np.argmin(dist_to_center)\n\n            # Create new routes by splitting at the cluster center\n            if split_pos < len(customers1):\n                part1 = np.concatenate(([0], customers1[:split_pos+1], [0]))\n                part2 = np.concatenate(([0], customers1[split_pos+1:], customers2, [0]))\n            else:\n                part1 = np.concatenate(([0], customers1, customers2[:split_pos-len(customers1)+1], [0]))\n                part2 = np.concatenate(([0], customers2[split_pos-len(customers1)+1:], [0]))\n\n            # Validate capacity constraints\n            if (np.sum(demand[part1[1:-1]]) <= capacity and\n                np.sum(demand[part2[1:-1]]) <= capacity):\n                new_solution = [r for i, r in enumerate(base_solution)\n                               if i not in (route1_idx, route2_idx)]\n                new_solution.extend([part1, part2])\n            else:\n                new_solution = base_solution.copy()\n        else:\n            new_solution = base_solution.copy()\n    else:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8923663452625354,
            0.6838812530040741
        ]
    }
]