[
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7797213923185287,
            0.09580197930335999
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and route length diversity, then applies a hybrid local search combining route merging, route splitting, and intelligent insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, (total_dist, makespan) in archive:\n        # Potential is a combination of makespan and total distance normalized by archive size\n        potential = (makespan / (total_dist + 1e-6)) * len(archive)\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine route merging, splitting, and intelligent insertion\n    if len(new_solution) > 1:\n        # Try merging two routes\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        # Check if merging is feasible\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution = [r for idx, r in enumerate(new_solution) if idx not in {i, j}] + [merged_route]\n\n    # Try splitting a long route\n    for route in new_solution:\n        if len(route) > 4:  # Only consider routes with more than 3 customers\n            split_pos = random.randint(2, len(route) - 2)\n            part1 = route[:split_pos + 1]\n            part2 = route[split_pos:]\n\n            if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)] + [part1, part2]\n                break\n\n    # Intelligent insertion: find best position for a random customer in a random route\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 2:  # Ensure there's space to move\n            # Select a random customer from the route (not depot)\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove customer from route\n            new_route = np.concatenate([route[:customer_pos], route[customer_pos + 1:]])\n\n            # Find best insertion position in the same route\n            best_pos = 1\n            min_increase = float('inf')\n\n            for pos in range(1, len(new_route)):\n                test_route = np.insert(new_route, pos, customer)\n                if np.sum(demand[test_route[1:-1]]) <= capacity:\n                    increase = (distance_matrix[test_route[pos-1]][customer] +\n                                distance_matrix[customer][test_route[pos+1]] -\n                                distance_matrix[test_route[pos-1]][test_route[pos+1]])\n                    if increase < min_increase:\n                        min_increase = increase\n                        best_pos = pos\n\n            # Insert at best position\n            new_route = np.insert(new_route, best_pos, customer)\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.838963792451251,
            0.19506263732910156
        ]
    }
]