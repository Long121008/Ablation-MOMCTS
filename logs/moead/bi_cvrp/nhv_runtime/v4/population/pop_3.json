[
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7797213923185287,
            0.09580197930335999
        ]
    },
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route merging and customer reinsertion to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Try merging the longest route with another route\n    for candidate_route_idx in range(len(selected_solution)):\n        if candidate_route_idx == longest_route_idx:\n            continue\n        candidate_route = selected_solution[candidate_route_idx].copy()\n\n        # Check if merging is feasible\n        merged_route = np.concatenate([candidate_route[:-1], longest_route[1:]])\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            # Replace the original routes with the merged route\n            new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx and i != candidate_route_idx]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging is not feasible, try reinserting a customer from the longest route to another route\n    for candidate_route_idx in range(len(selected_solution)):\n        if candidate_route_idx == longest_route_idx:\n            continue\n        candidate_route = selected_solution[candidate_route_idx].copy()\n\n        for customer in longest_route[1:-1]:\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Update the routes\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[longest_route_idx] = np.concatenate([\n                        longest_route[:list(longest_route).index(customer)],\n                        longest_route[list(longest_route).index(customer) + 1:]\n                    ])\n                    if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                        new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.872915977004242,
            0.3502544164657593
        ]
    }
]