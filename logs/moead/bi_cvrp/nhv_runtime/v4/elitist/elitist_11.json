[
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7797213923185287,
            0.09580197930335999
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive with high total distance, identifies a critical route segment, and applies a hybrid local search combining route merging and customer reinsertion to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][0])  # Sort by total distance in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Select a random route from the solution\n    route_idx = random.randint(0, len(selected_solution) - 1)\n    selected_route = selected_solution[route_idx].copy()\n\n    # Identify the longest segment in the selected route\n    max_segment_length = 0\n    split_point = 1\n    for i in range(1, len(selected_route) - 1):\n        segment_length = distance_matrix[selected_route[i-1], selected_route[i]]\n        if segment_length > max_segment_length:\n            max_segment_length = segment_length\n            split_point = i\n\n    # Split the route at the split point\n    first_part = selected_route[:split_point + 1]\n    second_part = np.concatenate([[0], selected_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try merging with another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            merged_route = np.concatenate([candidate_route[:-1], selected_route[1:]])\n            if is_feasible(merged_route):\n                new_solution[candidate_route_idx] = merged_route\n                new_solution = [route for i, route in enumerate(new_solution) if i != route_idx]\n                return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6776755761537206,
            0.04273110628128052
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    }
]