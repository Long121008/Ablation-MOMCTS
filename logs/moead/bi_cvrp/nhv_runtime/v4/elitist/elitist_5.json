[
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7797213923185287,
            0.09580197930335999
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    },
    {
        "algorithm": "{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.9308481603560892,
            0.0830659568309784
        ]
    }
]