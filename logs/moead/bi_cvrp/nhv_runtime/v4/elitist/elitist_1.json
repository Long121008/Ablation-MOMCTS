[
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7797213923185287,
            0.09580197930335999
        ]
    },
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7797213923185287,
            0.09580197930335999
        ]
    },
    {
        "algorithm": "{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7797213923185287,
            0.09580197930335999
        ]
    }
]