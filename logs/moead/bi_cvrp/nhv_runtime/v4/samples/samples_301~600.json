[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This function selects a solution from the archive based on a combination of distance and makespan, then applies a novel hybrid local search that combines route merging with strategic customer insertion and rebalancing to generate a neighbor solution, ensuring feasibility while potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive[0][0].copy()\n\n    # Identify routes with high distance-to-demand ratio (potential for merging)\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_demand = sum(demand[route[1:-1]])\n        route_scores.append(route_distance / (route_demand + 1e-6))\n    candidate_pairs = sorted([(i, j) for i in range(len(selected_solution)) for j in range(i+1, len(selected_solution))],\n                           key=lambda x: (route_scores[x[0]] + route_scores[x[1]]) / 2, reverse=True)\n\n    # Try merging the most promising route pair\n    for i, j in candidate_pairs:\n        route1, route2 = selected_solution[i], selected_solution[j]\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Create merged route by connecting the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Check if the merged route is feasible\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution = [route for k, route in enumerate(selected_solution) if k not in (i, j)]\n                new_solution.append(merged_route)\n                return new_solution\n\n    # If merging failed, try rebalancing customers between routes\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        if len(route) <= 3:\n            continue\n        # Find customer with highest demand in this route\n        customers = route[1:-1]\n        customer_demands = demand[customers]\n        max_demand_customer = customers[np.argmax(customer_demands)]\n\n        # Try inserting this customer into another route\n        for other_route_idx in range(len(selected_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = selected_solution[other_route_idx]\n            # Try inserting at all possible positions\n            for pos in range(1, len(other_route)):\n                new_route = np.concatenate([other_route[:pos], [max_demand_customer], other_route[pos:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([\n                        route[:list(route).index(max_demand_customer)],\n                        route[list(route).index(max_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[route_idx]) <= 2:\n                        new_solution = [r for k, r in enumerate(new_solution) if k != route_idx]\n                    return new_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n",
        "score": [
            -0.8100683938044612,
            1.6609705984592438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = archive[0][0].copy()\n\n    # Identify routes with high distance-to-demand ratio (potential for merging)\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_demand = sum(demand[route[1:-1]])\n        route_scores.append(route_distance / (route_demand + 1e-6))\n    candidate_pairs = sorted([(i, j) for i in range(len(selected_solution)) for j in range(i+1, len(selected_solution))],\n                           key=lambda x: (route_scores[x[0]] + route_scores[x[1]]) / 2, reverse=True)\n\n    # Try merging the most promising route pair\n    for i, j in candidate_pairs:\n        route1, route2 = selected_solution[i], selected_solution[j]\n        # Check if merging is feasible\n        if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            # Create merged route by connecting the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            # Check if the merged route is feasible\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution = [route for k, route in enumerate(selected_solution) if k not in (i, j)]\n                new_solution.append(merged_route)\n                return new_solution\n\n    # If merging failed, try rebalancing customers between routes\n    for route_idx in range(len(selected_solution)):\n        route = selected_solution[route_idx]\n        if len(route) <= 3:\n            continue\n        # Find customer with highest demand in this route\n        customers = route[1:-1]\n        customer_demands = demand[customers]\n        max_demand_customer = customers[np.argmax(customer_demands)]\n\n        # Try inserting this customer into another route\n        for other_route_idx in range(len(selected_solution)):\n            if other_route_idx == route_idx:\n                continue\n            other_route = selected_solution[other_route_idx]\n            # Try inserting at all possible positions\n            for pos in range(1, len(other_route)):\n                new_route = np.concatenate([other_route[:pos], [max_demand_customer], other_route[pos:]])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Create new solution\n                    new_solution = selected_solution.copy()\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([\n                        route[:list(route).index(max_demand_customer)],\n                        route[list(route).index(max_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[route_idx]) <= 2:\n                        new_solution = [r for k, r in enumerate(new_solution) if k != route_idx]\n                    return new_solution\n\n    # If no improvement found, return original solution\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This function selects a solution from the archive based on a novel combination of distance and makespan metrics, then applies a hybrid local search combining route merging and customer reinsertion with adaptive demand-based selection to balance both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    selected_solution = archive[0][0].copy()\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Try merging two routes if they can be combined\n    if len(selected_solution) > 1:\n        # Find pair of routes with smallest combined distance\n        min_merge_dist = float('inf')\n        best_pair = None\n        for i in range(len(selected_solution)):\n            for j in range(i + 1, len(selected_solution)):\n                route1 = selected_solution[i]\n                route2 = selected_solution[j]\n                # Calculate distance between last of route1 and first of route2\n                dist = distance_matrix[route1[-2], route2[1]]\n                if dist < min_merge_dist:\n                    min_merge_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            route1 = selected_solution[i]\n            route2 = selected_solution[j]\n            # Try merging route1 and route2\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if is_feasible(merged_route):\n                new_solution = [route for idx, route in enumerate(selected_solution) if idx not in [i, j]]\n                new_solution.append(merged_route)\n                return new_solution\n\n    # If merging failed, try reinserting customers from routes with high demand\n    for route in selected_solution:\n        if len(route) > 3:\n            # Find customer with highest demand in this route\n            customers = route[1:-1]\n            demands = demand[customers]\n            high_demand_customer = customers[np.argmax(demands)]\n\n            # Try inserting this customer into another route\n            for target_route in selected_solution:\n                if np.array_equal(target_route, route):\n                    continue\n                for pos in range(1, len(target_route)):\n                    new_route = np.concatenate([target_route[:pos], [high_demand_customer], target_route[pos:]])\n                    if is_feasible(new_route):\n                        # Remove customer from original route\n                        original_route = np.concatenate([\n                            route[:list(route).index(high_demand_customer)],\n                            route[list(route).index(high_demand_customer) + 1:]\n                        ])\n                        # Build new solution\n                        new_solution = []\n                        for r in selected_solution:\n                            if np.array_equal(r, route):\n                                if len(original_route) > 2:\n                                    new_solution.append(original_route)\n                            elif np.array_equal(r, target_route):\n                                new_solution.append(new_route)\n                            else:\n                                new_solution.append(r)\n                        return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.7006823982842334,
            1.5321440696716309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    selected_solution = archive[0][0].copy()\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Try merging two routes if they can be combined\n    if len(selected_solution) > 1:\n        # Find pair of routes with smallest combined distance\n        min_merge_dist = float('inf')\n        best_pair = None\n        for i in range(len(selected_solution)):\n            for j in range(i + 1, len(selected_solution)):\n                route1 = selected_solution[i]\n                route2 = selected_solution[j]\n                # Calculate distance between last of route1 and first of route2\n                dist = distance_matrix[route1[-2], route2[1]]\n                if dist < min_merge_dist:\n                    min_merge_dist = dist\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            route1 = selected_solution[i]\n            route2 = selected_solution[j]\n            # Try merging route1 and route2\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            if is_feasible(merged_route):\n                new_solution = [route for idx, route in enumerate(selected_solution) if idx not in [i, j]]\n                new_solution.append(merged_route)\n                return new_solution\n\n    # If merging failed, try reinserting customers from routes with high demand\n    for route in selected_solution:\n        if len(route) > 3:\n            # Find customer with highest demand in this route\n            customers = route[1:-1]\n            demands = demand[customers]\n            high_demand_customer = customers[np.argmax(demands)]\n\n            # Try inserting this customer into another route\n            for target_route in selected_solution:\n                if np.array_equal(target_route, route):\n                    continue\n                for pos in range(1, len(target_route)):\n                    new_route = np.concatenate([target_route[:pos], [high_demand_customer], target_route[pos:]])\n                    if is_feasible(new_route):\n                        # Remove customer from original route\n                        original_route = np.concatenate([\n                            route[:list(route).index(high_demand_customer)],\n                            route[list(route).index(high_demand_customer) + 1:]\n                        ])\n                        # Build new solution\n                        new_solution = []\n                        for r in selected_solution:\n                            if np.array_equal(r, route):\n                                if len(original_route) > 2:\n                                    new_solution.append(original_route)\n                            elif np.array_equal(r, target_route):\n                                new_solution.append(new_route)\n                            else:\n                                new_solution.append(r)\n                        return new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This function selects a solution with the smallest total distance from the archive, identifies a critical route with high makespan, and applies a novel hybrid local search that combines strategic route merging with demand-aware customer rebalancing to simultaneously improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])  # Sort by total distance in ascending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Identify the shortest route (candidate for merging)\n    shortest_route_idx = np.argmin([len(route) for route in selected_solution if len(route) > 2])\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Check capacity feasibility for merged route\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Attempt to merge the longest and shortest routes\n    merged_route = np.concatenate([shortest_route[:-1], longest_route[1:]])\n    if is_feasible(merged_route):\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in [longest_route_idx, shortest_route_idx]]\n        new_solution.append(merged_route)\n    else:\n        # If merge is infeasible, try rebalancing customers between routes\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx in [longest_route_idx, shortest_route_idx]:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7529109906947442,
            1.9097956717014313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])  # Sort by total distance in ascending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Identify the shortest route (candidate for merging)\n    shortest_route_idx = np.argmin([len(route) for route in selected_solution if len(route) > 2])\n    shortest_route = selected_solution[shortest_route_idx].copy()\n\n    # Check capacity feasibility for merged route\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    # Attempt to merge the longest and shortest routes\n    merged_route = np.concatenate([shortest_route[:-1], longest_route[1:]])\n    if is_feasible(merged_route):\n        new_solution = [route for i, route in enumerate(selected_solution) if i not in [longest_route_idx, shortest_route_idx]]\n        new_solution.append(merged_route)\n    else:\n        # If merge is infeasible, try rebalancing customers between routes\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx in [longest_route_idx, shortest_route_idx]:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This function selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a route-splitting and customer reallocation strategy with adaptive split points and feasibility checks to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] / (x[1][1] + 1e-6)))\n    selected_solution = archive[0][0].copy()\n\n    # Identify the route with the highest distance-to-makespan ratio\n    route_scores = []\n    for route in selected_solution:\n        route_distance = distance_matrix[route[:-1], route[1:]].sum()\n        route_scores.append(route_distance / (len(route) - 1))\n    target_route_idx = np.argmax(route_scores)\n    target_route = selected_solution[target_route_idx].copy()\n\n    # Adaptive split point selection: split at the customer with highest demand\n    if len(target_route) > 3:\n        demands = demand[target_route[1:-1]]\n        split_idx = np.argmax(demands) + 1  # +1 to account for depot\n        first_part = target_route[:split_idx + 1]\n        second_part = np.concatenate([[0], target_route[split_idx:-1]])\n\n        # Check feasibility\n        def is_feasible(route):\n            return sum(demand[route[1:-1]]) <= capacity\n\n        if is_feasible(first_part) and is_feasible(second_part):\n            new_solution = [route for i, route in enumerate(selected_solution) if i != target_route_idx]\n            new_solution.append(first_part)\n            new_solution.append(second_part)\n            return new_solution\n\n    # If split failed, try reallocating the highest-demand customer\n    if len(target_route) > 2:\n        highest_demand_customer = target_route[1:-1][np.argmax(demand[target_route[1:-1]])]\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == target_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting at all possible positions\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [highest_demand_customer], candidate_route[pos:]])\n                if is_feasible(new_route):\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[target_route_idx] = np.concatenate([\n                        target_route[:list(target_route).index(highest_demand_customer)],\n                        target_route[list(target_route).index(highest_demand_customer) + 1:]\n                    ])\n                    if len(new_solution[target_route_idx]) <= 2:\n                        new_solution = [route for i, route in enumerate(new_solution) if i != target_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This function selects a solution from the archive based on a novel hybrid scoring of distance and makespan, then applies a route-reshaping strategy that combines adaptive route merging and customer redistribution to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    selected_solution = archive[0][0].copy()\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    longest_route_idx = np.argmax(route_lengths)\n\n    shortest_route = selected_solution[shortest_route_idx].copy()\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    for customer in shortest_route[1:-1]:\n        for pos in range(1, len(longest_route)):\n            new_route = np.concatenate([longest_route[:pos], [customer], longest_route[pos:]])\n            if is_feasible(new_route):\n                new_solution = selected_solution.copy()\n                new_solution[longest_route_idx] = new_route\n                new_solution[shortest_route_idx] = np.concatenate([\n                    shortest_route[:list(shortest_route).index(customer)],\n                    shortest_route[list(shortest_route).index(customer) + 1:]\n                ])\n                if len(new_solution[shortest_route_idx]) <= 2:\n                    new_solution = [route for i, route in enumerate(new_solution) if i != shortest_route_idx]\n                return new_solution\n\n    if len(shortest_route) + len(longest_route) - 2 <= capacity:\n        merged_route = np.concatenate([shortest_route[1:-1], longest_route[1:-1]])\n        new_route = np.concatenate([[0], merged_route, [0]])\n        if is_feasible(new_route):\n            new_solution = [route for i, route in enumerate(selected_solution) if i not in [shortest_route_idx, longest_route_idx]]\n            new_solution.append(new_route)\n            return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.814997282168695,
            2.7685527205467224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    selected_solution = archive[0][0].copy()\n\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if len(selected_solution) < 2:\n        return selected_solution\n\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution]\n    shortest_route_idx = np.argmin(route_lengths)\n    longest_route_idx = np.argmax(route_lengths)\n\n    shortest_route = selected_solution[shortest_route_idx].copy()\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    for customer in shortest_route[1:-1]:\n        for pos in range(1, len(longest_route)):\n            new_route = np.concatenate([longest_route[:pos], [customer], longest_route[pos:]])\n            if is_feasible(new_route):\n                new_solution = selected_solution.copy()\n                new_solution[longest_route_idx] = new_route\n                new_solution[shortest_route_idx] = np.concatenate([\n                    shortest_route[:list(shortest_route).index(customer)],\n                    shortest_route[list(shortest_route).index(customer) + 1:]\n                ])\n                if len(new_solution[shortest_route_idx]) <= 2:\n                    new_solution = [route for i, route in enumerate(new_solution) if i != shortest_route_idx]\n                return new_solution\n\n    if len(shortest_route) + len(longest_route) - 2 <= capacity:\n        merged_route = np.concatenate([shortest_route[1:-1], longest_route[1:-1]])\n        new_route = np.concatenate([[0], merged_route, [0]])\n        if is_feasible(new_route):\n            new_solution = [route for i, route in enumerate(selected_solution) if i not in [shortest_route_idx, longest_route_idx]]\n            new_solution.append(new_route)\n            return new_solution\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This function selects a promising solution from the archive, identifies a critical route with high makespan, and applies a hybrid local search combining route splitting and customer reallocation to improve both objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: -x[1][1])  # Sort by makespan in descending order\n    selected_solution = archive[0][0].copy()\n\n    # Identify the longest route (makespan)\n    longest_route_idx = np.argmax([distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution])\n    longest_route = selected_solution[longest_route_idx].copy()\n\n    # Split the longest route into two parts at a random point\n    split_point = random.randint(1, len(longest_route) - 2)\n    first_part = longest_route[:split_point + 1]\n    second_part = np.concatenate([[0], longest_route[split_point:-1]])\n\n    # Check capacity feasibility for the split parts\n    def is_feasible(route):\n        return sum(demand[route[1:-1]]) <= capacity\n\n    if is_feasible(first_part) and is_feasible(second_part):\n        # Replace the original route with the two new routes\n        new_solution = [route for i, route in enumerate(selected_solution) if i != longest_route_idx]\n        new_solution.append(first_part)\n        new_solution.append(second_part)\n    else:\n        # If split is infeasible, try reallocating a customer from the longest route to another route\n        new_solution = selected_solution.copy()\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == longest_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n            for customer in longest_route[1:-1]:\n                # Try inserting the customer into the candidate route\n                for pos in range(1, len(candidate_route)):\n                    new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                    if is_feasible(new_route):\n                        # Update the routes\n                        new_solution[candidate_route_idx] = new_route\n                        new_solution[longest_route_idx] = np.concatenate([\n                            longest_route[:list(longest_route).index(customer)],\n                            longest_route[list(longest_route).index(customer) + 1:]\n                        ])\n                        if len(new_solution[longest_route_idx]) <= 2:  # If route becomes empty after removal\n                            new_solution = [route for i, route in enumerate(new_solution) if i != longest_route_idx]\n                        return new_solution\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This function selects a solution from the archive based on a weighted combination of distance and makespan, then applies a hybrid local search that combines route merging and customer reinsertion to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution]\n    route_demands = [demand[route[1:-1]].sum() for route in selected_solution]\n\n    # Find the most balanced route (minimize |length - makespan|)\n    makespan = max(route_lengths)\n    balanced_route_idx = np.argmin([abs(l - makespan) for l in route_lengths])\n    balanced_route = selected_solution[balanced_route_idx].copy()\n\n    # Try merging with another route\n    for candidate_route_idx in range(len(selected_solution)):\n        if candidate_route_idx == balanced_route_idx:\n            continue\n        candidate_route = selected_solution[candidate_route_idx].copy()\n\n        # Check if merging is feasible\n        combined_demand = route_demands[balanced_route_idx] + route_demands[candidate_route_idx]\n        if combined_demand > capacity:\n            continue\n\n        # Create merged route\n        merged_route = np.concatenate([balanced_route[:-1], candidate_route[1:]])\n\n        # Check if merged route is feasible\n        if demand[merged_route[1:-1]].sum() <= capacity:\n            # Replace routes\n            new_solution = [route for i, route in enumerate(selected_solution)\n                           if i != balanced_route_idx and i != candidate_route_idx]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging failed, try reinserting a customer from the balanced route\n    for customer in balanced_route[1:-1]:\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == balanced_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting customer at each possible position\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                if demand[new_route[1:-1]].sum() <= capacity:\n                    # Update routes\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[balanced_route_idx] = np.concatenate([\n                        balanced_route[:list(balanced_route).index(customer)],\n                        balanced_route[list(balanced_route).index(customer) + 1:]\n                    ])\n                    if len(new_solution[balanced_route_idx]) <= 2:  # If route becomes empty\n                        new_solution = [route for i, route in enumerate(new_solution)\n                                       if i != balanced_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n",
        "score": [
            -0.6266725659299561,
            3.5208581387996674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Calculate route lengths and demands\n    route_lengths = [distance_matrix[route[:-1], route[1:]].sum() for route in selected_solution]\n    route_demands = [demand[route[1:-1]].sum() for route in selected_solution]\n\n    # Find the most balanced route (minimize |length - makespan|)\n    makespan = max(route_lengths)\n    balanced_route_idx = np.argmin([abs(l - makespan) for l in route_lengths])\n    balanced_route = selected_solution[balanced_route_idx].copy()\n\n    # Try merging with another route\n    for candidate_route_idx in range(len(selected_solution)):\n        if candidate_route_idx == balanced_route_idx:\n            continue\n        candidate_route = selected_solution[candidate_route_idx].copy()\n\n        # Check if merging is feasible\n        combined_demand = route_demands[balanced_route_idx] + route_demands[candidate_route_idx]\n        if combined_demand > capacity:\n            continue\n\n        # Create merged route\n        merged_route = np.concatenate([balanced_route[:-1], candidate_route[1:]])\n\n        # Check if merged route is feasible\n        if demand[merged_route[1:-1]].sum() <= capacity:\n            # Replace routes\n            new_solution = [route for i, route in enumerate(selected_solution)\n                           if i != balanced_route_idx and i != candidate_route_idx]\n            new_solution.append(merged_route)\n            return new_solution\n\n    # If merging failed, try reinserting a customer from the balanced route\n    for customer in balanced_route[1:-1]:\n        for candidate_route_idx in range(len(selected_solution)):\n            if candidate_route_idx == balanced_route_idx:\n                continue\n            candidate_route = selected_solution[candidate_route_idx].copy()\n\n            # Try inserting customer at each possible position\n            for pos in range(1, len(candidate_route)):\n                new_route = np.concatenate([candidate_route[:pos], [customer], candidate_route[pos:]])\n                if demand[new_route[1:-1]].sum() <= capacity:\n                    # Update routes\n                    new_solution = selected_solution.copy()\n                    new_solution[candidate_route_idx] = new_route\n                    new_solution[balanced_route_idx] = np.concatenate([\n                        balanced_route[:list(balanced_route).index(customer)],\n                        balanced_route[list(balanced_route).index(customer) + 1:]\n                    ])\n                    if len(new_solution[balanced_route_idx]) <= 2:  # If route becomes empty\n                        new_solution = [route for i, route in enumerate(new_solution)\n                                       if i != balanced_route_idx]\n                    return new_solution\n\n    return selected_solution\n\n"
    }
]