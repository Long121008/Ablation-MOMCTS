[
    {
        "algorithm": "{A hybrid local search operator that combines route splitting with demand-based node relocations and a makespan-aware edge exchange mechanism to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting based on demand patterns\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find split point where demand exceeds capacity\n        cumulative_demand = 0\n        split_point = -1\n        for j in range(1, len(route)-1):\n            cumulative_demand += demand[route[j]]\n            if cumulative_demand > capacity:\n                split_point = j\n                break\n\n        if split_point > 1:\n            # Split the route\n            new_route1 = np.concatenate((route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_point+1:]))\n\n            # Replace old route with new ones\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Step 2: Makespan-aware edge exchange\n    # Find the longest route (highest makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n    if len(new_solution) > 1:\n        # Try to transfer nodes from longest route to others\n        longest_route = new_solution[longest_route_idx].copy()\n        for i in range(len(longest_route)-2, 0, -1):  # Iterate backwards\n            node = longest_route[i]\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Insert node into route j\n                    best_pos = 1  # Default position\n                    best_cost = float('inf')\n\n                    # Find best insertion position in route j\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    # Perform insertion\n                    new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from longest route\n                    new_solution[longest_route_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.7810190492705298,
            0.512780100107193
        ]
    },
    {
        "algorithm": "{A hybrid local search operator that combines demand-aware route merging with distance-balancing edge swaps and a makespan-sensitive route rebalancing mechanism to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by combined objective score\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)-1):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check if merging is feasible\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Calculate merging cost\n                    cost1 = distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]]\n                    cost2 = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n                    cost_diff = cost2 - cost1\n\n                    # Calculate makespan impact\n                    makespan1 = distance_matrix[route1[-2], 0] + sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1))\n                    makespan2 = distance_matrix[route2[-2], 0] + sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1))\n                    max_makespan = max(makespan1, makespan2)\n\n                    new_makespan = distance_matrix[route1[-2], route2[1]] + sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) + \\\n                                  distance_matrix[route2[-2], 0] + sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1))\n                    new_max_makespan = max(new_makespan, max_makespan)\n\n                    # Accept merge if it improves both objectives\n                    if cost_diff < 0 and new_max_makespan <= max_makespan:\n                        merged_route = np.concatenate((route1[:-1], route2[1:]))\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    # Step 2: Distance-balancing edge swaps\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find edges that can be swapped to balance distances\n        for j in range(1, len(route)-2):\n            for k in range(j+2, len(route)-1):\n                # Calculate current and potential new distances\n                current_dist = distance_matrix[route[j], route[j+1]] + distance_matrix[route[k], route[k+1]]\n                new_dist = distance_matrix[route[j], route[k]] + distance_matrix[route[j+1], route[k+1]]\n\n                # Check capacity constraints\n                if (sum(demand[route[j+1:k+1]]) + sum(demand[route[1:j+1]]) <= capacity and\n                    sum(demand[route[k+1:]]) + sum(demand[route[1:j+1]]) <= capacity):\n\n                    # Accept swap if it improves distance\n                    if new_dist < current_dist:\n                        # Perform the swap\n                        new_route = np.concatenate((route[:j+1], route[k:j:-1], route[k+1:]))\n                        new_solution[i] = new_route\n                        break\n\n    # Step 3: Makespan-sensitive route rebalancing\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n        shortest_idx = min(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx].copy()\n            shortest_route = new_solution[shortest_idx].copy()\n\n            # Try to transfer nodes from longest to shortest route\n            for i in range(len(longest_route)-2, 0, -1):\n                node = longest_route[i]\n                if sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for j in range(1, len(shortest_route)):\n                        prev_node = shortest_route[j-1]\n                        next_node = shortest_route[j]\n\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = j\n\n                    # Perform insertion\n                    new_shortest = np.concatenate((shortest_route[:best_pos], [node], shortest_route[best_pos:]))\n                    new_solution[shortest_idx] = new_shortest\n\n                    # Remove from longest route\n                    new_solution[longest_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.9734037118815195,
            5.390408217906952
        ]
    }
]