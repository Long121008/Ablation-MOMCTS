[
    {
        "algorithm": "{A hybrid local search operator that combines route splitting with demand-based node relocations and a makespan-aware edge exchange mechanism to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting based on demand patterns\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find split point where demand exceeds capacity\n        cumulative_demand = 0\n        split_point = -1\n        for j in range(1, len(route)-1):\n            cumulative_demand += demand[route[j]]\n            if cumulative_demand > capacity:\n                split_point = j\n                break\n\n        if split_point > 1:\n            # Split the route\n            new_route1 = np.concatenate((route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_point+1:]))\n\n            # Replace old route with new ones\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Step 2: Makespan-aware edge exchange\n    # Find the longest route (highest makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n    if len(new_solution) > 1:\n        # Try to transfer nodes from longest route to others\n        longest_route = new_solution[longest_route_idx].copy()\n        for i in range(len(longest_route)-2, 0, -1):  # Iterate backwards\n            node = longest_route[i]\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Insert node into route j\n                    best_pos = 1  # Default position\n                    best_cost = float('inf')\n\n                    # Find best insertion position in route j\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    # Perform insertion\n                    new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from longest route\n                    new_solution[longest_route_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.7810190492705298,
            0.512780100107193
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines multi-objective route merging with spatial clustering and demand-aware node redistribution, while maintaining feasibility through capacity-constrained route balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)  # Weighted combination\n    selected_idx = min(2, len(archive) - 1)  # Select among top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and route merging\n    if len(new_solution) > 2:\n        # Find two closest routes based on spatial proximity\n        min_dist = float('inf')\n        merge_pair = (0, 1)\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Calculate centroids\n                centroid1 = np.mean(coords[route1[1:-1]], axis=0)\n                centroid2 = np.mean(coords[route2[1:-1]], axis=0)\n\n                dist = np.linalg.norm(centroid1 - centroid2)\n                if dist < min_dist:\n                    min_dist = dist\n                    merge_pair = (i, j)\n\n        # Check if merging is feasible\n        i, j = merge_pair\n        if (sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]])) <= capacity:\n            # Merge routes\n            merged_route = np.concatenate((new_solution[i][1:-1], new_solution[j][1:-1], [0]))\n            new_solution[i] = np.concatenate(([0], merged_route))\n            del new_solution[j]\n\n    # Step 2: Demand-aware node redistribution\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Sort nodes by demand (descending)\n        nodes = route[1:-1]\n        sorted_nodes = sorted(nodes, key=lambda x: demand[x], reverse=True)\n\n        # Try to move nodes to other routes if beneficial\n        for node in sorted_nodes:\n            best_route_idx = -1\n            best_improvement = 0\n\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], route):\n                    continue\n\n                # Check capacity constraint\n                if (sum(demand[new_solution[i][1:-1]]) + demand[node]) <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for k in range(1, len(new_solution[i])):\n                        prev_node = new_solution[i][k-1]\n                        next_node = new_solution[i][k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    if best_cost < best_improvement:\n                        best_improvement = best_cost\n                        best_route_idx = i\n\n            if best_route_idx != -1:\n                # Perform the move\n                new_route = new_solution[best_route_idx]\n                new_route = np.concatenate((new_route[:best_pos], [node], new_route[best_pos:]))\n                new_solution[best_route_idx] = new_route\n\n                # Remove from original route\n                route_idx = np.where(route == node)[0][0]\n                route = np.concatenate((route[:route_idx], route[route_idx+1:]))\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.847394180525441,
            9.075175285339355
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search combining route splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route)\n\n    # Apply inter-route insertion to reduce makespan\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Try moving a random customer from route_i to route_j\n        if len(route_i) > 2:\n            customer_idx = np.random.randint(1, len(route_i) - 1)\n            customer = route_i[customer_idx]\n\n            # Check if insertion is feasible\n            if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route_j\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.insert(route_j, insert_pos, customer)\n                new_route_i = np.delete(route_i, customer_idx)\n\n                # Update solution\n                new_solution[i] = new_route_i if len(new_route_i) > 2 else []\n                new_solution[j] = new_route_j\n\n                # Remove empty routes\n                new_solution = [r for r in new_solution if len(r) > 0]\n\n    # If no improvement, return the original solution\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7916364238107323,
            0.16387081146240234
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive using a weighted random selection favoring solutions with lower makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and route merging to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    makespans = [obj[1] for _, obj in archive]\n    min_makespan = min(makespans)\n    weights = [1.0 / (obj[1] - min_makespan + 1e-6) for _, obj in archive]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: split, reinsert, merge\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two parts\n        split_pos = random.randint(1, len(route) - 2)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Reinsert customers from part2 into part1 if feasible\n        temp_route = part1.copy()\n        remaining = part2[1:-1].copy()\n        random.shuffle(remaining)\n        for customer in remaining:\n            # Find best insertion position\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(1, len(temp_route)):\n                new_route = np.insert(temp_route, i, customer)\n                if np.sum(demand[new_route[1:-1]]) > capacity:\n                    continue\n                cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i]] - distance_matrix[temp_route[i-1], temp_route[i]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = i\n            if best_pos != -1:\n                temp_route = np.insert(temp_route, best_pos, customer)\n\n        # Add the modified part1 to new solution\n        new_solution.append(temp_route)\n\n        # Check if part2 can be merged with another route\n        if len(part2) > 2:\n            best_merge_route = None\n            best_merge_cost = float('inf')\n            for i, r in enumerate(new_solution):\n                if i == len(new_solution) - 1:  # Skip the last added route\n                    continue\n                # Check if merging is feasible\n                merged_route = np.concatenate([r[:-1], part2[1:]])\n                if np.sum(demand[merged_route[1:-1]]) > capacity:\n                    continue\n                # Calculate merge cost\n                merge_cost = distance_matrix[r[-2], part2[1]] + distance_matrix[part2[-2], 0] - (distance_matrix[r[-2], 0] + distance_matrix[part2[-2], 0])\n                if merge_cost < best_merge_cost:\n                    best_merge_cost = merge_cost\n                    best_merge_route = i\n            if best_merge_route is not None:\n                new_solution[best_merge_route] = np.concatenate([new_solution[best_merge_route][:-1], part2[1:]])\n            else:\n                new_solution.append(part2.copy())\n\n    # Ensure all customers are served (in case of split/merge failures)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        remaining_customers = list(missing_customers)\n        while remaining_customers:\n            new_route = [0]\n            current_load = 0\n            i = 0\n            while i < len(remaining_customers):\n                customer = remaining_customers[i]\n                if current_load + demand[customer] <= capacity:\n                    new_route.append(customer)\n                    current_load += demand[customer]\n                    remaining_customers.pop(i)\n                else:\n                    i += 1\n            new_route.append(0)\n            new_solution.append(np.array(new_route))\n\n    return new_solution\n\n",
        "score": [
            -0.8145617066457862,
            4.89728307723999
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines multi-objective route merging with spatial clustering and demand-aware node redistribution, while maintaining feasibility through capacity-constrained route balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * 0.3 + x[1][1] * 0.7)  # Weighted combination\n    selected_idx = min(2, len(archive) - 1)  # Select among top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and route merging\n    if len(new_solution) > 2:\n        # Find two closest routes based on spatial proximity\n        min_dist = float('inf')\n        merge_pair = (0, 1)\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Calculate centroids\n                centroid1 = np.mean(coords[route1[1:-1]], axis=0)\n                centroid2 = np.mean(coords[route2[1:-1]], axis=0)\n\n                dist = np.linalg.norm(centroid1 - centroid2)\n                if dist < min_dist:\n                    min_dist = dist\n                    merge_pair = (i, j)\n\n        # Check if merging is feasible\n        i, j = merge_pair\n        if (sum(demand[new_solution[i][1:-1]]) + sum(demand[new_solution[j][1:-1]])) <= capacity:\n            # Merge routes\n            merged_route = np.concatenate((new_solution[i][1:-1], new_solution[j][1:-1], [0]))\n            new_solution[i] = np.concatenate(([0], merged_route))\n            del new_solution[j]\n\n    # Step 2: Demand-aware node redistribution\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Sort nodes by demand (descending)\n        nodes = route[1:-1]\n        sorted_nodes = sorted(nodes, key=lambda x: demand[x], reverse=True)\n\n        # Try to move nodes to other routes if beneficial\n        for node in sorted_nodes:\n            best_route_idx = -1\n            best_improvement = 0\n\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], route):\n                    continue\n\n                # Check capacity constraint\n                if (sum(demand[new_solution[i][1:-1]]) + demand[node]) <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for k in range(1, len(new_solution[i])):\n                        prev_node = new_solution[i][k-1]\n                        next_node = new_solution[i][k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    if best_cost < best_improvement:\n                        best_improvement = best_cost\n                        best_route_idx = i\n\n            if best_route_idx != -1:\n                # Perform the move\n                new_route = new_solution[best_route_idx]\n                new_route = np.concatenate((new_route[:best_pos], [node], new_route[best_pos:]))\n                new_solution[best_route_idx] = new_route\n\n                # Remove from original route\n                route_idx = np.where(route == node)[0][0]\n                route = np.concatenate((route[:route_idx], route[route_idx+1:]))\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.847394180525441,
            9.075175285339355
        ]
    }
]