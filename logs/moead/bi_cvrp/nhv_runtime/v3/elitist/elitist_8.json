[
    {
        "algorithm": "{A hybrid local search operator that combines route splitting with demand-based node relocations and a makespan-aware edge exchange mechanism to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting based on demand patterns\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find split point where demand exceeds capacity\n        cumulative_demand = 0\n        split_point = -1\n        for j in range(1, len(route)-1):\n            cumulative_demand += demand[route[j]]\n            if cumulative_demand > capacity:\n                split_point = j\n                break\n\n        if split_point > 1:\n            # Split the route\n            new_route1 = np.concatenate((route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_point+1:]))\n\n            # Replace old route with new ones\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Step 2: Makespan-aware edge exchange\n    # Find the longest route (highest makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n    if len(new_solution) > 1:\n        # Try to transfer nodes from longest route to others\n        longest_route = new_solution[longest_route_idx].copy()\n        for i in range(len(longest_route)-2, 0, -1):  # Iterate backwards\n            node = longest_route[i]\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Insert node into route j\n                    best_pos = 1  # Default position\n                    best_cost = float('inf')\n\n                    # Find best insertion position in route j\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    # Perform insertion\n                    new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from longest route\n                    new_solution[longest_route_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.7810190492705298,
            0.512780100107193
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines spatial clustering with demand-aware route merging and a bi-objective-aware node reallocation mechanism to simultaneously optimize distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware route merging\n    # Group nodes by spatial proximity and demand similarity\n    from collections import defaultdict\n    clusters = defaultdict(list)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        for node in route[1:-1]:\n            # Assign to cluster based on both coordinates and demand\n            x, y = coords[node]\n            d = demand[node]\n            cluster_key = (int(x/10), int(y/10), int(d/5))  # Coarse clustering\n            clusters[cluster_key].append((i, node))\n\n    # Merge routes that serve nodes from the same cluster\n    for cluster in clusters.values():\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with highest makespan in this cluster\n        route_indices = {i for i, _ in cluster}\n        longest_route = max(route_indices, key=lambda i: len(new_solution[i]))\n\n        # Merge other routes into the longest route\n        for i, node in cluster:\n            if i == longest_route:\n                continue\n\n            # Check if merging is feasible\n            route = new_solution[i]\n            if sum(demand[route[1:-1]]) + sum(demand[new_solution[longest_route][1:-1]]) > capacity:\n                continue\n\n            # Find best insertion position in longest route\n            best_pos = 1\n            best_cost = float('inf')\n            for k in range(1, len(new_solution[longest_route])):\n                prev_node = new_solution[longest_route][k-1]\n                next_node = new_solution[longest_route][k]\n                old_cost = distance_matrix[prev_node, next_node]\n                new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                if new_cost - old_cost < best_cost:\n                    best_cost = new_cost - old_cost\n                    best_pos = k\n\n            # Perform insertion\n            new_solution[longest_route] = np.concatenate((\n                new_solution[longest_route][:best_pos],\n                [node],\n                new_solution[longest_route][best_pos:]\n            ))\n\n            # Remove node from original route\n            new_solution[i] = np.concatenate((\n                new_solution[i][:np.where(new_solution[i] == node)[0][0]],\n                new_solution[i][np.where(new_solution[i] == node)[0][0]+1:]\n            ))\n\n    # Step 2: Bi-objective-aware node reallocation\n    # Calculate route priorities based on both distance and makespan\n    route_priorities = []\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n        route_makespan = route_distance\n        priority = (route_distance / archive[selected_idx][1][0]) + (route_makespan / archive[selected_idx][1][1])\n        route_priorities.append((priority, i))\n\n    # Process routes in priority order\n    route_priorities.sort(reverse=True)\n    for priority, i in route_priorities:\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reallocate nodes to improve both objectives\n        for j in range(len(route)-2, 0, -1):\n            node = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n\n                # Check feasibility\n                if sum(demand[new_solution[k][1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                old_cost = (distance_matrix[route[j-1], node] +\n                           distance_matrix[node, route[j+1]] -\n                           distance_matrix[route[j-1], route[j+1]])\n\n                # Find best insertion in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_solution[k])):\n                    prev_node = new_solution[k][pos-1]\n                    next_node = new_solution[k][pos]\n                    new_cost = (distance_matrix[prev_node, node] +\n                               distance_matrix[node, next_node] -\n                               distance_matrix[prev_node, next_node])\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # If significant improvement, perform the move\n                if best_cost < -old_cost * 0.1:  # Threshold for significant improvement\n                    # Perform insertion\n                    new_solution[k] = np.concatenate((\n                        new_solution[k][:best_pos],\n                        [node],\n                        new_solution[k][best_pos:]\n                    ))\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((\n                        route[:j],\n                        route[j+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.9141913547582446,
            7.675832092761993
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines spatial clustering with demand-aware route merging and a bi-objective-aware node reallocation mechanism to simultaneously optimize distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware route merging\n    # Group nodes by spatial proximity and demand similarity\n    from collections import defaultdict\n    clusters = defaultdict(list)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        for node in route[1:-1]:\n            # Assign to cluster based on both coordinates and demand\n            x, y = coords[node]\n            d = demand[node]\n            cluster_key = (int(x/10), int(y/10), int(d/5))  # Coarse clustering\n            clusters[cluster_key].append((i, node))\n\n    # Merge routes that serve nodes from the same cluster\n    for cluster in clusters.values():\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with highest makespan in this cluster\n        route_indices = {i for i, _ in cluster}\n        longest_route = max(route_indices, key=lambda i: len(new_solution[i]))\n\n        # Merge other routes into the longest route\n        for i, node in cluster:\n            if i == longest_route:\n                continue\n\n            # Check if merging is feasible\n            route = new_solution[i]\n            if sum(demand[route[1:-1]]) + sum(demand[new_solution[longest_route][1:-1]]) > capacity:\n                continue\n\n            # Find best insertion position in longest route\n            best_pos = 1\n            best_cost = float('inf')\n            for k in range(1, len(new_solution[longest_route])):\n                prev_node = new_solution[longest_route][k-1]\n                next_node = new_solution[longest_route][k]\n                old_cost = distance_matrix[prev_node, next_node]\n                new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                if new_cost - old_cost < best_cost:\n                    best_cost = new_cost - old_cost\n                    best_pos = k\n\n            # Perform insertion\n            new_solution[longest_route] = np.concatenate((\n                new_solution[longest_route][:best_pos],\n                [node],\n                new_solution[longest_route][best_pos:]\n            ))\n\n            # Remove node from original route\n            new_solution[i] = np.concatenate((\n                new_solution[i][:np.where(new_solution[i] == node)[0][0]],\n                new_solution[i][np.where(new_solution[i] == node)[0][0]+1:]\n            ))\n\n    # Step 2: Bi-objective-aware node reallocation\n    # Calculate route priorities based on both distance and makespan\n    route_priorities = []\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n        route_makespan = route_distance\n        priority = (route_distance / archive[selected_idx][1][0]) + (route_makespan / archive[selected_idx][1][1])\n        route_priorities.append((priority, i))\n\n    # Process routes in priority order\n    route_priorities.sort(reverse=True)\n    for priority, i in route_priorities:\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reallocate nodes to improve both objectives\n        for j in range(len(route)-2, 0, -1):\n            node = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n\n                # Check feasibility\n                if sum(demand[new_solution[k][1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                old_cost = (distance_matrix[route[j-1], node] +\n                           distance_matrix[node, route[j+1]] -\n                           distance_matrix[route[j-1], route[j+1]])\n\n                # Find best insertion in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_solution[k])):\n                    prev_node = new_solution[k][pos-1]\n                    next_node = new_solution[k][pos]\n                    new_cost = (distance_matrix[prev_node, node] +\n                               distance_matrix[node, next_node] -\n                               distance_matrix[prev_node, next_node])\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # If significant improvement, perform the move\n                if best_cost < -old_cost * 0.1:  # Threshold for significant improvement\n                    # Perform insertion\n                    new_solution[k] = np.concatenate((\n                        new_solution[k][:best_pos],\n                        [node],\n                        new_solution[k][best_pos:]\n                    ))\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((\n                        route[:j],\n                        route[j+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.9141913547582446,
            7.675832092761993
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines adaptive route merging with between-route demand redistribution and a multi-objective edge swapping mechanism to balance distance and makespan objectives while ensuring feasibility through capacity-aware demand reallocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average objective\n    selected_idx = min(2, len(archive) - 1)  # Select among top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route merging\n    if len(new_solution) > 2:\n        # Find two routes to merge\n        route_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_pairs.append((i, j))\n\n        if route_pairs:\n            i, j = random.choice(route_pairs)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n                new_solution[i] = merged_route\n                new_solution.pop(j)\n\n    # Demand redistribution\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Calculate current demand\n        current_demand = sum(demand[route[1:-1]])\n        if current_demand > capacity:\n            # Remove nodes until feasible\n            while current_demand > capacity:\n                # Find node to remove (excluding depot)\n                nodes = route[1:-1]\n                node_to_remove = nodes[np.argmax(demand[nodes])]  # Remove highest demand node\n                idx = np.where(route == node_to_remove)[0][0]\n                route = np.concatenate((route[:idx], route[idx+1:]))\n                current_demand -= demand[node_to_remove]\n\n    # Multi-objective edge swapping\n    for _ in range(2):  # Perform 2 swaps\n        # Select two random routes\n        if len(new_solution) < 2:\n            break\n\n        i, j = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[i]\n        route2 = new_solution[j]\n\n        if len(route1) <= 3 or len(route2) <= 3:\n            continue\n\n        # Select random nodes from each route (excluding depots)\n        node1 = random.choice(route1[1:-1])\n        node2 = random.choice(route2[1:-1])\n\n        # Check if swap is feasible\n        demand1 = sum(demand[route1[1:-1]]) - demand[node1] + demand[node2]\n        demand2 = sum(demand[route2[1:-1]]) - demand[node2] + demand[node1]\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Perform swap\n            idx1 = np.where(route1 == node1)[0][0]\n            idx2 = np.where(route2 == node2)[0][0]\n\n            route1[idx1] = node2\n            route2[idx2] = node1\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.8418895498990154,
            0.1776145100593567
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines spatial clustering with demand-aware route merging and a bi-objective-aware node reallocation mechanism to simultaneously optimize distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware route merging\n    # Group nodes by spatial proximity and demand similarity\n    from collections import defaultdict\n    clusters = defaultdict(list)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        for node in route[1:-1]:\n            # Assign to cluster based on both coordinates and demand\n            x, y = coords[node]\n            d = demand[node]\n            cluster_key = (int(x/10), int(y/10), int(d/5))  # Coarse clustering\n            clusters[cluster_key].append((i, node))\n\n    # Merge routes that serve nodes from the same cluster\n    for cluster in clusters.values():\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with highest makespan in this cluster\n        route_indices = {i for i, _ in cluster}\n        longest_route = max(route_indices, key=lambda i: len(new_solution[i]))\n\n        # Merge other routes into the longest route\n        for i, node in cluster:\n            if i == longest_route:\n                continue\n\n            # Check if merging is feasible\n            route = new_solution[i]\n            if sum(demand[route[1:-1]]) + sum(demand[new_solution[longest_route][1:-1]]) > capacity:\n                continue\n\n            # Find best insertion position in longest route\n            best_pos = 1\n            best_cost = float('inf')\n            for k in range(1, len(new_solution[longest_route])):\n                prev_node = new_solution[longest_route][k-1]\n                next_node = new_solution[longest_route][k]\n                old_cost = distance_matrix[prev_node, next_node]\n                new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                if new_cost - old_cost < best_cost:\n                    best_cost = new_cost - old_cost\n                    best_pos = k\n\n            # Perform insertion\n            new_solution[longest_route] = np.concatenate((\n                new_solution[longest_route][:best_pos],\n                [node],\n                new_solution[longest_route][best_pos:]\n            ))\n\n            # Remove node from original route\n            new_solution[i] = np.concatenate((\n                new_solution[i][:np.where(new_solution[i] == node)[0][0]],\n                new_solution[i][np.where(new_solution[i] == node)[0][0]+1:]\n            ))\n\n    # Step 2: Bi-objective-aware node reallocation\n    # Calculate route priorities based on both distance and makespan\n    route_priorities = []\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n        route_makespan = route_distance\n        priority = (route_distance / archive[selected_idx][1][0]) + (route_makespan / archive[selected_idx][1][1])\n        route_priorities.append((priority, i))\n\n    # Process routes in priority order\n    route_priorities.sort(reverse=True)\n    for priority, i in route_priorities:\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reallocate nodes to improve both objectives\n        for j in range(len(route)-2, 0, -1):\n            node = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n\n                # Check feasibility\n                if sum(demand[new_solution[k][1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                old_cost = (distance_matrix[route[j-1], node] +\n                           distance_matrix[node, route[j+1]] -\n                           distance_matrix[route[j-1], route[j+1]])\n\n                # Find best insertion in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_solution[k])):\n                    prev_node = new_solution[k][pos-1]\n                    next_node = new_solution[k][pos]\n                    new_cost = (distance_matrix[prev_node, node] +\n                               distance_matrix[node, next_node] -\n                               distance_matrix[prev_node, next_node])\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # If significant improvement, perform the move\n                if best_cost < -old_cost * 0.1:  # Threshold for significant improvement\n                    # Perform insertion\n                    new_solution[k] = np.concatenate((\n                        new_solution[k][:best_pos],\n                        [node],\n                        new_solution[k][best_pos:]\n                    ))\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((\n                        route[:j],\n                        route[j+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.9141913547582446,
            7.675832092761993
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines spatial clustering with demand-aware route merging and a bi-objective-aware node reallocation mechanism to simultaneously optimize distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware route merging\n    # Group nodes by spatial proximity and demand similarity\n    from collections import defaultdict\n    clusters = defaultdict(list)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        for node in route[1:-1]:\n            # Assign to cluster based on both coordinates and demand\n            x, y = coords[node]\n            d = demand[node]\n            cluster_key = (int(x/10), int(y/10), int(d/5))  # Coarse clustering\n            clusters[cluster_key].append((i, node))\n\n    # Merge routes that serve nodes from the same cluster\n    for cluster in clusters.values():\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with highest makespan in this cluster\n        route_indices = {i for i, _ in cluster}\n        longest_route = max(route_indices, key=lambda i: len(new_solution[i]))\n\n        # Merge other routes into the longest route\n        for i, node in cluster:\n            if i == longest_route:\n                continue\n\n            # Check if merging is feasible\n            route = new_solution[i]\n            if sum(demand[route[1:-1]]) + sum(demand[new_solution[longest_route][1:-1]]) > capacity:\n                continue\n\n            # Find best insertion position in longest route\n            best_pos = 1\n            best_cost = float('inf')\n            for k in range(1, len(new_solution[longest_route])):\n                prev_node = new_solution[longest_route][k-1]\n                next_node = new_solution[longest_route][k]\n                old_cost = distance_matrix[prev_node, next_node]\n                new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                if new_cost - old_cost < best_cost:\n                    best_cost = new_cost - old_cost\n                    best_pos = k\n\n            # Perform insertion\n            new_solution[longest_route] = np.concatenate((\n                new_solution[longest_route][:best_pos],\n                [node],\n                new_solution[longest_route][best_pos:]\n            ))\n\n            # Remove node from original route\n            new_solution[i] = np.concatenate((\n                new_solution[i][:np.where(new_solution[i] == node)[0][0]],\n                new_solution[i][np.where(new_solution[i] == node)[0][0]+1:]\n            ))\n\n    # Step 2: Bi-objective-aware node reallocation\n    # Calculate route priorities based on both distance and makespan\n    route_priorities = []\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n        route_makespan = route_distance\n        priority = (route_distance / archive[selected_idx][1][0]) + (route_makespan / archive[selected_idx][1][1])\n        route_priorities.append((priority, i))\n\n    # Process routes in priority order\n    route_priorities.sort(reverse=True)\n    for priority, i in route_priorities:\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reallocate nodes to improve both objectives\n        for j in range(len(route)-2, 0, -1):\n            node = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n\n                # Check feasibility\n                if sum(demand[new_solution[k][1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                old_cost = (distance_matrix[route[j-1], node] +\n                           distance_matrix[node, route[j+1]] -\n                           distance_matrix[route[j-1], route[j+1]])\n\n                # Find best insertion in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_solution[k])):\n                    prev_node = new_solution[k][pos-1]\n                    next_node = new_solution[k][pos]\n                    new_cost = (distance_matrix[prev_node, node] +\n                               distance_matrix[node, next_node] -\n                               distance_matrix[prev_node, next_node])\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # If significant improvement, perform the move\n                if best_cost < -old_cost * 0.1:  # Threshold for significant improvement\n                    # Perform insertion\n                    new_solution[k] = np.concatenate((\n                        new_solution[k][:best_pos],\n                        [node],\n                        new_solution[k][best_pos:]\n                    ))\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((\n                        route[:j],\n                        route[j+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.9141913547582446,
            7.675832092761993
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines spatial clustering with demand-aware route merging and a bi-objective-aware node reallocation mechanism to simultaneously optimize distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware route merging\n    # Group nodes by spatial proximity and demand similarity\n    from collections import defaultdict\n    clusters = defaultdict(list)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        for node in route[1:-1]:\n            # Assign to cluster based on both coordinates and demand\n            x, y = coords[node]\n            d = demand[node]\n            cluster_key = (int(x/10), int(y/10), int(d/5))  # Coarse clustering\n            clusters[cluster_key].append((i, node))\n\n    # Merge routes that serve nodes from the same cluster\n    for cluster in clusters.values():\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with highest makespan in this cluster\n        route_indices = {i for i, _ in cluster}\n        longest_route = max(route_indices, key=lambda i: len(new_solution[i]))\n\n        # Merge other routes into the longest route\n        for i, node in cluster:\n            if i == longest_route:\n                continue\n\n            # Check if merging is feasible\n            route = new_solution[i]\n            if sum(demand[route[1:-1]]) + sum(demand[new_solution[longest_route][1:-1]]) > capacity:\n                continue\n\n            # Find best insertion position in longest route\n            best_pos = 1\n            best_cost = float('inf')\n            for k in range(1, len(new_solution[longest_route])):\n                prev_node = new_solution[longest_route][k-1]\n                next_node = new_solution[longest_route][k]\n                old_cost = distance_matrix[prev_node, next_node]\n                new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                if new_cost - old_cost < best_cost:\n                    best_cost = new_cost - old_cost\n                    best_pos = k\n\n            # Perform insertion\n            new_solution[longest_route] = np.concatenate((\n                new_solution[longest_route][:best_pos],\n                [node],\n                new_solution[longest_route][best_pos:]\n            ))\n\n            # Remove node from original route\n            new_solution[i] = np.concatenate((\n                new_solution[i][:np.where(new_solution[i] == node)[0][0]],\n                new_solution[i][np.where(new_solution[i] == node)[0][0]+1:]\n            ))\n\n    # Step 2: Bi-objective-aware node reallocation\n    # Calculate route priorities based on both distance and makespan\n    route_priorities = []\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n        route_makespan = route_distance\n        priority = (route_distance / archive[selected_idx][1][0]) + (route_makespan / archive[selected_idx][1][1])\n        route_priorities.append((priority, i))\n\n    # Process routes in priority order\n    route_priorities.sort(reverse=True)\n    for priority, i in route_priorities:\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reallocate nodes to improve both objectives\n        for j in range(len(route)-2, 0, -1):\n            node = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n\n                # Check feasibility\n                if sum(demand[new_solution[k][1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                old_cost = (distance_matrix[route[j-1], node] +\n                           distance_matrix[node, route[j+1]] -\n                           distance_matrix[route[j-1], route[j+1]])\n\n                # Find best insertion in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_solution[k])):\n                    prev_node = new_solution[k][pos-1]\n                    next_node = new_solution[k][pos]\n                    new_cost = (distance_matrix[prev_node, node] +\n                               distance_matrix[node, next_node] -\n                               distance_matrix[prev_node, next_node])\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # If significant improvement, perform the move\n                if best_cost < -old_cost * 0.1:  # Threshold for significant improvement\n                    # Perform insertion\n                    new_solution[k] = np.concatenate((\n                        new_solution[k][:best_pos],\n                        [node],\n                        new_solution[k][best_pos:]\n                    ))\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((\n                        route[:j],\n                        route[j+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.9141913547582446,
            7.675832092761993
        ]
    },
    {
        "algorithm": "{A hybrid local search operator that combines demand-based route merging with distance-aware node transfers and a balanced makespan-distance optimization to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + 0.3 * x[1][1])  # Weighted score\n    selected_idx = min(2, len(archive) - 1)  # Select among top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Demand-based route merging\n    for i in range(len(new_solution)-1, 0, -1):\n        route1 = new_solution[i]\n        if len(route1) <= 3:  # Skip trivial routes\n            continue\n\n        # Find compatible route to merge with\n        for j in range(i):\n            route2 = new_solution[j]\n            if len(route2) <= 3:\n                continue\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Calculate merging cost\n                old_cost = distance_matrix[route1[-2], 0] + distance_matrix[route2[-2], 0]\n                new_cost = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n\n                if new_cost < old_cost:\n                    # Merge routes\n                    merged_route = np.concatenate((route1[:-1], route2[1:]))\n                    new_solution[j] = merged_route\n                    new_solution.pop(i)\n                    break\n\n    # Step 2: Distance-aware node transfers\n    if len(new_solution) > 1:\n        # Find route with most distance savings potential\n        route_scores = []\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            total_distance = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n            route_scores.append((i, total_distance))\n\n        route_scores.sort(key=lambda x: x[1], reverse=True)\n        target_route_idx = route_scores[0][0]\n        target_route = new_solution[target_route_idx]\n\n        for i in range(len(target_route)-2, 0, -1):\n            node = target_route[i]\n            for j in range(len(new_solution)):\n                if j == target_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_improvement = 0\n\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        old_distance = distance_matrix[prev_node, next_node] + distance_matrix[target_route[i-1], node] + distance_matrix[node, target_route[i+1]]\n                        new_distance = distance_matrix[prev_node, node] + distance_matrix[node, next_node] + distance_matrix[target_route[i-1], target_route[i+1]]\n\n                        improvement = old_distance - new_distance\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_pos = k\n\n                    if best_improvement > 0:\n                        # Perform transfer\n                        new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                        new_solution[j] = new_route\n                        new_solution[target_route_idx] = np.concatenate((target_route[:i], target_route[i+1:]))\n                        break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.901196763963344,
            0.761800080537796
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines spatial clustering with demand-aware route merging and a bi-objective-aware node reallocation mechanism to simultaneously optimize distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware route merging\n    # Group nodes by spatial proximity and demand similarity\n    from collections import defaultdict\n    clusters = defaultdict(list)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        for node in route[1:-1]:\n            # Assign to cluster based on both coordinates and demand\n            x, y = coords[node]\n            d = demand[node]\n            cluster_key = (int(x/10), int(y/10), int(d/5))  # Coarse clustering\n            clusters[cluster_key].append((i, node))\n\n    # Merge routes that serve nodes from the same cluster\n    for cluster in clusters.values():\n        if len(cluster) < 2:\n            continue\n\n        # Find the route with highest makespan in this cluster\n        route_indices = {i for i, _ in cluster}\n        longest_route = max(route_indices, key=lambda i: len(new_solution[i]))\n\n        # Merge other routes into the longest route\n        for i, node in cluster:\n            if i == longest_route:\n                continue\n\n            # Check if merging is feasible\n            route = new_solution[i]\n            if sum(demand[route[1:-1]]) + sum(demand[new_solution[longest_route][1:-1]]) > capacity:\n                continue\n\n            # Find best insertion position in longest route\n            best_pos = 1\n            best_cost = float('inf')\n            for k in range(1, len(new_solution[longest_route])):\n                prev_node = new_solution[longest_route][k-1]\n                next_node = new_solution[longest_route][k]\n                old_cost = distance_matrix[prev_node, next_node]\n                new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n                if new_cost - old_cost < best_cost:\n                    best_cost = new_cost - old_cost\n                    best_pos = k\n\n            # Perform insertion\n            new_solution[longest_route] = np.concatenate((\n                new_solution[longest_route][:best_pos],\n                [node],\n                new_solution[longest_route][best_pos:]\n            ))\n\n            # Remove node from original route\n            new_solution[i] = np.concatenate((\n                new_solution[i][:np.where(new_solution[i] == node)[0][0]],\n                new_solution[i][np.where(new_solution[i] == node)[0][0]+1:]\n            ))\n\n    # Step 2: Bi-objective-aware node reallocation\n    # Calculate route priorities based on both distance and makespan\n    route_priorities = []\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n        route_makespan = route_distance\n        priority = (route_distance / archive[selected_idx][1][0]) + (route_makespan / archive[selected_idx][1][1])\n        route_priorities.append((priority, i))\n\n    # Process routes in priority order\n    route_priorities.sort(reverse=True)\n    for priority, i in route_priorities:\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Try to reallocate nodes to improve both objectives\n        for j in range(len(route)-2, 0, -1):\n            node = route[j]\n            for k in range(len(new_solution)):\n                if k == i:\n                    continue\n\n                # Check feasibility\n                if sum(demand[new_solution[k][1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Calculate potential improvement\n                old_cost = (distance_matrix[route[j-1], node] +\n                           distance_matrix[node, route[j+1]] -\n                           distance_matrix[route[j-1], route[j+1]])\n\n                # Find best insertion in target route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(new_solution[k])):\n                    prev_node = new_solution[k][pos-1]\n                    next_node = new_solution[k][pos]\n                    new_cost = (distance_matrix[prev_node, node] +\n                               distance_matrix[node, next_node] -\n                               distance_matrix[prev_node, next_node])\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # If significant improvement, perform the move\n                if best_cost < -old_cost * 0.1:  # Threshold for significant improvement\n                    # Perform insertion\n                    new_solution[k] = np.concatenate((\n                        new_solution[k][:best_pos],\n                        [node],\n                        new_solution[k][best_pos:]\n                    ))\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((\n                        route[:j],\n                        route[j+1:]\n                    ))\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.9141913547582446,
            7.675832092761993
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n\n    # Apply a hybrid local search combining route splitting and inter-route insertion\n    new_solution = []\n    for route in selected_solution:\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.extend([part1, part2])\n        else:\n            new_solution.append(route)\n\n    # Apply inter-route insertion to reduce makespan\n    if len(new_solution) > 1:\n        # Select two random routes\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n\n        # Try moving a random customer from route_i to route_j\n        if len(route_i) > 2:\n            customer_idx = np.random.randint(1, len(route_i) - 1)\n            customer = route_i[customer_idx]\n\n            # Check if insertion is feasible\n            if np.sum(demand[route_j[1:-1]]) + demand[customer] <= capacity:\n                # Insert customer into route_j\n                insert_pos = np.random.randint(1, len(route_j))\n                new_route_j = np.insert(route_j, insert_pos, customer)\n                new_route_i = np.delete(route_i, customer_idx)\n\n                # Update solution\n                new_solution[i] = new_route_i if len(new_route_i) > 2 else []\n                new_solution[j] = new_route_j\n\n                # Remove empty routes\n                new_solution = [r for r in new_solution if len(r) > 0]\n\n    # If no improvement, return the original solution\n    if not new_solution:\n        return selected_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7916364238107323,
            0.16387081146240234
        ]
    }
]