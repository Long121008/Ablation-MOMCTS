[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A hybrid local search operator that combines route splitting with demand-based node relocations and a makespan-aware edge exchange mechanism to balance distance and makespan objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting based on demand patterns\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find split point where demand exceeds capacity\n        cumulative_demand = 0\n        split_point = -1\n        for j in range(1, len(route)-1):\n            cumulative_demand += demand[route[j]]\n            if cumulative_demand > capacity:\n                split_point = j\n                break\n\n        if split_point > 1:\n            # Split the route\n            new_route1 = np.concatenate((route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_point+1:]))\n\n            # Replace old route with new ones\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Step 2: Makespan-aware edge exchange\n    # Find the longest route (highest makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n    if len(new_solution) > 1:\n        # Try to transfer nodes from longest route to others\n        longest_route = new_solution[longest_route_idx].copy()\n        for i in range(len(longest_route)-2, 0, -1):  # Iterate backwards\n            node = longest_route[i]\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Insert node into route j\n                    best_pos = 1  # Default position\n                    best_cost = float('inf')\n\n                    # Find best insertion position in route j\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    # Perform insertion\n                    new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from longest route\n                    new_solution[longest_route_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A hybrid local search operator that combines route splitting with demand-based node relocations and a makespan-aware edge exchange mechanism to balance distance and makespan objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting based on demand patterns\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find split point where demand exceeds capacity\n        cumulative_demand = 0\n        split_point = -1\n        for j in range(1, len(route)-1):\n            cumulative_demand += demand[route[j]]\n            if cumulative_demand > capacity:\n                split_point = j\n                break\n\n        if split_point > 1:\n            # Split the route\n            new_route1 = np.concatenate((route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_point+1:]))\n\n            # Replace old route with new ones\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Step 2: Makespan-aware edge exchange\n    # Find the longest route (highest makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n    if len(new_solution) > 1:\n        # Try to transfer nodes from longest route to others\n        longest_route = new_solution[longest_route_idx].copy()\n        for i in range(len(longest_route)-2, 0, -1):  # Iterate backwards\n            node = longest_route[i]\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Insert node into route j\n                    best_pos = 1  # Default position\n                    best_cost = float('inf')\n\n                    # Find best insertion position in route j\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    # Perform insertion\n                    new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from longest route\n                    new_solution[longest_route_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{A novel multi-objective local search operator that combines demand-aware route merging with spatial clustering and a balanced distance-makespan optimization using a hybrid of route reshaping and node reallocation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # More weight on distance to encourage diversity\n    archive.sort(key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware merging\n    if len(new_solution) > 1:\n        # Calculate centroids of routes\n        centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                centroids.append(centroid)\n            else:\n                centroids.append(np.zeros(2))\n\n        # Find closest route pairs\n        merge_pairs = []\n        for i in range(len(centroids)):\n            for j in range(i+1, len(centroids)):\n                dist = np.linalg.norm(centroids[i] - centroids[j])\n                merge_pairs.append((dist, i, j))\n\n        merge_pairs.sort()\n        for _, i, j in merge_pairs[:2]:  # Try merging 2 closest pairs\n            if i >= len(new_solution) or j >= len(new_solution):\n                continue\n\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Find best merge point (minimize added distance)\n                best_cost = float('inf')\n                best_merge = None\n\n                for k in range(1, len(route1)):\n                    for l in range(1, len(route2)):\n                        # Try merging route2 into route1 at position k\n                        new_route = np.concatenate((\n                            route1[:k],\n                            route2[1:-1],\n                            route1[k:]\n                        ))\n                        cost = (distance_matrix[route1[k-1], route2[1]] +\n                                distance_matrix[route2[-2], route1[k]] -\n                                distance_matrix[route1[k-1], route1[k]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_merge = new_route\n\n                if best_merge is not None:\n                    new_solution[i] = best_merge\n                    del new_solution[j]\n\n    # Step 2: Balanced distance-makespan optimization\n    if len(new_solution) > 1:\n        # Find routes with highest and lowest makespan\n        route_makespans = []\n        for route in new_solution:\n            route_dist = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n            route_makespans.append(route_dist)\n\n        max_idx = np.argmax(route_makespans)\n        min_idx = np.argmin(route_makespans)\n\n        # Try to transfer nodes from longest to shortest route\n        longest_route = new_solution[max_idx].copy()\n        shortest_route = new_solution[min_idx].copy()\n\n        for i in range(len(longest_route)-2, 0, -1):\n            node = longest_route[i]\n            # Check if adding to shortest route is feasible\n            if sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n\n                for k in range(1, len(shortest_route)):\n                    prev_node = shortest_route[k-1]\n                    next_node = shortest_route[k]\n\n                    old_cost = distance_matrix[prev_node, next_node]\n                    new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                    if new_cost - old_cost < best_cost:\n                        best_cost = new_cost - old_cost\n                        best_pos = k\n\n                # Perform insertion\n                new_shortest = np.concatenate((shortest_route[:best_pos], [node], shortest_route[best_pos:]))\n                new_solution[min_idx] = new_shortest\n\n                # Remove from longest route\n                new_solution[max_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.7445835249838046,
            1.3582822382450104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = [0.6, 0.4]  # More weight on distance to encourage diversity\n    archive.sort(key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Spatial clustering and demand-aware merging\n    if len(new_solution) > 1:\n        # Calculate centroids of routes\n        centroids = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                centroid = np.mean(route_coords, axis=0)\n                centroids.append(centroid)\n            else:\n                centroids.append(np.zeros(2))\n\n        # Find closest route pairs\n        merge_pairs = []\n        for i in range(len(centroids)):\n            for j in range(i+1, len(centroids)):\n                dist = np.linalg.norm(centroids[i] - centroids[j])\n                merge_pairs.append((dist, i, j))\n\n        merge_pairs.sort()\n        for _, i, j in merge_pairs[:2]:  # Try merging 2 closest pairs\n            if i >= len(new_solution) or j >= len(new_solution):\n                continue\n\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Find best merge point (minimize added distance)\n                best_cost = float('inf')\n                best_merge = None\n\n                for k in range(1, len(route1)):\n                    for l in range(1, len(route2)):\n                        # Try merging route2 into route1 at position k\n                        new_route = np.concatenate((\n                            route1[:k],\n                            route2[1:-1],\n                            route1[k:]\n                        ))\n                        cost = (distance_matrix[route1[k-1], route2[1]] +\n                                distance_matrix[route2[-2], route1[k]] -\n                                distance_matrix[route1[k-1], route1[k]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_merge = new_route\n\n                if best_merge is not None:\n                    new_solution[i] = best_merge\n                    del new_solution[j]\n\n    # Step 2: Balanced distance-makespan optimization\n    if len(new_solution) > 1:\n        # Find routes with highest and lowest makespan\n        route_makespans = []\n        for route in new_solution:\n            route_dist = distance_matrix[route[-2], 0] + sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1))\n            route_makespans.append(route_dist)\n\n        max_idx = np.argmax(route_makespans)\n        min_idx = np.argmin(route_makespans)\n\n        # Try to transfer nodes from longest to shortest route\n        longest_route = new_solution[max_idx].copy()\n        shortest_route = new_solution[min_idx].copy()\n\n        for i in range(len(longest_route)-2, 0, -1):\n            node = longest_route[i]\n            # Check if adding to shortest route is feasible\n            if sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n\n                for k in range(1, len(shortest_route)):\n                    prev_node = shortest_route[k-1]\n                    next_node = shortest_route[k]\n\n                    old_cost = distance_matrix[prev_node, next_node]\n                    new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                    if new_cost - old_cost < best_cost:\n                        best_cost = new_cost - old_cost\n                        best_pos = k\n\n                # Perform insertion\n                new_shortest = np.concatenate((shortest_route[:best_pos], [node], shortest_route[best_pos:]))\n                new_solution[min_idx] = new_shortest\n\n                # Remove from longest route\n                new_solution[max_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A hybrid local search operator that combines route splitting with demand-based node relocations and a makespan-aware edge exchange mechanism to balance distance and makespan objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting based on demand patterns\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find split point where demand exceeds capacity\n        cumulative_demand = 0\n        split_point = -1\n        for j in range(1, len(route)-1):\n            cumulative_demand += demand[route[j]]\n            if cumulative_demand > capacity:\n                split_point = j\n                break\n\n        if split_point > 1:\n            # Split the route\n            new_route1 = np.concatenate((route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_point+1:]))\n\n            # Replace old route with new ones\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Step 2: Makespan-aware edge exchange\n    # Find the longest route (highest makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n    if len(new_solution) > 1:\n        # Try to transfer nodes from longest route to others\n        longest_route = new_solution[longest_route_idx].copy()\n        for i in range(len(longest_route)-2, 0, -1):  # Iterate backwards\n            node = longest_route[i]\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Insert node into route j\n                    best_pos = 1  # Default position\n                    best_cost = float('inf')\n\n                    # Find best insertion position in route j\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    # Perform insertion\n                    new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from longest route\n                    new_solution[longest_route_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{A novel hybrid local search that combines demand-aware route merging with adaptive node swapping and a distance-balancing route reshaping mechanism to simultaneously optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])  # Sort by total distance\n    selected_idx = min(2, len(archive) - 1)  # Select among top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)-1, 0, -1):\n            route1 = new_solution[i]\n            for j in range(i):\n                route2 = new_solution[j]\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate((route1[1:-1], route2[1:-1], [0]))\n                    new_solution[j] = np.concatenate(([0], merged_route))\n                    del new_solution[i]\n                    break\n\n    # Step 2: Adaptive node swapping\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find node with highest potential for improvement\n        best_node = -1\n        best_gain = 0\n        for k in range(1, len(route)-1):\n            node = route[k]\n            # Calculate potential gain from removing node\n            gain = distance_matrix[route[k-1], route[k+1]] - distance_matrix[route[k-1], node] - distance_matrix[node, route[k+1]]\n\n            if gain > best_gain:\n                best_gain = gain\n                best_node = k\n\n        if best_node > 0:\n            node = route[best_node]\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if j == i:\n                    continue\n\n                target_route = new_solution[j]\n                if sum(demand[target_route[1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for l in range(1, len(target_route)):\n                    cost = distance_matrix[target_route[l-1], node] + distance_matrix[node, target_route[l]] - distance_matrix[target_route[l-1], target_route[l]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = l\n\n                if best_cost < 0:  # Only insert if improves\n                    # Perform insertion\n                    new_route = np.concatenate((target_route[:best_pos], [node], target_route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((route[:best_node], route[best_node+1:]))\n                    break\n\n    # Step 3: Distance-balancing route reshaping\n    avg_distance = sum(len(route)-1 for route in new_solution) / len(new_solution)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = len(route) - 1\n        if route_distance > avg_distance * 1.2:  # If route is significantly longer than average\n            # Try to split the route\n            split_pos = len(route) // 2\n            if split_pos > 1 and split_pos < len(route)-1:\n                new_route1 = np.concatenate((route[:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:]))\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.6192122320400274,
            1.5533189475536346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0])  # Sort by total distance\n    selected_idx = min(2, len(archive) - 1)  # Select among top 2 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)-1, 0, -1):\n            route1 = new_solution[i]\n            for j in range(i):\n                route2 = new_solution[j]\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Merge routes\n                    merged_route = np.concatenate((route1[1:-1], route2[1:-1], [0]))\n                    new_solution[j] = np.concatenate(([0], merged_route))\n                    del new_solution[i]\n                    break\n\n    # Step 2: Adaptive node swapping\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find node with highest potential for improvement\n        best_node = -1\n        best_gain = 0\n        for k in range(1, len(route)-1):\n            node = route[k]\n            # Calculate potential gain from removing node\n            gain = distance_matrix[route[k-1], route[k+1]] - distance_matrix[route[k-1], node] - distance_matrix[node, route[k+1]]\n\n            if gain > best_gain:\n                best_gain = gain\n                best_node = k\n\n        if best_node > 0:\n            node = route[best_node]\n            # Try to insert into another route\n            for j in range(len(new_solution)):\n                if j == i:\n                    continue\n\n                target_route = new_solution[j]\n                if sum(demand[target_route[1:-1]]) + demand[node] > capacity:\n                    continue\n\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for l in range(1, len(target_route)):\n                    cost = distance_matrix[target_route[l-1], node] + distance_matrix[node, target_route[l]] - distance_matrix[target_route[l-1], target_route[l]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = l\n\n                if best_cost < 0:  # Only insert if improves\n                    # Perform insertion\n                    new_route = np.concatenate((target_route[:best_pos], [node], target_route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from original route\n                    new_solution[i] = np.concatenate((route[:best_node], route[best_node+1:]))\n                    break\n\n    # Step 3: Distance-balancing route reshaping\n    avg_distance = sum(len(route)-1 for route in new_solution) / len(new_solution)\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        route_distance = len(route) - 1\n        if route_distance > avg_distance * 1.2:  # If route is significantly longer than average\n            # Try to split the route\n            split_pos = len(route) // 2\n            if split_pos > 1 and split_pos < len(route)-1:\n                new_route1 = np.concatenate((route[:split_pos+1], [0]))\n                new_route2 = np.concatenate(([0], route[split_pos+1:]))\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A hybrid local search operator that combines route splitting with demand-based node relocations and a makespan-aware edge exchange mechanism to balance distance and makespan objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])  # Sort by makespan\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy for modification\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Step 1: Route splitting based on demand patterns\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find split point where demand exceeds capacity\n        cumulative_demand = 0\n        split_point = -1\n        for j in range(1, len(route)-1):\n            cumulative_demand += demand[route[j]]\n            if cumulative_demand > capacity:\n                split_point = j\n                break\n\n        if split_point > 1:\n            # Split the route\n            new_route1 = np.concatenate((route[:split_point+1], [0]))\n            new_route2 = np.concatenate(([0], route[split_point+1:]))\n\n            # Replace old route with new ones\n            new_solution[i] = new_route1\n            new_solution.insert(i+1, new_route2)\n\n    # Step 2: Makespan-aware edge exchange\n    # Find the longest route (highest makespan)\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n    if len(new_solution) > 1:\n        # Try to transfer nodes from longest route to others\n        longest_route = new_solution[longest_route_idx].copy()\n        for i in range(len(longest_route)-2, 0, -1):  # Iterate backwards\n            node = longest_route[i]\n            for j in range(len(new_solution)):\n                if j == longest_route_idx:\n                    continue\n\n                # Check if adding node to route j is feasible\n                route = new_solution[j]\n                total_demand = sum(demand[route[1:-1]]) + demand[node]\n                if total_demand <= capacity:\n                    # Insert node into route j\n                    best_pos = 1  # Default position\n                    best_cost = float('inf')\n\n                    # Find best insertion position in route j\n                    for k in range(1, len(route)):\n                        prev_node = route[k-1]\n                        next_node = route[k]\n\n                        # Calculate cost difference\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = k\n\n                    # Perform insertion\n                    new_route = np.concatenate((route[:best_pos], [node], route[best_pos:]))\n                    new_solution[j] = new_route\n\n                    # Remove from longest route\n                    new_solution[longest_route_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A hybrid local search operator that combines demand-aware route merging with distance-balancing edge swaps and a makespan-sensitive route rebalancing mechanism to optimize both total distance and makespan while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by combined objective score\n    selected_idx = min(2, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Demand-aware route merging\n    if len(new_solution) > 1:\n        for i in range(len(new_solution)-1):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Check if merging is feasible\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Calculate merging cost\n                    cost1 = distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]]\n                    cost2 = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n                    cost_diff = cost2 - cost1\n\n                    # Calculate makespan impact\n                    makespan1 = distance_matrix[route1[-2], 0] + sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1))\n                    makespan2 = distance_matrix[route2[-2], 0] + sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1))\n                    max_makespan = max(makespan1, makespan2)\n\n                    new_makespan = distance_matrix[route1[-2], route2[1]] + sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) + \\\n                                  distance_matrix[route2[-2], 0] + sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1))\n                    new_max_makespan = max(new_makespan, max_makespan)\n\n                    # Accept merge if it improves both objectives\n                    if cost_diff < 0 and new_max_makespan <= max_makespan:\n                        merged_route = np.concatenate((route1[:-1], route2[1:]))\n                        new_solution[i] = merged_route\n                        new_solution.pop(j)\n                        break\n\n    # Step 2: Distance-balancing edge swaps\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find edges that can be swapped to balance distances\n        for j in range(1, len(route)-2):\n            for k in range(j+2, len(route)-1):\n                # Calculate current and potential new distances\n                current_dist = distance_matrix[route[j], route[j+1]] + distance_matrix[route[k], route[k+1]]\n                new_dist = distance_matrix[route[j], route[k]] + distance_matrix[route[j+1], route[k+1]]\n\n                # Check capacity constraints\n                if (sum(demand[route[j+1:k+1]]) + sum(demand[route[1:j+1]]) <= capacity and\n                    sum(demand[route[k+1:]]) + sum(demand[route[1:j+1]]) <= capacity):\n\n                    # Accept swap if it improves distance\n                    if new_dist < current_dist:\n                        # Perform the swap\n                        new_route = np.concatenate((route[:j+1], route[k:j:-1], route[k+1:]))\n                        new_solution[i] = new_route\n                        break\n\n    # Step 3: Makespan-sensitive route rebalancing\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_idx = max(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n        shortest_idx = min(range(len(new_solution)), key=lambda i: distance_matrix[new_solution[i][-2], 0] + sum(distance_matrix[new_solution[i][k], new_solution[i][k+1]] for k in range(len(new_solution[i])-1)))\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx].copy()\n            shortest_route = new_solution[shortest_idx].copy()\n\n            # Try to transfer nodes from longest to shortest route\n            for i in range(len(longest_route)-2, 0, -1):\n                node = longest_route[i]\n                if sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for j in range(1, len(shortest_route)):\n                        prev_node = shortest_route[j-1]\n                        next_node = shortest_route[j]\n\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = j\n\n                    # Perform insertion\n                    new_shortest = np.concatenate((shortest_route[:best_pos], [node], shortest_route[best_pos:]))\n                    new_solution[shortest_idx] = new_shortest\n\n                    # Remove from longest route\n                    new_solution[longest_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                    break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{A novel hybrid local search operator that combines adaptive route clustering with demand-weighted node swapping and a multi-objective route balancing mechanism to simultaneously optimize total distance and makespan while maintaining feasibility through capacity-constrained node transfers and route reordering.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)  # Weighted combination of distance and makespan\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Adaptive route clustering based on spatial proximity and demand similarity\n    if len(new_solution) > 1:\n        # Calculate route centers and demand profiles\n        route_centers = []\n        route_demands = []\n        for route in new_solution:\n            if len(route) <= 2:\n                route_centers.append(coords[0])  # Depot coordinates\n                route_demands.append(0)\n                continue\n\n            # Calculate geometric center\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n\n            # Calculate total demand\n            total_demand = sum(demand[route[1:-1]])\n            route_demands.append(total_demand)\n\n        # Find clusters of routes that are spatially close and demand-similar\n        for i in range(len(new_solution)-1):\n            for j in range(i+1, len(new_solution)):\n                if len(new_solution[i]) <= 2 or len(new_solution[j]) <= 2:\n                    continue\n\n                # Calculate spatial distance between centers\n                spatial_dist = np.linalg.norm(route_centers[i] - route_centers[j])\n\n                # Calculate demand difference\n                demand_diff = abs(route_demands[i] - route_demands[j])\n\n                # Normalize metrics\n                max_spatial = max(np.linalg.norm(coords[1:] - coords[0], axis=1)) if len(coords) > 1 else 1\n                max_demand = max(demand[1:]) if len(demand) > 1 else 1\n\n                norm_spatial = spatial_dist / max_spatial\n                norm_demand = demand_diff / max_demand\n\n                # Cluster if both metrics are below thresholds\n                if norm_spatial < 0.4 and norm_demand < 0.3:\n                    # Merge routes if capacity allows\n                    total_demand = route_demands[i] + route_demands[j]\n                    if total_demand <= capacity:\n                        route1 = new_solution[i]\n                        route2 = new_solution[j]\n\n                        # Calculate merging cost\n                        cost1 = distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]]\n                        cost2 = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n\n                        if cost2 < cost1:\n                            merged_route = np.concatenate((route1[:-1], route2[1:]))\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Step 2: Demand-weighted node swapping between routes\n    if len(new_solution) > 1:\n        # Sort routes by demand in descending order\n        route_indices = sorted(range(len(new_solution)), key=lambda i: sum(demand[new_solution[i][1:-1]]), reverse=True)\n\n        for i in route_indices:\n            if len(new_solution[i]) <= 3:\n                continue\n\n            route = new_solution[i]\n            # Calculate demand weights for each node in the route\n            node_weights = [demand[node] for node in route[1:-1]]\n\n            # Try to swap nodes with routes that can accommodate them\n            for j in range(1, len(route)-1):\n                node = route[j]\n                weight = node_weights[j-1]\n\n                for k in route_indices:\n                    if k == i:\n                        continue\n\n                    target_route = new_solution[k]\n                    current_demand = sum(demand[target_route[1:-1]])\n\n                    if current_demand + weight <= capacity:\n                        # Find best insertion position in target route\n                        best_pos = 1\n                        best_cost = float('inf')\n\n                        for l in range(1, len(target_route)):\n                            prev_node = target_route[l-1]\n                            next_node = target_route[l]\n\n                            old_cost = distance_matrix[prev_node, next_node]\n                            new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                            if new_cost - old_cost < best_cost:\n                                best_cost = new_cost - old_cost\n                                best_pos = l\n\n                        if best_cost < 0:  # Only perform if it improves the route\n                            # Perform the swap\n                            new_route = np.concatenate((target_route[:best_pos], [node], target_route[best_pos:]))\n                            new_solution[k] = new_route\n\n                            # Remove from original route\n                            new_solution[i] = np.concatenate((route[:j], route[j+1:]))\n                            break\n\n    # Step 3: Multi-objective route balancing\n    if len(new_solution) > 1:\n        # Calculate route lengths (excluding depot returns)\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n\n        # Find routes to balance\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            # Try to transfer nodes from longest to shortest route\n            for i in range(len(longest_route)-2, 0, -1):\n                node = longest_route[i]\n                if sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for j in range(1, len(shortest_route)):\n                        prev_node = shortest_route[j-1]\n                        next_node = shortest_route[j]\n\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = j\n\n                    # Calculate makespan impact\n                    old_makespan = max(route_lengths)\n                    new_length = route_lengths[shortest_idx] + best_cost\n                    new_makespan = max(new_length, route_lengths[longest_idx] - distance_matrix[longest_route[i-1], node] - distance_matrix[node, longest_route[i+1]])\n\n                    # Accept if it improves both objectives\n                    if (new_makespan <= old_makespan and\n                        (new_length < route_lengths[shortest_idx] or new_makespan < old_makespan)):\n                        # Perform insertion\n                        new_shortest = np.concatenate((shortest_route[:best_pos], [node], shortest_route[best_pos:]))\n                        new_solution[shortest_idx] = new_shortest\n\n                        # Remove from longest route\n                        new_solution[longest_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                        break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n",
        "score": [
            -0.8043143435930433,
            9.051447421312332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] * 0.6 + x[1][1] * 0.4)  # Weighted combination of distance and makespan\n    selected_idx = min(2, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Step 1: Adaptive route clustering based on spatial proximity and demand similarity\n    if len(new_solution) > 1:\n        # Calculate route centers and demand profiles\n        route_centers = []\n        route_demands = []\n        for route in new_solution:\n            if len(route) <= 2:\n                route_centers.append(coords[0])  # Depot coordinates\n                route_demands.append(0)\n                continue\n\n            # Calculate geometric center\n            route_coords = coords[route[1:-1]]\n            center = np.mean(route_coords, axis=0)\n            route_centers.append(center)\n\n            # Calculate total demand\n            total_demand = sum(demand[route[1:-1]])\n            route_demands.append(total_demand)\n\n        # Find clusters of routes that are spatially close and demand-similar\n        for i in range(len(new_solution)-1):\n            for j in range(i+1, len(new_solution)):\n                if len(new_solution[i]) <= 2 or len(new_solution[j]) <= 2:\n                    continue\n\n                # Calculate spatial distance between centers\n                spatial_dist = np.linalg.norm(route_centers[i] - route_centers[j])\n\n                # Calculate demand difference\n                demand_diff = abs(route_demands[i] - route_demands[j])\n\n                # Normalize metrics\n                max_spatial = max(np.linalg.norm(coords[1:] - coords[0], axis=1)) if len(coords) > 1 else 1\n                max_demand = max(demand[1:]) if len(demand) > 1 else 1\n\n                norm_spatial = spatial_dist / max_spatial\n                norm_demand = demand_diff / max_demand\n\n                # Cluster if both metrics are below thresholds\n                if norm_spatial < 0.4 and norm_demand < 0.3:\n                    # Merge routes if capacity allows\n                    total_demand = route_demands[i] + route_demands[j]\n                    if total_demand <= capacity:\n                        route1 = new_solution[i]\n                        route2 = new_solution[j]\n\n                        # Calculate merging cost\n                        cost1 = distance_matrix[route1[-2], 0] + distance_matrix[0, route2[1]]\n                        cost2 = distance_matrix[route1[-2], route2[1]] + distance_matrix[route2[-2], 0]\n\n                        if cost2 < cost1:\n                            merged_route = np.concatenate((route1[:-1], route2[1:]))\n                            new_solution[i] = merged_route\n                            new_solution.pop(j)\n                            break\n\n    # Step 2: Demand-weighted node swapping between routes\n    if len(new_solution) > 1:\n        # Sort routes by demand in descending order\n        route_indices = sorted(range(len(new_solution)), key=lambda i: sum(demand[new_solution[i][1:-1]]), reverse=True)\n\n        for i in route_indices:\n            if len(new_solution[i]) <= 3:\n                continue\n\n            route = new_solution[i]\n            # Calculate demand weights for each node in the route\n            node_weights = [demand[node] for node in route[1:-1]]\n\n            # Try to swap nodes with routes that can accommodate them\n            for j in range(1, len(route)-1):\n                node = route[j]\n                weight = node_weights[j-1]\n\n                for k in route_indices:\n                    if k == i:\n                        continue\n\n                    target_route = new_solution[k]\n                    current_demand = sum(demand[target_route[1:-1]])\n\n                    if current_demand + weight <= capacity:\n                        # Find best insertion position in target route\n                        best_pos = 1\n                        best_cost = float('inf')\n\n                        for l in range(1, len(target_route)):\n                            prev_node = target_route[l-1]\n                            next_node = target_route[l]\n\n                            old_cost = distance_matrix[prev_node, next_node]\n                            new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                            if new_cost - old_cost < best_cost:\n                                best_cost = new_cost - old_cost\n                                best_pos = l\n\n                        if best_cost < 0:  # Only perform if it improves the route\n                            # Perform the swap\n                            new_route = np.concatenate((target_route[:best_pos], [node], target_route[best_pos:]))\n                            new_solution[k] = new_route\n\n                            # Remove from original route\n                            new_solution[i] = np.concatenate((route[:j], route[j+1:]))\n                            break\n\n    # Step 3: Multi-objective route balancing\n    if len(new_solution) > 1:\n        # Calculate route lengths (excluding depot returns)\n        route_lengths = [sum(distance_matrix[route[k], route[k+1]] for k in range(len(route)-1)) for route in new_solution]\n\n        # Find routes to balance\n        longest_idx = np.argmax(route_lengths)\n        shortest_idx = np.argmin(route_lengths)\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            # Try to transfer nodes from longest to shortest route\n            for i in range(len(longest_route)-2, 0, -1):\n                node = longest_route[i]\n                if sum(demand[shortest_route[1:-1]]) + demand[node] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for j in range(1, len(shortest_route)):\n                        prev_node = shortest_route[j-1]\n                        next_node = shortest_route[j]\n\n                        old_cost = distance_matrix[prev_node, next_node]\n                        new_cost = distance_matrix[prev_node, node] + distance_matrix[node, next_node]\n\n                        if new_cost - old_cost < best_cost:\n                            best_cost = new_cost - old_cost\n                            best_pos = j\n\n                    # Calculate makespan impact\n                    old_makespan = max(route_lengths)\n                    new_length = route_lengths[shortest_idx] + best_cost\n                    new_makespan = max(new_length, route_lengths[longest_idx] - distance_matrix[longest_route[i-1], node] - distance_matrix[node, longest_route[i+1]])\n\n                    # Accept if it improves both objectives\n                    if (new_makespan <= old_makespan and\n                        (new_length < route_lengths[shortest_idx] or new_makespan < old_makespan)):\n                        # Perform insertion\n                        new_shortest = np.concatenate((shortest_route[:best_pos], [node], shortest_route[best_pos:]))\n                        new_solution[shortest_idx] = new_shortest\n\n                        # Remove from longest route\n                        new_solution[longest_idx] = np.concatenate((longest_route[:i], longest_route[i+1:]))\n                        break\n\n    # Verify feasibility\n    for route in new_solution:\n        if sum(demand[route[1:-1]]) > capacity:\n            raise ValueError(\"Generated solution is infeasible\")\n\n    return new_solution\n\n"
    }
]