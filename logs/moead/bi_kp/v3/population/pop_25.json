[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel local search strategy that combines multi-objective value-aware swaps with adaptive neighborhood exploration, using a hybrid of value correlation analysis and dynamic weight adjustment, but incorporates a probabilistic acceptance criterion to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Multi-objective value-aware swaps with probabilistic acceptance\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate value correlations and dynamic weights\n        corr = np.corrcoef(value1_lst[included], value2_lst[included])[0, 1] if len(included) > 1 else 0\n        if np.isnan(corr):\n            corr = 0\n\n        # Dynamic weight adjustment based on correlation\n        weight1 = 0.5 + 0.4 * corr\n        weight2 = 0.5 - 0.4 * corr\n\n        # Calculate combined value efficiency\n        efficiency = (weight1 * value1_lst + weight2 * value2_lst) / (weight_lst + 1e-10)\n\n        # Find best swap candidates with probabilistic selection\n        candidates = []\n        for i in included:\n            for j in excluded:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    gain = (value1_lst[j] - value1_lst[i]) * weight1 + (value2_lst[j] - value2_lst[i]) * weight2\n                    candidates.append((i, j, gain))\n\n        if candidates:\n            # Select top 3 candidates and choose one probabilistically\n            candidates.sort(key=lambda x: -x[2])\n            top_candidates = candidates[:min(3, len(candidates))]\n            selected = np.random.choice(len(top_candidates), p=[0.6, 0.3, 0.1] if len(top_candidates) == 3 else [0.7, 0.3])\n            best_swap = top_candidates[selected]\n\n            new_solution[best_swap[0]] = 0\n            new_solution[best_swap[1]] = 1\n            current_weight = current_weight - weight_lst[best_swap[0]] + weight_lst[best_swap[1]]\n\n    # Step 2: Adaptive neighborhood exploration with dynamic depth and probabilistic acceptance\n    exploration_depth = min(5, n_items // 2)\n    explore_indices = np.random.choice(n_items, exploration_depth, replace=False)\n\n    for idx in explore_indices:\n        if new_solution[idx] == 1:\n            # Probabilistic removal based on value contribution\n            value_contribution = (weight1 * value1_lst[idx] + weight2 * value2_lst[idx]) / (weight_lst[idx] + 1e-10)\n            remove_prob = max(0.1, min(0.9, 1 - value_contribution / (np.max(efficiency) + 1e-10)))\n\n            if np.random.rand() < remove_prob and current_weight - weight_lst[idx] >= 0:\n                temp_weight = current_weight - weight_lst[idx]\n                # Check if removing this item allows adding better items\n                can_add = False\n                for j in excluded:\n                    if temp_weight + weight_lst[j] <= capacity:\n                        can_add = True\n                        break\n                if can_add:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n        else:\n            # Probabilistic addition based on efficiency\n            if current_weight + weight_lst[idx] <= capacity:\n                add_prob = max(0.1, min(0.9, efficiency[idx] / (np.max(efficiency) + 1e-10)))\n                if np.random.rand() < add_prob:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -17.698753242264786,
            -18.993117891632604
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel local search strategy that combines multi-objective value-aware swaps with adaptive neighborhood exploration, using a hybrid of value diversity and correlation analysis with dynamic weight adjustment to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.sum(objectives, axis=1)  # Sum of objectives as improvement potential\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Multi-objective value-aware swaps with diversity and correlation\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        # Calculate value diversity and correlation\n        std1 = np.std(value1_lst[included])\n        std2 = np.std(value2_lst[included])\n        diversity = std1 + std2\n\n        corr = np.corrcoef(value1_lst[included], value2_lst[included])[0, 1]\n        if np.isnan(corr):\n            corr = 0\n\n        # Dynamic weight adjustment based on diversity and correlation\n        weight1 = 0.5 + 0.3 * (diversity / (std1 + std2 + 1e-10)) + 0.2 * corr\n        weight2 = 0.5 - 0.3 * (diversity / (std1 + std2 + 1e-10)) - 0.2 * corr\n\n        # Calculate combined value efficiency\n        efficiency = (weight1 * value1_lst + weight2 * value2_lst) / (weight_lst + 1e-10)\n\n        # Find best swap candidates\n        best_gain = -float('inf')\n        best_swap = (-1, -1)\n\n        for i in included:\n            for j in excluded:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    gain = (value1_lst[j] - value1_lst[i]) * weight1 + (value2_lst[j] - value2_lst[i]) * weight2\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_swap = (i, j)\n\n        if best_swap[0] != -1 and best_swap[1] != -1:\n            new_solution[best_swap[0]] = 0\n            new_solution[best_swap[1]] = 1\n            current_weight = current_weight - weight_lst[best_swap[0]] + weight_lst[best_swap[1]]\n\n    # Step 2: Adaptive neighborhood exploration with dynamic depth\n    exploration_depth = min(4, n_items // 4)\n    explore_indices = np.random.choice(n_items, exploration_depth, replace=False)\n\n    for idx in explore_indices:\n        if new_solution[idx] == 1:\n            # Try to remove item if it's not critical\n            if current_weight - weight_lst[idx] >= 0:\n                temp_weight = current_weight - weight_lst[idx]\n                # Check if removing this item allows adding better items\n                can_add = False\n                for j in excluded:\n                    if temp_weight + weight_lst[j] <= capacity:\n                        can_add = True\n                        break\n                if can_add:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n        else:\n            # Try to add item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -20.09610213745504,
            -16.871751765441996
        ]
    }
]