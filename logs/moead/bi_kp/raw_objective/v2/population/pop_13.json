[
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a novel diversity-aware selection based on the angle between normalized objectives and a reference direction, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a dynamic parameter setting for the score function by considering the ratio of normalized objectives with adaptive weights based on the current solution's dominance count, while also incorporating a novel neighborhood exploration strategy that considers item correlations and a dynamic exploration radius.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Diversity-aware selection based on angle with reference direction\n    objectives = np.array([obj for _, obj in archive])\n    max_v1, max_v2 = objectives.max(axis=0)\n    normalized = objectives / np.array([max_v1, max_v2])\n    reference_dir = np.array([0.7, 0.3])  # Predefined reference direction\n    angles = np.arccos(np.clip(np.dot(normalized, reference_dir), -1.0, 1.0))\n    selected_idx = np.argmin(angles)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Dynamic parameter setting based on dominance count\n    dominance_count = sum(1 for obj in objectives if (obj[0] > objectives[selected_idx][0] and obj[1] >= objectives[selected_idx][1]) or (obj[0] >= objectives[selected_idx][0] and obj[1] > objectives[selected_idx][1]))\n    alpha = 0.8 if dominance_count > 0 else 0.2\n    vw_ratio = (value1_lst * alpha + value2_lst * (1 - alpha)) / weight_lst\n\n    # Hybrid local search with dynamic exploration radius\n    exploration_radius = min(5, len(candidates))\n    for _ in range(3):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio and correlation\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(exploration_radius, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio and correlation\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # If no improvement, perform a targeted flip with correlation-aware strategy\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -17.122500679254017,
            -19.68324377047829
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(0.6 * obj[0]/max_v1 + 0.4 * obj[1]/max_v2) for _, obj in archive]  # Sum of normalized objectives with different weights\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.881238273007625,
            -17.612570262095716
        ]
    }
]