[
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a rank-based selection that prioritizes solutions with high diversity in their objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a dynamic parameter setting for the score function by considering the ratio of normalized objectives with adaptive weights based on the current solution's performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Rank-based selection with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    max_v1, max_v2 = objectives.max(axis=0)\n    normalized = objectives / np.array([max_v1, max_v2])\n    diversity_scores = np.std(normalized, axis=0)\n    weights = diversity_scores * np.array([0.6, 0.4])  # Weight based on diversity\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Dynamic parameter setting for value-to-weight ratio\n    alpha = 0.5 if len(candidates) < len(non_candidates) else 0.3\n    vw_ratio = (value1_lst * alpha + value2_lst * (1 - alpha)) / weight_lst\n\n    # Hybrid local search with probabilistic exploration\n    for _ in range(4):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(4, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # If no improvement, perform a targeted flip with adaptive strategy\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -17.612307406362465,
            -19.474858818924623
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(0.6 * obj[0]/max_v1 + 0.4 * obj[1]/max_v2) for _, obj in archive]  # Sum of normalized objectives with different weights\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.881238273007625,
            -17.612570262095716
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a rank-based selection that prioritizes solutions with high diversity in their objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a dynamic parameter setting for the score function by considering the ratio of normalized objectives with adaptive weights based on the current solution's performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Rank-based selection with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    max_v1, max_v2 = objectives.max(axis=0)\n    normalized = objectives / np.array([max_v1, max_v2])\n    diversity_scores = np.std(normalized, axis=0)\n    weights = diversity_scores * np.array([0.6, 0.4])  # Weight based on diversity\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Dynamic parameter setting for value-to-weight ratio\n    alpha = 0.5 if len(candidates) < len(non_candidates) else 0.3\n    vw_ratio = (value1_lst * alpha + value2_lst * (1 - alpha)) / weight_lst\n\n    # Hybrid local search with probabilistic exploration\n    for _ in range(4):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(4, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # If no improvement, perform a targeted flip with adaptive strategy\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -17.612307406362465,
            -19.474858818924623
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(0.6 * obj[0]/max_v1 + 0.4 * obj[1]/max_v2) for _, obj in archive]  # Sum of normalized objectives with different weights\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.881238273007625,
            -17.612570262095716
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objectives with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the product of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 * 0.4 + obj[1]/max_v2 * 0.6) for _, obj in archive]  # Sum of normalized objectives with weights\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # More trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.5 + value2_lst * 0.5) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.6 + value2_lst * 0.4) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.144538861714363,
            -18.587309667215894
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection based on the angle between objective vectors, then applies a novel local search that combines adaptive multi-objective swaps with a probabilistic exploration of high-value items while maintaining feasibility through dynamic capacity management.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Diversity-aware selection based on angle between objective vectors\n    objectives = np.array([obj for _, obj in archive])\n    max_v1, max_v2 = objectives.max(axis=0)\n    normalized = objectives / np.array([max_v1, max_v2])\n    angles = np.arctan2(normalized[:, 1], normalized[:, 0])\n    diversity_weights = np.abs(angles - np.median(angles))\n    selected_idx = np.argmax(diversity_weights)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Adaptive multi-objective swaps\n    for _ in range(5):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Calculate dynamic value-to-weight ratios\n            alpha = 0.7 if np.random.random() < 0.5 else 0.3\n            vw_ratio = (value1_lst * alpha + value2_lst * (1 - alpha)) / weight_lst\n\n            # Select items to remove based on low value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(5, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                # Greedy addition with dynamic capacity check\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # Probabilistic exploration of high-value items\n    if np.random.random() < 0.4:\n        high_value_items = np.argsort(-(value1_lst + value2_lst))\n        for i in high_value_items:\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    return new_solution\n\n",
        "score": [
            -18.666340980702657,
            -18.70733878754905
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the ratio of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the product of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1) * (obj[1]/max_v2) for _, obj in archive]  # Product of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.5 + value2_lst * 0.5) / weight_lst  # Equal weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(2, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.5 + value2_lst * 0.5) / weight_lst  # Equal weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.073688694175253,
            -18.645725210171413
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the harmonic mean of normalized objective values, then applies a hybrid local search that combines item swaps with a probabilistic neighborhood exploration prioritizing items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the product of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [2 * (obj[0]/max_v1) * (obj[1]/max_v2) / ((obj[0]/max_v1) + (obj[1]/max_v2)) for _, obj in archive]  # Harmonic mean of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.5 + value2_lst * 0.5) / weight_lst  # Equal weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(2, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.4 + value2_lst * 0.6) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.06963488411425,
            -18.659029005266614
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a crowding-distance-based selection that prioritizes solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a dynamic parameter setting for the score function by considering the ratio of normalized objectives with adaptive weights based on the current solution's performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Crowding-distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Dynamic parameter setting for value-to-weight ratio\n    beta = 0.7 if len(candidates) < len(non_candidates) else 0.4\n    vw_ratio = (value1_lst * beta + value2_lst * (1 - beta)) / weight_lst\n\n    # Hybrid local search with probabilistic exploration\n    for _ in range(5):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # If no improvement, perform a targeted flip with adaptive strategy\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.64301773307805,
            -18.746874491004142
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the product of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(0.4 * obj[0]/max_v1 + 0.6 * obj[1]/max_v2) for _, obj in archive]  # Sum of normalized objectives with different weights\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -17.96723015643667,
            -19.4127372211507
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a tournament-based selection considering both objective values and diversity, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a dynamic parameter setting for the score function by considering a weighted combination of normalized objectives with adaptive weights based on their relative importance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Tournament-based selection considering both objectives and diversity\n    tournament_size = min(5, len(archive))\n    selected_idx = random.choice(random.sample(range(len(archive)), tournament_size))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_v1, current_v2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Calculate adaptive weights based on relative importance\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n    v1_weight = 0.5 if max_v1 > 0 else 0.5\n    v2_weight = 1 - v1_weight\n\n    # Hybrid local search with probabilistic exploration\n    for _ in range(3):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio with adaptive weights\n            vw_ratio = (value1_lst * v1_weight + value2_lst * v2_weight) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip with adaptive weights\n    if np.array_equal(new_solution, base_solution):\n        vw_ratio = (value1_lst * v1_weight + value2_lst * v2_weight) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.138797262017462,
            -18.592009752814143
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the product of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 * 0.6 + obj[1]/max_v2 * 0.4) for _, obj in archive]  # Weighted sum of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.4 + value2_lst * 0.6) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.6 + value2_lst * 0.4) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.519182397911223,
            -19.0804501898452
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(0.6 * obj[0]/max_v1 + 0.4 * obj[1]/max_v2) for _, obj in archive]  # Sum of normalized objectives with different weights\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.8985557162141,
            -17.58171637398599
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a rank-based selection that prioritizes solutions with high diversity in their objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a dynamic parameter setting for the score function by considering the ratio of normalized objectives with adaptive weights based on the current solution's performance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Rank-based selection with diversity consideration\n    objectives = np.array([obj for _, obj in archive])\n    max_v1, max_v2 = objectives.max(axis=0)\n    normalized = objectives / np.array([max_v1, max_v2])\n    diversity_scores = np.std(normalized, axis=0)\n    weights = diversity_scores * np.array([0.6, 0.4])  # Weight based on diversity\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Dynamic parameter setting for value-to-weight ratio\n    alpha = 0.5 if len(candidates) < len(non_candidates) else 0.3\n    vw_ratio = (value1_lst * alpha + value2_lst * (1 - alpha)) / weight_lst\n\n    # Hybrid local search with probabilistic exploration\n    for _ in range(4):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(4, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # If no improvement, perform a targeted flip with adaptive strategy\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -17.612307406362465,
            -19.474858818924623
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the harmonic mean of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a dynamic weight adjustment mechanism to balance the exploration of both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n\n    # Calculate harmonic mean of normalized objectives with dynamic weights\n    alpha = 0.5 * (1 + np.sin(len(archive) / 10))  # Dynamic weight factor\n    weights = [(2 * (alpha * obj[0]/max_v1) * ((1-alpha) * obj[1]/max_v2)) /\n               ((alpha * obj[0]/max_v1) + ((1-alpha) * obj[1]/max_v2)) for _, obj in archive]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Dynamic value-to-weight ratio calculation\n    beta = 0.3 + 0.4 * (1 - np.exp(-len(archive)/100))  # Dynamic weight factor\n    vw_ratio = (value1_lst * beta + value2_lst * (1-beta)) / weight_lst\n\n    # Hybrid neighborhood exploration\n    for _ in range(4):  # Increased trials with dynamic adjustment\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(4, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a probabilistic flip based on dynamic ratio\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if random.random() < 0.3:  # Probabilistic flip\n                if new_solution[i] == 1:\n                    if current_weight - weight_lst[i] >= 0:\n                        new_solution[i] = 0\n                        break\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        break\n\n    return new_solution\n\n",
        "score": [
            -19.26991717530702,
            -18.335309102795897
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a tournament selection based on the product of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    scores = [(obj[0]/max_v1 * 0.5 + obj[1]/max_v2 * 0.5) for _, obj in archive]  # Product of normalized objectives with different weights\n\n    selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            vw_ratio = (value1_lst * 0.5 + value2_lst * 0.5) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(2, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.050288933279543,
            -18.673881201673023
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the harmonic mean of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with adaptive weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    max_v1 = max(obj[0] for _, obj in archive)\n    max_v2 = max(obj[1] for _, obj in archive)\n    weights = [2 * (obj[0]/max_v1 * obj[1]/max_v2) / ((obj[0]/max_v1) + (obj[1]/max_v2)) for _, obj in archive]  # Harmonic mean of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Adaptive value-to-weight ratio with changing weights\n    alpha = random.uniform(0.3, 0.7)\n    vw_ratio = (value1_lst * alpha + value2_lst * (1 - alpha)) / weight_lst\n\n    # Hybrid local search with probabilistic exploration\n    for _ in range(3):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Remove items with lowest value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(2, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Add items with highest value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip with adaptive strategy\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.090011791957718,
            -18.595798061490726
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a diversity-aware selection mechanism that considers both objective values and solution structure, then applies a hybrid local search combining item swaps with a probabilistic exploration of high-value items while ensuring feasibility, and uses a dynamic score function that adapts based on the current archive's objective distribution to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Diversity-aware selection\n    obj_values = np.array([obj for _, obj in archive])\n    min_v1, max_v1 = obj_values[:, 0].min(), obj_values[:, 0].max()\n    min_v2, max_v2 = obj_values[:, 1].min(), obj_values[:, 1].max()\n\n    # Normalize objectives and compute diversity score\n    norm_obj = (obj_values - np.array([min_v1, min_v2])) / (np.array([max_v1, max_v2]) - np.array([min_v1, min_v2]) + 1e-8)\n    div_scores = np.sum(norm_obj, axis=1)  # Sum of normalized objectives as diversity metric\n\n    # Select solution with highest diversity\n    selected_idx = np.argmax(div_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Dynamic value-to-weight ratio based on current archive\n    avg_v1 = np.mean(obj_values[:, 0])\n    avg_v2 = np.mean(obj_values[:, 1])\n    vw_ratio = (value1_lst * (1 + avg_v1/max_v1) + value2_lst * (1 + avg_v2/max_v2)) / weight_lst\n\n    # Hybrid local search\n    for _ in range(3):\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Remove items with lowest dynamic ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Add items with highest dynamic ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.925715976451784,
            -18.705915712103398
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values with different weights, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the product of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(0.4 * obj[0]/max_v1 + 0.6 * obj[1]/max_v2) for _, obj in archive]  # Sum of normalized objectives with different weights\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -17.96723015643667,
            -19.4127372211507
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function that emphasizes individual objective values more significantly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 + obj[1]/max_v2) for _, obj in archive]  # Changed to sum of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(5):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 3 + value2_lst * 2) / weight_lst  # Adjusted weighted value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(5, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 3 + value2_lst * 2) / weight_lst  # Adjusted weighted value-to-weight ratio\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.50886188171311,
            -18.077396161050803
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 + obj[1]/max_v2) for _, obj in archive]  # Changed to sum instead of product\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Reduced trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.204560256859423,
            -18.536946752989312
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1) * (obj[1]/max_v2) for _, obj in archive]  # Changed to product instead of sum\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Reduced trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.170230436380553,
            -18.55775908818245
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a tournament selection based on the dominance count of each solution, then applies a hybrid local search that combines item swaps with a probabilistic neighborhood exploration prioritizing items with high value-to-weight ratios, while ensuring feasibility through a capacity-aware item selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected_indices = random.sample(range(len(archive)), tournament_size)\n    selected_idx = max(selected_indices, key=lambda i: sum(1 for j in selected_indices if archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]))\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios for both objectives\n    vw_ratio1 = value1_lst / weight_lst\n    vw_ratio2 = value2_lst / weight_lst\n    combined_ratio = (vw_ratio1 + vw_ratio2) / 2\n\n    # Probabilistic neighborhood exploration with combined ratio\n    for _ in range(5):\n        candidates = np.where(new_solution == 1)[0]\n        non_candidates = np.where(new_solution == 0)[0]\n\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low combined ratio\n            remove_candidates = sorted(candidates, key=lambda i: combined_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high combined ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -combined_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # If no improvement, perform a capacity-aware flip\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(combined_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.087182662881773,
            -18.632184663896055
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 + obj[1]/max_v2) for _, obj in archive]  # Changed to sum instead of product\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Reduced trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.204560256859423,
            -18.536946752989312
        ]
    }
]