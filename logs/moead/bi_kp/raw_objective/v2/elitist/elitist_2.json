[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search that combines probabilistic item addition/removal with a biased random walk to explore the neighborhood while maintaining feasibility, favoring solutions that improve both objectives in a balanced manner.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = objectives / np.sum(objectives) if np.sum(objectives) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: probabilistic addition/removal with biased random walk\n    for _ in range(3):  # Perform multiple steps to explore neighborhood\n        # With 70% probability, try to add a new item\n        if random.random() < 0.7:\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Select items with high normalized contribution to both objectives\n                contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n                probabilities = contributions[available_items] / np.sum(contributions[available_items])\n                add_idx = random.choices(available_items, weights=probabilities, k=1)[0]\n\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n                    current_weight += weight_lst[add_idx]\n        else:\n            # With 30% probability, try to remove an item\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) > 0:\n                # Prefer removing items with low contribution to both objectives\n                contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n                probabilities = 1 / (contributions[selected_items] + 1e-6)\n                probabilities /= np.sum(probabilities)\n                remove_idx = random.choices(selected_items, weights=probabilities, k=1)[0]\n\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    # Ensure at least one item is selected if possible\n    if np.sum(new_solution) == 0 and len(weight_lst) > 0:\n        min_weight_idx = np.argmin(weight_lst)\n        if weight_lst[min_weight_idx] <= capacity:\n            new_solution[min_weight_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.65625422818227,
            -18.64331834957637
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive using a diversity-aware selection mechanism that prioritizes solutions with high potential for improvement in both objectives, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(v1 + v2) for (s, (v1, v2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration\n    for _ in range(3):  # Perform 3 trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Randomly select multiple items to remove (1-3 items)\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(list(candidates), num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add that fit within capacity\n            best_add_indices = []\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n\n            if available_items:\n                # Sort by combined value density\n                value_density = (value1_lst + value2_lst) / weight_lst\n                sorted_items = sorted(available_items, key=lambda i: -value_density[i])\n\n                # Greedily add items until capacity is full\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                # Apply the best additions\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement found, perform a random flip with probability based on potential\n    if np.array_equal(new_solution, base_solution):\n        flip_pos = random.choice(range(len(new_solution)))\n        if new_solution[flip_pos] == 1:\n            if current_weight - weight_lst[flip_pos] >= 0:\n                new_solution[flip_pos] = 0\n        else:\n            if current_weight + weight_lst[flip_pos] <= capacity:\n                new_solution[flip_pos] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.76992634216247,
            -18.41222076151245
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive using a diversity-aware selection mechanism that prioritizes solutions with high potential for improvement in both objectives, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(v1 + v2) for (s, (v1, v2)) in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration\n    for _ in range(3):  # Perform 3 trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Randomly select multiple items to remove (1-3 items)\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(list(candidates), num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add that fit within capacity\n            best_add_indices = []\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n\n            if available_items:\n                # Sort by combined value density\n                value_density = (value1_lst + value2_lst) / weight_lst\n                sorted_items = sorted(available_items, key=lambda i: -value_density[i])\n\n                # Greedily add items until capacity is full\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                # Apply the best additions\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement found, perform a random flip with probability based on potential\n    if np.array_equal(new_solution, base_solution):\n        flip_pos = random.choice(range(len(new_solution)))\n        if new_solution[flip_pos] == 1:\n            if current_weight - weight_lst[flip_pos] >= 0:\n                new_solution[flip_pos] = 0\n        else:\n            if current_weight + weight_lst[flip_pos] <= capacity:\n                new_solution[flip_pos] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.76992634216247,
            -18.41222076151245
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search that combines probabilistic item addition/removal with a biased random walk to explore the neighborhood while maintaining feasibility, favoring solutions that improve both objectives in a balanced manner.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = objectives / np.sum(objectives) if np.sum(objectives) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: probabilistic addition/removal with biased random walk\n    for _ in range(3):  # Perform multiple steps to explore neighborhood\n        # With 70% probability, try to add a new item\n        if random.random() < 0.7:\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Select items with high normalized contribution to both objectives\n                contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n                probabilities = contributions[available_items] / np.sum(contributions[available_items])\n                add_idx = random.choices(available_items, weights=probabilities, k=1)[0]\n\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n                    current_weight += weight_lst[add_idx]\n        else:\n            # With 30% probability, try to remove an item\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) > 0:\n                # Prefer removing items with low contribution to both objectives\n                contributions = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n                probabilities = 1 / (contributions[selected_items] + 1e-6)\n                probabilities /= np.sum(probabilities)\n                remove_idx = random.choices(selected_items, weights=probabilities, k=1)[0]\n\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    # Ensure at least one item is selected if possible\n    if np.sum(new_solution) == 0 and len(weight_lst) > 0:\n        min_weight_idx = np.argmin(weight_lst)\n        if weight_lst[min_weight_idx] <= capacity:\n            new_solution[min_weight_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.65625422818227,
            -18.64331834957637
        ]
    }
]