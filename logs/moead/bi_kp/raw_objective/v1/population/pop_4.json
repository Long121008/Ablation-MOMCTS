[
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest product of normalized objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest product of normalized objectives)\n    archive_objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(archive_objectives, axis=0)\n    normalized_objectives = archive_objectives / max_values\n    product_scores = np.prod(normalized_objectives, axis=1)\n    selected_idx = np.argmax(product_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(5):  # Increased number of iterations\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.4:  # Increased probability to add an item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.3:  # Increased probability to remove an item\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -18.83120158709039,
            -18.735394671888194
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining item swaps with a biased probabilistic replacement strategy to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and compute weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / max_values\n    weights = np.array([0.6, 0.4])  # Higher weight for objective 1\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with biased probabilities\n    for _ in range(4):  # Increased iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Weighted random selection for swap\n            weights_in = value1_lst[items_in] + value2_lst[items_in]\n            weights_out = value1_lst[items_out] + value2_lst[items_out]\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Biased probabilistic operations\n        if random.random() < 0.4:  # Higher probability to add\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = value1_lst[candidate_items] * 0.7 + value2_lst[candidate_items] * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.15:  # Lower probability to remove\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = value1_lst[candidate_items] * 0.3 + value2_lst[candidate_items] * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.454846407496873,
            -18.03891502255262
        ]
    }
]