[
    {
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by evaluating their marginal improvements in both objectives, then applies a hybrid local search operator that combines item swapping and probabilistic flipping to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on marginal improvements\n    def evaluate_promisingness(solution, objective):\n        total_weight = np.sum(weight_lst * solution)\n        if total_weight > capacity:\n            return -np.inf  # Penalize infeasible solutions\n\n        # Calculate marginal improvements for each objective\n        marginal1 = np.sum(value1_lst * solution) / (total_weight + 1e-6)\n        marginal2 = np.sum(value2_lst * solution) / (total_weight + 1e-6)\n\n        # Combine marginal improvements with current objective values\n        return marginal1 * objective[0] + marginal2 * objective[1]\n\n    # Evaluate all solutions and select the most promising one\n    evaluated = [(evaluate_promisingness(sol, obj), sol) for sol, obj in archive]\n    evaluated.sort(reverse=True, key=lambda x: x[0])\n    base_solution = evaluated[0][1].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider swapping\n    subset_size = min(5, N)\n    indices = random.sample(range(N), subset_size)\n\n    # Step 2: For each selected item, decide to flip or swap with another\n    for i in indices:\n        if random.random() < 0.7:  # 70% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n        else:  # 30% chance to swap with another item\n            j = random.choice([x for x in range(N) if x != i])\n            # Check if swapping keeps the solution feasible\n            delta = weight_lst[i] - weight_lst[j]\n            if np.sum(weight_lst * new_solution) + delta <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply probabilistic flipping to explore more neighbors\n    for i in range(N):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.435421740474464,
            -17.94921824562523
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by evaluating their marginal improvements in both objectives, then applies a hybrid local search operator that combines item swapping and probabilistic flipping to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on marginal improvements\n    def evaluate_promisingness(solution, objective):\n        total_weight = np.sum(weight_lst * solution)\n        if total_weight > capacity:\n            return -np.inf  # Penalize infeasible solutions\n\n        # Calculate marginal improvements for each objective\n        marginal1 = np.sum(value1_lst * solution) / (total_weight + 1e-6)\n        marginal2 = np.sum(value2_lst * solution) / (total_weight + 1e-6)\n\n        # Combine marginal improvements with current objective values\n        return marginal1 * objective[0] + marginal2 * objective[1]\n\n    # Evaluate all solutions and select the most promising one\n    evaluated = [(evaluate_promisingness(sol, obj), sol) for sol, obj in archive]\n    evaluated.sort(reverse=True, key=lambda x: x[0])\n    base_solution = evaluated[0][1].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider swapping\n    subset_size = min(5, N)\n    indices = random.sample(range(N), subset_size)\n\n    # Step 2: For each selected item, decide to flip or swap with another\n    for i in indices:\n        if random.random() < 0.7:  # 70% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n        else:  # 30% chance to swap with another item\n            j = random.choice([x for x in range(N) if x != i])\n            # Check if swapping keeps the solution feasible\n            delta = weight_lst[i] - weight_lst[j]\n            if np.sum(weight_lst * new_solution) + delta <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply probabilistic flipping to explore more neighbors\n    for i in range(N):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.435421740474464,
            -17.94921824562523
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive by evaluating their marginal improvements in both objectives, then applies a hybrid local search operator that combines item swapping and probabilistic flipping to explore high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on marginal improvements\n    def evaluate_promisingness(solution, objective):\n        total_weight = np.sum(weight_lst * solution)\n        if total_weight > capacity:\n            return -np.inf  # Penalize infeasible solutions\n\n        # Calculate marginal improvements for each objective\n        marginal1 = np.sum(value1_lst * solution) / (total_weight + 1e-6)\n        marginal2 = np.sum(value2_lst * solution) / (total_weight + 1e-6)\n\n        # Combine marginal improvements with current objective values\n        return marginal1 * objective[0] + marginal2 * objective[1]\n\n    # Evaluate all solutions and select the most promising one\n    evaluated = [(evaluate_promisingness(sol, obj), sol) for sol, obj in archive]\n    evaluated.sort(reverse=True, key=lambda x: x[0])\n    base_solution = evaluated[0][1].copy()\n\n    # Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider swapping\n    subset_size = min(5, N)\n    indices = random.sample(range(N), subset_size)\n\n    # Step 2: For each selected item, decide to flip or swap with another\n    for i in indices:\n        if random.random() < 0.7:  # 70% chance to flip\n            if new_solution[i] == 1:\n                # Check if removing the item keeps the solution feasible\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Check if adding the item keeps the solution feasible\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n        else:  # 30% chance to swap with another item\n            j = random.choice([x for x in range(N) if x != i])\n            # Check if swapping keeps the solution feasible\n            delta = weight_lst[i] - weight_lst[j]\n            if np.sum(weight_lst * new_solution) + delta <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply probabilistic flipping to explore more neighbors\n    for i in range(N):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.435421740474464,
            -17.94921824562523
        ]
    }
]