[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest objective values, then applies a hybrid local search combining item swaps and random perturbations to generate a feasible neighbor solution while ensuring the total weight does not exceed the capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor via hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly swap items between included and excluded (if feasible)\n    included = np.where(new_solution == 1)[0]\n    excluded = np.where(new_solution == 0)[0]\n\n    if len(included) > 0 and len(excluded) > 0:\n        swap_candidates = random.sample(list(included), min(3, len(included)))\n        for i in swap_candidates:\n            # Try to remove item i and add a random excluded item\n            temp_weight = current_weight - weight_lst[i]\n            possible_adds = [j for j in excluded if temp_weight + weight_lst[j] <= capacity]\n            if possible_adds:\n                j = random.choice(possible_adds)\n                new_solution[i] = 0\n                new_solution[j] = 1\n                current_weight = temp_weight + weight_lst[j]\n\n    # Step 2: Random perturbation (flip a small number of items if feasible)\n    flip_indices = random.sample(range(len(new_solution)), min(2, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -18.778469514591507,
            -18.433732729431092
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines item swaps, flips, and adaptive neighborhood exploration to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives as a starting point\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate candidate solutions using hybrid local search\n    candidates = []\n    n_items = len(base_solution)\n\n    # 1. Random item flip with feasibility check\n    flip_idx = np.random.choice(n_items)\n    new_solution = base_solution.copy()\n    if new_solution[flip_idx] == 1:\n        if current_weight - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n            candidates.append(new_solution.copy())\n    else:\n        if current_weight + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n            candidates.append(new_solution.copy())\n\n    # 2. Swap two items if feasible\n    if n_items >= 2:\n        idx1, idx2 = np.random.choice(n_items, 2, replace=False)\n        new_solution = base_solution.copy()\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = (new_solution[idx2] - new_solution[idx1]) * (weight_lst[idx1] - weight_lst[idx2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                candidates.append(new_solution.copy())\n\n    # 3. Adaptive neighborhood: add/remove items with highest marginal gain\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal gains with randomness\n    combined_gain = marginal_gain1 + marginal_gain2 + np.random.rand(n_items) * 0.1\n\n    # Select top k items to consider\n    k = min(5, n_items)\n    top_indices = np.argsort(combined_gain)[-k:]\n\n    for idx in top_indices:\n        new_solution = base_solution.copy()\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                candidates.append(new_solution.copy())\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                candidates.append(new_solution.copy())\n\n    if not candidates:\n        # If no candidates found, return a slightly modified version of the base solution\n        new_solution = base_solution.copy()\n        # Try to flip a random item that doesn't violate capacity\n        for _ in range(10):\n            flip_idx = np.random.choice(n_items)\n            if new_solution[flip_idx] == 1:\n                if current_weight - weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 0\n                    break\n            else:\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    break\n        return new_solution\n\n    # Select the best candidate based on combined objective improvement\n    best_candidate = None\n    best_score = -float('inf')\n\n    for candidate in candidates:\n        candidate_weight = np.sum(weight_lst * candidate)\n        if candidate_weight > capacity:\n            continue\n\n        candidate_value1 = np.sum(value1_lst * candidate)\n        candidate_value2 = np.sum(value2_lst * candidate)\n\n        # Calculate improvement score\n        improvement1 = candidate_value1 - current_value1\n        improvement2 = candidate_value2 - current_value2\n        score = improvement1 + improvement2\n\n        if score > best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    return best_candidate if best_candidate is not None else base_solution.copy()\n\n",
        "score": [
            -19.175428418766153,
            -18.319888943682244
        ]
    }
]