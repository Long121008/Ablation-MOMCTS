[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted random selection favoring solutions with higher potential for improvement, then applies a hybrid local search combining item swaps with a greedy neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine swap with greedy neighborhood exploration\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Try swapping out one item and adding another greedily\n    if len(candidates) > 0 and len(non_candidates) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(candidates)\n        temp_weight = current_weight - weight_lst[remove_idx]\n\n        # Find the best item to add that fits within capacity\n        best_add_idx = -1\n        best_improvement = -float('inf')\n\n        for add_idx in non_candidates:\n            if temp_weight + weight_lst[add_idx] <= capacity:\n                # Calculate improvement in both objectives\n                improvement1 = value1_lst[add_idx] - value1_lst[remove_idx]\n                improvement2 = value2_lst[add_idx] - value2_lst[remove_idx]\n                combined_improvement = improvement1 + improvement2  # Simple heuristic\n\n                if combined_improvement > best_improvement:\n                    best_improvement = combined_improvement\n                    best_add_idx = add_idx\n\n        if best_add_idx != -1:\n            new_solution[remove_idx] = 0\n            new_solution[best_add_idx] = 1\n\n    # If no improvement found, perform a random flip\n    if np.array_equal(new_solution, base_solution):\n        flip_pos = random.choice(range(len(new_solution)))\n        if new_solution[flip_pos] == 1:\n            if current_weight - weight_lst[flip_pos] >= 0:\n                new_solution[flip_pos] = 0\n        else:\n            if current_weight + weight_lst[flip_pos] <= capacity:\n                new_solution[flip_pos] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.605167221427585,
            -18.17273753544476
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted random selection favoring solutions with higher potential for improvement, then applies a hybrid local search combining item swaps with a greedy neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine swap with greedy neighborhood exploration\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Try swapping out one item and adding another greedily\n    if len(candidates) > 0 and len(non_candidates) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(candidates)\n        temp_weight = current_weight - weight_lst[remove_idx]\n\n        # Find the best item to add that fits within capacity\n        best_add_idx = -1\n        best_improvement = -float('inf')\n\n        for add_idx in non_candidates:\n            if temp_weight + weight_lst[add_idx] <= capacity:\n                # Calculate improvement in both objectives\n                improvement1 = value1_lst[add_idx] - value1_lst[remove_idx]\n                improvement2 = value2_lst[add_idx] - value2_lst[remove_idx]\n                combined_improvement = improvement1 + improvement2  # Simple heuristic\n\n                if combined_improvement > best_improvement:\n                    best_improvement = combined_improvement\n                    best_add_idx = add_idx\n\n        if best_add_idx != -1:\n            new_solution[remove_idx] = 0\n            new_solution[best_add_idx] = 1\n\n    # If no improvement found, perform a random flip\n    if np.array_equal(new_solution, base_solution):\n        flip_pos = random.choice(range(len(new_solution)))\n        if new_solution[flip_pos] == 1:\n            if current_weight - weight_lst[flip_pos] >= 0:\n                new_solution[flip_pos] = 0\n        else:\n            if current_weight + weight_lst[flip_pos] <= capacity:\n                new_solution[flip_pos] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.605167221427585,
            -18.17273753544476
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted random selection favoring solutions with higher potential for improvement, then applies a hybrid local search combining item swaps with a greedy neighborhood exploration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: combine swap with greedy neighborhood exploration\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Try swapping out one item and adding another greedily\n    if len(candidates) > 0 and len(non_candidates) > 0:\n        # Randomly select an item to remove\n        remove_idx = random.choice(candidates)\n        temp_weight = current_weight - weight_lst[remove_idx]\n\n        # Find the best item to add that fits within capacity\n        best_add_idx = -1\n        best_improvement = -float('inf')\n\n        for add_idx in non_candidates:\n            if temp_weight + weight_lst[add_idx] <= capacity:\n                # Calculate improvement in both objectives\n                improvement1 = value1_lst[add_idx] - value1_lst[remove_idx]\n                improvement2 = value2_lst[add_idx] - value2_lst[remove_idx]\n                combined_improvement = improvement1 + improvement2  # Simple heuristic\n\n                if combined_improvement > best_improvement:\n                    best_improvement = combined_improvement\n                    best_add_idx = add_idx\n\n        if best_add_idx != -1:\n            new_solution[remove_idx] = 0\n            new_solution[best_add_idx] = 1\n\n    # If no improvement found, perform a random flip\n    if np.array_equal(new_solution, base_solution):\n        flip_pos = random.choice(range(len(new_solution)))\n        if new_solution[flip_pos] == 1:\n            if current_weight - weight_lst[flip_pos] >= 0:\n                new_solution[flip_pos] = 0\n        else:\n            if current_weight + weight_lst[flip_pos] <= capacity:\n                new_solution[flip_pos] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.605167221427585,
            -18.17273753544476
        ]
    }
]