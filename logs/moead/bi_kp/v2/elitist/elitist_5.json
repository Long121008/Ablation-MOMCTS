[
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function that emphasizes individual objective values more significantly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 * obj[1]/max_v2) for _, obj in archive]  # Changed to product of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(5):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 2 + value2_lst * 3) / weight_lst  # Weighted value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(5, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 2 + value2_lst * 3) / weight_lst  # Weighted value-to-weight ratio\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.475583618576852,
            -19.010276108248554
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 * obj[1]/max_v2) for _, obj in archive]  # Product of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(2):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(2, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.6971695136679,
            -17.589979162866808
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search that combines probabilistic item addition/removal with a biased random walk to explore the neighborhood while maintaining feasibility, favoring solutions that improve both objectives in a balanced manner.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = objectives / np.sum(objectives) if np.sum(objectives) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for _ in range(3):\n        if random.random() < 0.6:\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                contributions = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n                probabilities = contributions[available_items] / np.sum(contributions[available_items])\n                add_idx = random.choices(available_items, weights=probabilities, k=1)[0]\n\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n                    current_weight += weight_lst[add_idx]\n        else:\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) > 0:\n                contributions = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n                probabilities = 1 / (contributions[selected_items] + 1e-6)\n                probabilities /= np.sum(probabilities)\n                remove_idx = random.choices(selected_items, weights=probabilities, k=1)[0]\n\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    if np.sum(new_solution) == 0 and len(weight_lst) > 0:\n        min_weight_idx = np.argmin(weight_lst)\n        if weight_lst[min_weight_idx] <= capacity:\n            new_solution[min_weight_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.56239444872832,
            -18.744827626267806
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 + obj[1]/max_v2) for _, obj in archive]  # Changed to sum instead of product\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Reduced trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.204560256859423,
            -18.536946752989312
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function by considering the sum of normalized objectives with different weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 * obj[1]/max_v2) for _, obj in archive]  # Product of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(2):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 0.7 + value2_lst * 0.3) / weight_lst  # Different weight combination\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(2, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 0.3 + value2_lst * 0.7) / weight_lst  # Different weight combination\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.6971695136679,
            -17.589979162866808
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function that emphasizes individual objective values more significantly.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 * obj[1]/max_v2) for _, obj in archive]  # Changed to product of normalized objectives\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(5):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst * 2 + value2_lst * 3) / weight_lst  # Weighted value-to-weight ratio\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(5, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst * 2 + value2_lst * 3) / weight_lst  # Weighted value-to-weight ratio\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.475583618576852,
            -19.010276108248554
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1) * (obj[1]/max_v2) for _, obj in archive]  # Changed to product instead of sum\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Reduced trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.170230436380553,
            -18.55775908818245
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a tournament selection based on the dominance count of each solution, then applies a hybrid local search that combines item swaps with a probabilistic neighborhood exploration prioritizing items with high value-to-weight ratios, while ensuring feasibility through a capacity-aware item selection strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(5, len(archive))\n    selected_indices = random.sample(range(len(archive)), tournament_size)\n    selected_idx = max(selected_indices, key=lambda i: sum(1 for j in selected_indices if archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]))\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios for both objectives\n    vw_ratio1 = value1_lst / weight_lst\n    vw_ratio2 = value2_lst / weight_lst\n    combined_ratio = (vw_ratio1 + vw_ratio2) / 2\n\n    # Probabilistic neighborhood exploration with combined ratio\n    for _ in range(5):\n        candidates = np.where(new_solution == 1)[0]\n        non_candidates = np.where(new_solution == 0)[0]\n\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low combined ratio\n            remove_candidates = sorted(candidates, key=lambda i: combined_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high combined ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -combined_ratio[i])\n\n                best_add_indices = []\n                temp_weight_check = temp_weight\n                for i in sorted_items:\n                    if temp_weight_check + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight_check += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n                    current_weight = temp_weight_check\n\n    # If no improvement, perform a capacity-aware flip\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(combined_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.087182662881773,
            -18.632184663896055
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a tournament selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios for each objective separately while ensuring feasibility, and uses a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), k=2)\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    selected_idx = selected_idx[0] if (archive[selected_idx[0]][1][0]/max_v1 * archive[selected_idx[0]][1][1]/max_v2) > (archive[selected_idx[1]][1][0]/max_v1 * archive[selected_idx[1]][1][1]/max_v2) else selected_idx[1]\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search\n    for _ in range(2):\n        # Remove items with low value-to-weight ratio for each objective\n        vw1_ratio = value1_lst / weight_lst\n        vw2_ratio = value2_lst / weight_lst\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            remove_indices = random.sample(list(remove_candidates), min(2, len(remove_candidates)))\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Add items with high value-to-weight ratio for each objective\n            remaining_capacity = capacity - temp_weight\n            available_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n            if len(available_items) > 0:\n                sorted_items_v1 = sorted(available_items, key=lambda i: -vw1_ratio[i])\n                sorted_items_v2 = sorted(available_items, key=lambda i: -vw2_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items_v1[:2]:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n                for i in sorted_items_v2[:2]:\n                    if i not in best_add_indices and temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        flip_candidates = np.argsort(vw1_ratio + vw2_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.38706587139096,
            -17.924689083967895
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1) * (obj[1]/max_v2) for _, obj in archive]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(5):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(5, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.9916569938734,
            -18.63504314300442
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search that combines probabilistic item addition/removal with a biased random walk to explore the neighborhood while maintaining feasibility, favoring solutions that improve both objectives in a balanced manner.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([sum(obj) for _, obj in archive])\n    weights = objectives / np.sum(objectives) if np.sum(objectives) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for _ in range(3):\n        if random.random() < 0.6:\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                contributions = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n                probabilities = contributions[available_items] / np.sum(contributions[available_items])\n                add_idx = random.choices(available_items, weights=probabilities, k=1)[0]\n\n                if current_weight + weight_lst[add_idx] <= capacity:\n                    new_solution[add_idx] = 1\n                    current_weight += weight_lst[add_idx]\n        else:\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) > 0:\n                contributions = (value1_lst * value2_lst) / (weight_lst + 1e-6)\n                probabilities = 1 / (contributions[selected_items] + 1e-6)\n                probabilities /= np.sum(probabilities)\n                remove_idx = random.choices(selected_items, weights=probabilities, k=1)[0]\n\n                new_solution[remove_idx] = 0\n                current_weight -= weight_lst[remove_idx]\n\n    if np.sum(new_solution) == 0 and len(weight_lst) > 0:\n        min_weight_idx = np.argmin(weight_lst)\n        if weight_lst[min_weight_idx] <= capacity:\n            new_solution[min_weight_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -18.56239444872832,
            -18.744827626267806
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1) * (obj[1]/max_v2) for _, obj in archive]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(5):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(5, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.94840858425457,
            -18.660567511152152
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the sum of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility, and uses a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1 + obj[1]/max_v2) for _, obj in archive]  # Changed to sum instead of product\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(3):  # Reduced trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(3, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -19.204560256859423,
            -18.536946752989312
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on the product of normalized objective values, then applies a hybrid local search combining item swaps with a probabilistic neighborhood exploration that prioritizes items with high value-to-weight ratios while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    max_v1 = max(obj[0] for _, obj in archive) if archive else 1\n    max_v2 = max(obj[1] for _, obj in archive) if archive else 1\n    weights = [(obj[0]/max_v1) * (obj[1]/max_v2) for _, obj in archive]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    non_candidates = np.where(new_solution == 0)[0]\n\n    # Probabilistic neighborhood exploration with value-to-weight ratio\n    for _ in range(5):  # Increased trials\n        if len(candidates) > 0 and len(non_candidates) > 0:\n            # Select items to remove based on low value-to-weight ratio\n            vw_ratio = (value1_lst + value2_lst) / weight_lst\n            remove_candidates = sorted(candidates, key=lambda i: vw_ratio[i])\n            num_remove = random.randint(1, min(5, len(candidates)))\n            remove_indices = random.sample(remove_candidates[:num_remove], num_remove)\n            temp_weight = current_weight - np.sum(weight_lst[remove_indices])\n\n            # Find best items to add based on high value-to-weight ratio\n            remaining_capacity = capacity - temp_weight\n            available_items = [i for i in non_candidates if weight_lst[i] <= remaining_capacity]\n            if available_items:\n                sorted_items = sorted(available_items, key=lambda i: -vw_ratio[i])\n\n                best_add_indices = []\n                for i in sorted_items:\n                    if temp_weight + weight_lst[i] <= capacity:\n                        best_add_indices.append(i)\n                        temp_weight += weight_lst[i]\n\n                if best_add_indices:\n                    for idx in remove_indices:\n                        new_solution[idx] = 0\n                    for idx in best_add_indices:\n                        new_solution[idx] = 1\n\n    # If no improvement, perform a targeted flip\n    if np.array_equal(new_solution, base_solution):\n        # Flip items with lowest value-to-weight ratio\n        vw_ratio = (value1_lst + value2_lst) / weight_lst\n        flip_candidates = np.argsort(vw_ratio)\n        for i in flip_candidates:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    break\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -18.9916569938734,
            -18.63504314300442
        ]
    }
]