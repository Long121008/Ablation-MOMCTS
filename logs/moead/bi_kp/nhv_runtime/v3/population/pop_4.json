[
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7689353162418655,
            1.299185574054718
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective values and low weight usage, then applies a hybrid local search combining random flips and value-based swaps, but with a different scoring function that emphasizes the geometric mean of normalized objectives and weight ratio, and adjusts the local search parameters to explore more aggressively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest geometric mean of normalized objectives and weight ratio)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.dot(sol, weight_lst) for sol in solutions])\n    normalized = objectives / np.max(objectives, axis=0)\n    geo_mean = np.sqrt(normalized[:, 0] * normalized[:, 1])\n    scores = geo_mean * (weights / capacity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adjusted parameters\n    for _ in range(7):  # Increased attempts\n        # Random flip with high-value-density item preference\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            densities = (value1_lst[candidates] * value2_lst[candidates]) / (weight_lst[candidates] ** 2)\n            item = np.random.choice(candidates, p=densities/np.sum(densities))\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Value-density-based swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select lowest density item to remove\n            in_densities = (value1_lst[in_items] * value2_lst[in_items]) / (weight_lst[in_items] ** 2)\n            remove_item = in_items[np.argmin(in_densities)]\n\n            # Select highest density item to add\n            out_densities = (value1_lst[out_items] * value2_lst[out_items]) / (weight_lst[out_items] ** 2)\n            add_item = out_items[np.argmax(out_densities)]\n\n            # Check feasibility\n            temp_weight = np.dot(new_solution, weight_lst) - weight_lst[remove_item] + weight_lst[add_item]\n            if temp_weight <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[remove_item] = 0\n                temp_solution[add_item] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9662340067546548,
            6.186157733201981
        ]
    }
]