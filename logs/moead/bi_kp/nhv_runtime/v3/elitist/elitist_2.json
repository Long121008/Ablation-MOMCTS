[
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7689353162418655,
            1.299185574054718
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective values and low weight usage, then applies a hybrid local search combining random flips and value-based swaps, but with a different scoring function that emphasizes the ratio of objective values to weight, and adjusts the local search parameters to explore more aggressively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest ratio of normalized objectives to weight)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.dot(sol, weight_lst) for sol in solutions])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = (normalized.sum(axis=1) / weights) * (weights / capacity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adjusted parameters\n    for _ in range(5):  # Increased attempts\n        # Random flip with high-value-density item preference\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            densities = (value1_lst[candidates] + value2_lst[candidates]) / weight_lst[candidates]\n            item = np.random.choice(candidates, p=densities/np.sum(densities))\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Value-density-based swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select lowest density item to remove\n            in_densities = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            remove_item = in_items[np.argmin(in_densities)]\n\n            # Select highest density item to add\n            out_densities = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            add_item = out_items[np.argmax(out_densities)]\n\n            # Check feasibility\n            temp_weight = np.dot(new_solution, weight_lst) - weight_lst[remove_item] + weight_lst[add_item]\n            if temp_weight <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[remove_item] = 0\n                temp_solution[add_item] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9238064448228166,
            4.070809632539749
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on its objective values and weight efficiency, then applies a hybrid local search that combines value-driven flips with a novel \"objective-balanced\" swap strategy, ensuring feasibility through dynamic weight adjustment while prioritizing both objectives in a balanced manner.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective balance (value1 + value2) and lowest weight usage\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    total_values = objectives.sum(axis=1)\n    weights = np.array([np.dot(sol, weight_lst) for sol in solutions])\n    efficiency = total_values / (weights + 1e-8)  # Avoid division by zero\n    selected_idx = np.argmax(efficiency)\n    base_solution = solutions[selected_idx].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n    current_weight = np.dot(new_solution, weight_lst)\n\n    # Hybrid local search: value-driven flips with objective-balanced swaps\n    for _ in range(3):  # Number of attempts\n        # Value-driven flip: remove low-value items first\n        in_items = np.where(new_solution == 1)[0]\n        if len(in_items) > 0:\n            item_values = value1_lst[in_items] + value2_lst[in_items]\n            remove_candidate = in_items[np.argmin(item_values)]\n            temp_weight = current_weight - weight_lst[remove_candidate]\n            if temp_weight <= capacity:\n                new_solution[remove_candidate] = 0\n                current_weight = temp_weight\n                continue\n\n        # Objective-balanced swap: prioritize items that improve both objectives\n        out_items = np.where(new_solution == 0)[0]\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Calculate potential improvements\n            potential_gains = []\n            for in_item in in_items:\n                for out_item in out_items:\n                    weight_diff = weight_lst[out_item] - weight_lst[in_item]\n                    if current_weight + weight_diff <= capacity:\n                        value1_diff = value1_lst[out_item] - value1_lst[in_item]\n                        value2_diff = value2_lst[out_item] - value2_lst[in_item]\n                        # Prefer swaps that improve both objectives\n                        if value1_diff > 0 and value2_diff > 0:\n                            potential_gains.append((value1_diff + value2_diff, in_item, out_item))\n\n            if potential_gains:\n                # Select swap with highest combined improvement\n                best_gain, best_in, best_out = max(potential_gains)\n                new_solution[best_in] = 0\n                new_solution[best_out] = 1\n                current_weight += weight_lst[best_out] - weight_lst[best_in]\n\n    return new_solution\n\n",
        "score": [
            -0.8811808610506524,
            1.361110895872116
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight usage, then applies a hybrid local search combining random flips and value-based swaps to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random flips and value-based swaps\n    for _ in range(3):  # Number of attempts\n        # Random flip with high-value item preference\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            item = random.choice(candidates)\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Value-based swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select highest value item to remove\n            in_values = value1_lst[in_items] + value2_lst[in_items]\n            remove_item = in_items[np.argmax(in_values)]\n\n            # Select highest value item to add\n            out_values = value1_lst[out_items] + value2_lst[out_items]\n            add_item = out_items[np.argmax(out_values)]\n\n            # Check feasibility\n            temp_weight = np.dot(new_solution, weight_lst) - weight_lst[remove_item] + weight_lst[add_item]\n            if temp_weight <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[remove_item] = 0\n                temp_solution[add_item] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8143272505562531,
            0.7539661824703217
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high objective values and low weight usage, then applies a hybrid local search combining random flips and value-based swaps, but with a different scoring function that emphasizes the ratio of objective values to weight, and adjusts the local search parameters to explore more aggressively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest ratio of normalized objectives to weight)\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([np.dot(sol, weight_lst) for sol in solutions])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = (normalized.sum(axis=1) / weights) * (weights / capacity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adjusted parameters\n    for _ in range(5):  # Increased attempts\n        # Random flip with high-value-density item preference\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            densities = (value1_lst[candidates] + value2_lst[candidates]) / weight_lst[candidates]\n            item = np.random.choice(candidates, p=densities/np.sum(densities))\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Value-density-based swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select lowest density item to remove\n            in_densities = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n            remove_item = in_items[np.argmin(in_densities)]\n\n            # Select highest density item to add\n            out_densities = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n            add_item = out_items[np.argmax(out_densities)]\n\n            # Check feasibility\n            temp_weight = np.dot(new_solution, weight_lst) - weight_lst[remove_item] + weight_lst[add_item]\n            if temp_weight <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[remove_item] = 0\n                temp_solution[add_item] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9238064448228166,
            4.070809632539749
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a novel local search that flips items based on their diversity-aware marginal contributions, using a weighted combination of objective values and item uniqueness, while ensuring feasibility through a dynamic capacity-aware adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate diversity-aware marginal contributions\n    # Weighted combination of objective values and item uniqueness\n    uniqueness = 1 / (np.sum(archive[0][0], axis=0) + 1)  # Avoid division by zero\n    marginal1 = value1_lst * uniqueness / weight_lst\n    marginal2 = value2_lst * uniqueness / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(10, len(new_solution))  # Flip up to 10 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    # Dynamic capacity-aware adjustment\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, perform a more aggressive flip\n    if np.array_equal(new_solution, selected_solution):\n        # Find the item with the highest diversity-aware marginal\n        best_idx = np.argmax(combined_marginal)\n        if new_solution[best_idx] == 1:\n            if current_weight - weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 0\n        else:\n            if current_weight + weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7986658775729618,
            0.6032519042491913
        ]
    }
]