[
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7689353162418655,
            1.299185574054718
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight usage, then applies a hybrid local search combining random flips and value-based swaps to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random flips and value-based swaps\n    for _ in range(3):  # Number of attempts\n        # Random flip with high-value item preference\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            item = random.choice(candidates)\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Value-based swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select highest value item to remove\n            in_values = value1_lst[in_items] + value2_lst[in_items]\n            remove_item = in_items[np.argmax(in_values)]\n\n            # Select highest value item to add\n            out_values = value1_lst[out_items] + value2_lst[out_items]\n            add_item = out_items[np.argmax(out_values)]\n\n            # Check feasibility\n            temp_weight = np.dot(new_solution, weight_lst) - weight_lst[remove_item] + weight_lst[add_item]\n            if temp_weight <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[remove_item] = 0\n                temp_solution[add_item] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8002371058611607,
            2.0849095582962036
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7689353162418655,
            1.299185574054718
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight usage, then applies a hybrid local search combining random flips and value-based swaps to generate a feasible neighbor solution while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random flips and value-based swaps\n    for _ in range(3):  # Number of attempts\n        # Random flip with high-value item preference\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) > 0:\n            item = random.choice(candidates)\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.dot(temp_solution, weight_lst) <= capacity:\n                new_solution = temp_solution\n                continue\n\n        # Value-based swap\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select highest value item to remove\n            in_values = value1_lst[in_items] + value2_lst[in_items]\n            remove_item = in_items[np.argmax(in_values)]\n\n            # Select highest value item to add\n            out_values = value1_lst[out_items] + value2_lst[out_items]\n            add_item = out_items[np.argmax(out_values)]\n\n            # Check feasibility\n            temp_weight = np.dot(new_solution, weight_lst) - weight_lst[remove_item] + weight_lst[add_item]\n            if temp_weight <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[remove_item] = 0\n                temp_solution[add_item] = 1\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8002371058611607,
            2.0849095582962036
        ]
    }
]