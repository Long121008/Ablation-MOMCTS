[
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7689353162418655,
            1.299185574054718
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9956450712300795,
            0.535682737827301
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9956450712300795,
            0.535682737827301
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9956450712300795,
            0.535682737827301
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9956450712300795,
            0.535682737827301
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9956450712300795,
            0.535682737827301
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.9956450712300795,
            0.535682737827301
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined objective value, then applies a hybrid local search that flips a subset of items based on their marginal contribution to both objectives, while ensuring feasibility through a greedy weight adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal1 = value1_lst / weight_lst\n    marginal2 = value2_lst / weight_lst\n    combined_marginal = marginal1 + marginal2\n\n    # Identify items to flip (top k items with highest combined marginal)\n    k = min(5, len(new_solution))  # Flip up to 5 items\n    top_indices = np.argsort(combined_marginal)[-k:]\n\n    for idx in top_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # If no change was made, flip a random item\n    if np.array_equal(new_solution, selected_solution):\n        idx = np.random.choice(len(new_solution))\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.921772783590152,
            0.46418073773384094
        ]
    }
]