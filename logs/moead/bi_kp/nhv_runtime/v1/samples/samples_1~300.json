[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.45817590907238315,
            5.758057504892349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.45817590907238315,
            5.758057504892349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.45817590907238315,
            5.758057504892349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n",
        "score": [
            -0.8828980235516555,
            2.424465984106064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n",
        "score": [
            -0.8828980235516555,
            2.424465984106064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n",
        "score": [
            -0.8828980235516555,
            2.424465984106064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining item swaps and adaptive flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high objective values and low weight utilization\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol == 1]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive item swap and flip\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swap (swap two items if it improves at least one objective)\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) >= 2:\n        i, j = random.sample(list(candidates), 2)\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Adaptive item flip (flip an item if it improves both objectives)\n    for item in range(len(base_solution)):\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_solution[item] = 0\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8862762572605425,
            10.260523825883865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high objective values and low weight utilization\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol == 1]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive item swap and flip\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swap (swap two items if it improves at least one objective)\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) >= 2:\n        i, j = random.sample(list(candidates), 2)\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Adaptive item flip (flip an item if it improves both objectives)\n    for item in range(len(base_solution)):\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_solution[item] = 0\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with high objective values and low weight utilization, then applies a hybrid local search combining item swaps and adaptive flips to explore the neighborhood while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high objective values and low weight utilization\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol == 1]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive item swap and flip\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swap (swap two items if it improves at least one objective)\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) >= 2:\n        i, j = random.sample(list(candidates), 2)\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Adaptive item flip (flip an item if it improves both objectives)\n    for item in range(len(base_solution)):\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_solution[item] = 0\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8862762572605425,
            10.260523825883865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high objective values and low weight utilization\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(weight_lst[sol == 1]) + 1e-6) for sol, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive item swap and flip\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swap (swap two items if it improves at least one objective)\n    candidates = np.where(base_solution == 1)[0]\n    if len(candidates) >= 2:\n        i, j = random.sample(list(candidates), 2)\n        new_weight = current_weight - weight_lst[i] + weight_lst[j]\n        if new_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Adaptive item flip (flip an item if it improves both objectives)\n    for item in range(len(base_solution)):\n        if new_solution[item] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_solution[item] = 0\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    max_v1 = max(obj[0] for obj in objectives)\n    min_v1 = min(obj[0] for obj in objectives)\n    max_v2 = max(obj[1] for obj in objectives)\n    min_v2 = min(obj[1] for obj in objectives)\n\n    candidates = []\n    for sol, obj in archive:\n        if not (obj[0] == max_v1 or obj[0] == min_v1 or obj[1] == max_v2 or obj[1] == min_v2):\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a base solution from promising candidates\n    base_sol, _ = random.choice(candidates)\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_sol.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to consider for flipping\n    subset_size = max(1, int(np.sqrt(n_items)))\n    indices = random.sample(range(n_items), subset_size)\n\n    # Evaluate the impact of flipping each item in the subset\n    best_flip = None\n    best_improvement = 0\n\n    for i in indices:\n        # Calculate the effect of flipping the i-th item\n        if new_solution[i] == 1:\n            delta_weight = -weight_lst[i]\n            delta_v1 = -value1_lst[i]\n            delta_v2 = -value2_lst[i]\n        else:\n            delta_weight = weight_lst[i]\n            delta_v1 = value1_lst[i]\n            delta_v2 = value2_lst[i]\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight + delta_weight > capacity:\n            continue\n\n        # Calculate a combined improvement metric (weighted sum of both objectives)\n        improvement = 0.5 * delta_v1 + 0.5 * delta_v2\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_flip = i\n\n    # Apply the best flip if found\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Step 3: Apply a second phase of local search (small random perturbation)\n    # Randomly flip a small number of items to escape local optima\n    perturbation_size = max(1, int(np.sqrt(n_items)) // 2)\n    perturbation_indices = random.sample(range(n_items), perturbation_size)\n\n    for i in perturbation_indices:\n        if new_solution[i] == 1:\n            delta_weight = -weight_lst[i]\n        else:\n            delta_weight = weight_lst[i]\n\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight + delta_weight <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.239060418657131,
            3.1898692846298218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    max_v1 = max(obj[0] for obj in objectives)\n    min_v1 = min(obj[0] for obj in objectives)\n    max_v2 = max(obj[1] for obj in objectives)\n    min_v2 = min(obj[1] for obj in objectives)\n\n    candidates = []\n    for sol, obj in archive:\n        if not (obj[0] == max_v1 or obj[0] == min_v1 or obj[1] == max_v2 or obj[1] == min_v2):\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    # Randomly select a base solution from promising candidates\n    base_sol, _ = random.choice(candidates)\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_sol.copy()\n    n_items = len(new_solution)\n\n    # Randomly select a subset of items to consider for flipping\n    subset_size = max(1, int(np.sqrt(n_items)))\n    indices = random.sample(range(n_items), subset_size)\n\n    # Evaluate the impact of flipping each item in the subset\n    best_flip = None\n    best_improvement = 0\n\n    for i in indices:\n        # Calculate the effect of flipping the i-th item\n        if new_solution[i] == 1:\n            delta_weight = -weight_lst[i]\n            delta_v1 = -value1_lst[i]\n            delta_v2 = -value2_lst[i]\n        else:\n            delta_weight = weight_lst[i]\n            delta_v1 = value1_lst[i]\n            delta_v2 = value2_lst[i]\n\n        # Check feasibility\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight + delta_weight > capacity:\n            continue\n\n        # Calculate a combined improvement metric (weighted sum of both objectives)\n        improvement = 0.5 * delta_v1 + 0.5 * delta_v2\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_flip = i\n\n    # Apply the best flip if found\n    if best_flip is not None:\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Step 3: Apply a second phase of local search (small random perturbation)\n    # Randomly flip a small number of items to escape local optima\n    perturbation_size = max(1, int(np.sqrt(n_items)) // 2)\n    perturbation_indices = random.sample(range(n_items), perturbation_size)\n\n    for i in perturbation_indices:\n        if new_solution[i] == 1:\n            delta_weight = -weight_lst[i]\n        else:\n            delta_weight = weight_lst[i]\n\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight + delta_weight <= capacity:\n            new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm selects a random solution from the archive and applies a novel neighborhood structure that combines item swaps with objective-specific perturbations, prioritizing items with high marginal contributions to either objective while maintaining feasibility through a capacity-aware adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items to potentially swap or perturb\n    in_solution = np.where(base_solution == 1)[0]\n    out_solution = np.where(base_solution == 0)[0]\n\n    # Objective-specific perturbation probabilities\n    obj1_prob = 0.6 if len(in_solution) > 0 else 0.0\n    obj2_prob = 0.4 if len(in_solution) > 0 else 0.0\n\n    # Perform objective-specific perturbations\n    for item in in_solution:\n        if random.random() < obj1_prob:\n            # Probabilistically swap with a high-value1 item not in solution\n            if len(out_solution) > 0:\n                candidates = [i for i in out_solution if current_weight - weight_lst[item] + weight_lst[i] <= capacity]\n                if candidates:\n                    best_candidate = max(candidates, key=lambda x: value1_lst[x])\n                    new_solution[item] = 0\n                    new_solution[best_candidate] = 1\n                    current_weight = current_weight - weight_lst[item] + weight_lst[best_candidate]\n                    break\n\n    for item in in_solution:\n        if random.random() < obj2_prob:\n            # Probabilistically swap with a high-value2 item not in solution\n            if len(out_solution) > 0:\n                candidates = [i for i in out_solution if current_weight - weight_lst[item] + weight_lst[i] <= capacity]\n                if candidates:\n                    best_candidate = max(candidates, key=lambda x: value2_lst[x])\n                    new_solution[item] = 0\n                    new_solution[best_candidate] = 1\n                    current_weight = current_weight - weight_lst[item] + weight_lst[best_candidate]\n                    break\n\n    # Add a random high-value item if space allows\n    if current_weight < capacity and len(out_solution) > 0:\n        candidates = [i for i in out_solution if current_weight + weight_lst[i] <= capacity]\n        if candidates:\n            # Choose between value1 and value2 with equal probability\n            if random.random() < 0.5:\n                best_item = max(candidates, key=lambda x: value1_lst[x])\n            else:\n                best_item = max(candidates, key=lambda x: value2_lst[x])\n            new_solution[best_item] = 1\n\n    # Ensure feasibility (minor adjustment if needed)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio until feasible\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.32019667328613366,
            3.277929335832596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items to potentially swap or perturb\n    in_solution = np.where(base_solution == 1)[0]\n    out_solution = np.where(base_solution == 0)[0]\n\n    # Objective-specific perturbation probabilities\n    obj1_prob = 0.6 if len(in_solution) > 0 else 0.0\n    obj2_prob = 0.4 if len(in_solution) > 0 else 0.0\n\n    # Perform objective-specific perturbations\n    for item in in_solution:\n        if random.random() < obj1_prob:\n            # Probabilistically swap with a high-value1 item not in solution\n            if len(out_solution) > 0:\n                candidates = [i for i in out_solution if current_weight - weight_lst[item] + weight_lst[i] <= capacity]\n                if candidates:\n                    best_candidate = max(candidates, key=lambda x: value1_lst[x])\n                    new_solution[item] = 0\n                    new_solution[best_candidate] = 1\n                    current_weight = current_weight - weight_lst[item] + weight_lst[best_candidate]\n                    break\n\n    for item in in_solution:\n        if random.random() < obj2_prob:\n            # Probabilistically swap with a high-value2 item not in solution\n            if len(out_solution) > 0:\n                candidates = [i for i in out_solution if current_weight - weight_lst[item] + weight_lst[i] <= capacity]\n                if candidates:\n                    best_candidate = max(candidates, key=lambda x: value2_lst[x])\n                    new_solution[item] = 0\n                    new_solution[best_candidate] = 1\n                    current_weight = current_weight - weight_lst[item] + weight_lst[best_candidate]\n                    break\n\n    # Add a random high-value item if space allows\n    if current_weight < capacity and len(out_solution) > 0:\n        candidates = [i for i in out_solution if current_weight + weight_lst[i] <= capacity]\n        if candidates:\n            # Choose between value1 and value2 with equal probability\n            if random.random() < 0.5:\n                best_item = max(candidates, key=lambda x: value1_lst[x])\n            else:\n                best_item = max(candidates, key=lambda x: value2_lst[x])\n            new_solution[best_item] = 1\n\n    # Ensure feasibility (minor adjustment if needed)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio until feasible\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9310630187472508,
            4.768872857093811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9310630187472508,
            4.768872857093811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The new algorithm combines a diversity-aware selection of solutions with a hybrid local search that prioritizes items based on their marginal contribution to both objectives while maintaining feasibility through a controlled perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high diversity potential\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - np.mean([s[0] for s in archive], axis=0)))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and marginal contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Hybrid local search: controlled perturbation\n    for item in np.argsort(-combined_marginal):\n        if base_solution[item] == 1:\n            if np.random.random() < 0.2:  # Lower probability to remove\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and np.random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(weight_lst / (combined_marginal + 1e-10)):\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7497123652496318,
            8.944656401872635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a solution with high diversity potential\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - np.mean([s[0] for s in archive], axis=0)))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and marginal contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Hybrid local search: controlled perturbation\n    for item in np.argsort(-combined_marginal):\n        if base_solution[item] == 1:\n            if np.random.random() < 0.2:  # Lower probability to remove\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and np.random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(weight_lst / (combined_marginal + 1e-10)):\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of dominance and diversity criteria, then applies a novel local search strategy that combines item swapping with a value-weighted randomized selection to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select solution with best combined value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify candidate items for swap\n    in_solution = np.where(base_solution == 1)[0]\n    out_solution = np.where(base_solution == 0)[0]\n\n    if len(in_solution) == 0 or len(out_solution) == 0:\n        return base_solution\n\n    # Calculate value ratios for weighted random selection\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Select items to swap with weighted probability\n    swap_from = np.random.choice(in_solution, p=value_ratios[in_solution]/np.sum(value_ratios[in_solution]))\n    swap_to = np.random.choice(out_solution, p=value_ratios[out_solution]/np.sum(value_ratios[out_solution]))\n\n    # Generate neighbor by swapping\n    neighbor = base_solution.copy()\n    neighbor[swap_from] = 0\n    neighbor[swap_to] = 1\n\n    # Ensure feasibility\n    new_weight = current_weight - weight_lst[swap_from] + weight_lst[swap_to]\n    if new_weight > capacity:\n        # If swap is infeasible, try to remove least valuable item\n        in_solution = np.where(neighbor == 1)[0]\n        if len(in_solution) > 0:\n            worst_item = min(in_solution, key=lambda x: value_ratios[x])\n            neighbor[worst_item] = 0\n\n    return neighbor\n\n",
        "score": [
            -0.3326787990190653,
            7.028292626142502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select solution with best combined value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify candidate items for swap\n    in_solution = np.where(base_solution == 1)[0]\n    out_solution = np.where(base_solution == 0)[0]\n\n    if len(in_solution) == 0 or len(out_solution) == 0:\n        return base_solution\n\n    # Calculate value ratios for weighted random selection\n    value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Select items to swap with weighted probability\n    swap_from = np.random.choice(in_solution, p=value_ratios[in_solution]/np.sum(value_ratios[in_solution]))\n    swap_to = np.random.choice(out_solution, p=value_ratios[out_solution]/np.sum(value_ratios[out_solution]))\n\n    # Generate neighbor by swapping\n    neighbor = base_solution.copy()\n    neighbor[swap_from] = 0\n    neighbor[swap_to] = 1\n\n    # Ensure feasibility\n    new_weight = current_weight - weight_lst[swap_from] + weight_lst[swap_to]\n    if new_weight > capacity:\n        # If swap is infeasible, try to remove least valuable item\n        in_solution = np.where(neighbor == 1)[0]\n        if len(in_solution) > 0:\n            worst_item = min(in_solution, key=lambda x: value_ratios[x])\n            neighbor[worst_item] = 0\n\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4634047957731969,
            4.600763976573944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a hybrid local search that combines item swaps and flips to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj_idx] - objectives[sorted_indices[i-1], obj_idx]) / (objectives[sorted_indices[-1], obj_idx] - objectives[sorted_indices[0], obj_idx] + 1e-10)\n\n    # Select a solution with low crowding distance (less explored region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip one item\n    items_in = np.where(base_solution == 1)[0]\n    items_out = np.where(base_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0 and np.random.rand() < 0.7:\n        # Swap two items (one in, one out)\n        item_in = np.random.choice(items_in)\n        item_out = np.random.choice(items_out)\n        new_solution[item_in] = 0\n        new_solution[item_out] = 1\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            # If infeasible, revert the swap and flip a random item\n            new_solution[item_in] = 1\n            new_solution[item_out] = 0\n            item_to_flip = np.random.choice(items_in)\n            new_solution[item_to_flip] = 0\n    else:\n        # Flip a random item\n        item_to_flip = np.random.choice(np.arange(len(weight_lst)))\n        new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n    # Ensure feasibility by removing items if needed\n    while np.sum(weight_lst * new_solution) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        # Remove the item with the smallest ratio of (value1 + value2) / weight\n        ratios = (value1_lst[items_in] + value2_lst[items_in]) / weight_lst[items_in]\n        item_to_remove = items_in[np.argmin(ratios)]\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8759035581962222,
            3.886027008295059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for obj_idx in range(2):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj_idx] - objectives[sorted_indices[i-1], obj_idx]) / (objectives[sorted_indices[-1], obj_idx] - objectives[sorted_indices[0], obj_idx] + 1e-10)\n\n    # Select a solution with low crowding distance (less explored region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: swap two items or flip one item\n    items_in = np.where(base_solution == 1)[0]\n    items_out = np.where(base_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0 and np.random.rand() < 0.7:\n        # Swap two items (one in, one out)\n        item_in = np.random.choice(items_in)\n        item_out = np.random.choice(items_out)\n        new_solution[item_in] = 0\n        new_solution[item_out] = 1\n        # Check feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            # If infeasible, revert the swap and flip a random item\n            new_solution[item_in] = 1\n            new_solution[item_out] = 0\n            item_to_flip = np.random.choice(items_in)\n            new_solution[item_to_flip] = 0\n    else:\n        # Flip a random item\n        item_to_flip = np.random.choice(np.arange(len(weight_lst)))\n        new_solution[item_to_flip] = 1 - new_solution[item_to_flip]\n\n    # Ensure feasibility by removing items if needed\n    while np.sum(weight_lst * new_solution) > capacity:\n        items_in = np.where(new_solution == 1)[0]\n        if len(items_in) == 0:\n            break\n        # Remove the item with the smallest ratio of (value1 + value2) / weight\n        ratios = (value1_lst[items_in] + value2_lst[items_in]) / weight_lst[items_in]\n        item_to_remove = items_in[np.argmin(ratios)]\n        new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This new algorithm selects a solution from the archive with a high combined objective score, identifies promising items to swap or flip, and applies a hybrid local search strategy that combines greedy addition of high-value items and removal of low-value items to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Calculate the current total weight\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    new_weight = np.sum(weight_lst * neighbor)\n    if new_weight > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            # Calculate the value ratio for each available item\n            value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n            best_item = available_items[np.argmax(value_ratios)]\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            new_weight = np.sum(weight_lst * neighbor)\n            if new_weight > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    value_ratios_in = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n                    worst_item = in_solution[np.argmin(value_ratios_in)]\n                    neighbor[worst_item] = 0\n\n    return neighbor\n\n",
        "score": [
            -0.927374303446451,
            1.4551216065883636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Calculate the current total weight\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    new_weight = np.sum(weight_lst * neighbor)\n    if new_weight > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            # Calculate the value ratio for each available item\n            value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n            best_item = available_items[np.argmax(value_ratios)]\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            new_weight = np.sum(weight_lst * neighbor)\n            if new_weight > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    value_ratios_in = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n                    worst_item = in_solution[np.argmin(value_ratios_in)]\n                    neighbor[worst_item] = 0\n\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This new algorithm selects a solution from the archive with a high combined objective score, identifies promising items to swap or flip, and applies a hybrid local search strategy that combines greedy addition of high-value items and removal of low-value items to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Calculate the current total weight\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    new_weight = np.sum(weight_lst * neighbor)\n    if new_weight > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            # Calculate the value ratio for each available item\n            value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n            best_item = available_items[np.argmax(value_ratios)]\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            new_weight = np.sum(weight_lst * neighbor)\n            if new_weight > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    value_ratios_in = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n                    worst_item = in_solution[np.argmin(value_ratios_in)]\n                    neighbor[worst_item] = 0\n\n    return neighbor\n\n",
        "score": [
            -0.927374303446451,
            1.4551216065883636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Calculate the current total weight\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    new_weight = np.sum(weight_lst * neighbor)\n    if new_weight > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            # Calculate the value ratio for each available item\n            value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n            best_item = available_items[np.argmax(value_ratios)]\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            new_weight = np.sum(weight_lst * neighbor)\n            if new_weight > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    value_ratios_in = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n                    worst_item = in_solution[np.argmin(value_ratios_in)]\n                    neighbor[worst_item] = 0\n\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    neighbor = selected_solution.copy()\n\n    # Normalize values for multi-objective consideration\n    norm_value1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    norm_value2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_value = norm_value1 + norm_value2\n\n    # Greedy improvement: add items with highest combined value until no more can be added\n    available_items = np.where(neighbor == 0)[0]\n    while available_items.size > 0:\n        # Select item with highest combined value\n        best_item = available_items[np.argmax(combined_value[available_items])]\n        new_weight = np.sum(weight_lst * neighbor) + weight_lst[best_item]\n\n        if new_weight <= capacity:\n            neighbor[best_item] = 1\n            available_items = np.where(neighbor == 0)[0]\n        else:\n            break\n\n    # Small perturbation: flip one random item to escape local optima\n    in_solution = np.where(neighbor == 1)[0]\n    if in_solution.size > 0:\n        flip_idx = np.random.choice(in_solution)\n        neighbor[flip_idx] = 0\n\n    return neighbor\n\n",
        "score": [
            -0.6852443123635971,
            4.219389826059341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    neighbor = selected_solution.copy()\n\n    # Normalize values for multi-objective consideration\n    norm_value1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    norm_value2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_value = norm_value1 + norm_value2\n\n    # Greedy improvement: add items with highest combined value until no more can be added\n    available_items = np.where(neighbor == 0)[0]\n    while available_items.size > 0:\n        # Select item with highest combined value\n        best_item = available_items[np.argmax(combined_value[available_items])]\n        new_weight = np.sum(weight_lst * neighbor) + weight_lst[best_item]\n\n        if new_weight <= capacity:\n            neighbor[best_item] = 1\n            available_items = np.where(neighbor == 0)[0]\n        else:\n            break\n\n    # Small perturbation: flip one random item to escape local optima\n    in_solution = np.where(neighbor == 1)[0]\n    if in_solution.size > 0:\n        flip_idx = np.random.choice(in_solution)\n        neighbor[flip_idx] = 0\n\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{The novel algorithm combines a dynamic item prioritization based on both objectives with a probabilistic flip mechanism, where items are selected for potential inclusion or exclusion based on their marginal contributions to either objective, while ensuring feasibility through a biased random walk that avoids excessive weight violations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginals with a bias towards the objective with lower current value\n    total_value1, total_value2 = archive[selected_idx][1]\n    if total_value1 < total_value2:\n        combined_marginal = marginal1 * 1.5 + marginal2 * 0.5\n    else:\n        combined_marginal = marginal1 * 0.5 + marginal2 * 1.5\n\n    # Sort items by combined marginal (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform biased random walk\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal changes\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5381740987002155,
            4.5025200843811035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginals with a bias towards the objective with lower current value\n    total_value1, total_value2 = archive[selected_idx][1]\n    if total_value1 < total_value2:\n        combined_marginal = marginal1 * 1.5 + marginal2 * 0.5\n    else:\n        combined_marginal = marginal1 * 0.5 + marginal2 * 1.5\n\n    # Sort items by combined marginal (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform biased random walk\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal changes\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-6))[0].copy()\n\n    # Calculate marginal utility for each item (weighted sum of both objectives)\n    marginal_util = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to consider for addition or removal\n    in_solution = np.where(selected_solution == 1)[0]\n    out_solution = np.where(selected_solution == 0)[0]\n\n    # Generate neighbor by combining high-marginal-utility items\n    neighbor = selected_solution.copy()\n\n    # Try adding the best item not in the solution\n    if len(out_solution) > 0:\n        best_add = max(out_solution, key=lambda x: marginal_util[x])\n        if weight_lst[best_add] <= capacity - np.sum(weight_lst * neighbor):\n            neighbor[best_add] = 1\n\n    # Try removing the worst item in the solution\n    if len(in_solution) > 0:\n        worst_remove = min(in_solution, key=lambda x: marginal_util[x])\n        neighbor[worst_remove] = 0\n\n    # If no change, try swapping a pair of items\n    if np.array_equal(neighbor, selected_solution) and len(in_solution) > 0 and len(out_solution) > 0:\n        swap_in = max(out_solution, key=lambda x: marginal_util[x])\n        swap_out = min(in_solution, key=lambda x: marginal_util[x])\n        if weight_lst[swap_in] - weight_lst[swap_out] <= capacity - np.sum(weight_lst * neighbor):\n            neighbor[swap_in] = 1\n            neighbor[swap_out] = 0\n\n    return neighbor\n\n",
        "score": [
            -0.892495023862607,
            8.419867187738419
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-6))[0].copy()\n\n    # Calculate marginal utility for each item (weighted sum of both objectives)\n    marginal_util = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n\n    # Identify items to consider for addition or removal\n    in_solution = np.where(selected_solution == 1)[0]\n    out_solution = np.where(selected_solution == 0)[0]\n\n    # Generate neighbor by combining high-marginal-utility items\n    neighbor = selected_solution.copy()\n\n    # Try adding the best item not in the solution\n    if len(out_solution) > 0:\n        best_add = max(out_solution, key=lambda x: marginal_util[x])\n        if weight_lst[best_add] <= capacity - np.sum(weight_lst * neighbor):\n            neighbor[best_add] = 1\n\n    # Try removing the worst item in the solution\n    if len(in_solution) > 0:\n        worst_remove = min(in_solution, key=lambda x: marginal_util[x])\n        neighbor[worst_remove] = 0\n\n    # If no change, try swapping a pair of items\n    if np.array_equal(neighbor, selected_solution) and len(in_solution) > 0 and len(out_solution) > 0:\n        swap_in = max(out_solution, key=lambda x: marginal_util[x])\n        swap_out = min(in_solution, key=lambda x: marginal_util[x])\n        if weight_lst[swap_in] - weight_lst[swap_out] <= capacity - np.sum(weight_lst * neighbor):\n            neighbor[swap_in] = 1\n            neighbor[swap_out] = 0\n\n    return neighbor\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This new algorithm employs a dynamic neighborhood exploration strategy that alternates between targeted item removals and probabilistic item additions, prioritizing items with high marginal contributions to both objectives while maintaining feasibility through adaptive capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Phase 1: Remove low-contribution items with probability based on their rank\n    for i, item in enumerate(sorted_items):\n        if new_solution[item] == 1 and random.random() < (i / len(sorted_items)) * 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Phase 2: Add high-contribution items with probability based on their rank\n    for i, item in enumerate(sorted_items):\n        if new_solution[item] == 0 and random.random() < (1 - i / len(sorted_items)) * 0.6:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing the heaviest items if needed\n    if current_weight > capacity:\n        sorted_by_weight = np.argsort(-weight_lst)\n        for item in sorted_by_weight:\n            if new_solution[item] == 1 and current_weight > capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3983579389949119,
            7.189755350351334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Phase 1: Remove low-contribution items with probability based on their rank\n    for i, item in enumerate(sorted_items):\n        if new_solution[item] == 1 and random.random() < (i / len(sorted_items)) * 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Phase 2: Add high-contribution items with probability based on their rank\n    for i, item in enumerate(sorted_items):\n        if new_solution[item] == 0 and random.random() < (1 - i / len(sorted_items)) * 0.6:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing the heaviest items if needed\n    if current_weight > capacity:\n        sorted_by_weight = np.argsort(-weight_lst)\n        for item in sorted_by_weight:\n            if new_solution[item] == 1 and current_weight > capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The new algorithm employs a dynamic marginal contribution-based selection with adaptive probability thresholds, where items are prioritized based on their normalized marginal impact on both objectives, combined with a biased random walk to explore high-potential regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([sum(obj) for _, obj in archive])\n    selection_probs = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and marginal contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic probability thresholds based on current solution quality\n    base_value = np.sum(value1_lst * base_solution) + np.sum(value2_lst * base_solution)\n    prob_threshold = max(0.1, 0.5 - 0.01 * (base_value / (np.sum(value1_lst) + np.sum(value2_lst))))\n\n    # Adaptive local search: biased towards high-marginal items\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < prob_threshold * 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < prob_threshold:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4530845518074748,
            6.291111588478088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([sum(obj) for _, obj in archive])\n    selection_probs = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and marginal contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic probability thresholds based on current solution quality\n    base_value = np.sum(value1_lst * base_solution) + np.sum(value2_lst * base_solution)\n    prob_threshold = max(0.1, 0.5 - 0.01 * (base_value / (np.sum(value1_lst) + np.sum(value2_lst))))\n\n    # Adaptive local search: biased towards high-marginal items\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < prob_threshold * 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < prob_threshold:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This new algorithm uses a dynamic score function that combines normalized marginal contributions of items to both objectives with a temperature-based exploration mechanism, allowing for more controlled and adaptive perturbation of solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = np.array([v1 + v2 for _, (v1, v2) in archive])\n    if len(scores) > 0 and np.max(scores) > 0:\n        probs = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic score function combining normalized marginal contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    weight_norm = weight_lst / (np.max(weight_lst) + 1e-10)\n\n    temp = max(0.1, 1.0 - (current_value1 + current_value2) / 200)  # Temperature decreases with solution quality\n\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Score for removing an item: penalize high marginal contributions\n            score = -(value1_norm[i] + value2_norm[i]) * (1 - temp)\n            if random.random() < np.exp(score):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Score for adding an item: reward high marginal contributions\n            if current_weight + weight_lst[i] <= capacity:\n                score = (value1_norm[i] + value2_norm[i]) * temp\n                if random.random() < np.exp(score):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_norm):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4520791372916906,
            8.78357994556427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = np.array([v1 + v2 for _, (v1, v2) in archive])\n    if len(scores) > 0 and np.max(scores) > 0:\n        probs = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic score function combining normalized marginal contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    weight_norm = weight_lst / (np.max(weight_lst) + 1e-10)\n\n    temp = max(0.1, 1.0 - (current_value1 + current_value2) / 200)  # Temperature decreases with solution quality\n\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Score for removing an item: penalize high marginal contributions\n            score = -(value1_norm[i] + value2_norm[i]) * (1 - temp)\n            if random.random() < np.exp(score):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Score for adding an item: reward high marginal contributions\n            if current_weight + weight_lst[i] <= capacity:\n                score = (value1_norm[i] + value2_norm[i]) * temp\n                if random.random() < np.exp(score):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_norm):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This algorithm employs a multi-phase local search strategy that combines adaptive item prioritization with a probabilistic neighborhood exploration, where items are dynamically categorized based on their contribution to both objectives and their interaction effects, followed by a guided perturbation that balances exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate interaction scores for items\n    interaction_scores = np.zeros(len(base_solution))\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # For items in solution, score based on how much they improve both objectives\n            interaction_scores[i] = (value1_lst[i] / weight_lst[i]) + (value2_lst[i] / weight_lst[i])\n        else:\n            # For items not in solution, score based on potential improvement\n            interaction_scores[i] = (value1_lst[i] / (weight_lst[i] + 1e-10)) + (value2_lst[i] / (weight_lst[i] + 1e-10))\n\n    # Sort items by interaction scores (descending)\n    sorted_items = np.argsort(-interaction_scores)\n\n    # Phase 1: Adaptive perturbation - flip items with high interaction scores\n    for item in sorted_items[:max(1, len(sorted_items)//5)]:\n        if random.random() < 0.4:  # 40% chance to flip\n            if base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Phase 2: Guided exploration - add high-scoring items not in solution\n    for item in sorted_items:\n        if new_solution[item] == 0 and random.random() < 0.6:  # 60% chance to consider\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                # Check if adding this item creates a beneficial interaction\n                for other_item in sorted_items:\n                    if new_solution[other_item] == 1 and random.random() < 0.3:  # 30% chance to check interaction\n                        combined_value = (value1_lst[item] + value1_lst[other_item]) / (weight_lst[item] + weight_lst[other_item])\n                        if combined_value > (value1_lst[item] / weight_lst[item]) + (value1_lst[other_item] / weight_lst[other_item]):\n                            break  # Keep the interaction\n                        else:\n                            new_solution[item] = 0\n                            current_weight -= weight_lst[item]\n                            break\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest interaction scores until feasible\n        while current_weight > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            worst_item = in_solution[np.argmin(interaction_scores[in_solution])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.5148507826505029,
            3.405231237411499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate interaction scores for items\n    interaction_scores = np.zeros(len(base_solution))\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # For items in solution, score based on how much they improve both objectives\n            interaction_scores[i] = (value1_lst[i] / weight_lst[i]) + (value2_lst[i] / weight_lst[i])\n        else:\n            # For items not in solution, score based on potential improvement\n            interaction_scores[i] = (value1_lst[i] / (weight_lst[i] + 1e-10)) + (value2_lst[i] / (weight_lst[i] + 1e-10))\n\n    # Sort items by interaction scores (descending)\n    sorted_items = np.argsort(-interaction_scores)\n\n    # Phase 1: Adaptive perturbation - flip items with high interaction scores\n    for item in sorted_items[:max(1, len(sorted_items)//5)]:\n        if random.random() < 0.4:  # 40% chance to flip\n            if base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Phase 2: Guided exploration - add high-scoring items not in solution\n    for item in sorted_items:\n        if new_solution[item] == 0 and random.random() < 0.6:  # 60% chance to consider\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                # Check if adding this item creates a beneficial interaction\n                for other_item in sorted_items:\n                    if new_solution[other_item] == 1 and random.random() < 0.3:  # 30% chance to check interaction\n                        combined_value = (value1_lst[item] + value1_lst[other_item]) / (weight_lst[item] + weight_lst[other_item])\n                        if combined_value > (value1_lst[item] / weight_lst[item]) + (value1_lst[other_item] / weight_lst[other_item]):\n                            break  # Keep the interaction\n                        else:\n                            new_solution[item] = 0\n                            current_weight -= weight_lst[item]\n                            break\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest interaction scores until feasible\n        while current_weight > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            worst_item = in_solution[np.argmin(interaction_scores[in_solution])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy selection, where items are prioritized based on their normalized contributions to both objectives, while maintaining feasibility through constrained random walks and adaptive weight balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        common_items = 0\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                common_items += np.sum(sol == other_sol)\n        diversity_scores.append(common_items)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and normalize objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n\n    # Adaptive weight balancing based on current solution's objective values\n    obj1, obj2 = archive[selected_idx][1]\n    total_obj = obj1 + obj2\n    if total_obj > 0:\n        weight1 = obj1 / total_obj\n        weight2 = obj2 / total_obj\n    else:\n        weight1, weight2 = 0.5, 0.5\n\n    # Calculate combined normalized score with adaptive weights\n    combined_score = weight1 * value1_norm + weight2 * value2_norm\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform constrained random walk with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Randomly flip out items with lower probability for higher-score items\n            flip_prob = 0.1 + 0.4 * (1 - combined_score[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add items if feasible and score is high enough\n            if current_weight + weight_lst[item] <= capacity and combined_score[item] > 0.3:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility through final adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4231901427124266,
            4.345001757144928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        common_items = 0\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                common_items += np.sum(sol == other_sol)\n        diversity_scores.append(common_items)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and normalize objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n\n    # Adaptive weight balancing based on current solution's objective values\n    obj1, obj2 = archive[selected_idx][1]\n    total_obj = obj1 + obj2\n    if total_obj > 0:\n        weight1 = obj1 / total_obj\n        weight2 = obj2 / total_obj\n    else:\n        weight1, weight2 = 0.5, 0.5\n\n    # Calculate combined normalized score with adaptive weights\n    combined_score = weight1 * value1_norm + weight2 * value2_norm\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform constrained random walk with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Randomly flip out items with lower probability for higher-score items\n            flip_prob = 0.1 + 0.4 * (1 - combined_score[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add items if feasible and score is high enough\n            if current_weight + weight_lst[item] <= capacity and combined_score[item] > 0.3:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility through final adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst - (value1_lst * base_solution)\n    marginal_value2 = value2_lst - (value2_lst * base_solution)\n    marginal_ratio = (marginal_value1 + marginal_value2) / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution (descending)\n    sorted_items = np.argsort(-marginal_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8863274204254625,
            1.2014946341514587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst - (value1_lst * base_solution)\n    marginal_value2 = value2_lst - (value2_lst * base_solution)\n    marginal_ratio = (marginal_value1 + marginal_value2) / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution (descending)\n    sorted_items = np.argsort(-marginal_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst - (value1_lst * base_solution)\n    marginal_value2 = value2_lst - (value2_lst * base_solution)\n    marginal_ratio = (marginal_value1 + marginal_value2) / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution (descending)\n    sorted_items = np.argsort(-marginal_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8863274204254625,
            1.2014946341514587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst - (value1_lst * base_solution)\n    marginal_value2 = value2_lst - (value2_lst * base_solution)\n    marginal_ratio = (marginal_value1 + marginal_value2) / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution (descending)\n    sorted_items = np.argsort(-marginal_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This novel local search strategy employs a dynamic item prioritization based on both objective values and their interactions, followed by a probabilistic perturbation that selectively replaces items with those offering the highest marginal gain while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic prioritization based on both objectives and their interactions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    interaction = value1_norm * value2_norm\n    combined_score = value1_norm + value2_norm + interaction\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform probabilistic perturbation with selective replacement\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Calculate marginal gain for both objectives\n            marginal_gain1 = value1_lst[item] / (weight_lst[item] + 1e-10)\n            marginal_gain2 = value2_lst[item] / (weight_lst[item] + 1e-10)\n            if random.random() < 0.6 * (marginal_gain1 + marginal_gain2):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4055757426514452,
            4.213695585727692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic prioritization based on both objectives and their interactions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    interaction = value1_norm * value2_norm\n    combined_score = value1_norm + value2_norm + interaction\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform probabilistic perturbation with selective replacement\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Calculate marginal gain for both objectives\n            marginal_gain1 = value1_lst[item] / (weight_lst[item] + 1e-10)\n            marginal_gain2 = value2_lst[item] / (weight_lst[item] + 1e-10)\n            if random.random() < 0.6 * (marginal_gain1 + marginal_gain2):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The new algorithm uses a dynamic prioritization of items based on their marginal contributions to both objectives, combined with a probabilistic flip mechanism that balances exploration and exploitation, ensuring feasibility through a constrained greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n    dynamic_score = (value1_contribution + value2_contribution) * (1 + base_solution * 0.5)\n\n    sorted_items = np.argsort(-dynamic_score)\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Constrained greedy adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.42049465801505015,
            0.5469358563423157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n    dynamic_score = (value1_contribution + value2_contribution) * (1 + base_solution * 0.5)\n\n    sorted_items = np.argsort(-dynamic_score)\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Constrained greedy adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The new algorithm uses a dynamic prioritization of items based on their marginal contributions to both objectives, combined with a probabilistic flip mechanism that balances exploration and exploitation, ensuring feasibility through a constrained greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n    dynamic_score = (value1_contribution + value2_contribution) * (1 + base_solution * 0.5)\n\n    sorted_items = np.argsort(-dynamic_score)\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Constrained greedy adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.42049465801505015,
            0.5469358563423157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n    dynamic_score = (value1_contribution + value2_contribution) * (1 + base_solution * 0.5)\n\n    sorted_items = np.argsort(-dynamic_score)\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Constrained greedy adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm employs a hybrid search strategy that combines a probabilistic item removal based on solution structure with a targeted addition of items that show high potential for improving both objectives, while maintaining feasibility through dynamic weight adjustments and a priority-based selection mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.sum(x[0])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value ratios\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Calculate priority scores for items (combining both objectives and solution structure)\n    priority_scores = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Items in solution get lower priority if they are not contributing significantly\n            priority = -value1_ratio[i] - value2_ratio[i] + 0.1 * (current_weight - weight_lst[i]) / capacity\n        else:\n            # Items not in solution get higher priority if they are promising\n            priority = value1_ratio[i] + value2_ratio[i] - 0.1 * (current_weight + weight_lst[i]) / capacity\n        priority_scores.append(priority)\n\n    # Sort items by priority (descending)\n    sorted_items = np.argsort(-np.array(priority_scores))\n\n    # Perform hybrid local search: remove low-priority items and add high-priority items\n    for i in sorted_items:\n        if new_solution[i] == 1:\n            # Remove items with low priority if feasible\n            if random.random() < 0.4 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add items with high priority if feasible\n            if random.random() < 0.6 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest priority until feasible\n        excess_weight = current_weight - capacity\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8764108454311008,
            5.216365873813629
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.sum(x[0])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value ratios\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Calculate priority scores for items (combining both objectives and solution structure)\n    priority_scores = []\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Items in solution get lower priority if they are not contributing significantly\n            priority = -value1_ratio[i] - value2_ratio[i] + 0.1 * (current_weight - weight_lst[i]) / capacity\n        else:\n            # Items not in solution get higher priority if they are promising\n            priority = value1_ratio[i] + value2_ratio[i] - 0.1 * (current_weight + weight_lst[i]) / capacity\n        priority_scores.append(priority)\n\n    # Sort items by priority (descending)\n    sorted_items = np.argsort(-np.array(priority_scores))\n\n    # Perform hybrid local search: remove low-priority items and add high-priority items\n    for i in sorted_items:\n        if new_solution[i] == 1:\n            # Remove items with low priority if feasible\n            if random.random() < 0.4 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add items with high priority if feasible\n            if random.random() < 0.6 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest priority until feasible\n        excess_weight = current_weight - capacity\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This new algorithm employs a hybrid approach that combines a diversity-preserving swap with a value-driven perturbation, where items are prioritized based on their individual contributions to each objective, followed by a feasibility check and a probabilistic adjustment step to ensure high-quality solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Prioritize items based on their individual contributions to each objective\n    value1_contribution = value1_lst * base_solution\n    value2_contribution = value2_lst * base_solution\n\n    # Sort items by their contributions to each objective (descending)\n    sorted_value1 = np.argsort(-value1_contribution)\n    sorted_value2 = np.argsort(-value2_contribution)\n\n    # Perform hybrid perturbation: swap items between objectives\n    for i in range(min(len(sorted_value1), len(sorted_value2))):\n        item1 = sorted_value1[i]\n        item2 = sorted_value2[i]\n\n        if base_solution[item1] == 1 and base_solution[item2] == 0:\n            # Check feasibility of swapping\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            if current_weight + delta_weight <= capacity and random.random() < 0.5:\n                new_solution[item1] = 0\n                new_solution[item2] = 1\n                current_weight += delta_weight\n\n    # Probabilistic adjustment: flip low-value items\n    for item in range(len(new_solution)):\n        if new_solution[item] == 1 and random.random() < 0.1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_value1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4715274132839864,
            1.1321587264537811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Prioritize items based on their individual contributions to each objective\n    value1_contribution = value1_lst * base_solution\n    value2_contribution = value2_lst * base_solution\n\n    # Sort items by their contributions to each objective (descending)\n    sorted_value1 = np.argsort(-value1_contribution)\n    sorted_value2 = np.argsort(-value2_contribution)\n\n    # Perform hybrid perturbation: swap items between objectives\n    for i in range(min(len(sorted_value1), len(sorted_value2))):\n        item1 = sorted_value1[i]\n        item2 = sorted_value2[i]\n\n        if base_solution[item1] == 1 and base_solution[item2] == 0:\n            # Check feasibility of swapping\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            if current_weight + delta_weight <= capacity and random.random() < 0.5:\n                new_solution[item1] = 0\n                new_solution[item2] = 1\n                current_weight += delta_weight\n\n    # Probabilistic adjustment: flip low-value items\n    for item in range(len(new_solution)):\n        if new_solution[item] == 1 and random.random() < 0.1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_value1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with an adaptive greedy insertion, where solutions are selected based on their crowding distance in objective space to maintain exploration, and items are prioritized by their contribution to the less explored objective, while ensuring feasibility through a capacity-aware adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                continue\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with minimum crowding distance (promising for exploration)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Determine which objective to prioritize (the one with less exploration)\n    obj1_values = objectives[:, 0]\n    obj2_values = objectives[:, 1]\n    obj1_range = np.max(obj1_values) - np.min(obj1_values)\n    obj2_range = np.max(obj2_values) - np.min(obj2_values)\n\n    if obj1_range < obj2_range:\n        # Prioritize objective 1 (less explored)\n        priority_ratio = value1_lst / (weight_lst + 1e-10)\n    else:\n        # Prioritize objective 2 (less explored)\n        priority_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by priority ratio (descending)\n    sorted_items = np.argsort(-priority_ratio)\n\n    # Adaptive perturbation: remove low-priority items and add high-priority items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest priority ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7070908387723689,
            2.045212298631668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                continue\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with minimum crowding distance (promising for exploration)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Determine which objective to prioritize (the one with less exploration)\n    obj1_values = objectives[:, 0]\n    obj2_values = objectives[:, 1]\n    obj1_range = np.max(obj1_values) - np.min(obj1_values)\n    obj2_range = np.max(obj2_values) - np.min(obj2_values)\n\n    if obj1_range < obj2_range:\n        # Prioritize objective 1 (less explored)\n        priority_ratio = value1_lst / (weight_lst + 1e-10)\n    else:\n        # Prioritize objective 2 (less explored)\n        priority_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by priority ratio (descending)\n    sorted_items = np.argsort(-priority_ratio)\n\n    # Adaptive perturbation: remove low-priority items and add high-priority items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest priority ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm employs an adaptive neighborhood exploration strategy that combines value-aware item selection with dynamic weight balancing to generate high-quality neighbors by iteratively refining the solution through a combination of targeted additions, conditional removals, and marginal contribution analysis while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized value scores for adaptive selection\n    value1_norm = value1_lst / np.max(value1_lst) if np.max(value1_lst) > 0 else value1_lst\n    value2_norm = value2_lst / np.max(value2_lst) if np.max(value2_lst) > 0 else value2_lst\n    combined_value = 0.5 * value1_norm + 0.5 * value2_norm\n\n    # Determine items to consider for modification\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # More likely to keep valuable items but may remove less valuable ones\n            prob = 0.7 if combined_value[i] > 0.5 else 0.3\n            if random.random() > prob:\n                candidates.append(i)\n        else:\n            # More likely to add high-value items\n            if combined_value[i] > 0.7:\n                candidates.append(i)\n\n    # Apply adaptive modifications\n    for i in candidates:\n        if new_solution[i] == 1 and random.random() < 0.4:\n            # Try to remove item with some probability\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Try to add item if it fits\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Dynamic weight balancing phase\n    if random.random() < 0.3:\n        # Occasionally focus on one objective\n        if random.random() < 0.5:\n            # Focus on value1\n            value_scores = value1_norm\n        else:\n            # Focus on value2\n            value_scores = value2_norm\n\n        # Remove items with lowest scores until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            scores = [(value_scores[i], i) for i in in_solution]\n            _, worst_item = min(scores)\n            new_solution[worst_item] = 0\n\n    # Final marginal contribution check\n    if np.sum(weight_lst * new_solution) > capacity:\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                marginal.append((np.sum(value1_lst * temp) + np.sum(value2_lst * temp), i))\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8520551909684682,
            1.8223977386951447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized value scores for adaptive selection\n    value1_norm = value1_lst / np.max(value1_lst) if np.max(value1_lst) > 0 else value1_lst\n    value2_norm = value2_lst / np.max(value2_lst) if np.max(value2_lst) > 0 else value2_lst\n    combined_value = 0.5 * value1_norm + 0.5 * value2_norm\n\n    # Determine items to consider for modification\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # More likely to keep valuable items but may remove less valuable ones\n            prob = 0.7 if combined_value[i] > 0.5 else 0.3\n            if random.random() > prob:\n                candidates.append(i)\n        else:\n            # More likely to add high-value items\n            if combined_value[i] > 0.7:\n                candidates.append(i)\n\n    # Apply adaptive modifications\n    for i in candidates:\n        if new_solution[i] == 1 and random.random() < 0.4:\n            # Try to remove item with some probability\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        elif new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Try to add item if it fits\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Dynamic weight balancing phase\n    if random.random() < 0.3:\n        # Occasionally focus on one objective\n        if random.random() < 0.5:\n            # Focus on value1\n            value_scores = value1_norm\n        else:\n            # Focus on value2\n            value_scores = value2_norm\n\n        # Remove items with lowest scores until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            scores = [(value_scores[i], i) for i in in_solution]\n            _, worst_item = min(scores)\n            new_solution[worst_item] = 0\n\n    # Final marginal contribution check\n    if np.sum(weight_lst * new_solution) > capacity:\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                marginal.append((np.sum(value1_lst * temp) + np.sum(value2_lst * temp), i))\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm employs a weighted random selection strategy that combines item swaps with a probabilistic exploration of high-value items, using a dynamic score function based on both objective values and solution structure to generate high-quality, feasible neighbors while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_scores = [sum(obj) for _, obj in archive]\n    max_score = max(total_scores) if total_scores else 1.0\n    selection_probs = [score / max_score for score in total_scores]\n    selected_idx = random.choices(range(len(archive)), weights=selection_probs, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized value scores\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n    combined_score = 0.7 * value1_norm + 0.3 * value2_norm\n\n    # Determine items for potential swap based on combined score\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            prob = 0.4 * (1 - combined_score[i]) * (1 - combined_score[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            prob = 0.6 * combined_score[i] * combined_score[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8684558847786283,
            2.8866948783397675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_scores = [sum(obj) for _, obj in archive]\n    max_score = max(total_scores) if total_scores else 1.0\n    selection_probs = [score / max_score for score in total_scores]\n    selected_idx = random.choices(range(len(archive)), weights=selection_probs, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized value scores\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n    combined_score = 0.7 * value1_norm + 0.3 * value2_norm\n\n    # Determine items for potential swap based on combined score\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            prob = 0.4 * (1 - combined_score[i]) * (1 - combined_score[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            prob = 0.6 * combined_score[i] * combined_score[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The new algorithm combines a probabilistic flip-based perturbation with a targeted improvement phase that selectively replaces items based on their marginal contribution to both objectives, while ensuring feasibility through a dynamic adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Probabilistic flip phase\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Targeted improvement phase\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Dynamic adjustment to ensure feasibility\n    if current_weight > capacity:\n        while current_weight > capacity:\n            for item in sorted_items:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.3278027397466934,
            1.9335657060146332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Probabilistic flip phase\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Targeted improvement phase\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Dynamic adjustment to ensure feasibility\n    if current_weight > capacity:\n        while current_weight > capacity:\n            for item in sorted_items:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    if current_weight <= capacity:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm employs a hybrid local search strategy that combines value-driven item selection with adaptive neighborhood exploration, using a dynamic weighting scheme to balance both objectives while maintaining feasibility through iterative refinement and marginal contribution analysis.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate normalized value scores for both objectives\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n\n    # Dynamic weighting based on current solution's objective values\n    total_v1, total_v2 = np.sum(value1_lst * new_solution), np.sum(value2_lst * new_solution)\n    weight_factor = total_v2 / (total_v1 + total_v2 + 1e-10) if total_v1 + total_v2 > 0 else 0.5\n\n    # Create composite score combining both objectives with dynamic weighting\n    composite_score = (1 - weight_factor) * value1_norm + weight_factor * value2_norm\n\n    # Identify candidate items to consider\n    candidate_items = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being reconsidered\n            prob = 0.3 + 0.7 * (1 - composite_score[i])\n        else:\n            # Items not in solution have probability based on composite score\n            prob = 0.1 + 0.9 * composite_score[i]\n        if random.random() < prob:\n            candidate_items.append(i)\n\n    # Sort candidates by composite score (descending for not in solution, ascending for in solution)\n    candidate_items.sort(key=lambda x: composite_score[x] if new_solution[x] == 0 else -composite_score[x])\n\n    # Perform adaptive neighborhood exploration\n    for i in candidate_items:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) <= capacity:\n                current_weight -= weight_lst[i]\n                remaining_capacity += weight_lst[i]\n            else:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                remaining_capacity -= weight_lst[i]\n\n    # Final refinement step\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest composite score until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Find item with lowest composite score\n            worst_item = min(in_solution, key=lambda x: composite_score[x])\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.897576828695755,
            6.5340220630168915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current state\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate normalized value scores for both objectives\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n\n    # Dynamic weighting based on current solution's objective values\n    total_v1, total_v2 = np.sum(value1_lst * new_solution), np.sum(value2_lst * new_solution)\n    weight_factor = total_v2 / (total_v1 + total_v2 + 1e-10) if total_v1 + total_v2 > 0 else 0.5\n\n    # Create composite score combining both objectives with dynamic weighting\n    composite_score = (1 - weight_factor) * value1_norm + weight_factor * value2_norm\n\n    # Identify candidate items to consider\n    candidate_items = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being reconsidered\n            prob = 0.3 + 0.7 * (1 - composite_score[i])\n        else:\n            # Items not in solution have probability based on composite score\n            prob = 0.1 + 0.9 * composite_score[i]\n        if random.random() < prob:\n            candidate_items.append(i)\n\n    # Sort candidates by composite score (descending for not in solution, ascending for in solution)\n    candidate_items.sort(key=lambda x: composite_score[x] if new_solution[x] == 0 else -composite_score[x])\n\n    # Perform adaptive neighborhood exploration\n    for i in candidate_items:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) <= capacity:\n                current_weight -= weight_lst[i]\n                remaining_capacity += weight_lst[i]\n            else:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                remaining_capacity -= weight_lst[i]\n\n    # Final refinement step\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest composite score until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Find item with lowest composite score\n            worst_item = min(in_solution, key=lambda x: composite_score[x])\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm uses a dynamic item prioritization strategy that combines value-to-weight ratios with a diversity-aware selection mechanism to generate high-quality neighbors by iteratively refining the solution with probabilistic swaps and targeted insertions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware priority scores\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Alternate between objectives to balance exploration\n    if random.random() < 0.5:\n        priority_scores = value1_ratio + 0.3 * value2_ratio\n    else:\n        priority_scores = value2_ratio + 0.3 * value1_ratio\n\n    # Sort items by priority scores (descending)\n    sorted_items = np.argsort(-priority_scores)\n\n    # Perform dynamic item swaps and insertions\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-priority items\n            if random.random() < 0.25:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-priority items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with targeted removals\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.35172985098495485,
            1.865822821855545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware priority scores\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Alternate between objectives to balance exploration\n    if random.random() < 0.5:\n        priority_scores = value1_ratio + 0.3 * value2_ratio\n    else:\n        priority_scores = value2_ratio + 0.3 * value1_ratio\n\n    # Sort items by priority scores (descending)\n    sorted_items = np.argsort(-priority_scores)\n\n    # Perform dynamic item swaps and insertions\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-priority items\n            if random.random() < 0.25:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-priority items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with targeted removals\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm employs a hybrid local search strategy that combines adaptive item selection based on both objective values and solution structure with a targeted perturbation mechanism to explore promising regions of the solution space while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and objective distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / (np.sum(value1_lst) + 1e-8)\n    value2_dist = value2_lst / (np.sum(value2_lst) + 1e-8)\n\n    # Determine items for potential modification based on combined objective importance\n    items_to_modify = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being modified if they are less important in both objectives\n            prob = 0.5 * (1 - value1_dist[i] * value2_dist[i])\n            if random.random() < prob:\n                items_to_modify.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are important in at least one objective\n            prob = 0.5 * (value1_dist[i] + value2_dist[i]) / 2\n            if random.random() < prob:\n                items_to_modify.append(i)\n\n    # Perform modifications while maintaining feasibility\n    for i in items_to_modify:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check with enhanced removal strategy\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined marginal contribution\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8094818639706884,
            6.294560551643372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and objective distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / (np.sum(value1_lst) + 1e-8)\n    value2_dist = value2_lst / (np.sum(value2_lst) + 1e-8)\n\n    # Determine items for potential modification based on combined objective importance\n    items_to_modify = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being modified if they are less important in both objectives\n            prob = 0.5 * (1 - value1_dist[i] * value2_dist[i])\n            if random.random() < prob:\n                items_to_modify.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are important in at least one objective\n            prob = 0.5 * (value1_dist[i] + value2_dist[i]) / 2\n            if random.random() < prob:\n                items_to_modify.append(i)\n\n    # Perform modifications while maintaining feasibility\n    for i in items_to_modify:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check with enhanced removal strategy\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined marginal contribution\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy insertion, where items are selected based on their Pareto-efficient marginal contributions, ensuring both solution quality and exploration of the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1.0 + i) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by both objectives (lexicographic order)\n    sorted_items = np.lexsort((-marginal_value1, -marginal_value2))\n\n    # Perform multi-objective greedy insertion\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Probabilistically add items that improve both objectives\n            if random.random() < 0.5 and (marginal_value1[item] > 0 or marginal_value2[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform targeted removal of low-contribution items\n    for item in sorted_items:\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8537454061923645,
            0.7239254117012024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1.0 + i) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by both objectives (lexicographic order)\n    sorted_items = np.lexsort((-marginal_value1, -marginal_value2))\n\n    # Perform multi-objective greedy insertion\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Probabilistically add items that improve both objectives\n            if random.random() < 0.5 and (marginal_value1[item] > 0 or marginal_value2[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform targeted removal of low-contribution items\n    for item in sorted_items:\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4412300200815416,
            2.1832918226718903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions using a weighted sum\n    combined_contribution = 0.6 * marginal_value1 + 0.4 * marginal_value2\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contribution)\n\n    # Probabilistic swap-based perturbation with adaptive thresholds\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Higher probability to remove low-contribution items\n            removal_prob = 0.2 + 0.3 * (1 - combined_contribution[item] / np.max(combined_contribution))\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Higher probability to add high-contribution items if feasible\n            addition_prob = 0.5 + 0.2 * (combined_contribution[item] / np.max(combined_contribution))\n            if current_weight + weight_lst[item] <= capacity and random.random() < addition_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a more aggressive adjustment\n    if current_weight > capacity:\n        # Remove items in reverse order of contribution until feasible\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.45474467243719296,
            10.962082922458649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions using a weighted sum\n    combined_contribution = 0.6 * marginal_value1 + 0.4 * marginal_value2\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contribution)\n\n    # Probabilistic swap-based perturbation with adaptive thresholds\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Higher probability to remove low-contribution items\n            removal_prob = 0.2 + 0.3 * (1 - combined_contribution[item] / np.max(combined_contribution))\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Higher probability to add high-contribution items if feasible\n            addition_prob = 0.5 + 0.2 * (combined_contribution[item] / np.max(combined_contribution))\n            if current_weight + weight_lst[item] <= capacity and random.random() < addition_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a more aggressive adjustment\n    if current_weight > capacity:\n        # Remove items in reverse order of contribution until feasible\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to objective 1 (descending)\n    sorted_items_obj1 = np.argsort(-marginal_value1)\n\n    # Sort items by marginal contribution to objective 2 (descending)\n    sorted_items_obj2 = np.argsort(-marginal_value2)\n\n    # Alternate between objectives to diversify the search\n    for i in range(len(weight_lst)):\n        if i % 2 == 0:\n            item = sorted_items_obj1[i % len(sorted_items_obj1)]\n        else:\n            item = sorted_items_obj2[i % len(sorted_items_obj2)]\n\n        if base_solution[item] == 1:\n            if random.random() < 0.2:  # Lower probability to flip out\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:  # Lower probability to add\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items_obj1:  # Use objective 1's sorted list for removal\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.35728443169477475,
            3.713185667991638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to objective 1 (descending)\n    sorted_items_obj1 = np.argsort(-marginal_value1)\n\n    # Sort items by marginal contribution to objective 2 (descending)\n    sorted_items_obj2 = np.argsort(-marginal_value2)\n\n    # Alternate between objectives to diversify the search\n    for i in range(len(weight_lst)):\n        if i % 2 == 0:\n            item = sorted_items_obj1[i % len(sorted_items_obj1)]\n        else:\n            item = sorted_items_obj2[i % len(sorted_items_obj2)]\n\n        if base_solution[item] == 1:\n            if random.random() < 0.2:  # Lower probability to flip out\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:  # Lower probability to add\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items_obj1:  # Use objective 1's sorted list for removal\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The new algorithm uses a value-based diversification strategy that probabilistically flips items with high marginal contributions to both objectives while ensuring feasibility, followed by a targeted intensification phase that reinserts high-ratio items, balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Diversification phase: probabilistically flip high-marginal items\n    for item in np.argsort(-combined_marginal):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Intensification phase: greedily reinsert high-marginal items\n    for item in np.argsort(-combined_marginal):\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        for item in np.argsort(combined_marginal):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.32551868332047307,
            2.644956350326538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Diversification phase: probabilistically flip high-marginal items\n    for item in np.argsort(-combined_marginal):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Intensification phase: greedily reinsert high-marginal items\n    for item in np.argsort(-combined_marginal):\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        for item in np.argsort(combined_marginal):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This new algorithm uses a dynamic prioritization approach where items are scored based on their marginal contribution to both objectives, combined with a probabilistic perturbation mechanism to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic marginal contribution scores\n    marginal_score = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # For included items, score based on reduction in objectives\n            marginal_score[i] = -value1_lst[i] - value2_lst[i]\n        else:\n            # For excluded items, score based on potential addition\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_score[i] = value1_lst[i] + value2_lst[i]\n            else:\n                marginal_score[i] = -np.inf  # Mark as infeasible\n\n    # Sort items by marginal score (descending)\n    sorted_items = np.argsort(-marginal_score)\n\n    # Dynamic perturbation: flip items with high marginal score\n    for item in sorted_items[:len(sorted_items)//2]:  # Consider top 50% items\n        if base_solution[item] == 1 and random.random() < 0.4:  # 40% chance to remove\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.6:  # 60% chance to add if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        # Remove items with lowest marginal score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:  # Start from worst items\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4327774830683002,
            2.864568382501602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic marginal contribution scores\n    marginal_score = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # For included items, score based on reduction in objectives\n            marginal_score[i] = -value1_lst[i] - value2_lst[i]\n        else:\n            # For excluded items, score based on potential addition\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_score[i] = value1_lst[i] + value2_lst[i]\n            else:\n                marginal_score[i] = -np.inf  # Mark as infeasible\n\n    # Sort items by marginal score (descending)\n    sorted_items = np.argsort(-marginal_score)\n\n    # Dynamic perturbation: flip items with high marginal score\n    for item in sorted_items[:len(sorted_items)//2]:  # Consider top 50% items\n        if base_solution[item] == 1 and random.random() < 0.4:  # 40% chance to remove\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.6:  # 60% chance to add if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        # Remove items with lowest marginal score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:  # Start from worst items\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9743457739700838,
            10.994741052389145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9743457739700838,
            10.994741052389145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item with lower marginal contribution\n            if random.random() < 0.3 and combined_marginal[item] < np.mean(combined_marginal):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items in reverse order of marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4577543979864934,
            1.7183402180671692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item with lower marginal contribution\n            if random.random() < 0.3 and combined_marginal[item] < np.mean(combined_marginal):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items in reverse order of marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm employs a diversity-aware local search that combines random swaps with a targeted replacement of items based on their marginal contribution to both objectives, while maintaining feasibility through a weighted adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Identify items to potentially swap or replace\n    items_in = np.where(base_solution == 1)[0]\n    items_out = np.where(base_solution == 0)[0]\n\n    # Perform random swaps between included and excluded items\n    if len(items_in) > 0 and len(items_out) > 0:\n        swap_candidates_in = np.random.choice(items_in, size=min(3, len(items_in)), replace=False)\n        swap_candidates_out = np.random.choice(items_out, size=min(3, len(items_out)), replace=False)\n\n        for item_in in swap_candidates_in:\n            for item_out in swap_candidates_out:\n                if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n                    current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n                    break\n\n    # Replace low-marginal items with high-marginal ones if feasible\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            break\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.2857942978346605,
            3.6495876610279083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Identify items to potentially swap or replace\n    items_in = np.where(base_solution == 1)[0]\n    items_out = np.where(base_solution == 0)[0]\n\n    # Perform random swaps between included and excluded items\n    if len(items_in) > 0 and len(items_out) > 0:\n        swap_candidates_in = np.random.choice(items_in, size=min(3, len(items_in)), replace=False)\n        swap_candidates_out = np.random.choice(items_out, size=min(3, len(items_out)), replace=False)\n\n        for item_in in swap_candidates_in:\n            for item_out in swap_candidates_out:\n                if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n                    current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n                    break\n\n    # Replace low-marginal items with high-marginal ones if feasible\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n            break\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{The novel local search strategy employs a dynamic priority-based selection combined with a probabilistic flip mechanism, where items are prioritized based on their normalized marginal contributions to both objectives, and feasibility is maintained through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize value contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = value1_norm + value2_norm\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic priority-based local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out lower-priority items\n            if random.random() < 0.2 * (1 - combined_score[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-priority items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * combined_score[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.39268984052480416,
            3.694900929927826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize value contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = value1_norm + value2_norm\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic priority-based local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out lower-priority items\n            if random.random() < 0.2 * (1 - combined_score[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-priority items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * combined_score[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The novel local search strategy combines a diversity-aware selection of solutions with a multi-objective greedy insertion/removal heuristic, where items are prioritized based on their normalized contributions to both objectives, while ensuring feasibility through a capacity-aware adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values for multi-objective prioritization\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    combined_score = norm_value1 + norm_value2\n\n    # Sort items by combined normalized score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Multi-objective greedy insertion/removal\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item if it doesn't contribute significantly to either objective\n            if random.random() < 0.2 or (norm_value1[item] < 0.3 and norm_value2[item] < 0.3):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if it fits and improves at least one objective significantly\n            if (current_weight + weight_lst[item] <= capacity and\n                (norm_value1[item] > 0.5 or norm_value2[item] > 0.5)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Capacity adjustment if needed\n    if current_weight > capacity:\n        # Remove items with lowest combined score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37223000180309107,
            3.2722471058368683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values for multi-objective prioritization\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    combined_score = norm_value1 + norm_value2\n\n    # Sort items by combined normalized score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Multi-objective greedy insertion/removal\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item if it doesn't contribute significantly to either objective\n            if random.random() < 0.2 or (norm_value1[item] < 0.3 and norm_value2[item] < 0.3):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if it fits and improves at least one objective significantly\n            if (current_weight + weight_lst[item] <= capacity and\n                (norm_value1[item] > 0.5 or norm_value2[item] > 0.5)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Capacity adjustment if needed\n    if current_weight > capacity:\n        # Remove items with lowest combined score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This new algorithm employs a hybrid local search strategy that combines value-weighted random perturbations with a targeted exploration of solution space boundaries, using a dynamic selection probability based on both objective values and structural diversity to generate high-quality, feasible neighbors while maintaining archive diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select solution with highest combined value\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value scores\n    current_weight = np.sum(weight_lst * new_solution)\n    value_scores = (value1_lst + value2_lst) / np.sum(value1_lst + value2_lst)\n\n    # Determine items for potential swap based on value score and structural diversity\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            prob = 0.3 * (1 - value_scores[i]) + 0.7 * (1 - (i % 2))  # Alternate between even/odd indices\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            prob = 0.3 * value_scores[i] + 0.7 * (i % 2)  # Prefer even indices for addition\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined value until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate combined value for each item in solution\n            values = value1_lst[in_solution] + value2_lst[in_solution]\n            worst_item = in_solution[np.argmin(values)]\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8369863959009045,
            8.203643560409546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select solution with highest combined value\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value scores\n    current_weight = np.sum(weight_lst * new_solution)\n    value_scores = (value1_lst + value2_lst) / np.sum(value1_lst + value2_lst)\n\n    # Determine items for potential swap based on value score and structural diversity\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            prob = 0.3 * (1 - value_scores[i]) + 0.7 * (1 - (i % 2))  # Alternate between even/odd indices\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            prob = 0.3 * value_scores[i] + 0.7 * (i % 2)  # Prefer even indices for addition\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined value until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate combined value for each item in solution\n            values = value1_lst[in_solution] + value2_lst[in_solution]\n            worst_item = in_solution[np.argmin(values)]\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{The new algorithm uses a dynamic priority-based selection with adaptive perturbation, where items are prioritized based on their marginal contributions to both objectives, combined with a probabilistic flip mechanism that balances exploration and exploitation while ensuring feasibility through a weighted adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4704271812420401,
            4.808054089546204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a diversity-aware perturbation strategy that combines random item swaps with a targeted exploration of underrepresented item combinations, using a dynamic selection probability based on both objective values and solution structure to generate high-quality, feasible neighbors while preserving archive diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current weight and value distributions\n    current_weight = np.sum(weight_lst * new_solution)\n    value1_dist = value1_lst / np.sum(value1_lst)\n    value2_dist = value2_lst / np.sum(value2_lst)\n\n    # Determine items for potential swap based on value distribution\n    items_to_swap = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Items in solution have higher probability of being swapped if they are less valuable\n            prob = 0.5 * (1 - value1_dist[i]) * (1 - value2_dist[i])\n            if random.random() < prob:\n                items_to_swap.append(i)\n        else:\n            # Items not in solution have higher probability of being added if they are valuable\n            prob = 0.5 * value1_dist[i] * value2_dist[i]\n            if random.random() < prob:\n                items_to_swap.append(i)\n\n    # Perform swaps while maintaining feasibility\n    for i in items_to_swap:\n        if new_solution[i] == 1:\n            # Try to remove item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) > capacity:\n                new_solution[i] = 1\n        else:\n            # Try to add item\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            in_solution = np.where(new_solution == 1)[0]\n            if len(in_solution) == 0:\n                break\n            # Calculate marginal contribution for each item in solution\n            marginal = []\n            for i in in_solution:\n                temp = new_solution.copy()\n                temp[i] = 0\n                v1 = np.sum(value1_lst * temp)\n                v2 = np.sum(value2_lst * temp)\n                marginal.append((v1 + v2, i))\n            # Remove item with lowest marginal contribution\n            _, worst_item = min(marginal)\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm employs a probabilistic item replacement strategy that dynamically prioritizes items based on their marginal contribution to both objectives while maintaining feasibility through a controlled perturbation of solution structure, using adaptive selection probabilities and a multi-objective greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-10))[0].copy()\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic probability calculation based on current solution\n    prob_replace = 0.5 * (1 - np.sum(new_solution) / len(new_solution))  # Higher when solution is sparse\n\n    # Perform controlled perturbation\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            if random.random() < prob_replace:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy adjustment phase\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Additional diversification step\n    if random.random() < 0.3:\n        # Randomly flip a small number of items (1-3) to introduce diversity\n        flip_count = random.randint(1, 3)\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            selected = np.random.choice(candidate_items, min(flip_count, len(candidate_items)), replace=False)\n            for item in selected:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.38410786867930236,
            7.496040344238281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (np.sum(weight_lst * x[0]) + 1e-10))[0].copy()\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic probability calculation based on current solution\n    prob_replace = 0.5 * (1 - np.sum(new_solution) / len(new_solution))  # Higher when solution is sparse\n\n    # Perform controlled perturbation\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            if random.random() < prob_replace:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy adjustment phase\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Additional diversification step\n    if random.random() < 0.3:\n        # Randomly flip a small number of items (1-3) to introduce diversity\n        flip_count = random.randint(1, 3)\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            selected = np.random.choice(candidate_items, min(flip_count, len(candidate_items)), replace=False)\n            for item in selected:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm combines a diversity-aware selection with a multi-objective greedy swap strategy, where solutions are chosen based on their crowding distance to promote exploration, and items are swapped based on their normalized marginal contributions to both objectives, ensuring balanced improvement while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate normalized marginal contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    normalized_marginal = (marginal1 + marginal2) / (np.max(marginal1 + marginal2) + 1e-10)\n\n    # Perform multi-objective greedy swaps\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Probabilistically remove low-contribution items\n            if random.random() < 0.3 * (1 - normalized_marginal[i]):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add high-contribution items if feasible\n            if current_weight + weight_lst[i] <= capacity and random.random() < 0.7 * normalized_marginal[i]:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(normalized_marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8094208764150062,
            5.411613881587982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate normalized marginal contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    normalized_marginal = (marginal1 + marginal2) / (np.max(marginal1 + marginal2) + 1e-10)\n\n    # Perform multi-objective greedy swaps\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Probabilistically remove low-contribution items\n            if random.random() < 0.3 * (1 - normalized_marginal[i]):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add high-contribution items if feasible\n            if current_weight + weight_lst[i] <= capacity and random.random() < 0.7 * normalized_marginal[i]:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(normalized_marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The novel local search strategy combines a diversity-preserving perturbation with a multi-objective greedy insertion, where items are selected based on their normalized contribution to both objectives, with a probabilistic acceptance of solutions that improve at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize value contributions\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n\n    # Calculate combined normalized contribution\n    combined_contrib = norm_value1 + norm_value2\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contrib)\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low contribution more likely\n            remove_prob = 0.2 + 0.8 * (1 - combined_contrib[item])\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high contribution more likely\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 + 0.5 * combined_contrib[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.34404640794866925,
            4.131558477878571
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize value contributions\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n\n    # Calculate combined normalized contribution\n    combined_contrib = norm_value1 + norm_value2\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contrib)\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low contribution more likely\n            remove_prob = 0.2 + 0.8 * (1 - combined_contrib[item])\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high contribution more likely\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 + 0.5 * combined_contrib[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{The novel local search strategy combines a dynamic clustering-based perturbation with a value-aware item replacement that considers both objectives and their trade-offs, ensuring both feasibility and high-quality neighbors through adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([sum(obj) for _, obj in archive])\n    if np.sum(total_values) > 0:\n        probabilities = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Cluster items into 3 groups based on value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Dynamic clustering: top 30%, middle 40%, bottom 30%\n    n_items = len(weight_lst)\n    cluster1 = sorted_items[:int(0.3 * n_items)]\n    cluster2 = sorted_items[int(0.3 * n_items):int(0.7 * n_items)]\n    cluster3 = sorted_items[int(0.7 * n_items):]\n\n    # Adaptive perturbation based on cluster\n    for cluster in [cluster1, cluster2, cluster3]:\n        for item in cluster:\n            if base_solution[item] == 1:\n                # Higher probability to remove from lower-value clusters\n                if cluster is cluster3 and random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif cluster is cluster2 and random.random() < 0.3:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif cluster is cluster1 and random.random() < 0.2:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Higher probability to add to higher-value clusters\n                if cluster is cluster1 and random.random() < 0.6 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                elif cluster is cluster2 and random.random() < 0.4 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                elif cluster is cluster3 and random.random() < 0.2 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items from lowest-value cluster first\n        for item in cluster3:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n        if current_weight > capacity:\n            for item in cluster2:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    if current_weight <= capacity:\n                        break\n            if current_weight > capacity:\n                for item in cluster1:\n                    if new_solution[item] == 1:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n                        if current_weight <= capacity:\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.422305238636356,
            5.1563361287117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([sum(obj) for _, obj in archive])\n    if np.sum(total_values) > 0:\n        probabilities = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Cluster items into 3 groups based on value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Dynamic clustering: top 30%, middle 40%, bottom 30%\n    n_items = len(weight_lst)\n    cluster1 = sorted_items[:int(0.3 * n_items)]\n    cluster2 = sorted_items[int(0.3 * n_items):int(0.7 * n_items)]\n    cluster3 = sorted_items[int(0.7 * n_items):]\n\n    # Adaptive perturbation based on cluster\n    for cluster in [cluster1, cluster2, cluster3]:\n        for item in cluster:\n            if base_solution[item] == 1:\n                # Higher probability to remove from lower-value clusters\n                if cluster is cluster3 and random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif cluster is cluster2 and random.random() < 0.3:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif cluster is cluster1 and random.random() < 0.2:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Higher probability to add to higher-value clusters\n                if cluster is cluster1 and random.random() < 0.6 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                elif cluster is cluster2 and random.random() < 0.4 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                elif cluster is cluster3 and random.random() < 0.2 and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items from lowest-value cluster first\n        for item in cluster3:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n        if current_weight > capacity:\n            for item in cluster2:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                    if current_weight <= capacity:\n                        break\n            if current_weight > capacity:\n                for item in cluster1:\n                    if new_solution[item] == 1:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n                        if current_weight <= capacity:\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The novel local search strategy employs a weighted marginal contribution heuristic that prioritizes items based on their normalized impact across both objectives, combined with a probabilistic relaxation of constraints to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    weight_norm = weight_lst / (np.max(weight_lst) + 1e-10)\n\n    # Weighted score combining both objectives and weight\n    score = (value1_norm + value2_norm) / (2 * (weight_norm + 1e-10))\n\n    # Sort items by score (descending)\n    sorted_items = np.argsort(-score)\n\n    # Probabilistic relaxation with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.25:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4939249320999366,
            4.166716277599335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    weight_norm = weight_lst / (np.max(weight_lst) + 1e-10)\n\n    # Weighted score combining both objectives and weight\n    score = (value1_norm + value2_norm) / (2 * (weight_norm + 1e-10))\n\n    # Sort items by score (descending)\n    sorted_items = np.argsort(-score)\n\n    # Probabilistic relaxation with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.25:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contribution for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic perturbation: flip items based on their position in the sorted list\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1:\n            # Higher-ranked items have lower probability of being flipped\n            flip_prob = 0.1 + 0.4 * (i / len(sorted_items))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Lower-ranked items have higher probability of being added\n            add_prob = 0.3 + 0.4 * (1 - i / len(sorted_items))\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Objective-aware greedy adjustment\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Objective-balanced final adjustment: ensure at least one item from each objective's top 30%\n    top_30 = len(sorted_items) // 3\n    top_items = sorted_items[:top_30]\n    if not np.any(new_solution[top_items]):\n        # Add the highest marginal item from each objective\n        if np.sum(weight_lst[top_items[0]]) <= capacity - current_weight:\n            new_solution[top_items[0]] = 1\n        elif np.sum(weight_lst[top_items[1]]) <= capacity - current_weight:\n            new_solution[top_items[1]] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.46565304238707467,
            3.592646449804306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contribution for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic perturbation: flip items based on their position in the sorted list\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1:\n            # Higher-ranked items have lower probability of being flipped\n            flip_prob = 0.1 + 0.4 * (i / len(sorted_items))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Lower-ranked items have higher probability of being added\n            add_prob = 0.3 + 0.4 * (1 - i / len(sorted_items))\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Objective-aware greedy adjustment\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Objective-balanced final adjustment: ensure at least one item from each objective's top 30%\n    top_30 = len(sorted_items) // 3\n    top_items = sorted_items[:top_30]\n    if not np.any(new_solution[top_items]):\n        # Add the highest marginal item from each objective\n        if np.sum(weight_lst[top_items[0]]) <= capacity - current_weight:\n            new_solution[top_items[0]] = 1\n        elif np.sum(weight_lst[top_items[1]]) <= capacity - current_weight:\n            new_solution[top_items[1]] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The novel local search strategy combines a dynamic clustering-based perturbation with a value-weighted item replacement mechanism, where items are grouped by their correlation with the objectives and replaced based on their normalized contributions, ensuring both feasibility and diversity in the generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Normalize values by their maximum to handle different scales\n    max_value1 = np.max(value1_lst) if np.max(value1_lst) > 0 else 1\n    max_value2 = np.max(value2_lst) if np.max(value2_lst) > 0 else 1\n    norm_value1 = value1_lst / max_value1\n    norm_value2 = value2_lst / max_value2\n\n    # Cluster items based on their correlation with objectives\n    item_scores = norm_value1 + norm_value2\n    sorted_items = np.argsort(-item_scores)\n\n    # Dynamic perturbation: replace items based on their position in the cluster\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1:\n            # Higher-ranked items have higher probability of being replaced\n            replace_prob = 0.1 + 0.9 * (i / len(sorted_items))\n            if random.random() < replace_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n\n    # Value-weighted item addition\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Higher-value items have higher probability of being added\n            add_prob = 0.5 * (item_scores[item] / np.max(item_scores))\n            if random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Ensure feasibility by removing items with lowest normalized value\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.40868995215596726,
            5.805482894182205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Normalize values by their maximum to handle different scales\n    max_value1 = np.max(value1_lst) if np.max(value1_lst) > 0 else 1\n    max_value2 = np.max(value2_lst) if np.max(value2_lst) > 0 else 1\n    norm_value1 = value1_lst / max_value1\n    norm_value2 = value2_lst / max_value2\n\n    # Cluster items based on their correlation with objectives\n    item_scores = norm_value1 + norm_value2\n    sorted_items = np.argsort(-item_scores)\n\n    # Dynamic perturbation: replace items based on their position in the cluster\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1:\n            # Higher-ranked items have higher probability of being replaced\n            replace_prob = 0.1 + 0.9 * (i / len(sorted_items))\n            if random.random() < replace_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n\n    # Value-weighted item addition\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Higher-value items have higher probability of being added\n            add_prob = 0.5 * (item_scores[item] / np.max(item_scores))\n            if random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Ensure feasibility by removing items with lowest normalized value\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3105342947629558,
            1.3933987021446228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    norm_value1 = value1_lst / np.max(value1_lst + 1e-10)\n    norm_value2 = value2_lst / np.max(value2_lst + 1e-10)\n    norm_weight = weight_lst / np.max(weight_lst + 1e-10)\n\n    # Calculate a composite score combining value and weight\n    composite_score = (norm_value1 + norm_value2) / (norm_weight + 1e-10)\n    sorted_items = np.argsort(-composite_score)\n\n    # Perform a hybrid local search: dynamic threshold-based selection\n    threshold = np.percentile(composite_score, 75)  # Focus on top 25% items\n\n    for item in sorted_items:\n        if composite_score[item] < threshold:\n            continue\n\n        if base_solution[item] == 1:\n            # Remove items below dynamic threshold with probability\n            if composite_score[item] < np.mean(composite_score[base_solution == 1]):\n                if random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n        else:\n            # Add high-scoring items with probability based on their score\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.6 * (composite_score[item] / threshold)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with a more aggressive removal strategy\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest composite score until feasible\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.386152179010674,
            8.211005508899689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    norm_value1 = value1_lst / np.max(value1_lst + 1e-10)\n    norm_value2 = value2_lst / np.max(value2_lst + 1e-10)\n    norm_weight = weight_lst / np.max(weight_lst + 1e-10)\n\n    # Calculate a composite score combining value and weight\n    composite_score = (norm_value1 + norm_value2) / (norm_weight + 1e-10)\n    sorted_items = np.argsort(-composite_score)\n\n    # Perform a hybrid local search: dynamic threshold-based selection\n    threshold = np.percentile(composite_score, 75)  # Focus on top 25% items\n\n    for item in sorted_items:\n        if composite_score[item] < threshold:\n            continue\n\n        if base_solution[item] == 1:\n            # Remove items below dynamic threshold with probability\n            if composite_score[item] < np.mean(composite_score[base_solution == 1]):\n                if random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n        else:\n            # Add high-scoring items with probability based on their score\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.6 * (composite_score[item] / threshold)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with a more aggressive removal strategy\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest composite score until feasible\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The new algorithm uses a dynamic marginal contribution scoring mechanism that balances item selection probabilities based on their normalized contributions to both objectives, with a temperature-based probability adjustment to explore both high and low-marginal items, ensuring diverse and high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([sum(obj) for _, obj in archive])\n    selection_probs = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    max_marginal1, max_marginal2 = np.max(marginal1), np.max(marginal2)\n\n    # Temperature-based probability adjustment\n    temp = 0.7\n    combined_marginal = (marginal1 / max_marginal1 + marginal2 / max_marginal2) / 2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic selection based on temperature-adjusted probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove items with lower marginal contribution\n            flip_prob = temp * (1 - combined_marginal[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 1 - temp * (1 - combined_marginal[item])\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8650280197602735,
            3.568402498960495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values = np.array([sum(obj) for _, obj in archive])\n    selection_probs = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    max_marginal1, max_marginal2 = np.max(marginal1), np.max(marginal2)\n\n    # Temperature-based probability adjustment\n    temp = 0.7\n    combined_marginal = (marginal1 / max_marginal1 + marginal2 / max_marginal2) / 2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic selection based on temperature-adjusted probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove items with lower marginal contribution\n            flip_prob = temp * (1 - combined_marginal[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 1 - temp * (1 - combined_marginal[item])\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each objective\n    marginal_gain1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine gains using a weighted sum (dynamic weights based on current solution)\n    weight1 = 1.0 if current_value1 == 0 else (current_value2 / (current_value1 + 1e-10))\n    weight2 = 1.0 if current_value2 == 0 else (current_value1 / (current_value2 + 1e-10))\n    combined_gain = weight1 * marginal_gain1 + weight2 * marginal_gain2\n\n    # Sort items by combined gain (descending)\n    sorted_items = np.argsort(-combined_gain)\n\n    # Perform a hybrid local search with adaptive probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # More aggressive removal of low-contribution items\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # More aggressive addition of high-gain items\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different approach\n    if current_weight > capacity:\n        # Remove items in reverse order of combined gain\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5802623862438893,
            2.0178530514240265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each objective\n    marginal_gain1 = value1_lst / (weight_lst + 1e-10)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine gains using a weighted sum (dynamic weights based on current solution)\n    weight1 = 1.0 if current_value1 == 0 else (current_value2 / (current_value1 + 1e-10))\n    weight2 = 1.0 if current_value2 == 0 else (current_value1 / (current_value2 + 1e-10))\n    combined_gain = weight1 * marginal_gain1 + weight2 * marginal_gain2\n\n    # Sort items by combined gain (descending)\n    sorted_items = np.argsort(-combined_gain)\n\n    # Perform a hybrid local search with adaptive probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # More aggressive removal of low-contribution items\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # More aggressive addition of high-gain items\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different approach\n    if current_weight > capacity:\n        # Remove items in reverse order of combined gain\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5223130822655494,
            2.0529005229473114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by the sum of their ratios (descending)\n    combined_ratio = ratio1 + ratio2\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with adaptive greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its position in the sorted list\n            flip_prob = 0.2 + 0.6 * (item / len(sorted_items))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Adaptively add items with high ratios if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 * (1 - item / len(sorted_items))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest ratio\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8357947274062928,
            3.477540045976639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by the sum of their ratios (descending)\n    combined_ratio = ratio1 + ratio2\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with adaptive greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its position in the sorted list\n            flip_prob = 0.2 + 0.6 * (item / len(sorted_items))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Adaptively add items with high ratios if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 * (1 - item / len(sorted_items))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest ratio\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic flip with adaptive selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                # Adaptive probability based on marginal contribution\n                prob = 0.5 + 0.5 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different repair strategy\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5214892468681969,
            6.121439218521118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic flip with adaptive selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                # Adaptive probability based on marginal contribution\n                prob = 0.5 + 0.5 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different repair strategy\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The novel local search strategy employs a dynamic priority-based flipping mechanism that alternates between objective-aware item prioritization and probabilistic swaps, while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on alternating objectives\n    if random.random() < 0.5:\n        priority_scores = value1_lst / (weight_lst + 1e-10)\n    else:\n        priority_scores = value2_lst / (weight_lst + 1e-10)\n\n    sorted_items = np.argsort(-priority_scores)\n\n    # Dynamic flipping mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3999538889997545,
            1.4240384697914124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on alternating objectives\n    if random.random() < 0.5:\n        priority_scores = value1_lst / (weight_lst + 1e-10)\n    else:\n        priority_scores = value2_lst / (weight_lst + 1e-10)\n\n    sorted_items = np.argsort(-priority_scores)\n\n    # Dynamic flipping mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated, but with a different parameter setting for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value1_ratio * 0.6) + (value2_ratio * 0.4)\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4188220753544225,
            10.88680124282837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value1_ratio * 0.6) + (value2_ratio * 0.4)\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.461606996626548,
            7.491226464509964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5602655809832722,
            4.122608542442322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The novel local search strategy employs a hybrid approach combining adaptive item prioritization based on objective-specific marginal contributions with a probabilistic swap mechanism, ensuring balanced exploration of the solution space while maintaining feasibility constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate objective-specific marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Normalize marginals for each objective\n    norm_marginal1 = (marginal1 - np.min(marginal1)) / (np.max(marginal1) - np.min(marginal1) + 1e-10)\n    norm_marginal2 = (marginal2 - np.min(marginal2)) / (np.max(marginal2) - np.min(marginal2) + 1e-10)\n\n    # Combine marginals with different weights for each objective\n    combined_marginal = 0.6 * norm_marginal1 + 0.4 * norm_marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive local search with probabilistic operations\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Higher probability to remove items with lower combined marginal\n            remove_prob = 0.3 * (1 - combined_marginal[item])\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Higher probability to add items with higher combined marginal\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * combined_marginal[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8175099007064943,
            3.038603663444519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate objective-specific marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Normalize marginals for each objective\n    norm_marginal1 = (marginal1 - np.min(marginal1)) / (np.max(marginal1) - np.min(marginal1) + 1e-10)\n    norm_marginal2 = (marginal2 - np.min(marginal2)) / (np.max(marginal2) - np.min(marginal2) + 1e-10)\n\n    # Combine marginals with different weights for each objective\n    combined_marginal = 0.6 * norm_marginal1 + 0.4 * norm_marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive local search with probabilistic operations\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Higher probability to remove items with lower combined marginal\n            remove_prob = 0.3 * (1 - combined_marginal[item])\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Higher probability to add items with higher combined marginal\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * combined_marginal[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy selection, where items are prioritized based on their normalized contributions to both objectives, with periodic random resets to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize contributions for both objectives\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_contribution = norm_value1 + norm_value2\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contribution)\n\n    # Perform diversity-aware perturbation with periodic reset\n    for item in sorted_items:\n        if random.random() < 0.4:  # Higher probability to consider more items\n            if base_solution[item] == 1:\n                # Remove item with probability inversely proportional to its contribution\n                remove_prob = 0.5 * (1 - combined_contribution[item])\n                if random.random() < remove_prob:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Add item with probability proportional to its contribution\n                if current_weight + weight_lst[item] <= capacity:\n                    add_prob = 0.6 * combined_contribution[item]\n                    if random.random() < add_prob:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Periodic random reset (20% chance)\n    if random.random() < 0.2:\n        new_solution = np.zeros_like(base_solution)\n        current_weight = 0\n        # Add random subset of items with high contribution\n        for item in sorted_items:\n            if random.random() < 0.3 * combined_contribution[item] and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.2932561815088188,
            3.297664999961853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize contributions for both objectives\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_contribution = norm_value1 + norm_value2\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contribution)\n\n    # Perform diversity-aware perturbation with periodic reset\n    for item in sorted_items:\n        if random.random() < 0.4:  # Higher probability to consider more items\n            if base_solution[item] == 1:\n                # Remove item with probability inversely proportional to its contribution\n                remove_prob = 0.5 * (1 - combined_contribution[item])\n                if random.random() < remove_prob:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Add item with probability proportional to its contribution\n                if current_weight + weight_lst[item] <= capacity:\n                    add_prob = 0.6 * combined_contribution[item]\n                    if random.random() < add_prob:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Periodic random reset (20% chance)\n    if random.random() < 0.2:\n        new_solution = np.zeros_like(base_solution)\n        current_weight = 0\n        # Add random subset of items with high contribution\n        for item in sorted_items:\n            if random.random() < 0.3 * combined_contribution[item] and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The novel local search strategy combines a diversity-preserving perturbation with a two-phase optimization: first prioritizing items by their value-to-weight ratio for both objectives in a probabilistic manner, then performing a targeted swap of items to balance the trade-off between the two objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Probabilistic value-to-weight prioritization\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Randomly select a subset of items to consider for swap\n    swap_candidates = random.sample(list(sorted_items), min(5, len(sorted_items)))\n\n    # Phase 2: Targeted swap optimization\n    for i in range(len(swap_candidates)):\n        for j in range(i + 1, len(swap_candidates)):\n            a, b = swap_candidates[i], swap_candidates[j]\n            if base_solution[a] != base_solution[b]:\n                # Calculate potential weight change\n                delta_weight = (weight_lst[b] - weight_lst[a]) if base_solution[a] else (weight_lst[a] - weight_lst[b])\n                if current_weight + delta_weight <= capacity:\n                    # Calculate potential value change\n                    delta_value1 = (value1_lst[b] - value1_lst[a]) if base_solution[a] else (value1_lst[a] - value1_lst[b])\n                    delta_value2 = (value2_lst[b] - value2_lst[a]) if base_solution[a] else (value2_lst[a] - value2_lst[b])\n\n                    # Accept swap if it improves at least one objective\n                    if delta_value1 > 0 or delta_value2 > 0:\n                        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                        current_weight += delta_weight\n                        break\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5575141819249796,
            1.8744905889034271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Probabilistic value-to-weight prioritization\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Randomly select a subset of items to consider for swap\n    swap_candidates = random.sample(list(sorted_items), min(5, len(sorted_items)))\n\n    # Phase 2: Targeted swap optimization\n    for i in range(len(swap_candidates)):\n        for j in range(i + 1, len(swap_candidates)):\n            a, b = swap_candidates[i], swap_candidates[j]\n            if base_solution[a] != base_solution[b]:\n                # Calculate potential weight change\n                delta_weight = (weight_lst[b] - weight_lst[a]) if base_solution[a] else (weight_lst[a] - weight_lst[b])\n                if current_weight + delta_weight <= capacity:\n                    # Calculate potential value change\n                    delta_value1 = (value1_lst[b] - value1_lst[a]) if base_solution[a] else (value1_lst[a] - value1_lst[b])\n                    delta_value2 = (value2_lst[b] - value2_lst[a]) if base_solution[a] else (value2_lst[a] - value2_lst[b])\n\n                    # Accept swap if it improves at least one objective\n                    if delta_value1 > 0 or delta_value2 > 0:\n                        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                        current_weight += delta_weight\n                        break\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This new algorithm uses a diversity-aware local search that combines random swaps with a weighted greedy selection of items, prioritizing those with high marginal contributions to either objective while maintaining feasibility through a probabilistic adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Weighted prioritization based on diversity and objective contributions\n    diversity_weight = 0.5\n    obj1_weight = 0.3\n    obj2_weight = 0.2\n\n    # Calculate diversity scores (difference from base solution)\n    diversity_scores = np.zeros(len(weight_lst))\n    for sol, _ in archive:\n        diversity_scores += np.abs(sol - base_solution)\n\n    # Normalize scores\n    diversity_scores = diversity_scores / (len(archive) + 1e-10)\n    value1_scores = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_scores = value2_lst / (np.max(value2_lst) + 1e-10)\n\n    # Combined score\n    combined_scores = (diversity_weight * diversity_scores +\n                       obj1_weight * value1_scores +\n                       obj2_weight * value2_scores)\n\n    sorted_items = np.argsort(-combined_scores)\n\n    # Perform probabilistic swaps and greedy additions\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.39372993268666634,
            2.733386754989624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Weighted prioritization based on diversity and objective contributions\n    diversity_weight = 0.5\n    obj1_weight = 0.3\n    obj2_weight = 0.2\n\n    # Calculate diversity scores (difference from base solution)\n    diversity_scores = np.zeros(len(weight_lst))\n    for sol, _ in archive:\n        diversity_scores += np.abs(sol - base_solution)\n\n    # Normalize scores\n    diversity_scores = diversity_scores / (len(archive) + 1e-10)\n    value1_scores = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_scores = value2_lst / (np.max(value2_lst) + 1e-10)\n\n    # Combined score\n    combined_scores = (diversity_weight * diversity_scores +\n                       obj1_weight * value1_scores +\n                       obj2_weight * value2_scores)\n\n    sorted_items = np.argsort(-combined_scores)\n\n    # Perform probabilistic swaps and greedy additions\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{The new algorithm employs a dynamic prioritization scheme that combines objective-specific marginal contributions with a probabilistic acceptance criterion, alternating between aggressive item swaps and conservative additions to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on alternating objectives\n    if random.random() < 0.5:\n        # Prioritize value1\n        priority_score = value1_lst / (weight_lst + 1e-10) * (1 + 0.2 * value2_lst / (weight_lst + 1e-10))\n    else:\n        # Prioritize value2\n        priority_score = value2_lst / (weight_lst + 1e-10) * (1 + 0.2 * value1_lst / (weight_lst + 1e-10))\n\n    sorted_items = np.argsort(-priority_score)\n\n    # Hybrid search with alternating strategies\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.43937644621562777,
            2.0898608565330505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on alternating objectives\n    if random.random() < 0.5:\n        # Prioritize value1\n        priority_score = value1_lst / (weight_lst + 1e-10) * (1 + 0.2 * value2_lst / (weight_lst + 1e-10))\n    else:\n        # Prioritize value2\n        priority_score = value2_lst / (weight_lst + 1e-10) * (1 + 0.2 * value1_lst / (weight_lst + 1e-10))\n\n    sorted_items = np.argsort(-priority_score)\n\n    # Hybrid search with alternating strategies\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{The novel local search strategy uses a dynamic clustering-based approach to identify item groups with complementary contributions to both objectives, then probabilistically replaces entire clusters with high-potential alternatives while maintaining feasibility through a weight-balanced reallocation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their contribution to both objectives\n    item_scores = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-item_scores)\n\n    # Identify clusters of items with similar scores\n    clusters = []\n    current_cluster = []\n    for i in range(len(sorted_items)):\n        if i == 0 or abs(item_scores[sorted_items[i]] - item_scores[sorted_items[i-1]]) < 0.1:\n            current_cluster.append(sorted_items[i])\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [sorted_items[i]]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Randomly select a cluster to replace\n    if clusters:\n        cluster_idx = random.randint(0, len(clusters) - 1)\n        selected_cluster = clusters[cluster_idx]\n\n        # Calculate total weight of the cluster\n        cluster_weight = np.sum(weight_lst[selected_cluster] * base_solution[selected_cluster])\n\n        # Find alternative items to replace the cluster\n        remaining_weight = capacity - (current_weight - cluster_weight)\n        potential_replacements = []\n        for item in sorted_items:\n            if item not in selected_cluster and weight_lst[item] <= remaining_weight:\n                potential_replacements.append(item)\n\n        # Select a random replacement pattern\n        if potential_replacements:\n            num_replacements = min(len(potential_replacements), len(selected_cluster))\n            selected_replacements = random.sample(potential_replacements, num_replacements)\n\n            # Replace the cluster\n            new_solution[selected_cluster] = 0\n            new_solution[selected_replacements] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.24486423069362212,
            6.010297775268555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their contribution to both objectives\n    item_scores = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-item_scores)\n\n    # Identify clusters of items with similar scores\n    clusters = []\n    current_cluster = []\n    for i in range(len(sorted_items)):\n        if i == 0 or abs(item_scores[sorted_items[i]] - item_scores[sorted_items[i-1]]) < 0.1:\n            current_cluster.append(sorted_items[i])\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [sorted_items[i]]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # Randomly select a cluster to replace\n    if clusters:\n        cluster_idx = random.randint(0, len(clusters) - 1)\n        selected_cluster = clusters[cluster_idx]\n\n        # Calculate total weight of the cluster\n        cluster_weight = np.sum(weight_lst[selected_cluster] * base_solution[selected_cluster])\n\n        # Find alternative items to replace the cluster\n        remaining_weight = capacity - (current_weight - cluster_weight)\n        potential_replacements = []\n        for item in sorted_items:\n            if item not in selected_cluster and weight_lst[item] <= remaining_weight:\n                potential_replacements.append(item)\n\n        # Select a random replacement pattern\n        if potential_replacements:\n            num_replacements = min(len(potential_replacements), len(selected_cluster))\n            selected_replacements = random.sample(potential_replacements, num_replacements)\n\n            # Replace the cluster\n            new_solution[selected_cluster] = 0\n            new_solution[selected_replacements] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy selection, where items are prioritized based on their normalized contributions to both objectives, while maintaining feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize objectives and calculate diversity-aware scores\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / max_value1 if max_value1 > 0 else value1_lst\n    norm_value2 = value2_lst / max_value2 if max_value2 > 0 else value2_lst\n\n    # Calculate diversity-aware scores (combination of normalized values and weight)\n    diversity_scores = (norm_value1 + norm_value2) / (weight_lst + 1e-10)\n\n    # Sort items by diversity scores (descending)\n    sorted_items = np.argsort(-diversity_scores)\n\n    # Perform adaptive perturbation and greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                # Adaptive probability based on diversity score\n                prob = 0.5 + 0.5 * (diversity_scores[item] / (np.max(diversity_scores) + 1e-10))\n                if random.random() < prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with adaptive weight adjustment\n    if current_weight > capacity:\n        # Remove items with lowest diversity scores until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5853486749854748,
            4.781958758831024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize objectives and calculate diversity-aware scores\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / max_value1 if max_value1 > 0 else value1_lst\n    norm_value2 = value2_lst / max_value2 if max_value2 > 0 else value2_lst\n\n    # Calculate diversity-aware scores (combination of normalized values and weight)\n    diversity_scores = (norm_value1 + norm_value2) / (weight_lst + 1e-10)\n\n    # Sort items by diversity scores (descending)\n    sorted_items = np.argsort(-diversity_scores)\n\n    # Perform adaptive perturbation and greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                # Adaptive probability based on diversity score\n                prob = 0.5 + 0.5 * (diversity_scores[item] / (np.max(diversity_scores) + 1e-10))\n                if random.random() < prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with adaptive weight adjustment\n    if current_weight > capacity:\n        # Remove items with lowest diversity scores until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy insertion, where items are prioritized based on their non-dominated front rankings and marginal contributions to both objectives, ensuring feasibility and exploration of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate non-dominated front rankings and marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform diversity-aware perturbation and multi-objective insertion\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            # Remove low-contribution items with higher probability\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and (current_weight + weight_lst[item] <= capacity):\n            # Insert high-contribution items with probability based on their rank\n            rank = np.where(sorted_items == item)[0][0]\n            insertion_prob = 0.8 * (1 - rank / len(sorted_items))\n            if random.random() < insertion_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different approach: swap with least critical items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:  # Start with least critical items\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.31418913075869725,
            5.034188598394394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate non-dominated front rankings and marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform diversity-aware perturbation and multi-objective insertion\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            # Remove low-contribution items with higher probability\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and (current_weight + weight_lst[item] <= capacity):\n            # Insert high-contribution items with probability based on their rank\n            rank = np.where(sorted_items == item)[0][0]\n            insertion_prob = 0.8 * (1 - rank / len(sorted_items))\n            if random.random() < insertion_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different approach: swap with least critical items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:  # Start with least critical items\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This new algorithm employs a multi-phase local search that first performs a targeted swap of high-contribution items, then applies a probabilistic perturbation to balance exploration and exploitation, followed by a feasibility-preserving adjustment phase to ensure the neighbor solution remains feasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Targeted swap of high-contribution items\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items[:len(sorted_items)//2]:\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 2: Probabilistic perturbation\n    for item in range(len(new_solution)):\n        if random.random() < 0.1:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Phase 3: Feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4553332694248367,
            5.989049047231674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Targeted swap of high-contribution items\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items[:len(sorted_items)//2]:\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 2: Probabilistic perturbation\n    for item in range(len(new_solution)):\n        if random.random() < 0.1:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Phase 3: Feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a dynamic perturbation: flip items based on their position in the sorted list\n    flip_probability = 0.5\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1:\n            # Higher-ranked items are less likely to be flipped\n            if random.random() < flip_probability * (1 - i / len(sorted_items)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Lower-ranked items are more likely to be added if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * (i / len(sorted_items)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest marginal items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7993871738441315,
            6.586517840623856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a dynamic perturbation: flip items based on their position in the sorted list\n    flip_probability = 0.5\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1:\n            # Higher-ranked items are less likely to be flipped\n            if random.random() < flip_probability * (1 - i / len(sorted_items)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Lower-ranked items are more likely to be added if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * (i / len(sorted_items)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest marginal items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The novel local search strategy employs a hybrid approach that combines a dynamic item prioritization based on Pareto dominance with a simulated annealing-inspired perturbation to escape local optima while maintaining feasibility, ensuring high-quality neighbors are generated through a balance of exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify Pareto-dominant items (items that improve at least one objective without worsening the other)\n    pareto_dominant = np.zeros_like(base_solution, dtype=bool)\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[i]\n                temp_value2 = current_value2 + value2_lst[i]\n                # Check if this item improves at least one objective without worsening the other\n                improves = False\n                for (_, (v1, v2)) in archive:\n                    if (v1 <= temp_value1 and v2 < temp_value2) or (v1 < temp_value1 and v2 <= temp_value2):\n                        improves = True\n                        break\n                if improves:\n                    pareto_dominant[i] = True\n\n    # Apply simulated annealing-inspired perturbation\n    temperature = 1.0\n    cooling_rate = 0.95\n    max_iterations = 10\n\n    for _ in range(max_iterations):\n        # Randomly select an item to potentially flip\n        item = random.randint(0, len(base_solution) - 1)\n\n        if base_solution[item] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_value1 = current_value1 - value1_lst[item]\n                new_value2 = current_value2 - value2_lst[item]\n                # Acceptance probability based on simulated annealing\n                delta = - (value1_lst[item] + value2_lst[item])  # Negative because we're removing\n                if delta > 0 or random.random() < np.exp(delta / temperature):\n                    new_solution[item] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try to add the item if it's Pareto-dominant or feasible\n            if pareto_dominant[item] or (current_weight + weight_lst[item] <= capacity):\n                new_weight = current_weight + weight_lst[item]\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n                # Acceptance probability based on simulated annealing\n                delta = value1_lst[item] + value2_lst[item]\n                if delta > 0 or random.random() < np.exp(delta / temperature):\n                    new_solution[item] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n        temperature *= cooling_rate\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        marginal = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.306758813474041,
            6.949093967676163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify Pareto-dominant items (items that improve at least one objective without worsening the other)\n    pareto_dominant = np.zeros_like(base_solution, dtype=bool)\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[i]\n                temp_value2 = current_value2 + value2_lst[i]\n                # Check if this item improves at least one objective without worsening the other\n                improves = False\n                for (_, (v1, v2)) in archive:\n                    if (v1 <= temp_value1 and v2 < temp_value2) or (v1 < temp_value1 and v2 <= temp_value2):\n                        improves = True\n                        break\n                if improves:\n                    pareto_dominant[i] = True\n\n    # Apply simulated annealing-inspired perturbation\n    temperature = 1.0\n    cooling_rate = 0.95\n    max_iterations = 10\n\n    for _ in range(max_iterations):\n        # Randomly select an item to potentially flip\n        item = random.randint(0, len(base_solution) - 1)\n\n        if base_solution[item] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight >= 0:\n                new_value1 = current_value1 - value1_lst[item]\n                new_value2 = current_value2 - value2_lst[item]\n                # Acceptance probability based on simulated annealing\n                delta = - (value1_lst[item] + value2_lst[item])  # Negative because we're removing\n                if delta > 0 or random.random() < np.exp(delta / temperature):\n                    new_solution[item] = 0\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Try to add the item if it's Pareto-dominant or feasible\n            if pareto_dominant[item] or (current_weight + weight_lst[item] <= capacity):\n                new_weight = current_weight + weight_lst[item]\n                new_value1 = current_value1 + value1_lst[item]\n                new_value2 = current_value2 + value2_lst[item]\n                # Acceptance probability based on simulated annealing\n                delta = value1_lst[item] + value2_lst[item]\n                if delta > 0 or random.random() < np.exp(delta / temperature):\n                    new_solution[item] = 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n        temperature *= cooling_rate\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        marginal = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{The new algorithm employs a hybrid local search strategy that combines a dynamic marginal contribution-based selection with a probabilistic flipping mechanism, prioritizing items with high normalized value-to-weight ratios in both objectives to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    norm_marginal1 = value1_lst / (weight_lst + 1e-10)\n    norm_marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions with dynamic weights\n    alpha = random.uniform(0.3, 0.7)  # Random weight for objective 1\n    combined_marginal = alpha * norm_marginal1 + (1 - alpha) * norm_marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform hybrid local search: dynamic flipping with probabilistic selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out items with lower marginal contribution\n            flip_prob = 0.6 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8732266359101863,
            9.579501390457153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    norm_marginal1 = value1_lst / (weight_lst + 1e-10)\n    norm_marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions with dynamic weights\n    alpha = random.uniform(0.3, 0.7)  # Random weight for objective 1\n    combined_marginal = alpha * norm_marginal1 + (1 - alpha) * norm_marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform hybrid local search: dynamic flipping with probabilistic selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out items with lower marginal contribution\n            flip_prob = 0.6 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The novel local search strategy employs a hybrid approach that combines a normalized marginal contribution-based prioritization with a dynamic selection probability mechanism, where items are probabilistically swapped or added based on their normalized objective-specific contributions, ensuring feasibility and maximizing multi-objective gains.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalized marginal contributions for both objectives\n    norm_marginal1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    norm_marginal2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n\n    # Dynamic selection probability based on normalized contributions\n    combined_marginal = norm_marginal1 + norm_marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Hybrid local search with dynamic probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on normalized contribution\n            flip_prob = 0.3 + 0.7 * (1 - combined_marginal[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with dynamic probability based on normalized contribution\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.2 + 0.8 * combined_marginal[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest normalized contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4677025736182101,
            3.5604249238967896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalized marginal contributions for both objectives\n    norm_marginal1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    norm_marginal2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n\n    # Dynamic selection probability based on normalized contributions\n    combined_marginal = norm_marginal1 + norm_marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Hybrid local search with dynamic probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on normalized contribution\n            flip_prob = 0.3 + 0.7 * (1 - combined_marginal[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with dynamic probability based on normalized contribution\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.2 + 0.8 * combined_marginal[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest normalized contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{The new algorithm uses a dynamic marginal contribution scoring mechanism that combines normalized objective values with a temperature-based probabilistic selection to explore high-value regions while maintaining feasibility, followed by a targeted item replacement strategy based on Pareto dominance and weight efficiency.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values1 = np.array([obj[0] for _, obj in archive])\n    total_values2 = np.array([obj[1] for _, obj in archive])\n    norm_values1 = (total_values1 - np.min(total_values1)) / (np.max(total_values1) - np.min(total_values1) + 1e-10)\n    norm_values2 = (total_values2 - np.min(total_values2)) / (np.max(total_values2) - np.min(total_values2) + 1e-10)\n    combined_scores = norm_values1 + norm_values2\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic marginal contributions with temperature-based weighting\n    temp = 0.7  # Temperature parameter for exploration\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / (1 + temp * np.max(marginal1 + marginal2))\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform targeted item replacement based on Pareto dominance and weight efficiency\n    current_weight = np.sum(weight_lst * base_solution)\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low marginal contribution or high weight\n            remove_prob = 0.3 * (1 - combined_marginal[item]) + 0.7 * (weight_lst[item] / capacity)\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-marginal items that improve at least one objective\n            if current_weight + weight_lst[item] <= capacity:\n                add_score = (value1_lst[item] / (current_value1 + 1e-10)) + (value2_lst[item] / (current_value2 + 1e-10))\n                if random.random() < add_score * 0.5:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with smallest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9091693949592783,
            5.91691130399704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_values1 = np.array([obj[0] for _, obj in archive])\n    total_values2 = np.array([obj[1] for _, obj in archive])\n    norm_values1 = (total_values1 - np.min(total_values1)) / (np.max(total_values1) - np.min(total_values1) + 1e-10)\n    norm_values2 = (total_values2 - np.min(total_values2)) / (np.max(total_values2) - np.min(total_values2) + 1e-10)\n    combined_scores = norm_values1 + norm_values2\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate dynamic marginal contributions with temperature-based weighting\n    temp = 0.7  # Temperature parameter for exploration\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / (1 + temp * np.max(marginal1 + marginal2))\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform targeted item replacement based on Pareto dominance and weight efficiency\n    current_weight = np.sum(weight_lst * base_solution)\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low marginal contribution or high weight\n            remove_prob = 0.3 * (1 - combined_marginal[item]) + 0.7 * (weight_lst[item] / capacity)\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-marginal items that improve at least one objective\n            if current_weight + weight_lst[item] <= capacity:\n                add_score = (value1_lst[item] / (current_value1 + 1e-10)) + (value2_lst[item] / (current_value2 + 1e-10))\n                if random.random() < add_score * 0.5:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with smallest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{The novel local search strategy combines a dynamic item clustering with a Pareto-optimal selection mechanism, where items are grouped based on their value correlations across objectives, and then selectively replaced or added using a probabilistic Pareto-dominance criterion to ensure both feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value correlations\n    value_correlation = np.corrcoef(value1_lst, value2_lst)[0, 1]\n    cluster_mask = (value1_lst > np.median(value1_lst)) & (value2_lst > np.median(value2_lst))\n\n    # Sort items by a combined score of value and weight\n    combined_score = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform dynamic clustering-based local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items from low-correlation clusters with probability\n            if not cluster_mask[item] and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items from high-correlation clusters if feasible\n            if cluster_mask[item] and current_weight + weight_lst[item] <= capacity:\n                if random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest combined score\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.814225818047489,
            5.166608482599258
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value correlations\n    value_correlation = np.corrcoef(value1_lst, value2_lst)[0, 1]\n    cluster_mask = (value1_lst > np.median(value1_lst)) & (value2_lst > np.median(value2_lst))\n\n    # Sort items by a combined score of value and weight\n    combined_score = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform dynamic clustering-based local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items from low-correlation clusters with probability\n            if not cluster_mask[item] and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items from high-correlation clusters if feasible\n            if cluster_mask[item] and current_weight + weight_lst[item] <= capacity:\n                if random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest combined score\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3956015796508031,
            1.6344321370124817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{The novel local search strategy combines a dynamic clustering of items based on their value-weight ratios and applies a cluster-based perturbation, where entire clusters are probabilistically added or removed to explore trade-offs between objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their value-weight ratios\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Normalize ratios and cluster items\n    normalized_ratio = (combined_ratio - np.min(combined_ratio)) / (np.max(combined_ratio) - np.min(combined_ratio) + 1e-10)\n    clusters = np.digitize(normalized_ratio, bins=[0.25, 0.5, 0.75])\n\n    # Process clusters in random order\n    cluster_order = np.random.permutation(np.unique(clusters))\n\n    for cluster in cluster_order:\n        cluster_items = np.where(clusters == cluster)[0]\n        cluster_weight = np.sum(weight_lst[cluster_items] * base_solution[cluster_items])\n        cluster_size = len(cluster_items)\n\n        # Probabilistically flip entire cluster based on its characteristics\n        flip_prob = 0.4 if cluster_weight > 0 else 0.6\n\n        if random.random() < flip_prob:\n            if cluster_weight > 0:  # Cluster is currently included\n                # Try to remove entire cluster\n                if current_weight - cluster_weight >= 0:\n                    new_solution[cluster_items] = 0\n                    current_weight -= cluster_weight\n            else:  # Cluster is currently excluded\n                # Try to add entire cluster\n                if current_weight + np.sum(weight_lst[cluster_items]) <= capacity:\n                    new_solution[cluster_items] = 1\n                    current_weight += np.sum(weight_lst[cluster_items])\n\n    # Ensure feasibility by removing items from least valuable clusters\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for cluster in reversed(cluster_order):\n            cluster_items = np.where(clusters == cluster)[0]\n            cluster_in_solution = cluster_items[new_solution[cluster_items] == 1]\n\n            for item in cluster_in_solution:\n                if excess_weight <= 0:\n                    break\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.2824249621411081,
            9.687328666448593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their value-weight ratios\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Normalize ratios and cluster items\n    normalized_ratio = (combined_ratio - np.min(combined_ratio)) / (np.max(combined_ratio) - np.min(combined_ratio) + 1e-10)\n    clusters = np.digitize(normalized_ratio, bins=[0.25, 0.5, 0.75])\n\n    # Process clusters in random order\n    cluster_order = np.random.permutation(np.unique(clusters))\n\n    for cluster in cluster_order:\n        cluster_items = np.where(clusters == cluster)[0]\n        cluster_weight = np.sum(weight_lst[cluster_items] * base_solution[cluster_items])\n        cluster_size = len(cluster_items)\n\n        # Probabilistically flip entire cluster based on its characteristics\n        flip_prob = 0.4 if cluster_weight > 0 else 0.6\n\n        if random.random() < flip_prob:\n            if cluster_weight > 0:  # Cluster is currently included\n                # Try to remove entire cluster\n                if current_weight - cluster_weight >= 0:\n                    new_solution[cluster_items] = 0\n                    current_weight -= cluster_weight\n            else:  # Cluster is currently excluded\n                # Try to add entire cluster\n                if current_weight + np.sum(weight_lst[cluster_items]) <= capacity:\n                    new_solution[cluster_items] = 1\n                    current_weight += np.sum(weight_lst[cluster_items])\n\n    # Ensure feasibility by removing items from least valuable clusters\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for cluster in reversed(cluster_order):\n            cluster_items = np.where(clusters == cluster)[0]\n            cluster_in_solution = cluster_items[new_solution[cluster_items] == 1]\n\n            for item in cluster_in_solution:\n                if excess_weight <= 0:\n                    break\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This new algorithm uses a cluster-based local search that first identifies item clusters with high combined value-to-weight ratios, then performs targeted swaps within these clusters to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Identify top 30% items with highest combined ratio\n    sorted_items = np.argsort(-combined_ratio)\n    cluster_size = max(1, int(0.3 * len(sorted_items)))\n    cluster = sorted_items[:cluster_size]\n\n    # Perform targeted swaps within the cluster\n    for i in range(len(cluster)):\n        for j in range(i + 1, len(cluster)):\n            item1, item2 = cluster[i], cluster[j]\n            if base_solution[item1] != base_solution[item2]:\n                # Check if swap maintains feasibility\n                delta_weight = weight_lst[item2] - weight_lst[item1]\n                if (base_solution[item1] == 1 and current_weight + delta_weight <= capacity) or \\\n                   (base_solution[item2] == 1 and current_weight - delta_weight >= 0):\n                    # Perform swap\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight += delta_weight\n                    break\n\n    # Ensure feasibility (minor adjustment if needed)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5769230974096233,
            5.877369225025177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Identify top 30% items with highest combined ratio\n    sorted_items = np.argsort(-combined_ratio)\n    cluster_size = max(1, int(0.3 * len(sorted_items)))\n    cluster = sorted_items[:cluster_size]\n\n    # Perform targeted swaps within the cluster\n    for i in range(len(cluster)):\n        for j in range(i + 1, len(cluster)):\n            item1, item2 = cluster[i], cluster[j]\n            if base_solution[item1] != base_solution[item2]:\n                # Check if swap maintains feasibility\n                delta_weight = weight_lst[item2] - weight_lst[item1]\n                if (base_solution[item1] == 1 and current_weight + delta_weight <= capacity) or \\\n                   (base_solution[item2] == 1 and current_weight - delta_weight >= 0):\n                    # Perform swap\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight += delta_weight\n                    break\n\n    # Ensure feasibility (minor adjustment if needed)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The novel local search strategy employs an adaptive value-based prioritization with a dynamic thresholding mechanism to selectively include/exclude items, balancing both objectives while ensuring feasibility through iterative weight adjustment and probabilistic selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Compute adaptive thresholds based on current solution's values\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n    threshold1 = current_value1 * 0.9\n    threshold2 = current_value2 * 0.9\n\n    # Identify items with high marginal contribution\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic thresholding and probabilistic selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item if below threshold or with probability\n            if (value1_lst[item] < threshold1 or value2_lst[item] < threshold2) and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible and meets threshold\n            if current_weight + weight_lst[item] <= capacity:\n                if (value1_lst[item] >= threshold1 or value2_lst[item] >= threshold2) and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7871236348996336,
            3.252501457929611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Compute adaptive thresholds based on current solution's values\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n    threshold1 = current_value1 * 0.9\n    threshold2 = current_value2 * 0.9\n\n    # Identify items with high marginal contribution\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic thresholding and probabilistic selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item if below threshold or with probability\n            if (value1_lst[item] < threshold1 or value2_lst[item] < threshold2) and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible and meets threshold\n            if current_weight + weight_lst[item] <= capacity:\n                if (value1_lst[item] >= threshold1 or value2_lst[item] >= threshold2) and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined marginal contribution (descending)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its marginal contribution\n            flip_prob = 0.5 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest marginal contribution\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{The novel local search strategy combines a diversity-preserving perturbation with a multi-objective greedy insertion, where items are prioritized based on their Pareto-optimal contributions, ensuring both exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-optimal contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    pareto_scores = value1_norm + value2_norm - (value1_norm * value2_norm)\n\n    # Sort items by Pareto scores (descending)\n    sorted_items = np.argsort(-pareto_scores)\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove with probability inversely proportional to Pareto score\n            remove_prob = 0.2 * (1 - pareto_scores[item])\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability proportional to Pareto score\n            add_prob = 0.5 * pareto_scores[item]\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    for item in sorted_items:\n        if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n            # Add item if it improves both objectives\n            if (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        excess = np.sum(weight_lst * new_solution) - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and weight_lst[item] <= excess:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.33304821176940436,
            5.910110712051392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-optimal contributions\n    value1_norm = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.max(value2_lst) + 1e-10)\n    pareto_scores = value1_norm + value2_norm - (value1_norm * value2_norm)\n\n    # Sort items by Pareto scores (descending)\n    sorted_items = np.argsort(-pareto_scores)\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove with probability inversely proportional to Pareto score\n            remove_prob = 0.2 * (1 - pareto_scores[item])\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability proportional to Pareto score\n            add_prob = 0.5 * pareto_scores[item]\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    for item in sorted_items:\n        if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n            # Add item if it improves both objectives\n            if (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        excess = np.sum(weight_lst * new_solution) - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and weight_lst[item] <= excess:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This novel algorithm employs a hybrid approach combining Pareto-frontier guided flips with a probabilistic dominance-based exploration, where items are prioritized based on their normalized contributions to both objectives, and solutions are refined through adaptive temperature-based perturbations while maintaining feasibility through a dynamic weight adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient contributions\n    norm_value1 = value1_lst / np.max(value1_lst)\n    norm_value2 = value2_lst / np.max(value2_lst)\n    pareto_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-pareto_score)\n\n    # Dynamic temperature-based perturbation\n    temp_factor = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on dominance\n            if random.random() < temp_factor * (1 - pareto_score[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistic addition based on feasibility and potential\n            if current_weight + weight_lst[item] <= capacity and random.random() < (1 - temp_factor) * pareto_score[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility adjustment with dynamic weight threshold\n    if current_weight > capacity:\n        threshold = 0.8 * capacity\n        while current_weight > threshold:\n            for item in sorted_items:\n                if new_solution[item] == 1 and current_weight > threshold:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.36556728042393766,
            8.179687708616257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient contributions\n    norm_value1 = value1_lst / np.max(value1_lst)\n    norm_value2 = value2_lst / np.max(value2_lst)\n    pareto_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-pareto_score)\n\n    # Dynamic temperature-based perturbation\n    temp_factor = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on dominance\n            if random.random() < temp_factor * (1 - pareto_score[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistic addition based on feasibility and potential\n            if current_weight + weight_lst[item] <= capacity and random.random() < (1 - temp_factor) * pareto_score[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility adjustment with dynamic weight threshold\n    if current_weight > capacity:\n        threshold = 0.8 * capacity\n        while current_weight > threshold:\n            for item in sorted_items:\n                if new_solution[item] == 1 and current_weight > threshold:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with high marginal contribution to either objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to either objective (descending)\n    sorted_items = np.argsort(-np.maximum(marginal_value1, marginal_value2))\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4466315345223113,
            1.7705729305744171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with high marginal contribution to either objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to either objective (descending)\n    sorted_items = np.argsort(-np.maximum(marginal_value1, marginal_value2))\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{The novel algorithm combines a diversity-aware selection of solutions with a multi-objective hill-climbing approach that alternates between improving one objective while temporarily sacrificing the other, ensuring balanced exploration of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        distances = []\n        for i, (sol_i, _) in enumerate(archive):\n            dist = 0\n            for j, (sol_j, _) in enumerate(archive):\n                if i != j:\n                    dist += np.sum(sol_i != sol_j)\n            distances.append(dist)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Alternate between improving value1 and value2\n    if random.random() < 0.5:\n        # Improve value1 while allowing temporary value2 decrease\n        value1_per_weight = value1_lst / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-value1_per_weight)\n\n        for item in sorted_items:\n            if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n    else:\n        # Improve value2 while allowing temporary value1 decrease\n        value2_per_weight = value2_lst / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-value2_per_weight)\n\n        for item in sorted_items:\n            if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5308066777474448,
            5.0250038504600525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        distances = []\n        for i, (sol_i, _) in enumerate(archive):\n            dist = 0\n            for j, (sol_j, _) in enumerate(archive):\n                if i != j:\n                    dist += np.sum(sol_i != sol_j)\n            distances.append(dist)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Alternate between improving value1 and value2\n    if random.random() < 0.5:\n        # Improve value1 while allowing temporary value2 decrease\n        value1_per_weight = value1_lst / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-value1_per_weight)\n\n        for item in sorted_items:\n            if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n    else:\n        # Improve value2 while allowing temporary value1 decrease\n        value2_per_weight = value2_lst / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-value2_per_weight)\n\n        for item in sorted_items:\n            if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest combined ratio\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The new algorithm employs a two-phase approach: first, it identifies and probabilistically removes underperforming items based on their marginal contribution to the objectives, followed by a greedy insertion of high-value items that significantly improve the combined objective, while always maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Remove underperforming items\n    for item in range(len(base_solution)):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Phase 2: Greedily add high-value items\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            if random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.31582190593821047,
            2.9556632041931152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Remove underperforming items\n    for item in range(len(base_solution)):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Phase 2: Greedily add high-value items\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            if random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a multi-objective greedy insertion strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, while maintaining solution diversity through adaptive neighborhood exploration and ensuring feasibility through constrained optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    diversity_scores = []\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 1:\n            # For included items, calculate how much their removal would affect both objectives\n            score = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n            diversity_scores.append((item, score, 'remove'))\n        else:\n            # For excluded items, calculate potential gain if added\n            if current_weight + weight_lst[item] <= capacity:\n                score = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n                diversity_scores.append((item, score, 'add'))\n\n    # Sort by score (descending) to prioritize high-impact items\n    diversity_scores.sort(key=lambda x: -x[1])\n\n    # Apply adaptive neighborhood exploration\n    for item, _, action in diversity_scores[:max(1, len(diversity_scores)//3)]:\n        if action == 'remove':\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        else:  # add\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate Pareto-optimal front for remaining items\n        remaining_items = [i for i in range(len(weight_lst)) if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity]\n        if remaining_items:\n            # Sort by non-dominated sorting (simplified approach)\n            remaining_items.sort(key=lambda i: -(value1_lst[i] + value2_lst[i]), reverse=True)\n\n            for item in remaining_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    # Check if adding improves at least one objective\n                    new_value1 = current_value1 + value1_lst[item]\n                    new_value2 = current_value2 + value2_lst[item]\n\n                    if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                       (new_value1 >= current_value1 and new_value2 > current_value2):\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n\n    # Ensure feasibility with minimal impact\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with smallest combined value-to-weight ratio\n        sorted_removals = sorted([(i, (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10))\n                                for i in range(len(weight_lst)) if new_solution[i] == 1],\n                               key=lambda x: x[1])\n        for item, _ in sorted_removals:\n            if excess <= 0:\n                break\n            new_solution[item] = 0\n            excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8965568912797756,
            5.000898897647858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    diversity_scores = []\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 1:\n            # For included items, calculate how much their removal would affect both objectives\n            score = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n            diversity_scores.append((item, score, 'remove'))\n        else:\n            # For excluded items, calculate potential gain if added\n            if current_weight + weight_lst[item] <= capacity:\n                score = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n                diversity_scores.append((item, score, 'add'))\n\n    # Sort by score (descending) to prioritize high-impact items\n    diversity_scores.sort(key=lambda x: -x[1])\n\n    # Apply adaptive neighborhood exploration\n    for item, _, action in diversity_scores[:max(1, len(diversity_scores)//3)]:\n        if action == 'remove':\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        else:  # add\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate Pareto-optimal front for remaining items\n        remaining_items = [i for i in range(len(weight_lst)) if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity]\n        if remaining_items:\n            # Sort by non-dominated sorting (simplified approach)\n            remaining_items.sort(key=lambda i: -(value1_lst[i] + value2_lst[i]), reverse=True)\n\n            for item in remaining_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    # Check if adding improves at least one objective\n                    new_value1 = current_value1 + value1_lst[item]\n                    new_value2 = current_value2 + value2_lst[item]\n\n                    if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                       (new_value1 >= current_value1 and new_value2 > current_value2):\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        current_value1 = new_value1\n                        current_value2 = new_value2\n\n    # Ensure feasibility with minimal impact\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with smallest combined value-to-weight ratio\n        sorted_removals = sorted([(i, (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10))\n                                for i in range(len(weight_lst)) if new_solution[i] == 1],\n                               key=lambda x: x[1])\n        for item, _ in sorted_removals:\n            if excess <= 0:\n                break\n            new_solution[item] = 0\n            excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The new algorithm employs a dynamic item prioritization based on both objective values and their interaction, followed by a two-phase perturbation where high-value items are either swapped or augmented with complementary items to enhance both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization: items with high value in either objective or balanced contribution\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    interaction_ratio = (value1_ratio + value2_ratio) * (value1_lst * value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-10)\n\n    # Sort items by interaction ratio (descending)\n    sorted_items = np.argsort(-interaction_ratio)\n\n    # Phase 1: Swap high-priority items probabilistically\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Phase 2: Add complementary items (high value in one objective but low in the other)\n    if current_weight < capacity:\n        for item in sorted_items:\n            if new_solution[item] == 0:\n                if (value1_ratio[item] > 1.5 * value2_ratio[item] or value2_ratio[item] > 1.5 * value1_ratio[item]):\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6026217188681544,
            4.592115432024002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization: items with high value in either objective or balanced contribution\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    interaction_ratio = (value1_ratio + value2_ratio) * (value1_lst * value2_lst) / (np.maximum(value1_lst, value2_lst) + 1e-10)\n\n    # Sort items by interaction ratio (descending)\n    sorted_items = np.argsort(-interaction_ratio)\n\n    # Phase 1: Swap high-priority items probabilistically\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Phase 2: Add complementary items (high value in one objective but low in the other)\n    if current_weight < capacity:\n        for item in sorted_items:\n            if new_solution[item] == 0:\n                if (value1_ratio[item] > 1.5 * value2_ratio[item] or value2_ratio[item] > 1.5 * value1_ratio[item]):\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{The new algorithm employs a weighted dominance-based selection with adaptive randomization, where items are prioritized based on their normalized contribution to both objectives, followed by a probabilistic swap with a bias toward improving the less-dominated objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    norm_value1 = value1_lst / (np.sum(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.sum(value2_lst) + 1e-10)\n    dominance_score = norm_value1 * 0.6 + norm_value2 * 0.4\n\n    sorted_items = np.argsort(-dominance_score)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3515503829686403,
            2.257652133703232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    norm_value1 = value1_lst / (np.sum(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.sum(value2_lst) + 1e-10)\n    dominance_score = norm_value1 * 0.6 + norm_value2 * 0.4\n\n    sorted_items = np.argsort(-dominance_score)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This new algorithm uses a dynamic marginal contribution scoring system that adaptsively weights item selection based on both objectives, combined with a probabilistic flip mechanism to balance exploration and exploitation while ensuring feasibility through a constrained greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic marginal contribution score\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n\n    # Adaptive weighting based on current solution's objective balance\n    if current_value1 > current_value2:\n        weight_factor = 0.7\n    else:\n        weight_factor = 0.3\n\n    combined_score = weight_factor * value1_contribution + (1 - weight_factor) * value2_contribution\n    sorted_items = np.argsort(-combined_score)\n\n    # Probabilistic flip with dynamic thresholds\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Constrained greedy adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5110038784001154,
            2.3585067093372345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic marginal contribution score\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n\n    # Adaptive weighting based on current solution's objective balance\n    if current_value1 > current_value2:\n        weight_factor = 0.7\n    else:\n        weight_factor = 0.3\n\n    combined_score = weight_factor * value1_contribution + (1 - weight_factor) * value2_contribution\n    sorted_items = np.argsort(-combined_score)\n\n    # Probabilistic flip with dynamic thresholds\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Constrained greedy adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{The new algorithm employs a hybrid strategy combining item clustering based on objective correlations with a dynamic neighborhood exploration that adaptsively selects items for swap or replacement, prioritizing items with high joint contribution to both objectives while maintaining feasibility through a constrained perturbation scheme.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on objective correlations\n    corr_matrix = np.corrcoef([value1_lst, value2_lst])\n    corr_values = corr_matrix[0, 1]\n    item_scores = (value1_lst + value2_lst) * (1 + corr_values) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-item_scores)\n\n    # Dynamic neighborhood exploration\n    for i in range(len(sorted_items)):\n        item = sorted_items[i]\n        if base_solution[item] == 1:\n            # Probabilistic swap with another item\n            swap_candidate = random.choice(sorted_items[max(0, i-2):min(len(sorted_items), i+3)])\n            if swap_candidate != item and base_solution[swap_candidate] == 0:\n                if current_weight - weight_lst[item] + weight_lst[swap_candidate] <= capacity:\n                    new_solution[item], new_solution[swap_candidate] = 0, 1\n                    current_weight = current_weight - weight_lst[item] + weight_lst[swap_candidate]\n        else:\n            # Add item if feasible and beneficial\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < 0.6 * (item_scores[item] / np.max(item_scores)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility through constrained removal\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6249653509080242,
            10.501003324985504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on objective correlations\n    corr_matrix = np.corrcoef([value1_lst, value2_lst])\n    corr_values = corr_matrix[0, 1]\n    item_scores = (value1_lst + value2_lst) * (1 + corr_values) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-item_scores)\n\n    # Dynamic neighborhood exploration\n    for i in range(len(sorted_items)):\n        item = sorted_items[i]\n        if base_solution[item] == 1:\n            # Probabilistic swap with another item\n            swap_candidate = random.choice(sorted_items[max(0, i-2):min(len(sorted_items), i+3)])\n            if swap_candidate != item and base_solution[swap_candidate] == 0:\n                if current_weight - weight_lst[item] + weight_lst[swap_candidate] <= capacity:\n                    new_solution[item], new_solution[swap_candidate] = 0, 1\n                    current_weight = current_weight - weight_lst[item] + weight_lst[swap_candidate]\n        else:\n            # Add item if feasible and beneficial\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < 0.6 * (item_scores[item] / np.max(item_scores)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility through constrained removal\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{The new algorithm employs a hybrid greedy-random approach that combines Pareto-frontier analysis with adaptive item prioritization, where items are scored based on their marginal contributions to both objectives, with a dynamic exploration-exploitation balance controlled by a tunable parameter to generate high-quality, feasible neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions and prioritize items\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic exploration-exploitation parameter\n    exploration_rate = 0.3\n\n    # Hybrid perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with lower marginal contribution\n            if random.random() < exploration_rate:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < (1 - exploration_rate) * (combined_marginal[item] / np.max(combined_marginal)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7620306981860647,
            10.486301928758621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions and prioritize items\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic exploration-exploitation parameter\n    exploration_rate = 0.3\n\n    # Hybrid perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with lower marginal contribution\n            if random.random() < exploration_rate:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < (1 - exploration_rate) * (combined_marginal[item] / np.max(combined_marginal)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The novel local search strategy combines a diversity-aware item reallocation with a probabilistic objective-balanced selection, where items are dynamically reassigned based on their current contribution to both objectives while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic objective-balanced prioritization\n    value1_contrib = value1_lst * base_solution\n    value2_contrib = value2_lst * base_solution\n    total_value1 = np.sum(value1_contrib)\n    total_value2 = np.sum(value2_contrib)\n\n    # Calculate diversity-aware scores\n    diversity_score = (value1_contrib / (total_value1 + 1e-10)) + (value2_contrib / (total_value2 + 1e-10))\n    sorted_items = np.argsort(-diversity_score)\n\n    # Adaptive reallocation with probabilistic selection\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            # Probabilistically remove low-diversity items\n            if diversity_score[item] < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.6:\n            # Probabilistically add items with high potential\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive weight adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Final diversification step\n    if random.random() < 0.2:\n        # Randomly swap a small number of items to maintain diversity\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=min(3, len(new_solution)), replace=False)\n        for idx in swap_indices:\n            if random.random() < 0.5 and current_weight - weight_lst[idx] + weight_lst[(idx + 1) % len(weight_lst)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[(idx + 1) % len(weight_lst)] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4863320194665697,
            2.644841730594635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic objective-balanced prioritization\n    value1_contrib = value1_lst * base_solution\n    value2_contrib = value2_lst * base_solution\n    total_value1 = np.sum(value1_contrib)\n    total_value2 = np.sum(value2_contrib)\n\n    # Calculate diversity-aware scores\n    diversity_score = (value1_contrib / (total_value1 + 1e-10)) + (value2_contrib / (total_value2 + 1e-10))\n    sorted_items = np.argsort(-diversity_score)\n\n    # Adaptive reallocation with probabilistic selection\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            # Probabilistically remove low-diversity items\n            if diversity_score[item] < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.6:\n            # Probabilistically add items with high potential\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive weight adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Final diversification step\n    if random.random() < 0.2:\n        # Randomly swap a small number of items to maintain diversity\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=min(3, len(new_solution)), replace=False)\n        for idx in swap_indices:\n            if random.random() < 0.5 and current_weight - weight_lst[idx] + weight_lst[(idx + 1) % len(weight_lst)] <= capacity:\n                new_solution[idx] = 0\n                new_solution[(idx + 1) % len(weight_lst)] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The novel local search strategy combines a dominance-based perturbation with a value-driven expansion, where items are prioritized based on their dominance in one objective while expanding in the other, ensuring balanced exploration of the Pareto front and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that are dominated in one objective but strong in the other\n    value1_dominance = value1_lst / (value2_lst + 1e-10)\n    value2_dominance = value2_lst / (value1_lst + 1e-10)\n\n    # Sort items by dominance in objective 1 (descending)\n    sorted_items_obj1 = np.argsort(-value1_dominance)\n\n    # Perturb by removing items that dominate in objective 1\n    for item in sorted_items_obj1:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Sort items by dominance in objective 2 (descending)\n    sorted_items_obj2 = np.argsort(-value2_dominance)\n\n    # Expand by adding items that dominate in objective 2\n    for item in sorted_items_obj2:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items_obj1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6782253829286621,
            3.0351912677288055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items that are dominated in one objective but strong in the other\n    value1_dominance = value1_lst / (value2_lst + 1e-10)\n    value2_dominance = value2_lst / (value1_lst + 1e-10)\n\n    # Sort items by dominance in objective 1 (descending)\n    sorted_items_obj1 = np.argsort(-value1_dominance)\n\n    # Perturb by removing items that dominate in objective 1\n    for item in sorted_items_obj1:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Sort items by dominance in objective 2 (descending)\n    sorted_items_obj2 = np.argsort(-value2_dominance)\n\n    # Expand by adding items that dominate in objective 2\n    for item in sorted_items_obj2:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items_obj1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{The new algorithm combines a diversity-preserving probabilistic swap with a greedy marginal contribution-based selection, where items are prioritized based on their normalized marginal gains in both objectives, ensuring feasibility and high-quality neighbors through adaptive perturbation and intelligent item replacement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    normalized_marginal = (marginal1 + marginal2) / (np.max(marginal1 + marginal2) + 1e-10)\n\n    # Sort items by normalized marginal contribution (descending)\n    sorted_items = np.argsort(-normalized_marginal)\n\n    # Adaptive perturbation: swap items with low marginal contribution\n    for item in sorted_items:\n        if base_solution[item] == 1 and normalized_marginal[item] < 0.5 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedy addition: add high-marginal items if feasible\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.6 * normalized_marginal[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8371908558513204,
            2.9387748539447784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    normalized_marginal = (marginal1 + marginal2) / (np.max(marginal1 + marginal2) + 1e-10)\n\n    # Sort items by normalized marginal contribution (descending)\n    sorted_items = np.argsort(-normalized_marginal)\n\n    # Adaptive perturbation: swap items with low marginal contribution\n    for item in sorted_items:\n        if base_solution[item] == 1 and normalized_marginal[item] < 0.5 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedy addition: add high-marginal items if feasible\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.6 * normalized_marginal[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{The new algorithm combines a Pareto-frontier guided perturbation with a value-to-weight ratio-based greedy selection, where items are prioritized based on their normalized contributions to both objectives while ensuring feasibility through adaptive thresholding and dominance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value-to-weight ratios\n    norm_value1 = value1_lst / (np.sum(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.sum(value2_lst) + 1e-10)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items that are not on the Pareto frontier\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high combined score if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive thresholding for dominance checks\n    threshold = 0.7 * np.max(combined_score)\n    for item in sorted_items:\n        if new_solution[item] == 1 and combined_score[item] < threshold:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest-score items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5331784052942188,
            4.006930291652679
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value-to-weight ratios\n    norm_value1 = value1_lst / (np.sum(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.sum(value2_lst) + 1e-10)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items that are not on the Pareto frontier\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high combined score if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive thresholding for dominance checks\n    threshold = 0.7 * np.max(combined_score)\n    for item in sorted_items:\n        if new_solution[item] == 1 and combined_score[item] < threshold:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest-score items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{The novel local search strategy combines a diversity-aware item selection with a Pareto-optimal balancing mechanism, where items are prioritized based on their trade-off between objectives and their potential to improve both values while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-optimal trade-off for each item\n    value1_normalized = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_normalized = value2_lst / (np.max(value2_lst) + 1e-10)\n    trade_off = np.abs(value1_normalized - value2_normalized)\n\n    # Sort items by trade-off (ascending) and weight (descending)\n    sorted_items = np.lexsort((-weight_lst, trade_off))\n\n    # Hybrid selection: prioritize items that improve both objectives when feasible\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items that don't contribute to both objectives\n            if (value1_lst[item] < 0.5 * np.mean(value1_lst) and value2_lst[item] < 0.5 * np.mean(value2_lst)) or random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that have balanced contribution to both objectives\n            if current_weight + weight_lst[item] <= capacity and (value1_lst[item] > 0.5 * np.mean(value1_lst) or value2_lst[item] > 0.5 * np.mean(value2_lst)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal impact\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1 and (value1_lst[item] < 0.3 * np.mean(value1_lst) or value2_lst[item] < 0.3 * np.mean(value2_lst)):\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4547678661112818,
            10.807645112276077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-optimal trade-off for each item\n    value1_normalized = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_normalized = value2_lst / (np.max(value2_lst) + 1e-10)\n    trade_off = np.abs(value1_normalized - value2_normalized)\n\n    # Sort items by trade-off (ascending) and weight (descending)\n    sorted_items = np.lexsort((-weight_lst, trade_off))\n\n    # Hybrid selection: prioritize items that improve both objectives when feasible\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items that don't contribute to both objectives\n            if (value1_lst[item] < 0.5 * np.mean(value1_lst) and value2_lst[item] < 0.5 * np.mean(value2_lst)) or random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that have balanced contribution to both objectives\n            if current_weight + weight_lst[item] <= capacity and (value1_lst[item] > 0.5 * np.mean(value1_lst) or value2_lst[item] > 0.5 * np.mean(value2_lst)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal impact\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1 and (value1_lst[item] < 0.3 * np.mean(value1_lst) or value2_lst[item] < 0.3 * np.mean(value2_lst)):\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n    combined_contribution = value1_contribution * value2_contribution  # Product to balance both objectives\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contribution)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-contribution items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4458106932195468,
            7.904520243406296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n    combined_contribution = value1_contribution * value2_contribution  # Product to balance both objectives\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contribution)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-contribution items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3928703337040748,
            9.125685423612595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The algorithm uses a multi-phase approach combining adaptive item prioritization based on marginal contributions to both objectives, followed by a guided perturbation that selectively flips items with high potential for improvement while maintaining feasibility, and finally applies a targeted refinement step to further optimize the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Phase 1: Adaptive perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item with probability based on its rank (higher rank = lower probability)\n            rank = np.where(sorted_items == item)[0][0]\n            prob = 0.1 * (1 - rank / len(sorted_items))\n            if random.random() < prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible and has high marginal contribution\n            if current_weight + weight_lst[item] <= capacity:\n                rank = np.where(sorted_items == item)[0][0]\n                prob = 0.5 * (1 - rank / len(sorted_items))\n                if random.random() < prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Phase 2: Targeted refinement\n    # Identify items that could improve at least one objective\n    improvement_candidates = []\n    for item in range(len(weight_lst)):\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves at least one objective\n            if value1_lst[item] > 0 or value2_lst[item] > 0:\n                improvement_candidates.append(item)\n\n    # Select top 3 candidates for addition\n    if improvement_candidates:\n        candidate_scores = [combined_marginal[item] for item in improvement_candidates]\n        top_candidates = np.argsort(-np.array(candidate_scores))[:3]\n        for idx in top_candidates:\n            item = improvement_candidates[idx]\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.35283147651579966,
            9.682762444019318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_values = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Phase 1: Adaptive perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item with probability based on its rank (higher rank = lower probability)\n            rank = np.where(sorted_items == item)[0][0]\n            prob = 0.1 * (1 - rank / len(sorted_items))\n            if random.random() < prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible and has high marginal contribution\n            if current_weight + weight_lst[item] <= capacity:\n                rank = np.where(sorted_items == item)[0][0]\n                prob = 0.5 * (1 - rank / len(sorted_items))\n                if random.random() < prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Phase 2: Targeted refinement\n    # Identify items that could improve at least one objective\n    improvement_candidates = []\n    for item in range(len(weight_lst)):\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves at least one objective\n            if value1_lst[item] > 0 or value2_lst[item] > 0:\n                improvement_candidates.append(item)\n\n    # Select top 3 candidates for addition\n    if improvement_candidates:\n        candidate_scores = [combined_marginal[item] for item in improvement_candidates]\n        top_candidates = np.argsort(-np.array(candidate_scores))[:3]\n        for idx in top_candidates:\n            item = improvement_candidates[idx]\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{The new algorithm employs a cluster-based neighborhood generation strategy that first partitions the archive into solution clusters based on item similarity, then selects a representative solution from the most diverse cluster, and applies a hybrid local search combining value-aware swaps and capacity-constrained perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Cluster solutions based on item similarity\n    solutions = [sol for sol, _ in archive]\n    clusters = {}\n    for i, sol in enumerate(solutions):\n        cluster_key = tuple(sol)\n        if cluster_key not in clusters:\n            clusters[cluster_key] = []\n        clusters[cluster_key].append(i)\n\n    # Select the most diverse cluster\n    selected_cluster = max(clusters.values(), key=len)\n    selected_idx = random.choice(selected_cluster)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Value-aware swap strategy\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform swaps between high and low value items\n    for i in range(len(sorted_items) // 2):\n        high_item = sorted_items[i]\n        low_item = sorted_items[-i-1]\n\n        if new_solution[high_item] == 1 and new_solution[low_item] == 0:\n            if current_weight - weight_lst[high_item] + weight_lst[low_item] <= capacity:\n                new_solution[high_item] = 0\n                new_solution[low_item] = 1\n                current_weight = current_weight - weight_lst[high_item] + weight_lst[low_item]\n\n    # Capacity-constrained perturbation\n    for item in sorted_items:\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7582693188474101,
            7.826560288667679
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Cluster solutions based on item similarity\n    solutions = [sol for sol, _ in archive]\n    clusters = {}\n    for i, sol in enumerate(solutions):\n        cluster_key = tuple(sol)\n        if cluster_key not in clusters:\n            clusters[cluster_key] = []\n        clusters[cluster_key].append(i)\n\n    # Select the most diverse cluster\n    selected_cluster = max(clusters.values(), key=len)\n    selected_idx = random.choice(selected_cluster)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Value-aware swap strategy\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform swaps between high and low value items\n    for i in range(len(sorted_items) // 2):\n        high_item = sorted_items[i]\n        low_item = sorted_items[-i-1]\n\n        if new_solution[high_item] == 1 and new_solution[low_item] == 0:\n            if current_weight - weight_lst[high_item] + weight_lst[low_item] <= capacity:\n                new_solution[high_item] = 0\n                new_solution[low_item] = 1\n                current_weight = current_weight - weight_lst[high_item] + weight_lst[low_item]\n\n    # Capacity-constrained perturbation\n    for item in sorted_items:\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a multi-objective greedy selection strategy, where items are prioritized based on their potential to improve both objectives while maintaining solution diversity through adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware item priorities\n    diversity_scores = np.zeros(len(weight_lst))\n    for i in range(len(archive)):\n        if i != selected_idx:\n            diversity_scores += np.abs(archive[i][0] - base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    combined_marginal = (combined_marginal - np.min(combined_marginal)) / (np.max(combined_marginal) - np.min(combined_marginal) + 1e-10)\n\n    # Combine diversity and marginal contribution\n    priority_scores = combined_marginal + 0.5 * diversity_scores / len(archive)\n    sorted_items = np.argsort(-priority_scores)\n\n    # Adaptive neighborhood exploration\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip based on diversity and marginal contribution\n            flip_prob = 0.2 + 0.3 * (1 - priority_scores[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add items with high priority if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing improves at least one objective\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing doesn't hurt either objective\n            if temp_value1 >= current_value1 and temp_value2 >= current_value2:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest priority items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.324439113316331,
            5.36925333738327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware item priorities\n    diversity_scores = np.zeros(len(weight_lst))\n    for i in range(len(archive)):\n        if i != selected_idx:\n            diversity_scores += np.abs(archive[i][0] - base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    combined_marginal = (combined_marginal - np.min(combined_marginal)) / (np.max(combined_marginal) - np.min(combined_marginal) + 1e-10)\n\n    # Combine diversity and marginal contribution\n    priority_scores = combined_marginal + 0.5 * diversity_scores / len(archive)\n    sorted_items = np.argsort(-priority_scores)\n\n    # Adaptive neighborhood exploration\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip based on diversity and marginal contribution\n            flip_prob = 0.2 + 0.3 * (1 - priority_scores[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add items with high priority if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing improves at least one objective\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing doesn't hurt either objective\n            if temp_value1 >= current_value1 and temp_value2 >= current_value2:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest priority items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The new algorithm uses a dynamic item prioritization approach that combines a weighted marginal contribution analysis with a probabilistic flip mechanism, where items are selected based on their relative importance to both objectives, and flips are guided by a balance between exploitation and exploration to generate high-quality, feasible neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    value1_contrib = value1_lst / (weight_lst + 1e-10)\n    value2_contrib = value2_lst / (weight_lst + 1e-10)\n    combined_contrib = (value1_contrib + value2_contrib) * (1 + 0.5 * np.random.rand(len(weight_lst)))\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contrib)\n\n    # Dynamic flip probability based on item importance\n    flip_prob = np.linspace(0.1, 0.9, len(sorted_items))\n\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1 and random.random() < flip_prob[i]:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.5 * flip_prob[i]:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4132949040423929,
            3.5114076733589172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    value1_contrib = value1_lst / (weight_lst + 1e-10)\n    value2_contrib = value2_lst / (weight_lst + 1e-10)\n    combined_contrib = (value1_contrib + value2_contrib) * (1 + 0.5 * np.random.rand(len(weight_lst)))\n\n    # Sort items by combined contribution (descending)\n    sorted_items = np.argsort(-combined_contrib)\n\n    # Dynamic flip probability based on item importance\n    flip_prob = np.linspace(0.1, 0.9, len(sorted_items))\n\n    for i, item in enumerate(sorted_items):\n        if base_solution[item] == 1 and random.random() < flip_prob[i]:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.5 * flip_prob[i]:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{The new algorithm employs a dynamic value-weighted perturbation strategy that combines a probabilistic item reassignment with a greedy selection of high-value items, where items are prioritized based on their normalized contribution to both objectives, while maintaining feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalized value scores for both objectives\n    value1_score = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_score = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = value1_score + value2_score\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic perturbation: probabilistic reassignment\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5 * combined_score[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility check\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5174941935560189,
            3.9364989399909973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalized value scores for both objectives\n    value1_score = value1_lst / (np.max(value1_lst) + 1e-10)\n    value2_score = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = value1_score + value2_score\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic perturbation: probabilistic reassignment\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5 * combined_score[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility check\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This algorithm implements a neighborhood exploration strategy that combines a probabilistic item reallocation with a marginal value-based item selection, where items are prioritized based on their individual contributions to each objective, ensuring feasibility and generating diverse high-quality neighbors by selectively reallocating items between objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contributions for each objective\n    sorted_items_value1 = np.argsort(-marginal_value1)\n    sorted_items_value2 = np.argsort(-marginal_value2)\n\n    # Probabilistic reallocation: prioritize items with high marginal value for either objective\n    for item in sorted_items_value1:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    for item in sorted_items_value2:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedy addition: add items with high marginal value for either objective if feasible\n    for item in sorted_items_value1:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    for item in sorted_items_value2:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest value items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items_value1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6231591572500139,
            7.914571046829224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contributions for each objective\n    sorted_items_value1 = np.argsort(-marginal_value1)\n    sorted_items_value2 = np.argsort(-marginal_value2)\n\n    # Probabilistic reallocation: prioritize items with high marginal value for either objective\n    for item in sorted_items_value1:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    for item in sorted_items_value2:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedy addition: add items with high marginal value for either objective if feasible\n    for item in sorted_items_value1:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    for item in sorted_items_value2:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest value items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items_value1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This novel local search strategy combines a multi-objective greedy insertion with a probabilistic removal of low-contributing items, where items are prioritized based on their Pareto-frontier dominance and marginal contributions to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected_idx = random.randint(0, min(2, len(archive)-1))  # Select from top 3 solutions\n    else:\n        selected_idx = 0\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items not in the current solution (potential candidates for insertion)\n    candidate_items = np.where(base_solution == 0)[0]\n\n    # Sort candidate items by Pareto dominance (simplified: prioritize items that improve both objectives)\n    pareto_scores = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n    sorted_candidates = np.argsort(-pareto_scores[candidate_items])\n\n    # Greedily insert high-priority items that fit\n    for item in sorted_candidates:\n        if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Probabilistically remove low-contributing items\n    for item in np.where(new_solution == 1)[0]:\n        if random.random() < 0.2:  # 20% chance to remove\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest combined ratio if needed\n    if current_weight > capacity:\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9588833784599934,
            2.3248770236968994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected_idx = random.randint(0, min(2, len(archive)-1))  # Select from top 3 solutions\n    else:\n        selected_idx = 0\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items not in the current solution (potential candidates for insertion)\n    candidate_items = np.where(base_solution == 0)[0]\n\n    # Sort candidate items by Pareto dominance (simplified: prioritize items that improve both objectives)\n    pareto_scores = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n    sorted_candidates = np.argsort(-pareto_scores[candidate_items])\n\n    # Greedily insert high-priority items that fit\n    for item in sorted_candidates:\n        if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Probabilistically remove low-contributing items\n    for item in np.where(new_solution == 1)[0]:\n        if random.random() < 0.2:  # 20% chance to remove\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest combined ratio if needed\n    if current_weight > capacity:\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = 0.7 * value1_ratio + 0.3 * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4560207005542309,
            1.6910613477230072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = 0.7 * value1_ratio + 0.3 * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The new algorithm uses a diversity-aware local search strategy that combines random item swaps with a multi-objective greedy selection mechanism, prioritizing items based on their marginal contributions to both objectives while ensuring solution feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: random swaps with greedy adjustments\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # With 20% probability, try to remove the item\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # With 50% probability, try to add the item if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest marginal items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.406069311355837,
            2.953814208507538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: random swaps with greedy adjustments\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # With 20% probability, try to remove the item\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # With 50% probability, try to add the item if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest marginal items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5999999366184239,
            4.23921126127243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{The novel local search strategy combines a probabilistic item removal with a value-driven greedy insertion, where items are prioritized based on their individual contributions to each objective, while ensuring feasibility and maintaining diversity in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to each objective\n    sorted_items1 = np.argsort(-marginal1)\n    sorted_items2 = np.argsort(-marginal2)\n\n    # Probabilistic removal of low-value items\n    for item in range(len(new_solution)):\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedy insertion of high-value items for each objective\n    for item in sorted_items1:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    for item in sorted_items2:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in range(len(new_solution)):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.32017760816251495,
            5.715686410665512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to each objective\n    sorted_items1 = np.argsort(-marginal1)\n    sorted_items2 = np.argsort(-marginal2)\n\n    # Probabilistic removal of low-value items\n    for item in range(len(new_solution)):\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedy insertion of high-value items for each objective\n    for item in sorted_items1:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    for item in sorted_items2:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in range(len(new_solution)):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The new algorithm employs a dynamic cluster-based perturbation strategy that first identifies solution clusters in the archive, then selectively applies a hybrid of greedy and probabilistic item swaps within clusters, prioritizing items based on their normalized marginal contributions to both objectives while maintaining feasibility through adaptive weight balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives[:, 0] + objectives[:, 1]\n    normalized_scores = normalized_scores / np.sum(normalized_scores)\n    selected_idx = np.random.choice(len(archive), p=normalized_scores)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic cluster-based perturbation\n    cluster_size = max(1, len(sorted_items) // 5)\n    for i in range(0, len(sorted_items), cluster_size):\n        cluster = sorted_items[i:i+cluster_size]\n        cluster_weight = np.sum(weight_lst[cluster])\n        cluster_value1 = np.sum(value1_lst[cluster])\n        cluster_value2 = np.sum(value2_lst[cluster])\n\n        # Probabilistic cluster swap\n        if current_weight - cluster_weight + cluster_weight <= capacity:\n            if random.random() < 0.5:\n                # Swap entire cluster\n                new_solution[cluster] = 1 - new_solution[cluster]\n                current_weight = current_weight - np.sum(weight_lst[base_solution == 1]) + np.sum(weight_lst[new_solution == 1])\n            else:\n                # Greedy cluster addition\n                if current_weight + cluster_weight <= capacity and random.random() < 0.6:\n                    new_solution[cluster] = 1\n                    current_weight += cluster_weight\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.43098473909308666,
            5.099405348300934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = objectives[:, 0] + objectives[:, 1]\n    normalized_scores = normalized_scores / np.sum(normalized_scores)\n    selected_idx = np.random.choice(len(archive), p=normalized_scores)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic cluster-based perturbation\n    cluster_size = max(1, len(sorted_items) // 5)\n    for i in range(0, len(sorted_items), cluster_size):\n        cluster = sorted_items[i:i+cluster_size]\n        cluster_weight = np.sum(weight_lst[cluster])\n        cluster_value1 = np.sum(value1_lst[cluster])\n        cluster_value2 = np.sum(value2_lst[cluster])\n\n        # Probabilistic cluster swap\n        if current_weight - cluster_weight + cluster_weight <= capacity:\n            if random.random() < 0.5:\n                # Swap entire cluster\n                new_solution[cluster] = 1 - new_solution[cluster]\n                current_weight = current_weight - np.sum(weight_lst[base_solution == 1]) + np.sum(weight_lst[new_solution == 1])\n            else:\n                # Greedy cluster addition\n                if current_weight + cluster_weight <= capacity and random.random() < 0.6:\n                    new_solution[cluster] = 1\n                    current_weight += cluster_weight\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The new algorithm employs a hybrid approach combining adaptive Pareto front sampling with a multi-armed bandit-inspired exploration strategy, where items are dynamically prioritized based on their estimated contribution to both objectives, while maintaining feasibility through a constraint-aware exploration-exploitation tradeoff mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance counts (simplified for selection)\n        dominance = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    v1_i, v2_i = archive[i][1]\n                    v1_j, v2_j = archive[j][1]\n                    if (v1_i >= v1_j and v2_i > v2_j) or (v1_i > v1_j and v2_i >= v2_j):\n                        dominance[i] += 1\n        # Select with inverse probability of being dominated\n        selection_probs = 1 / (1 + dominance)\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Multi-armed bandit approach for item selection\n    item_rewards = np.zeros(len(weight_lst))\n    item_counts = np.ones(len(weight_lst))\n\n    # Initial exploration phase\n    for _ in range(min(10, len(weight_lst))):\n        item = np.random.randint(0, len(weight_lst))\n        if base_solution[item] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                new_solution[item] = 0\n                current_weight = temp_weight\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        else:\n            # Try adding item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        item_counts[item] += 1\n\n    # Exploitation phase with UCB-like selection\n    for _ in range(20):\n        # Calculate UCB scores\n        ucb_scores = item_rewards / item_counts + np.sqrt(2 * np.log(np.sum(item_counts)) / item_counts)\n        item = np.argmax(ucb_scores)\n\n        if base_solution[item] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                new_solution[item] = 0\n                current_weight = temp_weight\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        else:\n            # Try adding item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        item_counts[item] += 1\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items with lowest value-to-weight ratio\n        value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(value_ratio)\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3323266366509493,
            8.42129534482956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance counts (simplified for selection)\n        dominance = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    v1_i, v2_i = archive[i][1]\n                    v1_j, v2_j = archive[j][1]\n                    if (v1_i >= v1_j and v2_i > v2_j) or (v1_i > v1_j and v2_i >= v2_j):\n                        dominance[i] += 1\n        # Select with inverse probability of being dominated\n        selection_probs = 1 / (1 + dominance)\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Multi-armed bandit approach for item selection\n    item_rewards = np.zeros(len(weight_lst))\n    item_counts = np.ones(len(weight_lst))\n\n    # Initial exploration phase\n    for _ in range(min(10, len(weight_lst))):\n        item = np.random.randint(0, len(weight_lst))\n        if base_solution[item] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                new_solution[item] = 0\n                current_weight = temp_weight\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        else:\n            # Try adding item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        item_counts[item] += 1\n\n    # Exploitation phase with UCB-like selection\n    for _ in range(20):\n        # Calculate UCB scores\n        ucb_scores = item_rewards / item_counts + np.sqrt(2 * np.log(np.sum(item_counts)) / item_counts)\n        item = np.argmax(ucb_scores)\n\n        if base_solution[item] == 1:\n            # Try removing item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                new_solution[item] = 0\n                current_weight = temp_weight\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        else:\n            # Try adding item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                item_rewards[item] += value1_lst[item] + value2_lst[item]\n        item_counts[item] += 1\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items with lowest value-to-weight ratio\n        value_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(value_ratio)\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{The new algorithm combines a multi-objective adaptive perturbation with a greedy dominance-aware selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, while dynamically adjusting the exploration-exploitation balance through a novel hybrid objective function that balances marginal gains and solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate hybrid objective scores\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    diversity_score = np.sum(np.abs(base_solution - archive[random.randint(0, len(archive)-1)][0]))\n    hybrid_score = marginal1 + marginal2 + 0.1 * diversity_score * (1 - base_solution)\n\n    # Sort items by hybrid score\n    sorted_items = np.argsort(-hybrid_score)\n\n    # Adaptive perturbation based on solution quality\n    solution_quality = (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))\n    perturbation_strength = 0.5 * (1 - solution_quality)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low marginal contribution\n            if random.random() < perturbation_strength * (1 - hybrid_score[item] / np.max(hybrid_score)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution and diversity\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - perturbation_strength) * (hybrid_score[item] / np.max(hybrid_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy dominance-aware selection\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removing improves at least one objective\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8892445824663859,
            7.5247408747673035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate hybrid objective scores\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    diversity_score = np.sum(np.abs(base_solution - archive[random.randint(0, len(archive)-1)][0]))\n    hybrid_score = marginal1 + marginal2 + 0.1 * diversity_score * (1 - base_solution)\n\n    # Sort items by hybrid score\n    sorted_items = np.argsort(-hybrid_score)\n\n    # Adaptive perturbation based on solution quality\n    solution_quality = (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))\n    perturbation_strength = 0.5 * (1 - solution_quality)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low marginal contribution\n            if random.random() < perturbation_strength * (1 - hybrid_score[item] / np.max(hybrid_score)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution and diversity\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - perturbation_strength) * (hybrid_score[item] / np.max(hybrid_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy dominance-aware selection\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removing improves at least one objective\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The new algorithm employs a hybrid of genetic algorithm-inspired crossover with a local search that prioritizes items based on their adaptive value contributions, using a tournament selection mechanism to ensure both objective improvements while maintaining feasibility through a dynamic capacity adjustment strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(3, len(archive))\n    selected_indices = random.sample(range(len(archive)), tournament_size)\n    selected_solutions = [archive[i] for i in selected_indices]\n\n    # Select the best solution from the tournament\n    best_solution = max(selected_solutions, key=lambda x: sum(x[1]))\n    base_solution, (current_value1, current_value2) = best_solution\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and adaptive value contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_contrib = value1_lst / (weight_lst + 1e-10)\n    value2_contrib = value2_lst / (weight_lst + 1e-10)\n    adaptive_weights = value1_contrib + value2_contrib\n\n    # Genetic crossover-inspired perturbation\n    crossover_point = random.randint(0, len(weight_lst) - 1)\n    for i in range(crossover_point):\n        if random.random() < 0.5:  # 50% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Local search with adaptive value contributions\n    sorted_items = np.argsort(-adaptive_weights)\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing item if it doesn't hurt both objectives\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 >= current_value2) and \\\n               (temp_value1 > current_value1 or temp_value2 > current_value2):\n                new_solution[item] = 0\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n        else:\n            # Try adding item if feasible and improves at least one objective\n            if current_weight + weight_lst[item] <= capacity:\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                if temp_value1 > current_value1 or temp_value2 > current_value2:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Dynamic capacity adjustment if still over capacity\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3201527459782873,
            5.089758068323135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    tournament_size = min(3, len(archive))\n    selected_indices = random.sample(range(len(archive)), tournament_size)\n    selected_solutions = [archive[i] for i in selected_indices]\n\n    # Select the best solution from the tournament\n    best_solution = max(selected_solutions, key=lambda x: sum(x[1]))\n    base_solution, (current_value1, current_value2) = best_solution\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and adaptive value contributions\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_contrib = value1_lst / (weight_lst + 1e-10)\n    value2_contrib = value2_lst / (weight_lst + 1e-10)\n    adaptive_weights = value1_contrib + value2_contrib\n\n    # Genetic crossover-inspired perturbation\n    crossover_point = random.randint(0, len(weight_lst) - 1)\n    for i in range(crossover_point):\n        if random.random() < 0.5:  # 50% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Local search with adaptive value contributions\n    sorted_items = np.argsort(-adaptive_weights)\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Try removing item if it doesn't hurt both objectives\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 >= current_value2) and \\\n               (temp_value1 > current_value1 or temp_value2 > current_value2):\n                new_solution[item] = 0\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n        else:\n            # Try adding item if feasible and improves at least one objective\n            if current_weight + weight_lst[item] <= capacity:\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                if temp_value1 > current_value1 or temp_value2 > current_value2:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Dynamic capacity adjustment if still over capacity\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{The new algorithm combines a genetic algorithm-inspired crossover with a dominance-based local search, where solutions are recombined using a weighted average of their item probabilities, followed by a dominance-preserving mutation that prioritizes non-dominated contributions to both objectives while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    parent1, (_, _) = random.choice(archive)\n    parent2, (_, _) = random.choice(archive)\n    new_solution = np.zeros_like(parent1)\n\n    # Weighted average crossover\n    weights = np.random.uniform(0.3, 0.7, size=len(parent1))\n    for i in range(len(parent1)):\n        if weights[i] > 0.5:\n            new_solution[i] = parent1[i]\n        else:\n            new_solution[i] = parent2[i]\n\n    # Dominance-based mutation\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(len(parent1)):\n        if new_solution[i] == 1:\n            # Check if removing improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                # Accept mutation if it improves at least one objective\n                if (value1_lst[i] < 0 and value2_lst[i] < 0) or \\\n                   (value1_lst[i] > 0 and value2_lst[i] > 0):\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n        else:\n            # Check if adding improves both objectives\n            if current_weight + weight_lst[i] <= capacity:\n                if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Adaptive weight adjustment for feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(weight_lst * new_solution / (value1_lst + value2_lst + 1e-10))\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.41242284697985077,
            4.076272010803223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    parent1, (_, _) = random.choice(archive)\n    parent2, (_, _) = random.choice(archive)\n    new_solution = np.zeros_like(parent1)\n\n    # Weighted average crossover\n    weights = np.random.uniform(0.3, 0.7, size=len(parent1))\n    for i in range(len(parent1)):\n        if weights[i] > 0.5:\n            new_solution[i] = parent1[i]\n        else:\n            new_solution[i] = parent2[i]\n\n    # Dominance-based mutation\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(len(parent1)):\n        if new_solution[i] == 1:\n            # Check if removing improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                # Accept mutation if it improves at least one objective\n                if (value1_lst[i] < 0 and value2_lst[i] < 0) or \\\n                   (value1_lst[i] > 0 and value2_lst[i] > 0):\n                    new_solution[i] = 0\n                    current_weight = temp_weight\n        else:\n            # Check if adding improves both objectives\n            if current_weight + weight_lst[i] <= capacity:\n                if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Adaptive weight adjustment for feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(weight_lst * new_solution / (value1_lst + value2_lst + 1e-10))\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This new algorithm employs a hybrid approach combining Pareto-ranking with a greedy perturbation strategy, where items are prioritized based on their non-dominated contributions to both objectives, and feasibility is maintained through adaptive weight adjustment and dominance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto ranks for items\n    item_scores = []\n    for i in range(len(weight_lst)):\n        temp_solution = base_solution.copy()\n        if temp_solution[i] == 1:\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n        else:\n            if current_weight + weight_lst[i] > capacity:\n                continue\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            temp_value1 = current_value1 + value1_lst[i]\n            temp_value2 = current_value2 + value2_lst[i]\n\n        # Check if the new solution dominates the current one\n        dominates = False\n        for _, (v1, v2) in archive:\n            if (temp_value1 > v1 and temp_value2 >= v2) or (temp_value1 >= v1 and temp_value2 > v2):\n                dominates = True\n                break\n            if (temp_value1 < v1 and temp_value2 <= v2) or (temp_value1 <= v1 and temp_value2 < v2):\n                dominates = False\n                break\n\n        item_scores.append((i, dominates, temp_value1, temp_value2))\n\n    # Sort items by dominance and value contributions\n    item_scores.sort(key=lambda x: (-int(x[1]), -x[2], -x[3]))\n\n    # Apply greedy perturbation\n    for i, dominates, _, _ in item_scores[:max(1, len(item_scores)//10)]:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Ensure feasibility by removing lowest value items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        sorted_items = np.argsort(value1_lst + value2_lst)\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7420781185315077,
            4.361724317073822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto ranks for items\n    item_scores = []\n    for i in range(len(weight_lst)):\n        temp_solution = base_solution.copy()\n        if temp_solution[i] == 1:\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n        else:\n            if current_weight + weight_lst[i] > capacity:\n                continue\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            temp_value1 = current_value1 + value1_lst[i]\n            temp_value2 = current_value2 + value2_lst[i]\n\n        # Check if the new solution dominates the current one\n        dominates = False\n        for _, (v1, v2) in archive:\n            if (temp_value1 > v1 and temp_value2 >= v2) or (temp_value1 >= v1 and temp_value2 > v2):\n                dominates = True\n                break\n            if (temp_value1 < v1 and temp_value2 <= v2) or (temp_value1 <= v1 and temp_value2 < v2):\n                dominates = False\n                break\n\n        item_scores.append((i, dominates, temp_value1, temp_value2))\n\n    # Sort items by dominance and value contributions\n    item_scores.sort(key=lambda x: (-int(x[1]), -x[2], -x[3]))\n\n    # Apply greedy perturbation\n    for i, dominates, _, _ in item_scores[:max(1, len(item_scores)//10)]:\n        if new_solution[i] == 1:\n            new_solution[i] = 0\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Ensure feasibility by removing lowest value items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        sorted_items = np.argsort(value1_lst + value2_lst)\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{A novel local search strategy that employs a dynamic item prioritization based on a weighted sum of normalized objective contributions, combined with a probabilistic two-phase perturbation (removal followed by addition) to ensure both exploration and exploitation of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and compute weighted score\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    if max_value1 == 0: max_value1 = 1\n    if max_value2 == 0: max_value2 = 1\n    norm_value1 = value1_lst / max_value1\n    norm_value2 = value2_lst / max_value2\n    score = 0.6 * norm_value1 + 0.4 * norm_value2\n\n    # Sort items by score (descending)\n    sorted_items = np.argsort(-score)\n\n    # Phase 1: Probabilistic removal of low-contribution items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Phase 2: Greedy addition of high-scoring items if feasible\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.32211100643296076,
            2.7063635885715485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and compute weighted score\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    if max_value1 == 0: max_value1 = 1\n    if max_value2 == 0: max_value2 = 1\n    norm_value1 = value1_lst / max_value1\n    norm_value2 = value2_lst / max_value2\n    score = 0.6 * norm_value1 + 0.4 * norm_value2\n\n    # Sort items by score (descending)\n    sorted_items = np.argsort(-score)\n\n    # Phase 1: Probabilistic removal of low-contribution items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Phase 2: Greedy addition of high-scoring items if feasible\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{The algorithm combines a multi-phase local search with a novel dominance-aware item clustering strategy, where items are first grouped by their contribution to both objectives, then explored through adaptive phase transitions that balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Cluster items by objective contribution\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    cluster1 = np.argsort(-value1_ratio)\n    cluster2 = np.argsort(-value2_ratio)\n\n    # Phase 2: Adaptive phase transitions based on current solution\n    phase = 1 if random.random() < 0.5 else 2\n    if phase == 1:\n        # Explore cluster1 (value1-optimized)\n        for item in cluster1:\n            if base_solution[item] == 1 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n    else:\n        # Explore cluster2 (value2-optimized)\n        for item in cluster2:\n            if base_solution[item] == 1 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 3: Dominance-aware refinement\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = base_value1 - value1_lst[i]\n            temp_value2 = base_value2 - value2_lst[i]\n\n            # Accept if at least one objective improves\n            if (temp_value1 >= base_value1 and temp_value2 > base_value2) or \\\n               (temp_value1 > base_value1 and temp_value2 >= base_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                base_value1 = temp_value1\n                base_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(weight_lst):\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.39780656461912856,
            5.871199309825897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Cluster items by objective contribution\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    cluster1 = np.argsort(-value1_ratio)\n    cluster2 = np.argsort(-value2_ratio)\n\n    # Phase 2: Adaptive phase transitions based on current solution\n    phase = 1 if random.random() < 0.5 else 2\n    if phase == 1:\n        # Explore cluster1 (value1-optimized)\n        for item in cluster1:\n            if base_solution[item] == 1 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n    else:\n        # Explore cluster2 (value2-optimized)\n        for item in cluster2:\n            if base_solution[item] == 1 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 3: Dominance-aware refinement\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = base_value1 - value1_lst[i]\n            temp_value2 = base_value2 - value2_lst[i]\n\n            # Accept if at least one objective improves\n            if (temp_value1 >= base_value1 and temp_value2 > base_value2) or \\\n               (temp_value1 > base_value1 and temp_value2 >= base_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                base_value1 = temp_value1\n                base_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(weight_lst):\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a Pareto-frontier guided selection, where items are prioritized based on their potential to improve both objectives while considering the current solution's position in the objective space, ensuring feasibility through adaptive weight balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    diversity_factor = np.abs(value1_ratio - value2_ratio)  # Encourages balanced exploration\n    combined_score = (value1_ratio + value2_ratio) * diversity_factor\n    sorted_items = np.argsort(-combined_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove items that are not on the Pareto frontier\n            if random.random() < 0.4 and (value1_lst[item] < current_value1 or value2_lst[item] < current_value2):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that could potentially improve both objectives\n            if current_weight + weight_lst[item] <= capacity:\n                improvement1 = value1_lst[item] / (current_value1 + 1e-10)\n                improvement2 = value2_lst[item] / (current_value2 + 1e-10)\n                add_prob = 0.6 * (improvement1 + improvement2) / 2  # Balanced improvement potential\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Adaptive weight balancing to ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest marginal score until feasible\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8317834779879762,
            3.1083035469055176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    diversity_factor = np.abs(value1_ratio - value2_ratio)  # Encourages balanced exploration\n    combined_score = (value1_ratio + value2_ratio) * diversity_factor\n    sorted_items = np.argsort(-combined_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove items that are not on the Pareto frontier\n            if random.random() < 0.4 and (value1_lst[item] < current_value1 or value2_lst[item] < current_value2):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that could potentially improve both objectives\n            if current_weight + weight_lst[item] <= capacity:\n                improvement1 = value1_lst[item] / (current_value1 + 1e-10)\n                improvement2 = value2_lst[item] / (current_value2 + 1e-10)\n                add_prob = 0.6 * (improvement1 + improvement2) / 2  # Balanced improvement potential\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Adaptive weight balancing to ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest marginal score until feasible\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{The new algorithm employs a dynamic priority-based perturbation that combines a weighted marginal contribution score with a probabilistic flip mechanism, prioritizing items with high marginal gains in either objective while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contribution scores for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Dynamic priority score combining both objectives with adaptive weights\n    alpha = 0.6 if random.random() < 0.5 else 0.4\n    priority_score = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Sort items by priority score (descending)\n    sorted_items = np.argsort(-priority_score)\n\n    # Dynamic perturbation: probabilistic flip with priority-based bias\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = 0.2 * (1 - priority_score[item] / (priority_score.max() + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            add_prob = 0.5 * (priority_score[item] / (priority_score.max() + 1e-10))\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7961834605728587,
            9.932141840457916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contribution scores for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Dynamic priority score combining both objectives with adaptive weights\n    alpha = 0.6 if random.random() < 0.5 else 0.4\n    priority_score = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Sort items by priority score (descending)\n    sorted_items = np.argsort(-priority_score)\n\n    # Dynamic perturbation: probabilistic flip with priority-based bias\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = 0.2 * (1 - priority_score[item] / (priority_score.max() + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            add_prob = 0.5 * (priority_score[item] / (priority_score.max() + 1e-10))\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5247327865994708,
            2.6415218114852905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This algorithm employs a dynamic clustering-based perturbation that groups items by their combined objective contributions and performs targeted flips within clusters, ensuring feasibility through adaptive cluster-based adjustments and maintaining solution quality by prioritizing high-margin items within each cluster.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate combined objective contributions\n    combined_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n\n    # Cluster items by their contribution\n    cluster_size = max(1, len(weight_lst) // 5)\n    sorted_items = np.argsort(-combined_contrib)\n    clusters = [sorted_items[i:i+cluster_size] for i in range(0, len(sorted_items), cluster_size)]\n\n    # Perform cluster-based perturbation\n    for cluster in clusters:\n        cluster_weight = np.sum(weight_lst[cluster] * base_solution[cluster])\n        cluster_value1 = np.sum(value1_lst[cluster] * base_solution[cluster])\n        cluster_value2 = np.sum(value2_lst[cluster] * base_solution[cluster])\n\n        # Decide whether to flip the entire cluster\n        flip_prob = 0.4 * (1 - (cluster_weight / (capacity + 1e-10)))\n        if random.random() < flip_prob:\n            # Remove entire cluster if feasible\n            if current_weight - cluster_weight >= 0:\n                new_solution[cluster] = 0\n                current_weight -= cluster_weight\n            else:\n                # If not feasible, try to add high-contribution items from cluster\n                for item in cluster:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest contribution items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.2668175112334682,
            5.484464198350906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate combined objective contributions\n    combined_contrib = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n\n    # Cluster items by their contribution\n    cluster_size = max(1, len(weight_lst) // 5)\n    sorted_items = np.argsort(-combined_contrib)\n    clusters = [sorted_items[i:i+cluster_size] for i in range(0, len(sorted_items), cluster_size)]\n\n    # Perform cluster-based perturbation\n    for cluster in clusters:\n        cluster_weight = np.sum(weight_lst[cluster] * base_solution[cluster])\n        cluster_value1 = np.sum(value1_lst[cluster] * base_solution[cluster])\n        cluster_value2 = np.sum(value2_lst[cluster] * base_solution[cluster])\n\n        # Decide whether to flip the entire cluster\n        flip_prob = 0.4 * (1 - (cluster_weight / (capacity + 1e-10)))\n        if random.random() < flip_prob:\n            # Remove entire cluster if feasible\n            if current_weight - cluster_weight >= 0:\n                new_solution[cluster] = 0\n                current_weight -= cluster_weight\n            else:\n                # If not feasible, try to add high-contribution items from cluster\n                for item in cluster:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest contribution items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{The novel local search strategy combines a dynamic Pareto frontier-aware perturbation with a hybrid greedy and stochastic selection of items, where items are prioritized based on their marginal contributions to both objectives while maintaining feasibility through adaptive weight balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic Pareto frontier awareness\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, (v1, v2) in archive:\n            if (v1 > obj[0] and v2 >= obj[1]) or (v1 >= obj[0] and v2 > obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol, obj))\n\n    # Calculate adaptive weights for objectives\n    if len(pareto_front) > 0:\n        max_v1 = max(obj[0] for _, obj in pareto_front)\n        max_v2 = max(obj[1] for _, obj in pareto_front)\n        weight_v1 = 1 / (max_v1 + 1e-10)\n        weight_v2 = 1 / (max_v2 + 1e-10)\n    else:\n        weight_v1 = weight_v2 = 0.5\n\n    # Hybrid selection strategy\n    for i in range(len(weight_lst)):\n        # Dynamic priority based on adaptive weights\n        priority = (weight_v1 * value1_lst[i] + weight_v2 * value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n        # Stochastic decision with priority consideration\n        if base_solution[i] == 1:\n            if random.random() < 0.2 * (1 / (priority + 1e-10)):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < 0.8 * priority / (priority + 1):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items with lowest priority until feasible\n        sorted_items = np.argsort([(weight_v1 * value1_lst[i] + weight_v2 * value2_lst[i]) / (weight_lst[i] + 1e-10) for i in range(len(weight_lst))])\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8607983030334594,
            7.194245427846909
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic Pareto frontier awareness\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, (v1, v2) in archive:\n            if (v1 > obj[0] and v2 >= obj[1]) or (v1 >= obj[0] and v2 > obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol, obj))\n\n    # Calculate adaptive weights for objectives\n    if len(pareto_front) > 0:\n        max_v1 = max(obj[0] for _, obj in pareto_front)\n        max_v2 = max(obj[1] for _, obj in pareto_front)\n        weight_v1 = 1 / (max_v1 + 1e-10)\n        weight_v2 = 1 / (max_v2 + 1e-10)\n    else:\n        weight_v1 = weight_v2 = 0.5\n\n    # Hybrid selection strategy\n    for i in range(len(weight_lst)):\n        # Dynamic priority based on adaptive weights\n        priority = (weight_v1 * value1_lst[i] + weight_v2 * value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n        # Stochastic decision with priority consideration\n        if base_solution[i] == 1:\n            if random.random() < 0.2 * (1 / (priority + 1e-10)):\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < 0.8 * priority / (priority + 1):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items with lowest priority until feasible\n        sorted_items = np.argsort([(weight_v1 * value1_lst[i] + weight_v2 * value2_lst[i]) / (weight_lst[i] + 1e-10) for i in range(len(weight_lst))])\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{The new algorithm employs a hybrid strategy combining a diversity-preserving perturbation with a multi-objective greedy insertion, where items are prioritized based on their trade-off between objectives via a hypervolume-based selection, ensuring both feasibility and exploration of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized hypervolume contributions\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    hypervolume = norm_value1 * norm_value2\n\n    # Sort items by hypervolume contribution (descending)\n    sorted_items = np.argsort(-hypervolume)\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability inversely proportional to hypervolume\n            flip_prob = 0.5 * (1 - hypervolume[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability proportional to hypervolume and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * hypervolume[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Sort items by Pareto front contribution (lexicographic order)\n        pareto_order = np.lexsort((value2_lst, -value1_lst))\n        for item in pareto_order:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Ensure feasibility by removing lowest hypervolume items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3862288173134029,
            4.582797020673752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized hypervolume contributions\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    hypervolume = norm_value1 * norm_value2\n\n    # Sort items by hypervolume contribution (descending)\n    sorted_items = np.argsort(-hypervolume)\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability inversely proportional to hypervolume\n            flip_prob = 0.5 * (1 - hypervolume[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability proportional to hypervolume and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * hypervolume[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Sort items by Pareto front contribution (lexicographic order)\n        pareto_order = np.lexsort((value2_lst, -value1_lst))\n        for item in pareto_order:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Ensure feasibility by removing lowest hypervolume items\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The new algorithm combines a diversity-aware probabilistic perturbation with a multi-objective greedy insertion strategy, where items are prioritized based on their normalized contributions to both objectives while maintaining feasibility through a dynamic capacity adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Diversity-aware perturbation\n    diversity_factor = 0.2\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < diversity_factor:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    for item in sorted_items:\n        if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n            # Check if adding this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n\n            # Calculate new objectives\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            # If adding improves both objectives\n            if (new_value1 > np.sum(value1_lst * new_solution) and\n                new_value2 > np.sum(value2_lst * new_solution)):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                remaining_capacity = capacity - current_weight\n\n    # Dynamic capacity adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3204747520032004,
            3.974787801504135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Diversity-aware perturbation\n    diversity_factor = 0.2\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < diversity_factor:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    remaining_capacity = capacity - current_weight\n    for item in sorted_items:\n        if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n            # Check if adding this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n\n            # Calculate new objectives\n            new_value1 = np.sum(value1_lst * temp_solution)\n            new_value2 = np.sum(value2_lst * temp_solution)\n\n            # If adding improves both objectives\n            if (new_value1 > np.sum(value1_lst * new_solution) and\n                new_value2 > np.sum(value2_lst * new_solution)):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                remaining_capacity = capacity - current_weight\n\n    # Dynamic capacity adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a Pareto-frontier guided local search, where items are prioritized based on their potential to improve both objectives while maintaining solution diversity, ensuring feasibility through adaptive removal of redundant items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    diversity_factor = np.abs(marginal1 - marginal2)\n    combined_score = marginal1 + marginal2 + diversity_factor\n    sorted_items = np.argsort(-combined_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items that are dominated in both objectives\n            if (value1_lst[item] < current_value1 and value2_lst[item] < current_value2) or random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that could potentially improve either objective\n            if current_weight + weight_lst[item] <= capacity and (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive removal of redundant items\n    if current_weight > capacity:\n        # Remove items with lowest combined score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8753892363242148,
            2.922364294528961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    diversity_factor = np.abs(marginal1 - marginal2)\n    combined_score = marginal1 + marginal2 + diversity_factor\n    sorted_items = np.argsort(-combined_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items that are dominated in both objectives\n            if (value1_lst[item] < current_value1 and value2_lst[item] < current_value2) or random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that could potentially improve either objective\n            if current_weight + weight_lst[item] <= capacity and (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive removal of redundant items\n    if current_weight > capacity:\n        # Remove items with lowest combined score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{The new algorithm employs a diversity-aware local search that combines a weighted random walk with a dominance-based item selection, where items are prioritized based on their Pareto-frontier contribution, ensuring both exploration of the solution space and exploitation of high-potential regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for items\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            # Check if adding the item would dominate any existing solution\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[i]\n                temp_value2 = current_value2 + value2_lst[i]\n                dominated = False\n                for sol, (v1, v2) in archive:\n                    if (temp_value1 >= v1 and temp_value2 >= v2) and (temp_value1 > v1 or temp_value2 > v2):\n                        dominated = True\n                        break\n                if dominated:\n                    dominance_scores[i] = 1.0\n                else:\n                    dominance_scores[i] = 0.5\n        else:\n            # Check if removing the item would still keep the solution non-dominated\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n            non_dominated = True\n            for sol, (v1, v2) in archive:\n                if (v1 >= temp_value1 and v2 >= temp_value2) and (v1 > temp_value1 or v2 > temp_value2):\n                    non_dominated = False\n                    break\n            if non_dominated:\n                dominance_scores[i] = 0.3\n            else:\n                dominance_scores[i] = 0.1\n\n    # Perform weighted random walk based on dominance scores\n    for i in range(len(weight_lst)):\n        if dominance_scores[i] > random.random():\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif base_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest dominance scores until feasible\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(dominance_scores)\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7073430871128944,
            3.2424073815345764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for items\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            # Check if adding the item would dominate any existing solution\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[i]\n                temp_value2 = current_value2 + value2_lst[i]\n                dominated = False\n                for sol, (v1, v2) in archive:\n                    if (temp_value1 >= v1 and temp_value2 >= v2) and (temp_value1 > v1 or temp_value2 > v2):\n                        dominated = True\n                        break\n                if dominated:\n                    dominance_scores[i] = 1.0\n                else:\n                    dominance_scores[i] = 0.5\n        else:\n            # Check if removing the item would still keep the solution non-dominated\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n            non_dominated = True\n            for sol, (v1, v2) in archive:\n                if (v1 >= temp_value1 and v2 >= temp_value2) and (v1 > temp_value1 or v2 > temp_value2):\n                    non_dominated = False\n                    break\n            if non_dominated:\n                dominance_scores[i] = 0.3\n            else:\n                dominance_scores[i] = 0.1\n\n    # Perform weighted random walk based on dominance scores\n    for i in range(len(weight_lst)):\n        if dominance_scores[i] > random.random():\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif base_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest dominance scores until feasible\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(dominance_scores)\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The new algorithm uses a dynamic priority-based selection with adaptive perturbation, where items are prioritized based on their marginal contribution to both objectives, and perturbations are applied with probability inversely proportional to their current weight contribution, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic priority based on marginal contribution\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_priority = (marginal_value1 + marginal_value2) * (1 + 0.1 * (1 - base_solution))\n\n    # Sort items by dynamic priority (descending)\n    sorted_items = np.argsort(-dynamic_priority)\n\n    # Adaptive perturbation with probability inversely proportional to weight\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove with probability based on weight\n            if random.random() < (weight_lst[item] / (current_weight + 1e-10)) ** 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on priority and remaining capacity\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = min(1.0, 0.5 * dynamic_priority[item] / (dynamic_priority[0] + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3538180290635691,
            6.333149343729019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic priority based on marginal contribution\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_priority = (marginal_value1 + marginal_value2) * (1 + 0.1 * (1 - base_solution))\n\n    # Sort items by dynamic priority (descending)\n    sorted_items = np.argsort(-dynamic_priority)\n\n    # Adaptive perturbation with probability inversely proportional to weight\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove with probability based on weight\n            if random.random() < (weight_lst[item] / (current_weight + 1e-10)) ** 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on priority and remaining capacity\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = min(1.0, 0.5 * dynamic_priority[item] / (dynamic_priority[0] + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The new algorithm combines a hybrid genetic algorithm-inspired operator with a multi-objective sorting network to generate neighbors by strategically swapping high-contribution items based on their Pareto-efficient utility, while maintaining feasibility through iterative repair and dominance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient utility scores\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Hybrid genetic-inspired operator: swap high-contribution items\n    for i in range(len(sorted_items) - 1):\n        item1 = sorted_items[i]\n        item2 = sorted_items[i + 1]\n\n        if base_solution[item1] == 1 and base_solution[item2] == 0:\n            temp_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if temp_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = temp_weight\n\n    # Multi-objective sorting network: improve Pareto front\n    for i in range(len(sorted_items)):\n        item = sorted_items[i]\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n\n            # Check if removing improves Pareto front\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8666404138850776,
            5.057433068752289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient utility scores\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Hybrid genetic-inspired operator: swap high-contribution items\n    for i in range(len(sorted_items) - 1):\n        item1 = sorted_items[i]\n        item2 = sorted_items[i + 1]\n\n        if base_solution[item1] == 1 and base_solution[item2] == 0:\n            temp_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if temp_weight <= capacity:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = temp_weight\n\n    # Multi-objective sorting network: improve Pareto front\n    for i in range(len(sorted_items)):\n        item = sorted_items[i]\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n\n            # Check if removing improves Pareto front\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This new algorithm employs a hybrid of dominance-based selection and adaptive probability flipping, where items are prioritized based on their normalized Pareto-optimal contributions, and flipping probabilities are dynamically adjusted based on item criticality and temperature decay to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized dominance scores\n    dominance_scores = (value1_lst / np.max(value1_lst)) * (value2_lst / np.max(value2_lst))\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Adaptive temperature decay\n    temperature = 0.7\n    decay_rate = 0.95\n\n    for item in sorted_items:\n        temperature *= decay_rate\n        if base_solution[item] == 1:\n            # Flip out based on dominance and temperature\n            flip_prob = temperature * (1 - dominance_scores[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on dominance and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * dominance_scores[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves both objectives\n            if temp_value1 > current_value1 and temp_value2 > current_value2:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.33329814850265727,
            6.78845340013504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized dominance scores\n    dominance_scores = (value1_lst / np.max(value1_lst)) * (value2_lst / np.max(value2_lst))\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Adaptive temperature decay\n    temperature = 0.7\n    decay_rate = 0.95\n\n    for item in sorted_items:\n        temperature *= decay_rate\n        if base_solution[item] == 1:\n            # Flip out based on dominance and temperature\n            flip_prob = temperature * (1 - dominance_scores[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on dominance and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * dominance_scores[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves both objectives\n            if temp_value1 > current_value1 and temp_value2 > current_value2:\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{The new algorithm combines a diversity-preserving perturbation with a multi-objective greedy selection strategy, where items are prioritized based on their normalized contributions to both objectives while maintaining solution diversity through controlled exploration and exploitation of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    diversity_score = norm_value1 + norm_value2 - 2 * (norm_value1 * norm_value2)\n    sorted_items = np.argsort(-diversity_score)\n\n    # Diversity-preserving perturbation\n    diversity_threshold = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < diversity_threshold * (1 - diversity_score[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < diversity_threshold * diversity_score[item]:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Multi-objective greedy selection\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            temp_weight = current_weight + weight_lst[item]\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n\n            # Check if adding this item improves at least one objective\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution[item] = 1\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4448023688695373,
            5.177968144416809
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    diversity_score = norm_value1 + norm_value2 - 2 * (norm_value1 * norm_value2)\n    sorted_items = np.argsort(-diversity_score)\n\n    # Diversity-preserving perturbation\n    diversity_threshold = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < diversity_threshold * (1 - diversity_score[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < diversity_threshold * diversity_score[item]:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Multi-objective greedy selection\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            temp_weight = current_weight + weight_lst[item]\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n\n            # Check if adding this item improves at least one objective\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution[item] = 1\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{The novel local search strategy combines a dynamic clustering-based perturbation with a value-driven item selection, where items are grouped by their contribution to each objective and perturbed based on their cluster's dominance in the objective space, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a solution with high potential for improvement (not just random)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their contribution to each objective\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Assign each item to a cluster based on which objective it contributes more to\n    cluster1 = (value1_ratio > value2_ratio) & (base_solution == 1)\n    cluster2 = (value2_ratio > value1_ratio) & (base_solution == 1)\n    neutral_cluster = (value1_ratio == value2_ratio) & (base_solution == 1)\n\n    # Determine which cluster is more dominant in the current solution\n    cluster1_weight = np.sum(weight_lst[cluster1])\n    cluster2_weight = np.sum(weight_lst[cluster2])\n    neutral_weight = np.sum(weight_lst[neutral_cluster])\n\n    # Perturb the dominant cluster\n    if cluster1_weight > cluster2_weight:\n        # Remove some items from cluster1\n        for item in np.where(cluster1)[0]:\n            if random.random() < 0.4 and new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n    else:\n        # Remove some items from cluster2\n        for item in np.where(cluster2)[0]:\n            if random.random() < 0.4 and new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Add items from the neutral cluster with high combined ratio\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_neutral = np.argsort(-combined_ratio)[np.where(neutral_cluster)[0]]\n\n    for item in sorted_neutral:\n        if current_weight + weight_lst[item] <= capacity and new_solution[item] == 0:\n            if random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(weight_lst)[::-1]:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9043797522565085,
            1.8328788578510284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a solution with high potential for improvement (not just random)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their contribution to each objective\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Assign each item to a cluster based on which objective it contributes more to\n    cluster1 = (value1_ratio > value2_ratio) & (base_solution == 1)\n    cluster2 = (value2_ratio > value1_ratio) & (base_solution == 1)\n    neutral_cluster = (value1_ratio == value2_ratio) & (base_solution == 1)\n\n    # Determine which cluster is more dominant in the current solution\n    cluster1_weight = np.sum(weight_lst[cluster1])\n    cluster2_weight = np.sum(weight_lst[cluster2])\n    neutral_weight = np.sum(weight_lst[neutral_cluster])\n\n    # Perturb the dominant cluster\n    if cluster1_weight > cluster2_weight:\n        # Remove some items from cluster1\n        for item in np.where(cluster1)[0]:\n            if random.random() < 0.4 and new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n    else:\n        # Remove some items from cluster2\n        for item in np.where(cluster2)[0]:\n            if random.random() < 0.4 and new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Add items from the neutral cluster with high combined ratio\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_neutral = np.argsort(-combined_ratio)[np.where(neutral_cluster)[0]]\n\n    for item in sorted_neutral:\n        if current_weight + weight_lst[item] <= capacity and new_solution[item] == 0:\n            if random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(weight_lst)[::-1]:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This new algorithm uses a dynamic marginal contribution analysis to prioritize items based on their impact on both objectives, combined with a probabilistic flipping mechanism that balances exploration and exploitation while ensuring feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic marginal contribution score\n    marginal_score = (value1_lst / (current_value1 + 1e-10) + value2_lst / (current_value2 + 1e-10)) * (1 / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-marginal_score)\n\n    # Adaptive flipping probability\n    flip_prob = 0.4 if current_weight < capacity * 0.7 else 0.6\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive weight adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5057340879273331,
            5.548760235309601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic marginal contribution score\n    marginal_score = (value1_lst / (current_value1 + 1e-10) + value2_lst / (current_value2 + 1e-10)) * (1 / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-marginal_score)\n\n    # Adaptive flipping probability\n    flip_prob = 0.4 if current_weight < capacity * 0.7 else 0.6\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive weight adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm employs a dynamic clustering-based perturbation that groups items by their value-to-weight ratios and selectively flips clusters to explore high-potential regions of the solution space, while maintaining feasibility through adaptive cluster adjustments and dominance-aware cluster selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Cluster items based on combined ratio (3 clusters)\n    cluster_labels = np.digitize(combined_ratio, np.quantile(combined_ratio, [0.33, 0.66]))\n\n    # Identify clusters with at least one item in the solution\n    active_clusters = set(cluster_labels[base_solution == 1])\n\n    # Select a cluster to perturb (prioritize clusters with high potential)\n    if active_clusters:\n        cluster_to_perturb = random.choice(list(active_clusters))\n        cluster_items = np.where(cluster_labels == cluster_to_perturb)[0]\n\n        # Flip all items in the selected cluster\n        for item in cluster_items:\n            if base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Adjust clusters if solution becomes infeasible\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Find the cluster with the lowest average ratio to remove items from\n        cluster_weights = np.zeros(3)\n        cluster_counts = np.zeros(3)\n        for i in range(len(weight_lst)):\n            cluster_weights[cluster_labels[i]] += weight_lst[i]\n            cluster_counts[cluster_labels[i]] += 1\n        avg_ratios = np.zeros(3)\n        for c in range(3):\n            if cluster_counts[c] > 0:\n                avg_ratios[c] = cluster_weights[c] / cluster_counts[c]\n\n        worst_cluster = np.argmin(avg_ratios)\n        worst_items = np.where((cluster_labels == worst_cluster) & (new_solution == 1))[0]\n\n        for item in worst_items:\n            if excess_weight <= 0:\n                break\n            new_solution[item] = 0\n            excess_weight -= weight_lst[item]\n\n    # Additional dominance-aware cluster adjustment\n    if random.random() < 0.5:  # 50% chance to perform this adjustment\n        # Find the cluster with the highest potential improvement\n        cluster_improvements = np.zeros(3)\n        for c in range(3):\n            cluster_items = np.where(cluster_labels == c)[0]\n            temp_weight = 0\n            temp_value1 = 0\n            temp_value2 = 0\n            for item in cluster_items:\n                if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    temp_weight += weight_lst[item]\n                    temp_value1 += value1_lst[item]\n                    temp_value2 += value2_lst[item]\n            cluster_improvements[c] = temp_value1 + temp_value2\n\n        best_cluster = np.argmax(cluster_improvements)\n        best_items = np.where(cluster_labels == best_cluster)[0]\n\n        # Add items from the best cluster if feasible\n        for item in best_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6538506226623191,
            7.381868124008179
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Cluster items based on combined ratio (3 clusters)\n    cluster_labels = np.digitize(combined_ratio, np.quantile(combined_ratio, [0.33, 0.66]))\n\n    # Identify clusters with at least one item in the solution\n    active_clusters = set(cluster_labels[base_solution == 1])\n\n    # Select a cluster to perturb (prioritize clusters with high potential)\n    if active_clusters:\n        cluster_to_perturb = random.choice(list(active_clusters))\n        cluster_items = np.where(cluster_labels == cluster_to_perturb)[0]\n\n        # Flip all items in the selected cluster\n        for item in cluster_items:\n            if base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Adjust clusters if solution becomes infeasible\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Find the cluster with the lowest average ratio to remove items from\n        cluster_weights = np.zeros(3)\n        cluster_counts = np.zeros(3)\n        for i in range(len(weight_lst)):\n            cluster_weights[cluster_labels[i]] += weight_lst[i]\n            cluster_counts[cluster_labels[i]] += 1\n        avg_ratios = np.zeros(3)\n        for c in range(3):\n            if cluster_counts[c] > 0:\n                avg_ratios[c] = cluster_weights[c] / cluster_counts[c]\n\n        worst_cluster = np.argmin(avg_ratios)\n        worst_items = np.where((cluster_labels == worst_cluster) & (new_solution == 1))[0]\n\n        for item in worst_items:\n            if excess_weight <= 0:\n                break\n            new_solution[item] = 0\n            excess_weight -= weight_lst[item]\n\n    # Additional dominance-aware cluster adjustment\n    if random.random() < 0.5:  # 50% chance to perform this adjustment\n        # Find the cluster with the highest potential improvement\n        cluster_improvements = np.zeros(3)\n        for c in range(3):\n            cluster_items = np.where(cluster_labels == c)[0]\n            temp_weight = 0\n            temp_value1 = 0\n            temp_value2 = 0\n            for item in cluster_items:\n                if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                    temp_weight += weight_lst[item]\n                    temp_value1 += value1_lst[item]\n                    temp_value2 += value2_lst[item]\n            cluster_improvements[c] = temp_value1 + temp_value2\n\n        best_cluster = np.argmax(cluster_improvements)\n        best_items = np.where(cluster_labels == best_cluster)[0]\n\n        # Add items from the best cluster if feasible\n        for item in best_items:\n            if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.36698588520363895,
            3.6770358085632324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{The new algorithm combines a diversity-preserving perturbation with a multi-objective greedy insertion strategy, where items are selected based on their adaptive trade-off between objectives while maintaining feasibility through a dynamic capacity allocation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate adaptive trade-off values\n    tradeoff = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-tradeoff)\n\n    # Dynamic capacity allocation\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity < 0:\n        remaining_capacity = 0\n\n    # Diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4 and (current_weight - weight_lst[item]) >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if random.random() < 0.6 and (current_weight + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            # Check if adding improves at least one objective\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n\n            # Accept if it's non-dominated in at least one objective\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest trade-off items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.41352651575071225,
            3.90034943819046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate adaptive trade-off values\n    tradeoff = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-tradeoff)\n\n    # Dynamic capacity allocation\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity < 0:\n        remaining_capacity = 0\n\n    # Diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4 and (current_weight - weight_lst[item]) >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if random.random() < 0.6 and (current_weight + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            # Check if adding improves at least one objective\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n\n            # Accept if it's non-dominated in at least one objective\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest trade-off items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This new algorithm employs a hybrid approach combining greedy value prioritization with adaptive dominance-aware flips, where items are selected based on their Pareto-efficient ratios and flipped probabilistically while maintaining feasibility through a capacity-aware selection process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_scores = [np.sum(value1_lst * sol) + np.sum(value2_lst * sol) for sol, _ in archive]\n    selected_idx = np.argmax(potential_scores)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient ratios\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Adaptive flipping strategy\n    flip_threshold = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability based on dominance\n            if random.random() < flip_threshold:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add if feasible and dominates current solution\n            if current_weight + weight_lst[item] <= capacity:\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                # Check if addition improves at least one objective\n                if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n                   (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                    new_solution[item] = 1\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Ensure feasibility by removing items with lowest combined ratio\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6361473324461533,
            6.972560495138168
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potential_scores = [np.sum(value1_lst * sol) + np.sum(value2_lst * sol) for sol, _ in archive]\n    selected_idx = np.argmax(potential_scores)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient ratios\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Adaptive flipping strategy\n    flip_threshold = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability based on dominance\n            if random.random() < flip_threshold:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add if feasible and dominates current solution\n            if current_weight + weight_lst[item] <= capacity:\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                # Check if addition improves at least one objective\n                if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n                   (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                    new_solution[item] = 1\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Ensure feasibility by removing items with lowest combined ratio\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The new algorithm uses a hybrid of multi-objective ranking and adaptive knapsack packing, where solutions are selected based on their non-dominated front ranking and then refined by strategically replacing or swapping item clusters that maximize the hypervolume improvement while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [v1 + v2 for _, (v1, v2) in archive]\n    sorted_indices = np.argsort(-np.array(scores))\n    selected_idx = random.choice(sorted_indices[:max(1, len(archive)//5)])\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate item clusters based on value ratios\n    value_ratios = value1_lst / (value2_lst + 1e-10)\n    sorted_items = np.argsort(value_ratios)\n    cluster_size = max(1, len(sorted_items) // 5)\n\n    # Randomly select a cluster to modify\n    cluster_start = random.randint(0, len(sorted_items) - cluster_size)\n    cluster_items = sorted_items[cluster_start:cluster_start+cluster_size]\n\n    # Strategy 1: Replace cluster with better items\n    for item in cluster_items:\n        if new_solution[item] == 1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Find best replacement items\n    candidate_items = np.where(new_solution == 0)[0]\n    candidate_scores = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    best_candidates = np.argsort(-candidate_scores)[:cluster_size]\n\n    for item in best_candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Strategy 2: Swap clusters if beneficial\n    if random.random() < 0.3:  # 30% chance to try swapping\n        swap_cluster_start = random.randint(0, len(sorted_items) - cluster_size)\n        swap_cluster_items = sorted_items[swap_cluster_start:swap_cluster_start+cluster_size]\n\n        # Calculate potential swap impact\n        swap_in_weight = np.sum(weight_lst[swap_cluster_items] * (1 - new_solution[swap_cluster_items]))\n        swap_out_weight = np.sum(weight_lst[cluster_items] * new_solution[cluster_items])\n        net_weight_change = swap_in_weight - swap_out_weight\n\n        if current_weight + net_weight_change <= capacity:\n            # Perform swap\n            new_solution[cluster_items] = 1 - new_solution[cluster_items]\n            new_solution[swap_cluster_items] = 1 - new_solution[swap_cluster_items]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove lowest value/weight ratio items\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        item_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_by_ratio = np.argsort(item_ratios)\n        for item in sorted_by_ratio:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.539839891562927,
            6.538245797157288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [v1 + v2 for _, (v1, v2) in archive]\n    sorted_indices = np.argsort(-np.array(scores))\n    selected_idx = random.choice(sorted_indices[:max(1, len(archive)//5)])\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate item clusters based on value ratios\n    value_ratios = value1_lst / (value2_lst + 1e-10)\n    sorted_items = np.argsort(value_ratios)\n    cluster_size = max(1, len(sorted_items) // 5)\n\n    # Randomly select a cluster to modify\n    cluster_start = random.randint(0, len(sorted_items) - cluster_size)\n    cluster_items = sorted_items[cluster_start:cluster_start+cluster_size]\n\n    # Strategy 1: Replace cluster with better items\n    for item in cluster_items:\n        if new_solution[item] == 1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Find best replacement items\n    candidate_items = np.where(new_solution == 0)[0]\n    candidate_scores = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n    best_candidates = np.argsort(-candidate_scores)[:cluster_size]\n\n    for item in best_candidates:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Strategy 2: Swap clusters if beneficial\n    if random.random() < 0.3:  # 30% chance to try swapping\n        swap_cluster_start = random.randint(0, len(sorted_items) - cluster_size)\n        swap_cluster_items = sorted_items[swap_cluster_start:swap_cluster_start+cluster_size]\n\n        # Calculate potential swap impact\n        swap_in_weight = np.sum(weight_lst[swap_cluster_items] * (1 - new_solution[swap_cluster_items]))\n        swap_out_weight = np.sum(weight_lst[cluster_items] * new_solution[cluster_items])\n        net_weight_change = swap_in_weight - swap_out_weight\n\n        if current_weight + net_weight_change <= capacity:\n            # Perform swap\n            new_solution[cluster_items] = 1 - new_solution[cluster_items]\n            new_solution[swap_cluster_items] = 1 - new_solution[swap_cluster_items]\n\n    # Ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove lowest value/weight ratio items\n        excess_weight = np.sum(weight_lst * new_solution) - capacity\n        item_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_by_ratio = np.argsort(item_ratios)\n        for item in sorted_by_ratio:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{The novel local search strategy employs a dynamic priority-based selection with adaptive flipping probabilities, where items are prioritized based on their marginal contribution to both objectives, while using a reinforcement learning-inspired approach to adjust probabilities based on recent improvements, ensuring both feasibility and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n    flip_prob = 0.5\n    add_prob = 0.6\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.39114705093099467,
            9.983463555574417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n    flip_prob = 0.5\n    add_prob = 0.6\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{The new algorithm combines a multi-objective greedy insertion with a probabilistic flip mechanism, where high-margin items are prioritized for insertion while low-margin items are randomly flipped to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Greedy insertion of high-margin items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.6:  # Higher probability to insert high-margin items\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Probabilistic flip of low-margin items\n    for item in sorted_items[::-1]:  # Reverse order for low-margin items\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9697579847697585,
            10.089807271957397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Greedy insertion of high-margin items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.6:  # Higher probability to insert high-margin items\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Probabilistic flip of low-margin items\n    for item in sorted_items[::-1]:  # Reverse order for low-margin items\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{The new algorithm employs a diversity-aware local search that combines adaptive item grouping with a probabilistic dominance-based swap mechanism, where items are organized into clusters based on their value-to-weight ratios and swapped between clusters to explore non-dominated regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items into 3 groups based on value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n    cluster_size = len(sorted_items) // 3\n\n    cluster1 = sorted_items[:cluster_size]\n    cluster2 = sorted_items[cluster_size:2*cluster_size]\n    cluster3 = sorted_items[2*cluster_size:]\n\n    # Perform cluster-based swaps\n    for i in range(min(len(cluster1), len(cluster2))):\n        if base_solution[cluster1[i]] == 1 and base_solution[cluster2[i]] == 0:\n            if current_weight - weight_lst[cluster1[i]] + weight_lst[cluster2[i]] <= capacity:\n                new_solution[cluster1[i]] = 0\n                new_solution[cluster2[i]] = 1\n                current_weight = current_weight - weight_lst[cluster1[i]] + weight_lst[cluster2[i]]\n\n    # Perform probabilistic dominance-based swaps\n    for i in range(len(cluster3)):\n        if base_solution[cluster3[i]] == 1:\n            # Find a cluster2 item to swap with\n            for j in range(len(cluster2)):\n                if base_solution[cluster2[j]] == 0:\n                    if (value1_lst[cluster3[i]] <= value1_lst[cluster2[j]] and value2_lst[cluster3[i]] < value2_lst[cluster2[j]]) or \\\n                       (value1_lst[cluster3[i]] < value1_lst[cluster2[j]] and value2_lst[cluster3[i]] <= value2_lst[cluster2[j]]):\n                        if current_weight - weight_lst[cluster3[i]] + weight_lst[cluster2[j]] <= capacity:\n                            new_solution[cluster3[i]] = 0\n                            new_solution[cluster2[j]] = 1\n                            current_weight = current_weight - weight_lst[cluster3[i]] + weight_lst[cluster2[j]]\n                            break\n\n    # Ensure feasibility by removing lowest ratio items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8214727132297348,
            3.190489739179611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items into 3 groups based on value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n    cluster_size = len(sorted_items) // 3\n\n    cluster1 = sorted_items[:cluster_size]\n    cluster2 = sorted_items[cluster_size:2*cluster_size]\n    cluster3 = sorted_items[2*cluster_size:]\n\n    # Perform cluster-based swaps\n    for i in range(min(len(cluster1), len(cluster2))):\n        if base_solution[cluster1[i]] == 1 and base_solution[cluster2[i]] == 0:\n            if current_weight - weight_lst[cluster1[i]] + weight_lst[cluster2[i]] <= capacity:\n                new_solution[cluster1[i]] = 0\n                new_solution[cluster2[i]] = 1\n                current_weight = current_weight - weight_lst[cluster1[i]] + weight_lst[cluster2[i]]\n\n    # Perform probabilistic dominance-based swaps\n    for i in range(len(cluster3)):\n        if base_solution[cluster3[i]] == 1:\n            # Find a cluster2 item to swap with\n            for j in range(len(cluster2)):\n                if base_solution[cluster2[j]] == 0:\n                    if (value1_lst[cluster3[i]] <= value1_lst[cluster2[j]] and value2_lst[cluster3[i]] < value2_lst[cluster2[j]]) or \\\n                       (value1_lst[cluster3[i]] < value1_lst[cluster2[j]] and value2_lst[cluster3[i]] <= value2_lst[cluster2[j]]):\n                        if current_weight - weight_lst[cluster3[i]] + weight_lst[cluster2[j]] <= capacity:\n                            new_solution[cluster3[i]] = 0\n                            new_solution[cluster2[j]] = 1\n                            current_weight = current_weight - weight_lst[cluster3[i]] + weight_lst[cluster2[j]]\n                            break\n\n    # Ensure feasibility by removing lowest ratio items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items using a weighted sum of normalized values\n    normalized_value1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    normalized_value2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_score = normalized_value1 + normalized_value2\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform a hybrid local search: probabilistic flip with adaptive selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on item's importance\n            flip_prob = 0.1 + 0.4 * (combined_score[item] / (np.max(combined_score) + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-scoring items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 + 0.5 * (combined_score[item] / (np.max(combined_score) + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with a more aggressive approach\n    if current_weight > capacity:\n        # Remove items in order of decreasing importance\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.37058371772931814,
            7.8754536509513855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items using a weighted sum of normalized values\n    normalized_value1 = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    normalized_value2 = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_score = normalized_value1 + normalized_value2\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform a hybrid local search: probabilistic flip with adaptive selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on item's importance\n            flip_prob = 0.1 + 0.4 * (combined_score[item] / (np.max(combined_score) + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-scoring items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 + 0.5 * (combined_score[item] / (np.max(combined_score) + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with a more aggressive approach\n    if current_weight > capacity:\n        # Remove items in order of decreasing importance\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The new algorithm combines a dominance-aware item clustering approach with a probabilistic local search that prioritizes high-value items while maintaining feasibility, using adaptive neighborhood exploration based on both objectives' marginal contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value dominance\n    dominance_scores = np.zeros_like(weight_lst)\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            dominance_scores[i] = (value1_lst[i] / (current_value1 + 1e-10)) + (value2_lst[i] / (current_value2 + 1e-10))\n\n    # Sort items by dominance and weight ratio\n    sorted_items = np.argsort(-dominance_scores * (value1_lst + value2_lst) / (weight_lst + 1e-10))\n\n    # Adaptive neighborhood exploration\n    exploration_radius = min(5, len(sorted_items))\n    for i in range(exploration_radius):\n        item = sorted_items[i]\n        if base_solution[item] == 1:\n            # Probabilistically remove based on dominance\n            if random.random() < 0.4 * (1 - dominance_scores[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add if feasible and has high potential\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * dominance_scores[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check with marginal adjustment\n    if current_weight > capacity:\n        # Remove least dominant items first\n        sorted_remove = np.argsort(dominance_scores)\n        excess = current_weight - capacity\n        for item in sorted_remove:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Final dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    return new_solution\n\n",
        "score": [
            -0.47439353998259015,
            3.9034449458122253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value dominance\n    dominance_scores = np.zeros_like(weight_lst)\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            dominance_scores[i] = (value1_lst[i] / (current_value1 + 1e-10)) + (value2_lst[i] / (current_value2 + 1e-10))\n\n    # Sort items by dominance and weight ratio\n    sorted_items = np.argsort(-dominance_scores * (value1_lst + value2_lst) / (weight_lst + 1e-10))\n\n    # Adaptive neighborhood exploration\n    exploration_radius = min(5, len(sorted_items))\n    for i in range(exploration_radius):\n        item = sorted_items[i]\n        if base_solution[item] == 1:\n            # Probabilistically remove based on dominance\n            if random.random() < 0.4 * (1 - dominance_scores[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add if feasible and has high potential\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * dominance_scores[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check with marginal adjustment\n    if current_weight > capacity:\n        # Remove least dominant items first\n        sorted_remove = np.argsort(dominance_scores)\n        excess = current_weight - capacity\n        for item in sorted_remove:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    # Final dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm employs a hybrid approach combining greedy selection with adaptive item prioritization, where items are evaluated based on their combined utility and diversity in the objective space, followed by a guided local search that selectively flips items while maintaining feasibility through dynamic capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate utility scores for both objectives\n    utility1 = value1_lst / (weight_lst + 1e-10)\n    utility2 = value2_lst / (weight_lst + 1e-10)\n    combined_utility = utility1 + utility2\n\n    # Identify items with high potential for improvement\n    potential_items = []\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 0:\n            if current_weight + weight_lst[item] <= capacity:\n                potential_items.append((item, combined_utility[item]))\n        else:\n            potential_items.append((item, -combined_utility[item]))\n\n    # Sort by potential impact\n    potential_items.sort(key=lambda x: abs(x[1]), reverse=True)\n\n    # Adaptive local search with guided flips\n    for item, utility in potential_items[:min(5, len(potential_items))]:\n        if base_solution[item] == 1:\n            # Consider removing items with low utility\n            if utility < -0.5 * np.mean(combined_utility):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Consider adding items with high utility\n            if utility > 0.7 * np.max(combined_utility):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest utility items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(combined_utility):\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8261193160961798,
            2.2612020075321198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate utility scores for both objectives\n    utility1 = value1_lst / (weight_lst + 1e-10)\n    utility2 = value2_lst / (weight_lst + 1e-10)\n    combined_utility = utility1 + utility2\n\n    # Identify items with high potential for improvement\n    potential_items = []\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 0:\n            if current_weight + weight_lst[item] <= capacity:\n                potential_items.append((item, combined_utility[item]))\n        else:\n            potential_items.append((item, -combined_utility[item]))\n\n    # Sort by potential impact\n    potential_items.sort(key=lambda x: abs(x[1]), reverse=True)\n\n    # Adaptive local search with guided flips\n    for item, utility in potential_items[:min(5, len(potential_items))]:\n        if base_solution[item] == 1:\n            # Consider removing items with low utility\n            if utility < -0.5 * np.mean(combined_utility):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Consider adding items with high utility\n            if utility > 0.7 * np.max(combined_utility):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest utility items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(combined_utility):\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The novel local search strategy employs a dynamic marginal contribution-based selection process that prioritizes items with high individual impact on both objectives, combined with a controlled random perturbation to escape local optima while maintaining feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution, (current_value1, current_value2) = archive[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_contribution = (marginal1 + marginal2) * (1 + 0.5 * (1 - base_solution))  # Boost unexplored items\n\n    # Sort items by dynamic contribution\n    sorted_items = np.argsort(-dynamic_contribution)\n\n    # Dynamic perturbation and selection\n    perturbation_rate = min(0.5, max(0.1, 0.3 * (1 - current_weight / capacity)))\n    selection_rate = min(0.9, max(0.4, 0.6 * (current_weight / capacity)))\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < perturbation_rate:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < selection_rate:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8543103067281782,
            2.23761522769928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution, (current_value1, current_value2) = archive[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_contribution = (marginal1 + marginal2) * (1 + 0.5 * (1 - base_solution))  # Boost unexplored items\n\n    # Sort items by dynamic contribution\n    sorted_items = np.argsort(-dynamic_contribution)\n\n    # Dynamic perturbation and selection\n    perturbation_rate = min(0.5, max(0.1, 0.3 * (1 - current_weight / capacity)))\n    selection_rate = min(0.9, max(0.4, 0.6 * (current_weight / capacity)))\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < perturbation_rate:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < selection_rate:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive feasibility adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{The new algorithm prioritizes items based on a weighted sum of normalized values for both objectives, then performs a biased random walk by flipping items with probabilities inversely proportional to their contribution, ensuring feasibility while exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and compute weighted score\n    max_v1 = np.max(value1_lst)\n    max_v2 = np.max(value2_lst)\n    norm_v1 = value1_lst / (max_v1 + 1e-10)\n    norm_v2 = value2_lst / (max_v2 + 1e-10)\n    weighted_score = 0.6 * norm_v1 + 0.4 * norm_v2\n\n    # Sort items by weighted score (descending)\n    sorted_items = np.argsort(-weighted_score)\n\n    # Biased random walk: flip items with probability inversely proportional to score\n    for item in sorted_items:\n        flip_prob = 1.0 / (1.0 + weighted_score[item])\n        if random.random() < flip_prob:\n            if base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5046527587045339,
            2.997925251722336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and compute weighted score\n    max_v1 = np.max(value1_lst)\n    max_v2 = np.max(value2_lst)\n    norm_v1 = value1_lst / (max_v1 + 1e-10)\n    norm_v2 = value2_lst / (max_v2 + 1e-10)\n    weighted_score = 0.6 * norm_v1 + 0.4 * norm_v2\n\n    # Sort items by weighted score (descending)\n    sorted_items = np.argsort(-weighted_score)\n\n    # Biased random walk: flip items with probability inversely proportional to score\n    for item in sorted_items:\n        flip_prob = 1.0 / (1.0 + weighted_score[item])\n        if random.random() < flip_prob:\n            if base_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This new algorithm employs a hybrid approach combining Pareto front sampling with a greedy local search that prioritizes items based on their normalized marginal contributions to both objectives, while dynamically adjusting the search radius to explore high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic search radius based on solution quality\n    search_radius = min(5, max(1, int(len(sorted_items) * 0.1)))\n\n    # Greedy local search with dynamic neighborhood\n    for i in range(search_radius):\n        item = sorted_items[i]\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                new_solution[item] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Pareto front sampling for further refinement\n    pareto_front = []\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                pareto_front.append((temp_solution, temp_weight))\n\n    # Select the best solution from the Pareto front\n    if pareto_front:\n        best_solution, best_weight = max(pareto_front, key=lambda x: np.sum(value1_lst * x[0]) + np.sum(value2_lst * x[0]))\n        new_solution = best_solution\n        current_weight = best_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8024427395360911,
            9.222576707601547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic search radius based on solution quality\n    search_radius = min(5, max(1, int(len(sorted_items) * 0.1)))\n\n    # Greedy local search with dynamic neighborhood\n    for i in range(search_radius):\n        item = sorted_items[i]\n        if new_solution[item] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                new_solution[item] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Pareto front sampling for further refinement\n    pareto_front = []\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight >= 0:\n                pareto_front.append((temp_solution, temp_weight))\n\n    # Select the best solution from the Pareto front\n    if pareto_front:\n        best_solution, best_weight = max(pareto_front, key=lambda x: np.sum(value1_lst * x[0]) + np.sum(value2_lst * x[0]))\n        new_solution = best_solution\n        current_weight = best_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{The new algorithm employs a hybrid approach combining a dominance-based greedy construction with a probabilistic local search, where items are first selected based on their Pareto-efficient contributions to both objectives, followed by a controlled perturbation phase that explores high-marginal neighborhoods while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for items\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Items already in solution get negative scores to encourage removal\n            dominance_scores[i] = - (value1_lst[i] + value2_lst[i])\n        else:\n            # Potential items get positive scores based on combined value\n            dominance_scores[i] = value1_lst[i] + value2_lst[i]\n\n    # Sort items by dominance scores\n    sorted_items = np.argsort(-dominance_scores)\n\n    # First phase: Greedy dominance-based selection\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Add items with highest dominance scores first\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Second phase: Probabilistic local search\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Remove items with low dominance scores probabilistically\n            if dominance_scores[item] < 0 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high dominance scores probabilistically\n            if dominance_scores[item] > 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest dominance scores\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8921171831492509,
            5.162306427955627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for items\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Items already in solution get negative scores to encourage removal\n            dominance_scores[i] = - (value1_lst[i] + value2_lst[i])\n        else:\n            # Potential items get positive scores based on combined value\n            dominance_scores[i] = value1_lst[i] + value2_lst[i]\n\n    # Sort items by dominance scores\n    sorted_items = np.argsort(-dominance_scores)\n\n    # First phase: Greedy dominance-based selection\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Add items with highest dominance scores first\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Second phase: Probabilistic local search\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Remove items with low dominance scores probabilistically\n            if dominance_scores[item] < 0 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high dominance scores probabilistically\n            if dominance_scores[item] > 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest dominance scores\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{The novel local search strategy combines a dominance-based item selection with a weighted random walk to explore the solution space, where items are prioritized based on their non-dominated status and weighted by their marginal contribution, ensuring diverse and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        values = np.array([obj[0] + obj[1] for _, obj in archive])\n        probs = values / np.sum(values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify non-dominated items based on Pareto efficiency\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Weighted random walk: prioritize items that improve at least one objective\n    for item in np.random.permutation(excluded_items):\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding the item improves at least one objective\n            if (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break  # Limit to one addition per iteration\n\n    # Remove items in a way that maintains diversity\n    for item in np.random.permutation(included_items):\n        if random.random() < 0.2:  # Probabilistic removal\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n            # Ensure solution doesn't become empty\n            if np.sum(new_solution) == 0:\n                # Add a random item to keep solution non-empty\n                candidates = np.where(base_solution == 0)[0]\n                if len(candidates) > 0:\n                    new_item = random.choice(candidates)\n                    if current_weight + weight_lst[new_item] <= capacity:\n                        new_solution[new_item] = 1\n                        current_weight += weight_lst[new_item]\n            break  # Limit to one removal per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.9081279089257763,
            5.198359489440918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        values = np.array([obj[0] + obj[1] for _, obj in archive])\n        probs = values / np.sum(values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify non-dominated items based on Pareto efficiency\n    included_items = np.where(base_solution == 1)[0]\n    excluded_items = np.where(base_solution == 0)[0]\n\n    # Weighted random walk: prioritize items that improve at least one objective\n    for item in np.random.permutation(excluded_items):\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding the item improves at least one objective\n            if (value1_lst[item] > 0 or value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                break  # Limit to one addition per iteration\n\n    # Remove items in a way that maintains diversity\n    for item in np.random.permutation(included_items):\n        if random.random() < 0.2:  # Probabilistic removal\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n            # Ensure solution doesn't become empty\n            if np.sum(new_solution) == 0:\n                # Add a random item to keep solution non-empty\n                candidates = np.where(base_solution == 0)[0]\n                if len(candidates) > 0:\n                    new_item = random.choice(candidates)\n                    if current_weight + weight_lst[new_item] <= capacity:\n                        new_solution[new_item] = 1\n                        current_weight += weight_lst[new_item]\n            break  # Limit to one removal per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The new algorithm combines a tabu search-inspired diversification strategy with a Pareto-frontier-based intensification mechanism, where items are prioritized based on their non-dominated contributions to both objectives, while maintaining feasibility through adaptive neighborhood exploration that avoids recent moves to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-optimal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    pareto_contribution = marginal1 * marginal2  # Approximate Pareto dominance\n    sorted_items = np.argsort(-pareto_contribution)\n\n    # Tabu list to avoid recent moves\n    tabu_list = set()\n    tabu_tenure = min(3, len(weight_lst) // 2)\n\n    # Hybrid neighborhood exploration\n    for item in sorted_items:\n        if item in tabu_list:\n            continue\n\n        if base_solution[item] == 1:\n            # Consider removing high-contribution items\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                tabu_list.add(item)\n        else:\n            # Consider adding items if feasible and not tabu\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                tabu_list.add(item)\n\n        # Update tabu list\n        if len(tabu_list) > tabu_tenure:\n            tabu_list.remove(next(iter(tabu_list)))\n\n    # Intensification: greedy improvement on Pareto frontier\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing improves Pareto dominance\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.318155243855737,
            10.29053145647049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-optimal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    pareto_contribution = marginal1 * marginal2  # Approximate Pareto dominance\n    sorted_items = np.argsort(-pareto_contribution)\n\n    # Tabu list to avoid recent moves\n    tabu_list = set()\n    tabu_tenure = min(3, len(weight_lst) // 2)\n\n    # Hybrid neighborhood exploration\n    for item in sorted_items:\n        if item in tabu_list:\n            continue\n\n        if base_solution[item] == 1:\n            # Consider removing high-contribution items\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                tabu_list.add(item)\n        else:\n            # Consider adding items if feasible and not tabu\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                tabu_list.add(item)\n\n        # Update tabu list\n        if len(tabu_list) > tabu_tenure:\n            tabu_list.remove(next(iter(tabu_list)))\n\n    # Intensification: greedy improvement on Pareto frontier\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing improves Pareto dominance\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The new algorithm uses a hybrid approach combining lexicographic ordering with a dominance-aware perturbation strategy, where items are prioritized based on their relative contributions to each objective, followed by a feasibility-preserving swap mechanism to explore high-quality neighbors while maintaining solution quality through adaptive dominance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate lexicographic scores for each objective\n    lex_score1 = value1_lst / (weight_lst + 1e-10)\n    lex_score2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items based on lexicographic scores\n    sorted_items1 = np.argsort(-lex_score1)\n    sorted_items2 = np.argsort(-lex_score2)\n\n    # Hybrid perturbation strategy\n    for i in range(len(sorted_items1)):\n        item1 = sorted_items1[i]\n        item2 = sorted_items2[i]\n\n        # Try swapping items from both objectives\n        if new_solution[item1] == 0 and new_solution[item2] == 1:\n            if current_weight - weight_lst[item2] + weight_lst[item1] <= capacity:\n                new_solution[item1] = 1\n                new_solution[item2] = 0\n                current_weight = current_weight - weight_lst[item2] + weight_lst[item1]\n                break\n\n    # Dominance-aware perturbation\n    for item in sorted_items1:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check dominance\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.40094200872395436,
            7.0629198253154755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate lexicographic scores for each objective\n    lex_score1 = value1_lst / (weight_lst + 1e-10)\n    lex_score2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items based on lexicographic scores\n    sorted_items1 = np.argsort(-lex_score1)\n    sorted_items2 = np.argsort(-lex_score2)\n\n    # Hybrid perturbation strategy\n    for i in range(len(sorted_items1)):\n        item1 = sorted_items1[i]\n        item2 = sorted_items2[i]\n\n        # Try swapping items from both objectives\n        if new_solution[item1] == 0 and new_solution[item2] == 1:\n            if current_weight - weight_lst[item2] + weight_lst[item1] <= capacity:\n                new_solution[item1] = 1\n                new_solution[item2] = 0\n                current_weight = current_weight - weight_lst[item2] + weight_lst[item1]\n                break\n\n    # Dominance-aware perturbation\n    for item in sorted_items1:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check dominance\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items1:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{The new algorithm employs a hybrid approach combining a dominance-aware item clustering technique with a probabilistic hill-climbing strategy, where items are grouped based on their Pareto-frontier contribution and then selectively flipped or added using adaptive probability thresholds to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on Pareto-frontier contribution\n    pareto_front = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            pareto_front.append((value1_lst[i], value2_lst[i]))\n\n    # Identify non-dominated clusters\n    non_dominated = []\n    for i in range(len(pareto_front)):\n        is_dominated = False\n        for j in range(len(pareto_front)):\n            if i != j and pareto_front[j][0] >= pareto_front[i][0] and pareto_front[j][1] >= pareto_front[i][1]:\n                if pareto_front[j][0] > pareto_front[i][0] or pareto_front[j][1] > pareto_front[i][1]:\n                    is_dominated = True\n                    break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    # Probabilistic hill-climbing with cluster awareness\n    for i in range(len(weight_lst)):\n        if i in non_dominated:\n            # Higher probability to keep non-dominated items\n            if random.random() < 0.8:\n                continue\n        else:\n            # Higher probability to flip dominated items\n            if random.random() < 0.2:\n                if base_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Ensure feasibility with minimal impact on objectives\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1 and i not in non_dominated:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5062460209888068,
            9.923530966043472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on Pareto-frontier contribution\n    pareto_front = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            pareto_front.append((value1_lst[i], value2_lst[i]))\n\n    # Identify non-dominated clusters\n    non_dominated = []\n    for i in range(len(pareto_front)):\n        is_dominated = False\n        for j in range(len(pareto_front)):\n            if i != j and pareto_front[j][0] >= pareto_front[i][0] and pareto_front[j][1] >= pareto_front[i][1]:\n                if pareto_front[j][0] > pareto_front[i][0] or pareto_front[j][1] > pareto_front[i][1]:\n                    is_dominated = True\n                    break\n        if not is_dominated:\n            non_dominated.append(i)\n\n    # Probabilistic hill-climbing with cluster awareness\n    for i in range(len(weight_lst)):\n        if i in non_dominated:\n            # Higher probability to keep non-dominated items\n            if random.random() < 0.8:\n                continue\n        else:\n            # Higher probability to flip dominated items\n            if random.random() < 0.2:\n                if base_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Ensure feasibility with minimal impact on objectives\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1 and i not in non_dominated:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The new algorithm uses a diversity-aware selection mechanism that combines a probabilistic mutation with a targeted improvement phase, where items are either randomly perturbed or selectively adjusted based on their marginal contribution to both objectives, ensuring feasibility while exploring the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        distances = []\n        base_solution = archive[0][0]\n        for sol, _ in archive[1:]:\n            distances.append(np.sum(base_solution != sol))\n        selected_idx = np.argmax(distances) + 1\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Compute marginal contributions (value-to-weight ratios)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Randomly perturb some items\n    for i in range(len(new_solution)):\n        if random.random() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Greedily improve by adding high-marginal items\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3541624848886598,
            4.944676458835602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        distances = []\n        base_solution = archive[0][0]\n        for sol, _ in archive[1:]:\n            distances.append(np.sum(base_solution != sol))\n        selected_idx = np.argmax(distances) + 1\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Compute marginal contributions (value-to-weight ratios)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Randomly perturb some items\n    for i in range(len(new_solution)):\n        if random.random() < 0.2:  # 20% chance to flip\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Greedily improve by adding high-marginal items\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{The new algorithm combines a dynamic priority-based selection with a probabilistic flipping mechanism, where items are prioritized based on their marginal contribution to a weighted combination of both objectives, and solutions are perturbed with a higher probability of flipping items with lower combined ratios to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic priority based on weighted combination of objectives\n    alpha = random.uniform(0.3, 0.7)\n    combined_ratio = alpha * (value1_lst / (weight_lst + 1e-10)) + (1 - alpha) * (value2_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Probabilistic flipping with lower priority items\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = 0.2 + 0.3 * (item / len(sorted_items))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4949130155030782,
            3.5853230357170105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic priority based on weighted combination of objectives\n    alpha = random.uniform(0.3, 0.7)\n    combined_ratio = alpha * (value1_lst / (weight_lst + 1e-10)) + (1 - alpha) * (value2_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Probabilistic flipping with lower priority items\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = 0.2 + 0.3 * (item / len(sorted_items))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3967068688130925,
            3.8387269973754883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The new algorithm uses a weighted marginal contribution score to prioritize items, where weights are dynamically adjusted based on the current solution's objectives, combining a greedy selection of high-scoring items with probabilistic flips of low-scoring ones to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contribution scores\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    total_value = current_value1 + current_value2\n    weight1 = current_value1 / (total_value + 1e-10)\n    weight2 = current_value2 / (total_value + 1e-10)\n    combined_score = weight1 * value1_ratio + weight2 * value2_ratio\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform hybrid local search: greedy selection with probabilistic flips\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:  # Lower probability to flip out\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:  # Higher probability to add\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.43121565997491285,
            4.0005010068416595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contribution scores\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    total_value = current_value1 + current_value2\n    weight1 = current_value1 / (total_value + 1e-10)\n    weight2 = current_value2 / (total_value + 1e-10)\n    combined_score = weight1 * value1_ratio + weight2 * value2_ratio\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform hybrid local search: greedy selection with probabilistic flips\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:  # Lower probability to flip out\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:  # Higher probability to add\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic flip with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.40224497096061557,
            2.8913641273975372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic flip with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{The novel local search strategy employs a two-phase approach: first, it performs a targeted item substitution where high-value items are swapped with low-value items, followed by a density-based refinement that removes items with the lowest value-to-weight density while ensuring feasibility, thereby balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Targeted item substitution\n    # Identify high-value and low-value items\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    high_value_items = np.argsort(-combined_ratio)[:len(weight_lst)//2]\n    low_value_items = np.argsort(combined_ratio)[:len(weight_lst)//2]\n\n    # Swap high-value items with low-value items if feasible\n    for high_item in high_value_items:\n        if base_solution[high_item] == 1:\n            for low_item in low_value_items:\n                if base_solution[low_item] == 0 and current_weight - weight_lst[high_item] + weight_lst[low_item] <= capacity:\n                    new_solution[high_item] = 0\n                    new_solution[low_item] = 1\n                    current_weight = current_weight - weight_lst[high_item] + weight_lst[low_item]\n                    break\n\n    # Phase 2: Density-based refinement\n    # Calculate value-to-weight density\n    density = combined_ratio\n\n    # Sort items by density (ascending) and remove low-density items\n    sorted_items = np.argsort(density)\n    for item in sorted_items:\n        if new_solution[item] == 1 and current_weight - weight_lst[item] >= 0:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7828053163930698,
            11.118515968322754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Phase 1: Targeted item substitution\n    # Identify high-value and low-value items\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    high_value_items = np.argsort(-combined_ratio)[:len(weight_lst)//2]\n    low_value_items = np.argsort(combined_ratio)[:len(weight_lst)//2]\n\n    # Swap high-value items with low-value items if feasible\n    for high_item in high_value_items:\n        if base_solution[high_item] == 1:\n            for low_item in low_value_items:\n                if base_solution[low_item] == 0 and current_weight - weight_lst[high_item] + weight_lst[low_item] <= capacity:\n                    new_solution[high_item] = 0\n                    new_solution[low_item] = 1\n                    current_weight = current_weight - weight_lst[high_item] + weight_lst[low_item]\n                    break\n\n    # Phase 2: Density-based refinement\n    # Calculate value-to-weight density\n    density = combined_ratio\n\n    # Sort items by density (ascending) and remove low-density items\n    sorted_items = np.argsort(density)\n    for item in sorted_items:\n        if new_solution[item] == 1 and current_weight - weight_lst[item] >= 0:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{The new algorithm combines a dominance-aware greedy construction with a multi-objective path-relinking strategy, where solutions are built by iteratively adding high-marginal items while preserving Pareto dominance, and then refined through guided relinking between diverse archive solutions to explore the Pareto front efficiently.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution, _ = archive[selected_idx]\n        return base_solution.copy()\n\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1, (v1_1, v2_1) = archive[idx1]\n    sol2, (v1_2, v2_2) = archive[idx2]\n\n    # Calculate solution differences\n    diff_items = np.where(sol1 != sol2)[0]\n    if len(diff_items) == 0:\n        return sol1.copy()\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Initialize new solution with one of the base solutions\n    new_solution = sol1.copy()\n    current_weight = np.sum(weight_lst * sol1)\n\n    # Path-relinking with dominance-aware selection\n    for item in sorted_items:\n        if sol1[item] != sol2[item]:\n            # Try adding the item from sol2 if feasible\n            if sol2[item] == 1 and current_weight + weight_lst[item] <= capacity:\n                temp_weight = current_weight + weight_lst[item]\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n\n                # Check dominance with respect to both objectives\n                temp_v1 = v1_1 + value1_lst[item] if sol1[item] == 0 else v1_1\n                temp_v2 = v2_1 + value2_lst[item] if sol1[item] == 0 else v2_1\n\n                # Accept if it doesn't dominate the other solution\n                if not ((temp_v1 >= v1_2 and temp_v2 > v2_2) or (temp_v1 > v1_2 and temp_v2 >= v2_2)):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n            # Try removing the item if it's in new_solution\n            elif new_solution[item] == 1:\n                temp_weight = current_weight - weight_lst[item]\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n\n                # Check if removal maintains feasibility\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8279298972873361,
            2.5440154373645782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution, _ = archive[selected_idx]\n        return base_solution.copy()\n\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1, (v1_1, v2_1) = archive[idx1]\n    sol2, (v1_2, v2_2) = archive[idx2]\n\n    # Calculate solution differences\n    diff_items = np.where(sol1 != sol2)[0]\n    if len(diff_items) == 0:\n        return sol1.copy()\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Initialize new solution with one of the base solutions\n    new_solution = sol1.copy()\n    current_weight = np.sum(weight_lst * sol1)\n\n    # Path-relinking with dominance-aware selection\n    for item in sorted_items:\n        if sol1[item] != sol2[item]:\n            # Try adding the item from sol2 if feasible\n            if sol2[item] == 1 and current_weight + weight_lst[item] <= capacity:\n                temp_weight = current_weight + weight_lst[item]\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n\n                # Check dominance with respect to both objectives\n                temp_v1 = v1_1 + value1_lst[item] if sol1[item] == 0 else v1_1\n                temp_v2 = v2_1 + value2_lst[item] if sol1[item] == 0 else v2_1\n\n                # Accept if it doesn't dominate the other solution\n                if not ((temp_v1 >= v1_2 and temp_v2 > v2_2) or (temp_v1 > v1_2 and temp_v2 >= v2_2)):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n            # Try removing the item if it's in new_solution\n            elif new_solution[item] == 1:\n                temp_weight = current_weight - weight_lst[item]\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n\n                # Check if removal maintains feasibility\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This new algorithm uses a hybrid of genetic algorithm crossover with adaptive dominance-based selection, where items are prioritized based on their hypervolume contribution to both objectives, with feasibility maintained through a capacity-aware mutation step that dynamically adjusts flip probabilities based on item criticality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two parents from archive\n    parent1, (obj1_val1, obj1_val2) = archive[random.randint(0, len(archive)-1)]\n    parent2, _ = archive[random.randint(0, len(archive)-1)]\n\n    # Genetic crossover\n    new_solution = np.zeros_like(parent1)\n    for i in range(len(parent1)):\n        if parent1[i] == 1 or parent2[i] == 1:\n            new_solution[i] = random.choice([parent1[i], parent2[i]])\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive dominance-based selection\n    hypervolume_scores = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Calculate hypervolume contribution\n            temp_weight = current_weight - weight_lst[i]\n            temp_val1 = obj1_val1 - value1_lst[i]\n            temp_val2 = obj1_val2 - value2_lst[i]\n            hypervolume_scores.append((temp_val1 * temp_val2, i))\n\n    # Sort by hypervolume contribution\n    hypervolume_scores.sort(reverse=True)\n    critical_items = [i for _, i in hypervolume_scores[:max(1, len(hypervolume_scores)//3)]]\n\n    # Capacity-aware mutation\n    mutation_rate = 0.3\n    for i in range(len(new_solution)):\n        if i in critical_items:\n            continue  # Protect critical items\n        if random.random() < mutation_rate:\n            if new_solution[i] == 1:\n                # Try to remove\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in sorted(range(len(new_solution)), key=lambda x: value1_lst[x] + value2_lst[x]):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5437020528331231,
            5.866621553897858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two parents from archive\n    parent1, (obj1_val1, obj1_val2) = archive[random.randint(0, len(archive)-1)]\n    parent2, _ = archive[random.randint(0, len(archive)-1)]\n\n    # Genetic crossover\n    new_solution = np.zeros_like(parent1)\n    for i in range(len(parent1)):\n        if parent1[i] == 1 or parent2[i] == 1:\n            new_solution[i] = random.choice([parent1[i], parent2[i]])\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive dominance-based selection\n    hypervolume_scores = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Calculate hypervolume contribution\n            temp_weight = current_weight - weight_lst[i]\n            temp_val1 = obj1_val1 - value1_lst[i]\n            temp_val2 = obj1_val2 - value2_lst[i]\n            hypervolume_scores.append((temp_val1 * temp_val2, i))\n\n    # Sort by hypervolume contribution\n    hypervolume_scores.sort(reverse=True)\n    critical_items = [i for _, i in hypervolume_scores[:max(1, len(hypervolume_scores)//3)]]\n\n    # Capacity-aware mutation\n    mutation_rate = 0.3\n    for i in range(len(new_solution)):\n        if i in critical_items:\n            continue  # Protect critical items\n        if random.random() < mutation_rate:\n            if new_solution[i] == 1:\n                # Try to remove\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in sorted(range(len(new_solution)), key=lambda x: value1_lst[x] + value2_lst[x]):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{The novel local search strategy combines a dominance-based perturbation with a value-driven knapsack construction, where items are prioritized based on their Pareto-efficient dominance in both objectives, followed by a constructive greedy phase to fill remaining capacity while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify Pareto-efficient items (dominance-based prioritization)\n    pareto_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                pareto_items.append(i)\n\n    # Perturb by removing items with low combined value\n    combined_value = value1_lst + value2_lst\n    sorted_removal = np.argsort(combined_value[base_solution == 1])\n    for item in sorted_removal[:max(1, len(sorted_removal)//3)]:\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Constructive phase: add items with highest combined value\n    sorted_addition = np.argsort(-combined_value[base_solution == 0])\n    for item in sorted_addition:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Final feasibility check\n    excess_weight = current_weight - capacity\n    if excess_weight > 0:\n        sorted_removal_final = np.argsort(combined_value[new_solution == 1])\n        for item in sorted_removal_final:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3553954611597749,
            3.7260595858097076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify Pareto-efficient items (dominance-based prioritization)\n    pareto_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                pareto_items.append(i)\n\n    # Perturb by removing items with low combined value\n    combined_value = value1_lst + value2_lst\n    sorted_removal = np.argsort(combined_value[base_solution == 1])\n    for item in sorted_removal[:max(1, len(sorted_removal)//3)]:\n        if base_solution[item] == 1:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Constructive phase: add items with highest combined value\n    sorted_addition = np.argsort(-combined_value[base_solution == 0])\n    for item in sorted_addition:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Final feasibility check\n    excess_weight = current_weight - capacity\n    if excess_weight > 0:\n        sorted_removal_final = np.argsort(combined_value[new_solution == 1])\n        for item in sorted_removal_final:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{The novel local search strategy combines a diversity-aware item selection with a multi-objective-aware perturbation, where items are prioritized based on their non-dominated contribution to both objectives, while ensuring feasibility through a constrained greedy insertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate non-dominated marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    marginal_contribution = np.maximum(value1_ratio, value2_ratio)\n\n    # Sort items by marginal contribution (descending)\n    sorted_items = np.argsort(-marginal_contribution)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective-aware feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                # Prefer removing items that contribute less to both objectives\n                if value1_ratio[item] + value2_ratio[item] < 2 * np.median(value1_ratio + value2_ratio):\n                    new_solution[item] = 0\n                    excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.47525566885317894,
            1.3267327845096588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate non-dominated marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    marginal_contribution = np.maximum(value1_ratio, value2_ratio)\n\n    # Sort items by marginal contribution (descending)\n    sorted_items = np.argsort(-marginal_contribution)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective-aware feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                # Prefer removing items that contribute less to both objectives\n                if value1_ratio[item] + value2_ratio[item] < 2 * np.median(value1_ratio + value2_ratio):\n                    new_solution[item] = 0\n                    excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a multi-objective greedy selection strategy, where items are prioritized based on their potential to create non-dominated solutions while ensuring feasibility through adaptive weight balancing and dominance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    diversity_factor = np.abs(marginal1 - marginal2) / (np.max(marginal1) + np.max(marginal2) + 1e-10)\n    combined_score = marginal1 + marginal2 + 0.5 * diversity_factor\n    sorted_items = np.argsort(-combined_score)\n\n    # Adaptive perturbation based on solution quality\n    quality_threshold = 0.7\n    solution_quality = (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))\n    perturbation_strength = 1.0 if solution_quality < quality_threshold else 0.3\n\n    # Multi-objective greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item with probability based on marginal contribution\n            if random.random() < perturbation_strength * (1 - combined_score[item] / np.max(combined_score)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if it improves at least one objective\n            temp_weight = current_weight + weight_lst[item]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                # Check if new solution is non-dominated\n                is_dominated = False\n                for sol, (v1, v2) in archive:\n                    if (v1 >= temp_value1 and v2 >= temp_value2) and (v1 > temp_value1 or v2 > temp_value2):\n                        is_dominated = True\n                        break\n\n                if not is_dominated and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Weight balancing to maintain feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7643177345329586,
            6.952602922916412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    diversity_factor = np.abs(marginal1 - marginal2) / (np.max(marginal1) + np.max(marginal2) + 1e-10)\n    combined_score = marginal1 + marginal2 + 0.5 * diversity_factor\n    sorted_items = np.argsort(-combined_score)\n\n    # Adaptive perturbation based on solution quality\n    quality_threshold = 0.7\n    solution_quality = (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))\n    perturbation_strength = 1.0 if solution_quality < quality_threshold else 0.3\n\n    # Multi-objective greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item with probability based on marginal contribution\n            if random.random() < perturbation_strength * (1 - combined_score[item] / np.max(combined_score)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if it improves at least one objective\n            temp_weight = current_weight + weight_lst[item]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                # Check if new solution is non-dominated\n                is_dominated = False\n                for sol, (v1, v2) in archive:\n                    if (v1 >= temp_value1 and v2 >= temp_value2) and (v1 > temp_value1 or v2 > temp_value2):\n                        is_dominated = True\n                        break\n\n                if not is_dominated and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Weight balancing to maintain feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This new algorithm combines a genetic algorithm-inspired crossover with a Pareto-based local search, where solutions are recombined with high-performing parents while using dominance relationships to guide item swaps, ensuring feasibility through adaptive weight adjustments and prioritizing items with balanced marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))[:3]\n    if not top_solutions:\n        return archive[0][0].copy()\n\n    # Randomly select two parents for crossover\n    parent1, _ = random.choice(top_solutions)\n    parent2, _ = random.choice(top_solutions)\n    new_solution = parent1.copy()\n\n    # Genetic crossover with dominance-based selection\n    crossover_point = random.randint(1, len(new_solution) - 1)\n    new_solution[:crossover_point] = parent1[:crossover_point]\n    new_solution[crossover_point:] = parent2[crossover_point:]\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Pareto-based local search\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item dominates the current solution\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        elif current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item dominates the current solution\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n            new_solution = temp_solution\n            current_weight = temp_weight\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5285501444722285,
            2.8582884073257446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))[:3]\n    if not top_solutions:\n        return archive[0][0].copy()\n\n    # Randomly select two parents for crossover\n    parent1, _ = random.choice(top_solutions)\n    parent2, _ = random.choice(top_solutions)\n    new_solution = parent1.copy()\n\n    # Genetic crossover with dominance-based selection\n    crossover_point = random.randint(1, len(new_solution) - 1)\n    new_solution[:crossover_point] = parent1[:crossover_point]\n    new_solution[crossover_point:] = parent2[crossover_point:]\n\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Pareto-based local search\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item dominates the current solution\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        elif current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item dominates the current solution\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n            new_solution = temp_solution\n            current_weight = temp_weight\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{The novel local search strategy employs an adaptive item prioritization mechanism that dynamically balances marginal contributions to both objectives, combined with a probabilistic path-relinking approach to explore high-quality regions of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive item prioritization\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    alpha = random.uniform(0.3, 0.7)\n    combined_ratio = alpha * value1_ratio + (1 - alpha) * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Path-relinking style perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.34333537750965826,
            1.9043963253498077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive item prioritization\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    alpha = random.uniform(0.3, 0.7)\n    combined_ratio = alpha * value1_ratio + (1 - alpha) * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Path-relinking style perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{The new algorithm employs a segment-based perturbation approach where the solution is divided into high and low marginal contribution segments, with high-segment items being flipped probabilistically and low-segment items being adjusted greedily to balance objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Divide items into high and low marginal segments\n    threshold1 = np.median(marginal1[base_solution == 1])\n    threshold2 = np.median(marginal2[base_solution == 1])\n    high_segment = (marginal1 > threshold1) | (marginal2 > threshold2)\n    low_segment = ~high_segment\n\n    # Perturb high-segment items probabilistically\n    for i in range(len(new_solution)):\n        if base_solution[i] == 1 and high_segment[i] and random.random() < 0.4:\n            new_solution[i] = 0\n\n    # Greedily adjust low-segment items to balance objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in np.argsort(-(marginal1 + marginal2)):\n        if new_solution[i] == 0 and low_segment[i] and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(marginal1 + marginal2):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8553949836058318,
            2.899296522140503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Divide items into high and low marginal segments\n    threshold1 = np.median(marginal1[base_solution == 1])\n    threshold2 = np.median(marginal2[base_solution == 1])\n    high_segment = (marginal1 > threshold1) | (marginal2 > threshold2)\n    low_segment = ~high_segment\n\n    # Perturb high-segment items probabilistically\n    for i in range(len(new_solution)):\n        if base_solution[i] == 1 and high_segment[i] and random.random() < 0.4:\n            new_solution[i] = 0\n\n    # Greedily adjust low-segment items to balance objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in np.argsort(-(marginal1 + marginal2)):\n        if new_solution[i] == 0 and low_segment[i] and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(marginal1 + marginal2):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{The new algorithm employs a hybrid of tabu search principles with a dynamic objective weighting strategy, where items are prioritized based on their contribution to a randomly weighted combination of objectives, while maintaining feasibility through a tabu list to prevent cycling and encourage exploration of diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly weight the objectives\n    weight1 = random.random()\n    weight2 = 1 - weight1\n\n    # Calculate dynamic objective scores\n    dynamic_scores = weight1 * value1_lst + weight2 * value2_lst\n\n    # Sort items by dynamic scores (descending)\n    sorted_items = np.argsort(-dynamic_scores)\n\n    # Tabu list to prevent cycling\n    tabu_list = set()\n    max_tabu_size = min(5, len(sorted_items))\n\n    # Iterate through items to find the best move\n    best_score = -float('inf')\n    best_item = -1\n    best_action = None  # 'add' or 'remove'\n\n    for item in sorted_items:\n        # Check if item is in tabu list\n        if item in tabu_list:\n            continue\n\n        if base_solution[item] == 1:\n            # Consider removing the item\n            temp_weight = current_weight - weight_lst[item]\n            temp_score = dynamic_scores[item] * -1  # Penalize for removal\n\n            if temp_score > best_score:\n                best_score = temp_score\n                best_item = item\n                best_action = 'remove'\n        else:\n            # Consider adding the item if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                temp_score = dynamic_scores[item]\n\n                if temp_score > best_score:\n                    best_score = temp_score\n                    best_item = item\n                    best_action = 'add'\n\n    # Apply the best move if found\n    if best_item != -1:\n        if best_action == 'add':\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n        else:\n            new_solution[best_item] = 0\n            current_weight -= weight_lst[best_item]\n\n        # Update tabu list\n        tabu_list.add(best_item)\n        if len(tabu_list) > max_tabu_size:\n            tabu_list.remove(next(iter(tabu_list)))\n\n    # Ensure feasibility by removing lowest dynamic score items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8737581748381308,
            1.7330072522163391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Randomly weight the objectives\n    weight1 = random.random()\n    weight2 = 1 - weight1\n\n    # Calculate dynamic objective scores\n    dynamic_scores = weight1 * value1_lst + weight2 * value2_lst\n\n    # Sort items by dynamic scores (descending)\n    sorted_items = np.argsort(-dynamic_scores)\n\n    # Tabu list to prevent cycling\n    tabu_list = set()\n    max_tabu_size = min(5, len(sorted_items))\n\n    # Iterate through items to find the best move\n    best_score = -float('inf')\n    best_item = -1\n    best_action = None  # 'add' or 'remove'\n\n    for item in sorted_items:\n        # Check if item is in tabu list\n        if item in tabu_list:\n            continue\n\n        if base_solution[item] == 1:\n            # Consider removing the item\n            temp_weight = current_weight - weight_lst[item]\n            temp_score = dynamic_scores[item] * -1  # Penalize for removal\n\n            if temp_score > best_score:\n                best_score = temp_score\n                best_item = item\n                best_action = 'remove'\n        else:\n            # Consider adding the item if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                temp_score = dynamic_scores[item]\n\n                if temp_score > best_score:\n                    best_score = temp_score\n                    best_item = item\n                    best_action = 'add'\n\n    # Apply the best move if found\n    if best_item != -1:\n        if best_action == 'add':\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n        else:\n            new_solution[best_item] = 0\n            current_weight -= weight_lst[best_item]\n\n        # Update tabu list\n        tabu_list.add(best_item)\n        if len(tabu_list) > max_tabu_size:\n            tabu_list.remove(next(iter(tabu_list)))\n\n    # Ensure feasibility by removing lowest dynamic score items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This new algorithm employs a hybrid approach combining dominance-aware item prioritization with a temperature-controlled simulated annealing mechanism to generate high-quality neighbors by adaptively flipping items based on their Pareto-optimal contributions while maintaining feasibility through dynamic capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized dominance scores\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Calculate how many other solutions would be dominated if this item were removed\n            dominated_count = 0\n            for sol, (v1, v2) in archive:\n                if sol[i] == 1 and (v1 - value1_lst[i] < current_value1 or v2 - value2_lst[i] < current_value2):\n                    dominated_count += 1\n            dominance_scores[i] = dominated_count / len(archive)\n        else:\n            # Calculate potential improvement if this item were added\n            if current_weight + weight_lst[i] <= capacity:\n                potential_value1 = current_value1 + value1_lst[i]\n                potential_value2 = current_value2 + value2_lst[i]\n                improvement_count = 0\n                for sol, (v1, v2) in archive:\n                    if (potential_value1 > v1 and potential_value2 >= v2) or (potential_value1 >= v1 and potential_value2 > v2):\n                        improvement_count += 1\n                dominance_scores[i] = improvement_count / len(archive)\n\n    # Sort items by dominance scores\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Temperature-controlled flips\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability based on dominance and temperature\n            flip_prob = temperature * (1 - dominance_scores[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on dominance and temperature\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * dominance_scores[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.953361269309609,
            6.430423945188522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized dominance scores\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Calculate how many other solutions would be dominated if this item were removed\n            dominated_count = 0\n            for sol, (v1, v2) in archive:\n                if sol[i] == 1 and (v1 - value1_lst[i] < current_value1 or v2 - value2_lst[i] < current_value2):\n                    dominated_count += 1\n            dominance_scores[i] = dominated_count / len(archive)\n        else:\n            # Calculate potential improvement if this item were added\n            if current_weight + weight_lst[i] <= capacity:\n                potential_value1 = current_value1 + value1_lst[i]\n                potential_value2 = current_value2 + value2_lst[i]\n                improvement_count = 0\n                for sol, (v1, v2) in archive:\n                    if (potential_value1 > v1 and potential_value2 >= v2) or (potential_value1 >= v1 and potential_value2 > v2):\n                        improvement_count += 1\n                dominance_scores[i] = improvement_count / len(archive)\n\n    # Sort items by dominance scores\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Temperature-controlled flips\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability based on dominance and temperature\n            flip_prob = temperature * (1 - dominance_scores[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on dominance and temperature\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * dominance_scores[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with high marginal contribution to either objective\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by their contribution to each objective (descending)\n    sorted_items_value1 = np.argsort(-value1_ratio)\n    sorted_items_value2 = np.argsort(-value2_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with objective-specific selection\n    for item in sorted_items_value1:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    for item in sorted_items_value2:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with smallest total contribution\n    if current_weight > capacity:\n        total_contribution = value1_lst + value2_lst\n        sorted_items_contribution = np.argsort(total_contribution)\n        excess_weight = current_weight - capacity\n        for item in sorted_items_contribution:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3810203570817921,
            4.495005697011948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with high marginal contribution to either objective\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by their contribution to each objective (descending)\n    sorted_items_value1 = np.argsort(-value1_ratio)\n    sorted_items_value2 = np.argsort(-value2_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with objective-specific selection\n    for item in sorted_items_value1:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    for item in sorted_items_value2:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing items with smallest total contribution\n    if current_weight > capacity:\n        total_contribution = value1_lst + value2_lst\n        sorted_items_contribution = np.argsort(total_contribution)\n        excess_weight = current_weight - capacity\n        for item in sorted_items_contribution:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The new algorithm employs a hybrid approach combining a diversity-preserving selection mechanism with a value-weighted random walk, where items are probabilistically swapped based on their normalized contributions to both objectives while maintaining feasibility through adaptive weight balancing and dominance-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        distances = []\n        for i in range(len(archive)):\n            left = archive[(i - 1) % len(archive)][1]\n            right = archive[(i + 1) % len(archive)][1]\n            distances.append(np.linalg.norm(np.array(right) - np.array(left)))\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value weights\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n    value1_weights = value1_lst / (total_value1 + 1e-10)\n    value2_weights = value2_lst / (total_value2 + 1e-10)\n    combined_weights = (value1_weights + value2_weights) / 2\n\n    # Perform value-weighted random walk\n    for _ in range(min(5, len(weight_lst))):\n        # Select item with probability proportional to its combined weight\n        probs = combined_weights / np.sum(combined_weights)\n        item = np.random.choice(len(weight_lst), p=probs)\n\n        if base_solution[item] == 1:\n            # Remove item with probability based on its weight\n            if random.random() < 0.5 * (1 - combined_weights[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Dominance-aware adjustment\n    for item in np.where(new_solution == 1)[0]:\n        temp_solution = new_solution.copy()\n        temp_solution[item] = 0\n        temp_weight = current_weight - weight_lst[item]\n        temp_value1 = current_value1 - value1_lst[item]\n        temp_value2 = current_value2 - value2_lst[item]\n\n        # If removing improves at least one objective without hurting the other\n        if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n           (temp_value1 > current_value1 and temp_value2 >= current_value2):\n            new_solution = temp_solution\n            current_weight = temp_weight\n            current_value1 = temp_value1\n            current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(weight_lst * (1 - combined_weights)):\n            if excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9348102668862311,
            6.4702107310295105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        distances = []\n        for i in range(len(archive)):\n            left = archive[(i - 1) % len(archive)][1]\n            right = archive[(i + 1) % len(archive)][1]\n            distances.append(np.linalg.norm(np.array(right) - np.array(left)))\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value weights\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n    value1_weights = value1_lst / (total_value1 + 1e-10)\n    value2_weights = value2_lst / (total_value2 + 1e-10)\n    combined_weights = (value1_weights + value2_weights) / 2\n\n    # Perform value-weighted random walk\n    for _ in range(min(5, len(weight_lst))):\n        # Select item with probability proportional to its combined weight\n        probs = combined_weights / np.sum(combined_weights)\n        item = np.random.choice(len(weight_lst), p=probs)\n\n        if base_solution[item] == 1:\n            # Remove item with probability based on its weight\n            if random.random() < 0.5 * (1 - combined_weights[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Dominance-aware adjustment\n    for item in np.where(new_solution == 1)[0]:\n        temp_solution = new_solution.copy()\n        temp_solution[item] = 0\n        temp_weight = current_weight - weight_lst[item]\n        temp_value1 = current_value1 - value1_lst[item]\n        temp_value2 = current_value2 - value2_lst[item]\n\n        # If removing improves at least one objective without hurting the other\n        if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n           (temp_value1 > current_value1 and temp_value2 >= current_value2):\n            new_solution = temp_solution\n            current_weight = temp_weight\n            current_value1 = temp_value1\n            current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in np.argsort(weight_lst * (1 - combined_weights)):\n            if excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm combines a multi-objective genetic crossover with a simulated annealing-based acceptance criterion to generate neighbors by intelligently combining solution components from the archive while ensuring feasibility, using a temperature-controlled probabilistic acceptance strategy to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        idx1, idx2 = random.sample(range(len(archive)), 2)\n    else:\n        idx1 = 0\n        idx2 = 0\n    sol1, _ = archive[idx1]\n    sol2, _ = archive[idx2]\n\n    # Perform multi-objective crossover\n    new_solution = np.zeros_like(sol1)\n    current_weight = 0.0\n\n    # Temperature for simulated annealing acceptance\n    temperature = max(0.1, 1.0 - (len(archive) / 100))\n\n    for i in range(len(sol1)):\n        # Probabilistically select from either parent\n        if random.random() < 0.5:\n            selected = sol1[i]\n        else:\n            selected = sol2[i]\n\n        # Acceptance criterion with temperature\n        if selected == 1:\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < temperature:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n            else:\n                # Try to replace with a lower-weight item if possible\n                if random.random() < temperature * 0.3:\n                    # Find a lower-weight item to swap with\n                    candidates = [j for j in range(len(sol1)) if new_solution[j] == 1 and weight_lst[j] > weight_lst[i]]\n                    if candidates:\n                        replace_idx = random.choice(candidates)\n                        new_solution[replace_idx] = 0\n                        new_solution[i] = 1\n                        current_weight = current_weight - weight_lst[replace_idx] + weight_lst[i]\n\n    # Ensure feasibility by removing excess items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Sort items by value-to-weight ratio in descending order\n        ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-ratios)\n\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.25843351874316334,
            1.4214022159576416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        idx1, idx2 = random.sample(range(len(archive)), 2)\n    else:\n        idx1 = 0\n        idx2 = 0\n    sol1, _ = archive[idx1]\n    sol2, _ = archive[idx2]\n\n    # Perform multi-objective crossover\n    new_solution = np.zeros_like(sol1)\n    current_weight = 0.0\n\n    # Temperature for simulated annealing acceptance\n    temperature = max(0.1, 1.0 - (len(archive) / 100))\n\n    for i in range(len(sol1)):\n        # Probabilistically select from either parent\n        if random.random() < 0.5:\n            selected = sol1[i]\n        else:\n            selected = sol2[i]\n\n        # Acceptance criterion with temperature\n        if selected == 1:\n            if current_weight + weight_lst[i] <= capacity:\n                if random.random() < temperature:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n            else:\n                # Try to replace with a lower-weight item if possible\n                if random.random() < temperature * 0.3:\n                    # Find a lower-weight item to swap with\n                    candidates = [j for j in range(len(sol1)) if new_solution[j] == 1 and weight_lst[j] > weight_lst[i]]\n                    if candidates:\n                        replace_idx = random.choice(candidates)\n                        new_solution[replace_idx] = 0\n                        new_solution[i] = 1\n                        current_weight = current_weight - weight_lst[replace_idx] + weight_lst[i]\n\n    # Ensure feasibility by removing excess items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Sort items by value-to-weight ratio in descending order\n        ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-ratios)\n\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The new algorithm combines a diversity-aware selection mechanism with a hybrid local search that alternates between targeted item flips and probabilistic swaps, prioritizing items with balanced marginal contributions to both objectives while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate item importance scores\n    value1_score = value1_lst / (weight_lst + 1e-10)\n    value2_score = value2_lst / (weight_lst + 1e-10)\n    balance_score = (value1_score + value2_score) / (np.abs(value1_score - value2_score) + 1e-10)\n\n    # Sort items by balance score (descending)\n    sorted_items = np.argsort(-balance_score)\n\n    # Hybrid local search: alternate between targeted flips and probabilistic swaps\n    for i, item in enumerate(sorted_items):\n        if i % 2 == 0:  # Targeted flip\n            if base_solution[item] == 1:\n                # Flip out if it improves at least one objective\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n                   (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n            else:  # Targeted addition\n                if current_weight + weight_lst[item] <= capacity:\n                    # Add if it improves both objectives\n                    temp_value1 = current_value1 + value1_lst[item]\n                    temp_value2 = current_value2 + value2_lst[item]\n\n                    if temp_value1 > current_value1 and temp_value2 > current_value2:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        current_value1 = temp_value1\n                        current_value2 = temp_value2\n        else:  # Probabilistic swap\n            if base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif base_solution[item] == 0 and random.random() < 0.5 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with adaptive weight reduction\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3641558609502185,
            2.382666975259781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate item importance scores\n    value1_score = value1_lst / (weight_lst + 1e-10)\n    value2_score = value2_lst / (weight_lst + 1e-10)\n    balance_score = (value1_score + value2_score) / (np.abs(value1_score - value2_score) + 1e-10)\n\n    # Sort items by balance score (descending)\n    sorted_items = np.argsort(-balance_score)\n\n    # Hybrid local search: alternate between targeted flips and probabilistic swaps\n    for i, item in enumerate(sorted_items):\n        if i % 2 == 0:  # Targeted flip\n            if base_solution[item] == 1:\n                # Flip out if it improves at least one objective\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n                   (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n            else:  # Targeted addition\n                if current_weight + weight_lst[item] <= capacity:\n                    # Add if it improves both objectives\n                    temp_value1 = current_value1 + value1_lst[item]\n                    temp_value2 = current_value2 + value2_lst[item]\n\n                    if temp_value1 > current_value1 and temp_value2 > current_value2:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        current_value1 = temp_value1\n                        current_value2 = temp_value2\n        else:  # Probabilistic swap\n            if base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            elif base_solution[item] == 0 and random.random() < 0.5 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with adaptive weight reduction\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The new algorithm combines a dominance-aware greedy construction with a Pareto-adaptive mutation strategy, where items are selectively added or removed based on their hypervolume contributions and adaptive neighborhood exploration to balance exploration and exploitation in the multi-objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate hypervolume contributions\n    hypervolume = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-hypervolume)\n\n    # Pareto-adaptive mutation\n    mutation_rate = 0.3\n    for item in sorted_items:\n        if random.random() < mutation_rate:\n            if new_solution[item] == 1:\n                # Try to remove with Pareto check\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                if temp_weight <= capacity and ((temp_value1 > current_value1 and temp_value2 >= current_value2) or\n                                              (temp_value1 >= current_value1 and temp_value2 > current_value2)):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n            else:\n                # Try to add with feasibility check\n                if current_weight + weight_lst[item] <= capacity:\n                    temp_solution = new_solution.copy()\n                    temp_solution[item] = 1\n                    temp_weight = current_weight + weight_lst[item]\n                    temp_value1 = current_value1 + value1_lst[item]\n                    temp_value2 = current_value2 + value2_lst[item]\n\n                    if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n                       (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                        new_solution = temp_solution\n                        current_weight = temp_weight\n                        current_value1 = temp_value1\n                        current_value2 = temp_value2\n\n    # Adaptive neighborhood exploration\n    neighborhood_size = max(1, int(0.2 * len(weight_lst)))\n    for _ in range(neighborhood_size):\n        item = random.choice(sorted_items)\n        if new_solution[item] == 1:\n            # Try to remove with weight check\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try to add with weight check\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3918793105687709,
            2.961012303829193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate hypervolume contributions\n    hypervolume = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-hypervolume)\n\n    # Pareto-adaptive mutation\n    mutation_rate = 0.3\n    for item in sorted_items:\n        if random.random() < mutation_rate:\n            if new_solution[item] == 1:\n                # Try to remove with Pareto check\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                if temp_weight <= capacity and ((temp_value1 > current_value1 and temp_value2 >= current_value2) or\n                                              (temp_value1 >= current_value1 and temp_value2 > current_value2)):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n            else:\n                # Try to add with feasibility check\n                if current_weight + weight_lst[item] <= capacity:\n                    temp_solution = new_solution.copy()\n                    temp_solution[item] = 1\n                    temp_weight = current_weight + weight_lst[item]\n                    temp_value1 = current_value1 + value1_lst[item]\n                    temp_value2 = current_value2 + value2_lst[item]\n\n                    if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n                       (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                        new_solution = temp_solution\n                        current_weight = temp_weight\n                        current_value1 = temp_value1\n                        current_value2 = temp_value2\n\n    # Adaptive neighborhood exploration\n    neighborhood_size = max(1, int(0.2 * len(weight_lst)))\n    for _ in range(neighborhood_size):\n        item = random.choice(sorted_items)\n        if new_solution[item] == 1:\n            # Try to remove with weight check\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Try to add with weight check\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The new algorithm employs a hybrid approach combining diversity-preserving perturbations with a multi-objective greedy improvement strategy, where solutions are modified through adaptive item swaps prioritized by their Pareto-efficient trade-offs while maintaining feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient trade-offs\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_items = np.argsort(-value_ratio)\n\n    # Hybrid perturbation strategy\n    for i in range(len(sorted_items)):\n        item = sorted_items[i]\n        # Adaptive swap probability based on position and current state\n        swap_prob = (0.5 + 0.5 * (i / len(sorted_items))) * (0.8 if base_solution[item] else 0.2)\n\n        if random.random() < swap_prob:\n            if base_solution[item] == 1:\n                # Try to remove if it doesn't dominate others\n                temp_weight = current_weight - weight_lst[item]\n                if temp_weight >= 0:\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n            else:\n                # Try to add if feasible\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement phase\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves at least one objective\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if the new solution is non-dominated by current\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing items with worst trade-offs\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6392970152245132,
            6.243055284023285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high diversity potential\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient trade-offs\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_items = np.argsort(-value_ratio)\n\n    # Hybrid perturbation strategy\n    for i in range(len(sorted_items)):\n        item = sorted_items[i]\n        # Adaptive swap probability based on position and current state\n        swap_prob = (0.5 + 0.5 * (i / len(sorted_items))) * (0.8 if base_solution[item] else 0.2)\n\n        if random.random() < swap_prob:\n            if base_solution[item] == 1:\n                # Try to remove if it doesn't dominate others\n                temp_weight = current_weight - weight_lst[item]\n                if temp_weight >= 0:\n                    new_solution[item] = 0\n                    current_weight = temp_weight\n            else:\n                # Try to add if feasible\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement phase\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves at least one objective\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if the new solution is non-dominated by current\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing items with worst trade-offs\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{The new algorithm combines a biased random walk with a hypervolume-based selection of critical items, where items are prioritized based on their potential to improve the Pareto front, ensuring feasibility and high-quality neighbors through a dynamic perturbation strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    hypervolumes = (objectives[:, 0] * objectives[:, 1]) / (max_values[0] * max_values[1])\n    probabilities = 1 - hypervolumes / (np.sum(1 - hypervolumes) + 1e-10)\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with potential for improvement\n    potential_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            potential_items.append(i)\n        elif base_solution[i] == 1:\n            potential_items.append(i)\n\n    # Perform dynamic perturbation\n    for _ in range(3):\n        if not potential_items:\n            break\n        item = random.choice(potential_items)\n        if base_solution[item] == 0:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n        else:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n        # Update potential items list\n        potential_items = [i for i in potential_items if i != item]\n        if current_weight > capacity:\n            # Remove items until feasible\n            for i in potential_items:\n                if new_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    potential_items.remove(i)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9705052288337033,
            5.372403293848038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    hypervolumes = (objectives[:, 0] * objectives[:, 1]) / (max_values[0] * max_values[1])\n    probabilities = 1 - hypervolumes / (np.sum(1 - hypervolumes) + 1e-10)\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items with potential for improvement\n    potential_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            potential_items.append(i)\n        elif base_solution[i] == 1:\n            potential_items.append(i)\n\n    # Perform dynamic perturbation\n    for _ in range(3):\n        if not potential_items:\n            break\n        item = random.choice(potential_items)\n        if base_solution[item] == 0:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n        else:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n        # Update potential items list\n        potential_items = [i for i in potential_items if i != item]\n        if current_weight > capacity:\n            # Remove items until feasible\n            for i in potential_items:\n                if new_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    potential_items.remove(i)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The novel local search strategy employs a diversity-aware probabilistic swap with a value-weighted greedy selection, where items are prioritized based on their normalized marginal contributions to both objectives, dynamically adjusting selection probabilities based on solution density in the archive to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    potential = np.sum((objectives / (max_obj + 1e-10)) * np.random.rand(2), axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalized value contributions\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n    combined_norm = value1_norm * 0.6 + value2_norm * 0.4  # Weighted combination\n\n    # Sort items by combined normalized value\n    sorted_items = np.argsort(-combined_norm)\n\n    # Dynamic probability adjustment based on archive diversity\n    diversity = len(archive) / len(archive[0][0]) if archive else 0.5\n    swap_prob = 0.4 - diversity * 0.2\n    add_prob = 0.6 + diversity * 0.2\n\n    # Perform diversity-aware local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < swap_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4863512510063005,
            2.3239340484142303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    potential = np.sum((objectives / (max_obj + 1e-10)) * np.random.rand(2), axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalized value contributions\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n    combined_norm = value1_norm * 0.6 + value2_norm * 0.4  # Weighted combination\n\n    # Sort items by combined normalized value\n    sorted_items = np.argsort(-combined_norm)\n\n    # Dynamic probability adjustment based on archive diversity\n    diversity = len(archive) / len(archive[0][0]) if archive else 0.5\n    swap_prob = 0.4 - diversity * 0.2\n    add_prob = 0.6 + diversity * 0.2\n\n    # Perform diversity-aware local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < swap_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The novel local search strategy employs a dynamic priority-based selection with adaptive weight adjustments, where items are prioritized based on their marginal contribution to both objectives, combined with a probabilistic flip mechanism to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic priority scores\n    remaining_capacity = capacity - current_weight\n    value1_score = value1_lst / (weight_lst + 1e-10)\n    value2_score = value2_lst / (weight_lst + 1e-10)\n    priority_score = (value1_score + value2_score) * (1 + 0.5 * (remaining_capacity / (capacity + 1e-10)))\n\n    # Sort items by priority score (descending)\n    sorted_items = np.argsort(-priority_score)\n\n    # Adaptive flip mechanism\n    flip_prob = 0.4 if remaining_capacity > 0.3 * capacity else 0.2\n\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < flip_prob:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.47148551968767505,
            1.0156825482845306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic priority scores\n    remaining_capacity = capacity - current_weight\n    value1_score = value1_lst / (weight_lst + 1e-10)\n    value2_score = value2_lst / (weight_lst + 1e-10)\n    priority_score = (value1_score + value2_score) * (1 + 0.5 * (remaining_capacity / (capacity + 1e-10)))\n\n    # Sort items by priority score (descending)\n    sorted_items = np.argsort(-priority_score)\n\n    # Adaptive flip mechanism\n    flip_prob = 0.4 if remaining_capacity > 0.3 * capacity else 0.2\n\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < flip_prob:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{The novel local search strategy combines a hypervolume-based selection with a dynamic neighborhood exploration that adaptively balances exploration and exploitation by considering both objective contributions and solution diversity, ensuring high-quality neighbors are generated through a combination of greedy and probabilistic operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate hypervolume contributions (simplified)\n    hypervolumes = []\n    for sol, obj in archive:\n        hypervolumes.append(obj[0] * obj[1])  # Approximate hypervolume as product of objectives\n    selected_idx = np.argmax(hypervolumes)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic neighborhood exploration\n    for _ in range(5):  # Number of iterations\n        # Randomly select a subset of items to explore\n        candidate_items = np.random.permutation(len(weight_lst))[:max(2, len(weight_lst)//5)]\n\n        for item in candidate_items:\n            if base_solution[item] == 1:\n                # Probabilistically remove based on marginal contribution\n                marginal1 = value1_lst[item] / (weight_lst[item] + 1e-10)\n                marginal2 = value2_lst[item] / (weight_lst[item] + 1e-10)\n                if random.random() < 0.5 * (marginal1 + marginal2) / (current_value1 + current_value2 + 1e-10):\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Probabilistically add based on feasibility and potential gain\n                potential_gain = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.8 * potential_gain:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest marginal contribution\n        marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(marginal_contributions)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3400182683852665,
            2.8134553730487823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate hypervolume contributions (simplified)\n    hypervolumes = []\n    for sol, obj in archive:\n        hypervolumes.append(obj[0] * obj[1])  # Approximate hypervolume as product of objectives\n    selected_idx = np.argmax(hypervolumes)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic neighborhood exploration\n    for _ in range(5):  # Number of iterations\n        # Randomly select a subset of items to explore\n        candidate_items = np.random.permutation(len(weight_lst))[:max(2, len(weight_lst)//5)]\n\n        for item in candidate_items:\n            if base_solution[item] == 1:\n                # Probabilistically remove based on marginal contribution\n                marginal1 = value1_lst[item] / (weight_lst[item] + 1e-10)\n                marginal2 = value2_lst[item] / (weight_lst[item] + 1e-10)\n                if random.random() < 0.5 * (marginal1 + marginal2) / (current_value1 + current_value2 + 1e-10):\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Probabilistically add based on feasibility and potential gain\n                potential_gain = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.8 * potential_gain:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest marginal contribution\n        marginal_contributions = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(marginal_contributions)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{The new algorithm employs a hybrid approach combining a diversity-aware item selection mechanism with a multi-objective regret-based perturbation, where items are prioritized based on their potential to improve either objective while maintaining feasibility, and perturbations are guided by the difference in marginal contributions between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate regret-based marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    regret = np.abs(marginal1 - marginal2)\n    sorted_items = np.argsort(-regret)\n\n    # Diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on regret and current weight\n            if random.random() < regret[item] / (np.max(regret) + 1e-10):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < (marginal1[item] + marginal2[item]) / (2 * np.max(marginal1 + marginal2) + 1e-10):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Multi-objective regret-based adjustment\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4683512570747388,
            8.49407547712326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate regret-based marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    regret = np.abs(marginal1 - marginal2)\n    sorted_items = np.argsort(-regret)\n\n    # Diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on regret and current weight\n            if random.random() < regret[item] / (np.max(regret) + 1e-10):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < (marginal1[item] + marginal2[item]) / (2 * np.max(marginal1 + marginal2) + 1e-10):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Multi-objective regret-based adjustment\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{The new algorithm combines a diversity-aware neighborhood exploration with a multi-objective regret-based selection strategy, where items are prioritized based on their potential to improve both objectives while maintaining solution diversity through controlled perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate regret-based priorities for both objectives\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    regret1 = max_value1 - value1_lst\n    regret2 = max_value2 - value2_lst\n    combined_regret = regret1 + regret2\n    sorted_items = np.argsort(-combined_regret)\n\n    # Diversity-aware perturbation\n    diversity_factor = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with high regret but lower probability\n            if random.random() < diversity_factor * (combined_regret[item] / np.max(combined_regret)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high regret if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective regret-based improvement\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Temporarily add the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n\n            # Check if adding improves at least one objective\n            if (value1_lst[item] > 0 or value2_lst[item] > 0) and \\\n               (random.random() < 0.5 or combined_regret[item] > np.median(combined_regret)):\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.40706354189324745,
            6.840838462114334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate regret-based priorities for both objectives\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    regret1 = max_value1 - value1_lst\n    regret2 = max_value2 - value2_lst\n    combined_regret = regret1 + regret2\n    sorted_items = np.argsort(-combined_regret)\n\n    # Diversity-aware perturbation\n    diversity_factor = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with high regret but lower probability\n            if random.random() < diversity_factor * (combined_regret[item] / np.max(combined_regret)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high regret if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective regret-based improvement\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Temporarily add the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 1\n            temp_weight = current_weight + weight_lst[item]\n\n            # Check if adding improves at least one objective\n            if (value1_lst[item] > 0 or value2_lst[item] > 0) and \\\n               (random.random() < 0.5 or combined_regret[item] > np.median(combined_regret)):\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This new algorithm uses an adaptive value-to-weight ratio scoring with dynamic probability thresholds to prioritize items based on their marginal contribution to both objectives, while incorporating a biased random walk to escape local optima and maintain feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        dominance_scores = np.array([i for i in range(len(archive))])\n        selected_idx = random.choices(range(len(archive)), weights=dominance_scores, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive value-to-weight ratio with dynamic thresholds\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4  # Weighted combination\n\n    # Dynamic probability thresholds\n    p_remove = 0.4 if current_weight > capacity * 0.8 else 0.2\n    p_add = 0.8 if current_weight < capacity * 0.5 else 0.5\n\n    # Biased random walk with greedy selection\n    for item in np.argsort(-combined_ratio):\n        if base_solution[item] == 1:\n            if random.random() < p_remove:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < p_add:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal adjustments\n    if current_weight > capacity:\n        for item in np.argsort(weight_lst * (value1_ratio + value2_ratio)):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4170686231478007,
            1.9685527980327606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        dominance_scores = np.array([i for i in range(len(archive))])\n        selected_idx = random.choices(range(len(archive)), weights=dominance_scores, k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive value-to-weight ratio with dynamic thresholds\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio * 0.6 + value2_ratio * 0.4  # Weighted combination\n\n    # Dynamic probability thresholds\n    p_remove = 0.4 if current_weight > capacity * 0.8 else 0.2\n    p_add = 0.8 if current_weight < capacity * 0.5 else 0.5\n\n    # Biased random walk with greedy selection\n    for item in np.argsort(-combined_ratio):\n        if base_solution[item] == 1:\n            if random.random() < p_remove:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < p_add:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal adjustments\n    if current_weight > capacity:\n        for item in np.argsort(weight_lst * (value1_ratio + value2_ratio)):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{The new algorithm uses a dynamic item prioritization strategy that combines marginal value improvements with a probabilistic item swap mechanism to generate high-quality neighbors while ensuring feasibility, by iteratively refining the solution through targeted perturbations and greedy additions of high-impact items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal values for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic perturbation: probabilistic item swaps\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.49210669000559926,
            1.9342737793922424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal values for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic perturbation: probabilistic item swaps\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value1_ratio + value2_ratio) / (np.max(value1_ratio + value2_ratio) + 1e-10)\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7 * combined_ratio[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9553012084658972,
            2.602281481027603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value1_ratio + value2_ratio) / (np.max(value1_ratio + value2_ratio) + 1e-10)\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7 * combined_ratio[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{The new algorithm employs a hybrid of greedy value-based selection with adaptive dominance-aware perturbations, where items are prioritized based on their combined objective contributions while dynamically adjusting flip probabilities through a novel utility function that balances marginal gains and solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate utility scores combining marginal gains and diversity\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    utility = (marginal1 + marginal2) * (1 - base_solution)  # Prioritize adding items not in solution\n    sorted_items = np.argsort(-utility)\n\n    # Adaptive perturbation based on solution quality\n    quality_factor = min(1.0, (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst)))\n    perturbation_strength = 0.5 * (1 - quality_factor)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low utility or high probability\n            removal_prob = perturbation_strength * (1 - utility[item] / (np.max(utility) + 1e-10))\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-utility items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - perturbation_strength) * (utility[item] / (np.max(utility) + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-aware local improvement\n    for _ in range(2):  # Limited iterations for efficiency\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                # Accept if at least one objective improves\n                if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n                   (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n                    break\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8613196325141124,
            11.01509913802147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate utility scores combining marginal gains and diversity\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    utility = (marginal1 + marginal2) * (1 - base_solution)  # Prioritize adding items not in solution\n    sorted_items = np.argsort(-utility)\n\n    # Adaptive perturbation based on solution quality\n    quality_factor = min(1.0, (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst)))\n    perturbation_strength = 0.5 * (1 - quality_factor)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low utility or high probability\n            removal_prob = perturbation_strength * (1 - utility[item] / (np.max(utility) + 1e-10))\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-utility items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - perturbation_strength) * (utility[item] / (np.max(utility) + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-aware local improvement\n    for _ in range(2):  # Limited iterations for efficiency\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 0\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                # Accept if at least one objective improves\n                if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n                   (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n                    break\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, but with a different parameter setting that emphasizes the value1 objective more than the original algorithm.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = 0.7 * value1_ratio + 0.3 * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3999771655057009,
            3.703897148370743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = 0.7 * value1_ratio + 0.3 * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This algorithm uses an adaptive greedy construction approach combined with a dominance-aware perturbation strategy, where items are selected based on their Pareto-efficient ratios while allowing occasional non-greedy moves to escape local optima, ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potentials = [np.sum((value1_lst + value2_lst) * (1 - sol)) for sol, _ in archive]\n    selected_idx = np.argmax(potentials)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive greedy construction with occasional non-greedy moves\n    for _ in range(2):  # Perform multiple passes\n        for i in np.random.permutation(len(weight_lst)):\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                # Calculate potential improvement\n                marginal1 = value1_lst[i] / (weight_lst[i] + 1e-10)\n                marginal2 = value2_lst[i] / (weight_lst[i] + 1e-10)\n\n                # Adaptive probability\n                prob = 0.7 if marginal1 + marginal2 > np.mean(marginal1 + marginal2) else 0.3\n                if random.random() < prob:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Dominance-aware perturbation\n    for i in np.random.permutation(np.where(new_solution == 1)[0]):\n        if random.random() < 0.2:  # Small probability to remove items\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n\n            # Check if removing improves dominance\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_lst / (value1_lst + value2_lst + 1e-10)):\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.892079438278242,
            9.75343844294548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    potentials = [np.sum((value1_lst + value2_lst) * (1 - sol)) for sol, _ in archive]\n    selected_idx = np.argmax(potentials)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive greedy construction with occasional non-greedy moves\n    for _ in range(2):  # Perform multiple passes\n        for i in np.random.permutation(len(weight_lst)):\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                # Calculate potential improvement\n                marginal1 = value1_lst[i] / (weight_lst[i] + 1e-10)\n                marginal2 = value2_lst[i] / (weight_lst[i] + 1e-10)\n\n                # Adaptive probability\n                prob = 0.7 if marginal1 + marginal2 > np.mean(marginal1 + marginal2) else 0.3\n                if random.random() < prob:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Dominance-aware perturbation\n    for i in np.random.permutation(np.where(new_solution == 1)[0]):\n        if random.random() < 0.2:  # Small probability to remove items\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n\n            # Check if removing improves dominance\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_lst / (value1_lst + value2_lst + 1e-10)):\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The novel local search strategy combines a diversity-preserving perturbation with a multi-objective greedy insertion, where items are selected based on their Pareto-efficient contributions to both objectives, while maintaining feasibility through a capacity-aware adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient item scores\n    value1_efficiency = value1_lst / (weight_lst + 1e-10)\n    value2_efficiency = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined efficiency (descending)\n    combined_efficiency = value1_efficiency + value2_efficiency\n    sorted_items = np.argsort(-combined_efficiency)\n\n    # Perform multi-objective greedy insertion\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Probabilistically add items based on both objectives\n            if (random.random() < 0.5 and value1_efficiency[item] > np.median(value1_efficiency)) or \\\n               (random.random() < 0.5 and value2_efficiency[item] > np.median(value2_efficiency)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility through capacity-aware adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:  # Remove least efficient items first\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8156177553743736,
            3.8410199880599976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient item scores\n    value1_efficiency = value1_lst / (weight_lst + 1e-10)\n    value2_efficiency = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by combined efficiency (descending)\n    combined_efficiency = value1_efficiency + value2_efficiency\n    sorted_items = np.argsort(-combined_efficiency)\n\n    # Perform multi-objective greedy insertion\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Probabilistically add items based on both objectives\n            if (random.random() < 0.5 and value1_efficiency[item] > np.median(value1_efficiency)) or \\\n               (random.random() < 0.5 and value2_efficiency[item] > np.median(value2_efficiency)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility through capacity-aware adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:  # Remove least efficient items first\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm employs a hybrid approach combining a greedy Pareto-frontier exploration with a novel \"objective-swapping\" mechanism, where items are dynamically reassigned between objectives based on their marginal contributions while maintaining feasibility through a capacity-aware packing strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate objective-specific marginal gains\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Objective-swapping mechanism: dynamically reassign items between objectives\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 1:\n            # Probabilistically swap item between objectives based on marginal gains\n            swap_prob = 0.5 * (abs(marginal1[item] - marginal2[item]) / max(marginal1[item], marginal2[item]))\n            if random.random() < swap_prob:\n                # Temporarily remove the item\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                # Check if adding the item to the other objective is beneficial\n                if marginal1[item] > marginal2[item]:\n                    # Try to add to objective 2\n                    if temp_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 0  # Remove from objective 1\n                        # Find a suitable replacement in objective 2\n                        for other_item in np.argsort(-marginal2):\n                            if base_solution[other_item] == 0 and temp_weight + weight_lst[other_item] <= capacity:\n                                new_solution[other_item] = 1\n                                temp_weight += weight_lst[other_item]\n                                temp_value2 += value2_lst[other_item]\n                                break\n                else:\n                    # Try to add to objective 1\n                    if temp_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 0  # Remove from objective 2\n                        # Find a suitable replacement in objective 1\n                        for other_item in np.argsort(-marginal1):\n                            if base_solution[other_item] == 0 and temp_weight + weight_lst[other_item] <= capacity:\n                                new_solution[other_item] = 1\n                                temp_weight += weight_lst[other_item]\n                                temp_value1 += value1_lst[other_item]\n                                break\n\n    # Ensure feasibility by removing items with lowest combined marginal value\n    while np.sum(weight_lst * new_solution) > capacity:\n        marginal_total = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        worst_item = np.argmax(marginal_total * new_solution)\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8182928508784162,
            8.767884343862534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in range(len(archive))])[0]\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate objective-specific marginal gains\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Objective-swapping mechanism: dynamically reassign items between objectives\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 1:\n            # Probabilistically swap item between objectives based on marginal gains\n            swap_prob = 0.5 * (abs(marginal1[item] - marginal2[item]) / max(marginal1[item], marginal2[item]))\n            if random.random() < swap_prob:\n                # Temporarily remove the item\n                temp_weight = current_weight - weight_lst[item]\n                temp_value1 = current_value1 - value1_lst[item]\n                temp_value2 = current_value2 - value2_lst[item]\n\n                # Check if adding the item to the other objective is beneficial\n                if marginal1[item] > marginal2[item]:\n                    # Try to add to objective 2\n                    if temp_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 0  # Remove from objective 1\n                        # Find a suitable replacement in objective 2\n                        for other_item in np.argsort(-marginal2):\n                            if base_solution[other_item] == 0 and temp_weight + weight_lst[other_item] <= capacity:\n                                new_solution[other_item] = 1\n                                temp_weight += weight_lst[other_item]\n                                temp_value2 += value2_lst[other_item]\n                                break\n                else:\n                    # Try to add to objective 1\n                    if temp_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 0  # Remove from objective 2\n                        # Find a suitable replacement in objective 1\n                        for other_item in np.argsort(-marginal1):\n                            if base_solution[other_item] == 0 and temp_weight + weight_lst[other_item] <= capacity:\n                                new_solution[other_item] = 1\n                                temp_weight += weight_lst[other_item]\n                                temp_value1 += value1_lst[other_item]\n                                break\n\n    # Ensure feasibility by removing items with lowest combined marginal value\n    while np.sum(weight_lst * new_solution) > capacity:\n        marginal_total = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        worst_item = np.argmax(marginal_total * new_solution)\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{The new algorithm combines a value-aware diversification strategy with a multi-objective greedy reconstruction approach, where it first diversifies the solution by probabilistically flipping items based on their individual objective contributions, followed by a greedy reconstruction that prioritizes items with the highest combined marginal gains while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Value-aware diversification phase\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Probabilistically flip based on individual objective contributions\n            flip_prob = 0.2 * (value1_lst[i] / (current_value1 + 1e-10)) + 0.2 * (value2_lst[i] / (current_value2 + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add items with high individual contributions\n            if current_weight + weight_lst[i] <= capacity:\n                add_prob = 0.3 * (value1_lst[i] / np.max(value1_lst)) + 0.3 * (value2_lst[i] / np.max(value2_lst))\n                if random.random() < add_prob:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Multi-objective greedy reconstruction phase\n    available_items = np.where(new_solution == 0)[0]\n    for item in available_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Calculate combined marginal gain\n            marginal_gain = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n            # Add items with highest marginal gain\n            if marginal_gain > 0.5 * (np.mean(value1_lst) + np.mean(value2_lst)) / (np.mean(weight_lst) + 1e-10):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest combined value-to-weight ratio\n        value_weight_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(value_weight_ratio)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.39069378287051837,
            7.992783755064011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Value-aware diversification phase\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Probabilistically flip based on individual objective contributions\n            flip_prob = 0.2 * (value1_lst[i] / (current_value1 + 1e-10)) + 0.2 * (value2_lst[i] / (current_value2 + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add items with high individual contributions\n            if current_weight + weight_lst[i] <= capacity:\n                add_prob = 0.3 * (value1_lst[i] / np.max(value1_lst)) + 0.3 * (value2_lst[i] / np.max(value2_lst))\n                if random.random() < add_prob:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Multi-objective greedy reconstruction phase\n    available_items = np.where(new_solution == 0)[0]\n    for item in available_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Calculate combined marginal gain\n            marginal_gain = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n            # Add items with highest marginal gain\n            if marginal_gain > 0.5 * (np.mean(value1_lst) + np.mean(value2_lst)) / (np.mean(weight_lst) + 1e-10):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest combined value-to-weight ratio\n        value_weight_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(value_weight_ratio)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{The new algorithm employs a dynamic item prioritization strategy that combines objective-specific rankings with a simulated annealing-inspired acceptance criterion to probabilistically explore high-potential regions while maintaining feasibility, balancing exploration and exploitation through temperature-adjusted perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = np.sum(normalized, axis=1)\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Create dynamic prioritization based on both objectives\n    value1_rank = np.argsort(-value1_lst)\n    value2_rank = np.argsort(-value2_lst)\n    combined_rank = value1_rank + value2_rank\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in np.argsort(combined_rank):\n        if random.random() < temperature:\n            if base_solution[item] == 1:\n                if random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        for item in np.argsort(weight_lst * (1 - new_solution)):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3757079605571886,
            2.938384860754013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = np.sum(normalized, axis=1)\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Create dynamic prioritization based on both objectives\n    value1_rank = np.argsort(-value1_lst)\n    value2_rank = np.argsort(-value2_lst)\n    combined_rank = value1_rank + value2_rank\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in np.argsort(combined_rank):\n        if random.random() < temperature:\n            if base_solution[item] == 1:\n                if random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        for item in np.argsort(weight_lst * (1 - new_solution)):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{The new algorithm employs a hybrid approach combining a diversity-preserving cluster-based selection with an adaptive knapsack-specific crossover operator that intelligently combines solution segments while ensuring feasibility through dynamic weight adjustment and objective-aware merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate pairwise distances in objective space\n        objectives = np.array([obj for _, obj in archive])\n        distances = np.sum((objectives[:, None, :] - objectives[None, :, :])**2, axis=2)\n        np.fill_diagonal(distances, np.inf)\n        selected_idx = np.argmin(np.min(distances, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive knapsack crossover with segment merging\n    crossover_point = random.randint(1, len(base_solution)-1)\n    partner_idx = random.randint(0, len(archive)-1)\n    partner_solution, _ = archive[partner_idx]\n\n    # Merge segments with dynamic weight adjustment\n    for i in range(crossover_point):\n        if partner_solution[i] == 1 and new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Objective-aware filling\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate normalized objective contributions\n        obj1_contrib = value1_lst / (weight_lst + 1e-10)\n        obj2_contrib = value2_lst / (weight_lst + 1e-10)\n        combined_contrib = obj1_contrib + obj2_contrib\n\n        # Sort by combined contribution\n        sorted_items = np.argsort(-combined_contrib)\n\n        for item in sorted_items:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n                if remaining_capacity <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7398130247004236,
            3.0629152953624725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate pairwise distances in objective space\n        objectives = np.array([obj for _, obj in archive])\n        distances = np.sum((objectives[:, None, :] - objectives[None, :, :])**2, axis=2)\n        np.fill_diagonal(distances, np.inf)\n        selected_idx = np.argmin(np.min(distances, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Adaptive knapsack crossover with segment merging\n    crossover_point = random.randint(1, len(base_solution)-1)\n    partner_idx = random.randint(0, len(archive)-1)\n    partner_solution, _ = archive[partner_idx]\n\n    # Merge segments with dynamic weight adjustment\n    for i in range(crossover_point):\n        if partner_solution[i] == 1 and new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Objective-aware filling\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate normalized objective contributions\n        obj1_contrib = value1_lst / (weight_lst + 1e-10)\n        obj2_contrib = value2_lst / (weight_lst + 1e-10)\n        combined_contrib = obj1_contrib + obj2_contrib\n\n        # Sort by combined contribution\n        sorted_items = np.argsort(-combined_contrib)\n\n        for item in sorted_items:\n            if new_solution[item] == 0 and weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n                if remaining_capacity <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a utility-based selection strategy, where items are prioritized based on their utility scores derived from both objectives and their potential to create diverse solutions, ensuring feasibility while exploring high-quality neighbors through adaptive utility-driven flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate utility scores combining both objectives and diversity potential\n    utility1 = value1_lst / (weight_lst + 1e-10)\n    utility2 = value2_lst / (weight_lst + 1e-10)\n    diversity_scores = np.zeros_like(weight_lst)\n\n    # Compute diversity scores based on solution differences in archive\n    for sol, _ in archive:\n        diversity_scores += np.abs(sol - base_solution)\n\n    combined_utility = utility1 + utility2 + 0.5 * diversity_scores\n    sorted_items = np.argsort(-combined_utility)\n\n    # Adaptive utility-driven perturbation\n    utility_threshold = np.percentile(combined_utility, 75)\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items below utility threshold with higher probability\n            if combined_utility[item] < utility_threshold and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items above utility threshold if feasible\n            if combined_utility[item] >= utility_threshold and current_weight + weight_lst[item] <= capacity:\n                if random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Utility-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves at least one utility\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one utility without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest utility items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8191058083806941,
            5.195401877164841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate utility scores combining both objectives and diversity potential\n    utility1 = value1_lst / (weight_lst + 1e-10)\n    utility2 = value2_lst / (weight_lst + 1e-10)\n    diversity_scores = np.zeros_like(weight_lst)\n\n    # Compute diversity scores based on solution differences in archive\n    for sol, _ in archive:\n        diversity_scores += np.abs(sol - base_solution)\n\n    combined_utility = utility1 + utility2 + 0.5 * diversity_scores\n    sorted_items = np.argsort(-combined_utility)\n\n    # Adaptive utility-driven perturbation\n    utility_threshold = np.percentile(combined_utility, 75)\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items below utility threshold with higher probability\n            if combined_utility[item] < utility_threshold and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items above utility threshold if feasible\n            if combined_utility[item] >= utility_threshold and current_weight + weight_lst[item] <= capacity:\n                if random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Utility-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves at least one utility\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one utility without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest utility items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{The new algorithm combines a dynamic marginal contribution scoring with a probabilistic item replacement strategy, where items are prioritized based on their normalized value ratios for both objectives, and solutions are perturbed by replacing items with high marginal gains while ensuring feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_score = (value1_ratio + value2_ratio) / (np.abs(value1_ratio - value2_ratio) + 1e-10)\n\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic perturbation with replacement\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adjust for feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.43091473898459676,
            1.7820101082324982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_score = (value1_ratio + value2_ratio) / (np.abs(value1_ratio - value2_ratio) + 1e-10)\n\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic perturbation with replacement\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adjust for feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{The novel local search strategy combines a probabilistic cluster-based perturbation with a value-driven expansion, where items are grouped by their correlation to objectives and expanded based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on correlation to objectives\n    corr1 = np.corrcoef(value1_lst, weight_lst)[0, 1]\n    corr2 = np.corrcoef(value2_lst, weight_lst)[0, 1]\n    cluster1 = value1_lst[base_solution == 1]\n    cluster2 = value2_lst[base_solution == 1]\n\n    # Determine expansion direction based on cluster dominance\n    if np.mean(cluster1) > np.mean(cluster2):\n        primary_value = value1_lst\n        secondary_value = value2_lst\n    else:\n        primary_value = value2_lst\n        secondary_value = value1_lst\n\n    # Sort items by primary value (descending) and secondary value (ascending)\n    primary_ratio = primary_value / (weight_lst + 1e-10)\n    secondary_ratio = secondary_value / (weight_lst + 1e-10)\n    combined_score = primary_ratio - 0.5 * secondary_ratio\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform probabilistic cluster-based expansion\n    for item in sorted_items:\n        if base_solution[item] == 0 and random.random() < 0.6:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        elif base_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3407219504988065,
            5.842486262321472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on correlation to objectives\n    corr1 = np.corrcoef(value1_lst, weight_lst)[0, 1]\n    corr2 = np.corrcoef(value2_lst, weight_lst)[0, 1]\n    cluster1 = value1_lst[base_solution == 1]\n    cluster2 = value2_lst[base_solution == 1]\n\n    # Determine expansion direction based on cluster dominance\n    if np.mean(cluster1) > np.mean(cluster2):\n        primary_value = value1_lst\n        secondary_value = value2_lst\n    else:\n        primary_value = value2_lst\n        secondary_value = value1_lst\n\n    # Sort items by primary value (descending) and secondary value (ascending)\n    primary_ratio = primary_value / (weight_lst + 1e-10)\n    secondary_ratio = secondary_value / (weight_lst + 1e-10)\n    combined_score = primary_ratio - 0.5 * secondary_ratio\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform probabilistic cluster-based expansion\n    for item in sorted_items:\n        if base_solution[item] == 0 and random.random() < 0.6:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        elif base_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{The new algorithm employs a hybrid strategy that combines a dynamic item prioritization based on marginal contributions to both objectives with a probabilistic swap mechanism, followed by a greedy refinement step to ensure feasibility and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_priority = marginal_value1 + marginal_value2\n\n    # Probabilistic swap with dynamic prioritization\n    for item in np.argsort(-dynamic_priority):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Greedy refinement step\n    for item in np.argsort(-dynamic_priority):\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in np.argsort(dynamic_priority):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.43944266041038527,
            2.2346125841140747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_priority = marginal_value1 + marginal_value2\n\n    # Probabilistic swap with dynamic prioritization\n    for item in np.argsort(-dynamic_priority):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Greedy refinement step\n    for item in np.argsort(-dynamic_priority):\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in np.argsort(dynamic_priority):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a multi-objective greedy reconstruction, where items are selected based on their contribution to both objectives while maintaining solution diversity through probabilistic exclusion of low-contribution items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware item scores\n    item_scores = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # For included items, score is negative to encourage removal\n            score = - (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n        else:\n            # For excluded items, score is positive to encourage addition\n            score = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n        item_scores.append(score)\n\n    item_scores = np.array(item_scores)\n    sorted_items = np.argsort(-item_scores)  # Highest score first\n\n    # Phase 1: Probabilistic perturbation of low-contribution items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Phase 2: Greedy reconstruction of high-contribution items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Add item if it significantly improves both objectives\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n            if (temp_value1 > current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and random.random() < 0.3) or \\\n               (temp_value2 > current_value2 and random.random() < 0.3):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest-scoring items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.40520369024542097,
            4.819338738918304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware item scores\n    item_scores = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # For included items, score is negative to encourage removal\n            score = - (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n        else:\n            # For excluded items, score is positive to encourage addition\n            score = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n        item_scores.append(score)\n\n    item_scores = np.array(item_scores)\n    sorted_items = np.argsort(-item_scores)  # Highest score first\n\n    # Phase 1: Probabilistic perturbation of low-contribution items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Phase 2: Greedy reconstruction of high-contribution items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Add item if it significantly improves both objectives\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n            if (temp_value1 > current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and random.random() < 0.3) or \\\n               (temp_value2 > current_value2 and random.random() < 0.3):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest-scoring items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{The novel local search strategy employs a hybrid approach that combines a rank-based item selection with a probabilistic swap mechanism, prioritizing items based on their marginal contribution to both objectives while ensuring feasibility through dynamic weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value1_ratio + value2_ratio) / 2\n\n    # Rank items by combined ratio\n    ranked_items = np.argsort(-combined_ratio)\n\n    # Dynamic perturbation: flip top-k items with probability\n    k = min(3, len(ranked_items))\n    for i in range(k):\n        item = ranked_items[i]\n        if random.random() < 0.5:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy addition of high-ratio items\n    for item in ranked_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.4:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        for item in ranked_items:\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4907031257423107,
            11.119214862585068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = (value1_ratio + value2_ratio) / 2\n\n    # Rank items by combined ratio\n    ranked_items = np.argsort(-combined_ratio)\n\n    # Dynamic perturbation: flip top-k items with probability\n    k = min(3, len(ranked_items))\n    for i in range(k):\n        item = ranked_items[i]\n        if random.random() < 0.5:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy addition of high-ratio items\n    for item in ranked_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.4:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and adjustment\n    if current_weight > capacity:\n        for item in ranked_items:\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{The new algorithm uses a hybrid approach combining dominance-based selection with a greedy local search that prioritizes items based on their Pareto-efficient trade-offs, while dynamically adjusting the search intensity using a temperature-based exploration strategy to balance exploitation and exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_potential = -1\n    selected_idx = 0\n    for idx, (sol, _) in enumerate(archive):\n        potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = idx\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate trade-off scores for items\n    tradeoff_scores = (value1_lst / (value2_lst + 1e-10)) * (1 - base_solution)\n    sorted_items = np.argsort(-tradeoff_scores)\n\n    # Temperature-based dynamic search\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low trade-off\n            if random.random() < temperature * (1 - tradeoff_scores[item] / np.max(tradeoff_scores)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items if feasible and promising\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < (1 - temperature) * (tradeoff_scores[item] / np.max(tradeoff_scores)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement step\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8017678280153054,
            7.100468248128891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_potential = -1\n    selected_idx = 0\n    for idx, (sol, _) in enumerate(archive):\n        potential = np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = idx\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate trade-off scores for items\n    tradeoff_scores = (value1_lst / (value2_lst + 1e-10)) * (1 - base_solution)\n    sorted_items = np.argsort(-tradeoff_scores)\n\n    # Temperature-based dynamic search\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low trade-off\n            if random.random() < temperature * (1 - tradeoff_scores[item] / np.max(tradeoff_scores)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items if feasible and promising\n            if current_weight + weight_lst[item] <= capacity:\n                if random.random() < (1 - temperature) * (tradeoff_scores[item] / np.max(tradeoff_scores)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement step\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{The new algorithm employs a dynamic priority-based local search that combines probabilistic item flipping with a value-weighted greedy insertion, where items are prioritized based on their marginal contribution to both objectives, adjusted by their weight sensitivity, to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic priority score combining value and weight sensitivity\n    value1_score = value1_lst / (weight_lst + 1e-10)\n    value2_score = value2_lst / (weight_lst + 1e-10)\n    weight_sensitivity = weight_lst / (current_weight + 1e-10)\n    combined_score = (value1_score + value2_score) * (1 + weight_sensitivity)\n\n    sorted_items = np.argsort(-combined_score)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.25:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.32843603177058517,
            0.654904305934906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic priority score combining value and weight sensitivity\n    value1_score = value1_lst / (weight_lst + 1e-10)\n    value2_score = value2_lst / (weight_lst + 1e-10)\n    weight_sensitivity = weight_lst / (current_weight + 1e-10)\n    combined_score = (value1_score + value2_score) * (1 + weight_sensitivity)\n\n    sorted_items = np.argsort(-combined_score)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.25:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{The novel algorithm combines a cluster-based perturbation with a dominance-aware greedy insertion, where items are grouped by their value ratios and perturbed based on cluster characteristics, followed by a dominance-preserving insertion of critical items to ensure both objectives are improved while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their value ratios\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Cluster-based perturbation: flip items based on their cluster position\n    cluster_size = max(1, len(sorted_items) // 5)\n    for i in range(0, len(sorted_items), cluster_size):\n        cluster = sorted_items[i:i+cluster_size]\n        if len(cluster) == 0:\n            continue\n\n        # Randomly select a cluster and flip its items\n        if random.random() < 0.4:\n            for item in cluster:\n                if base_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                else:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Dominance-aware greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Check if adding the item improves both objectives\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n\n            # If adding improves at least one objective without hurting the other\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest ratio items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3544525420544377,
            2.680452287197113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their value ratios\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Cluster-based perturbation: flip items based on their cluster position\n    cluster_size = max(1, len(sorted_items) // 5)\n    for i in range(0, len(sorted_items), cluster_size):\n        cluster = sorted_items[i:i+cluster_size]\n        if len(cluster) == 0:\n            continue\n\n        # Randomly select a cluster and flip its items\n        if random.random() < 0.4:\n            for item in cluster:\n                if base_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                else:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Dominance-aware greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Check if adding the item improves both objectives\n            temp_value1 = current_value1 + value1_lst[item]\n            temp_value2 = current_value2 + value2_lst[item]\n\n            # If adding improves at least one objective without hurting the other\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest ratio items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The novel algorithm employs a cluster-based perturbation strategy that first partitions items into three clusters based on their weight-to-value ratios for both objectives, then applies cluster-specific perturbations (intensified for low-weight/high-value clusters, balanced for medium clusters, and cautious for high-weight clusters) while maintaining feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate cluster-based metrics\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Cluster items (3 clusters: low, medium, high weight)\n    percentiles = np.percentile(weight_lst, [33, 66])\n    clusters = np.digitize(weight_lst, percentiles)\n\n    # Cluster-specific perturbations\n    for cluster in np.unique(clusters):\n        cluster_items = np.where(clusters == cluster)[0]\n        np.random.shuffle(cluster_items)\n\n        if cluster == 0:  # Low-weight cluster (aggressive)\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        elif cluster == 1:  # Medium-weight cluster (balanced)\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.3:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        else:  # High-weight cluster (conservative)\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.2:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.4:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing highest-weight items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_by_weight = np.argsort(-weight_lst)\n        for item in sorted_by_weight:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4589704144699119,
            3.118856728076935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate cluster-based metrics\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Cluster items (3 clusters: low, medium, high weight)\n    percentiles = np.percentile(weight_lst, [33, 66])\n    clusters = np.digitize(weight_lst, percentiles)\n\n    # Cluster-specific perturbations\n    for cluster in np.unique(clusters):\n        cluster_items = np.where(clusters == cluster)[0]\n        np.random.shuffle(cluster_items)\n\n        if cluster == 0:  # Low-weight cluster (aggressive)\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.4:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        elif cluster == 1:  # Medium-weight cluster (balanced)\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.3:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n        else:  # High-weight cluster (conservative)\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.2:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.4:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing highest-weight items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_by_weight = np.argsort(-weight_lst)\n        for item in sorted_by_weight:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The novel local search strategy combines a value-driven clustering approach with a dynamic item prioritization mechanism, where items are grouped based on their value-to-weight ratios for each objective and then selectively adjusted to balance improvements in both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for each objective\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Cluster items based on their value-to-weight ratios for both objectives\n    cluster1 = np.argsort(-value1_ratio)\n    cluster2 = np.argsort(-value2_ratio)\n\n    # Dynamic prioritization: alternate between clusters based on a probability\n    for i in range(len(weight_lst)):\n        if random.random() < 0.5:\n            item = cluster1[i % len(cluster1)]\n        else:\n            item = cluster2[i % len(cluster2)]\n\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(weight_lst / (value1_lst + value2_lst + 1e-10)):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4098955418041115,
            4.53842768073082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for each objective\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Cluster items based on their value-to-weight ratios for both objectives\n    cluster1 = np.argsort(-value1_ratio)\n    cluster2 = np.argsort(-value2_ratio)\n\n    # Dynamic prioritization: alternate between clusters based on a probability\n    for i in range(len(weight_lst)):\n        if random.random() < 0.5:\n            item = cluster1[i % len(cluster1)]\n        else:\n            item = cluster2[i % len(cluster2)]\n\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(weight_lst / (value1_lst + value2_lst + 1e-10)):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{The new algorithm combines a probabilistic item replacement strategy with a value-weighted random walk to explore high-potential regions of the solution space while maintaining feasibility, using a dynamic selection of items based on their marginal contributions to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform probabilistic replacement\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-contribution items\n            if random.random() < 0.4 and combined_marginal[item] < np.mean(combined_marginal):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistically add high-contribution items\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8034939948650757,
            5.192896097898483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform probabilistic replacement\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-contribution items\n            if random.random() < 0.4 and combined_marginal[item] < np.mean(combined_marginal):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistically add high-contribution items\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{The new algorithm combines a greedy selection of high-margin items with a probabilistic removal of low-contribution items, where items are prioritized based on their individual and combined objective contributions, ensuring feasibility through adaptive weight adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to objective 1 (descending)\n    sorted_items_obj1 = np.argsort(-marginal_value1)\n    # Sort items by marginal contribution to objective 2 (descending)\n    sorted_items_obj2 = np.argsort(-marginal_value2)\n\n    # Greedily add high-margin items for objective 1 if feasible\n    for item in sorted_items_obj1:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Probabilistically remove low-margin items for objective 2\n    for item in sorted_items_obj2:\n        if base_solution[item] == 1 and random.random() < 0.3:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest combined margin\n    if current_weight > capacity:\n        combined_margin = marginal_value1 + marginal_value2\n        sorted_items_combined = np.argsort(combined_margin)\n        excess_weight = current_weight - capacity\n        for item in sorted_items_combined:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7881639876662764,
            3.1917680203914642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for each objective\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution to objective 1 (descending)\n    sorted_items_obj1 = np.argsort(-marginal_value1)\n    # Sort items by marginal contribution to objective 2 (descending)\n    sorted_items_obj2 = np.argsort(-marginal_value2)\n\n    # Greedily add high-margin items for objective 1 if feasible\n    for item in sorted_items_obj1:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Probabilistically remove low-margin items for objective 2\n    for item in sorted_items_obj2:\n        if base_solution[item] == 1 and random.random() < 0.3:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest combined margin\n    if current_weight > capacity:\n        combined_margin = marginal_value1 + marginal_value2\n        sorted_items_combined = np.argsort(combined_margin)\n        excess_weight = current_weight - capacity\n        for item in sorted_items_combined:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm employs a dynamic priority-based perturbation that combines a weighted marginal contribution score with adaptive probability thresholds, allowing for both aggressive exploration of high-potential items and conservative refinement of the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] + obj[1] for (sol, obj) in archive]\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / 2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic probability thresholds based on current solution quality\n    base_prob = 0.5 + 0.5 * (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))\n    add_prob = min(0.9, base_prob + 0.2)\n    remove_prob = max(0.1, base_prob - 0.2)\n\n    # Perform dynamic local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # More aggressively remove items from worse solutions\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # More greedily add items to better solutions\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check and adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5148279674667529,
            2.59507817029953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] + obj[1] for (sol, obj) in archive]\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / 2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic probability thresholds based on current solution quality\n    base_prob = 0.5 + 0.5 * (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))\n    add_prob = min(0.9, base_prob + 0.2)\n    remove_prob = max(0.1, base_prob - 0.2)\n\n    # Perform dynamic local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # More aggressively remove items from worse solutions\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # More greedily add items to better solutions\n            if current_weight + weight_lst[item] <= capacity and random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check and adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This new algorithm employs a hypervolume-inspired scoring mechanism combined with a probabilistic flip strategy, where items are prioritized based on their contribution to the hypervolume improvement, and flips are guided by a dynamic temperature parameter that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_hv = -1\n    selected_idx = 0\n    for i, (sol, (v1, v2)) in enumerate(archive):\n        hv = v1 * v2\n        if hv > max_hv:\n            max_hv = hv\n            selected_idx = i\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate hypervolume-based scores\n    hv_scores = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-hv_scores)\n\n    # Dynamic temperature parameter\n    temp = min(1.0, max(0.1, 0.5 * (1 - max_hv / (np.max(value1_lst) * np.max(value2_lst)))))\n\n    # Probabilistic flip strategy\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temp * (1 - hv_scores[item] / np.max(hv_scores))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temp) * (hv_scores[item] / np.max(hv_scores))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5646355062434506,
            11.14758425951004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_hv = -1\n    selected_idx = 0\n    for i, (sol, (v1, v2)) in enumerate(archive):\n        hv = v1 * v2\n        if hv > max_hv:\n            max_hv = hv\n            selected_idx = i\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate hypervolume-based scores\n    hv_scores = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-hv_scores)\n\n    # Dynamic temperature parameter\n    temp = min(1.0, max(0.1, 0.5 * (1 - max_hv / (np.max(value1_lst) * np.max(value2_lst)))))\n\n    # Probabilistic flip strategy\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temp * (1 - hv_scores[item] / np.max(hv_scores))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temp) * (hv_scores[item] / np.max(hv_scores))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy selection, where items are prioritized based on their normalized contributions to both objectives, while maintaining feasibility through a controlled diversification process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversities = [np.sum(sol[0] != archive[0][0]) for sol in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize objectives and compute combined score\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    combined_score = norm_value1 + norm_value2\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove low-contribution items with probability based on diversity\n            if combined_score[item] < 0.5 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-contribution items with probability based on diversity\n            if current_weight + weight_lst[item] <= capacity and combined_score[item] > 0.5 and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility through controlled removal of least significant items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1 and combined_score[item] < 0.3:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6990114492545534,
            3.7135243117809296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversities = [np.sum(sol[0] != archive[0][0]) for sol in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize objectives and compute combined score\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    combined_score = norm_value1 + norm_value2\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove low-contribution items with probability based on diversity\n            if combined_score[item] < 0.5 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-contribution items with probability based on diversity\n            if current_weight + weight_lst[item] <= capacity and combined_score[item] > 0.5 and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility through controlled removal of least significant items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1 and combined_score[item] < 0.3:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The new algorithm employs a hybrid approach combining a multi-objective greedy insertion strategy with a probabilistic tabu search, where items are prioritized based on their normalized marginal contributions in both objectives, and a tabu list prevents cycling while allowing occasional non-improving moves to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / 2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Tabu list to avoid cycling\n    tabu_list = []\n    tabu_tenure = max(3, len(weight_lst) // 10)\n\n    # Multi-objective greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and item not in tabu_list:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                tabu_list.append(item)\n                if len(tabu_list) > tabu_tenure:\n                    tabu_list.pop(0)\n\n    # Probabilistic tabu search\n    for item in sorted_items:\n        if new_solution[item] == 1 and item not in tabu_list:\n            flip_prob = 0.3 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                tabu_list.append(item)\n                if len(tabu_list) > tabu_tenure:\n                    tabu_list.pop(0)\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8422560338784006,
            5.6572472751140594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / 2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Tabu list to avoid cycling\n    tabu_list = []\n    tabu_tenure = max(3, len(weight_lst) // 10)\n\n    # Multi-objective greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and item not in tabu_list:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                tabu_list.append(item)\n                if len(tabu_list) > tabu_tenure:\n                    tabu_list.pop(0)\n\n    # Probabilistic tabu search\n    for item in sorted_items:\n        if new_solution[item] == 1 and item not in tabu_list:\n            flip_prob = 0.3 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                tabu_list.append(item)\n                if len(tabu_list) > tabu_tenure:\n                    tabu_list.pop(0)\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic perturbation: adjust flip probability based on item's position in sorted list\n    for i, item in enumerate(sorted_items):\n        flip_prob = 0.1 + 0.8 * (1 - i / len(sorted_items))  # Higher probability for top items\n\n        if base_solution[item] == 1:\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedy addition with dynamic threshold\n            if current_weight + weight_lst[item] <= capacity and random.random() < max(0.5, 0.9 * (1 - i / len(sorted_items))):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check with dynamic removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1 and random.random() < 0.6:  # Higher chance to remove\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7244169542534729,
            1.9023391902446747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Dynamic perturbation: adjust flip probability based on item's position in sorted list\n    for i, item in enumerate(sorted_items):\n        flip_prob = 0.1 + 0.8 * (1 - i / len(sorted_items))  # Higher probability for top items\n\n        if base_solution[item] == 1:\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedy addition with dynamic threshold\n            if current_weight + weight_lst[item] <= capacity and random.random() < max(0.5, 0.9 * (1 - i / len(sorted_items))):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check with dynamic removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1 and random.random() < 0.6:  # Higher chance to remove\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This algorithm uses a hybrid approach combining marginal dominance analysis with adaptive item prioritization, where items are evaluated based on their normalized contributions to both objectives, and solutions are refined through a temperature-controlled flip mechanism that balances exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature-based perturbation\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8046951177072168,
            10.202752441167831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature-based perturbation\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{The novel local search strategy employs a dominance-based selection with adaptive item prioritization, where items are evaluated based on their potential to improve both objectives while considering their weight, followed by a probabilistic swap with a greedy addition of high-value items, ensuring feasibility and diversity in the generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance score for each item\n    dominance_score = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n\n    # Sort items by dominance score (descending)\n    sorted_items = np.argsort(-dominance_score)\n\n    # Perform adaptive local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.38508615517389433,
            1.5135975182056427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance score for each item\n    dominance_score = (value1_lst * value2_lst) / (weight_lst + 1e-10)\n\n    # Sort items by dominance score (descending)\n    sorted_items = np.argsort(-dominance_score)\n\n    # Perform adaptive local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{The novel local search strategy employs a dynamic clustering-based approach where items are grouped by similarity in their value-to-weight ratios across objectives, followed by a targeted perturbation that replaces clusters with complementary items from other clusters, ensuring feasibility and balanced improvement across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items by similarity in value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    ratio_diff = np.abs(value1_ratio - value2_ratio)\n    clusters = np.digitize(ratio_diff, bins=[np.percentile(ratio_diff, 33), np.percentile(ratio_diff, 66)])\n\n    # Identify clusters to perturb\n    cluster_counts = np.bincount(clusters, weights=base_solution)\n    target_clusters = np.where(cluster_counts > 0)[0]\n\n    if len(target_clusters) > 0:\n        # Select a cluster to remove\n        remove_cluster = random.choice(target_clusters)\n        items_in_cluster = np.where((clusters == remove_cluster) & (base_solution == 1))[0]\n\n        # Remove items from the selected cluster\n        for item in items_in_cluster:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n        # Add items from other clusters with complementary ratios\n        other_clusters = [c for c in range(3) if c != remove_cluster]\n        if other_clusters:\n            add_cluster = random.choice(other_clusters)\n            candidate_items = np.where((clusters == add_cluster) & (base_solution == 0))[0]\n            np.random.shuffle(candidate_items)\n\n            for item in candidate_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        items_sorted = np.argsort(weight_lst)\n        for item in items_sorted:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3468494103420059,
            3.299914389848709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items by similarity in value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    ratio_diff = np.abs(value1_ratio - value2_ratio)\n    clusters = np.digitize(ratio_diff, bins=[np.percentile(ratio_diff, 33), np.percentile(ratio_diff, 66)])\n\n    # Identify clusters to perturb\n    cluster_counts = np.bincount(clusters, weights=base_solution)\n    target_clusters = np.where(cluster_counts > 0)[0]\n\n    if len(target_clusters) > 0:\n        # Select a cluster to remove\n        remove_cluster = random.choice(target_clusters)\n        items_in_cluster = np.where((clusters == remove_cluster) & (base_solution == 1))[0]\n\n        # Remove items from the selected cluster\n        for item in items_in_cluster:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n        # Add items from other clusters with complementary ratios\n        other_clusters = [c for c in range(3) if c != remove_cluster]\n        if other_clusters:\n            add_cluster = random.choice(other_clusters)\n            candidate_items = np.where((clusters == add_cluster) & (base_solution == 0))[0]\n            np.random.shuffle(candidate_items)\n\n            for item in candidate_items:\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        items_sorted = np.argsort(weight_lst)\n        for item in items_sorted:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This algorithm employs a hybrid approach combining a greedy selection strategy with a simulated annealing-inspired perturbation, where items are prioritized based on their normalized marginal contributions, and temperature-controlled flips are used to explore high-quality neighbors while ensuring feasibility through adaptive dominance checks and weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Greedy selection with temperature-based perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9739637640814027,
            11.001282215118408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Greedy selection with temperature-based perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{The new algorithm uses a dynamic prioritization mechanism that combines value-to-weight ratios with objective-specific weights, followed by a probabilistic flip-and-add strategy to explore high-potential regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization: combine ratios with objective-specific weights\n    obj1_weight = 0.6 if current_value1 < np.mean([v[0] for _, v in archive]) else 0.4\n    obj2_weight = 0.6 if current_value2 < np.mean([v[1] for _, v in archive]) else 0.4\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = obj1_weight * value1_ratio + obj2_weight * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Probabilistic flip-and-add strategy\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.49462601948702045,
            2.3670695424079895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization: combine ratios with objective-specific weights\n    obj1_weight = 0.6 if current_value1 < np.mean([v[0] for _, v in archive]) else 0.4\n    obj2_weight = 0.6 if current_value2 < np.mean([v[1] for _, v in archive]) else 0.4\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = obj1_weight * value1_ratio + obj2_weight * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Probabilistic flip-and-add strategy\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8699186665626205,
            10.651316195726395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{The new algorithm employs a dynamic item prioritization based on a hybrid of marginal contributions and dominance relationships, where items are probabilistically swapped with neighbors that improve at least one objective while ensuring feasibility through a constrained local search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Compute marginal contributions and dominance indicators\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    dominance = (marginal1 > marginal2).astype(int) - (marginal1 < marginal2).astype(int)\n\n    # Sort items by hybrid score (marginal + dominance)\n    hybrid_score = marginal1 + marginal2 + 0.5 * dominance\n    sorted_items = np.argsort(-hybrid_score)\n\n    # Dynamic perturbation: swap items with neighbors\n    for i in range(len(sorted_items) - 1):\n        item1 = sorted_items[i]\n        item2 = sorted_items[i + 1]\n\n        # Probabilistic swap if feasible\n        if base_solution[item1] != base_solution[item2]:\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            if current_weight + delta_weight <= capacity and random.random() < 0.4:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Greedy addition of high-scoring items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.35210098298601744,
            5.935896307229996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Compute marginal contributions and dominance indicators\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    dominance = (marginal1 > marginal2).astype(int) - (marginal1 < marginal2).astype(int)\n\n    # Sort items by hybrid score (marginal + dominance)\n    hybrid_score = marginal1 + marginal2 + 0.5 * dominance\n    sorted_items = np.argsort(-hybrid_score)\n\n    # Dynamic perturbation: swap items with neighbors\n    for i in range(len(sorted_items) - 1):\n        item1 = sorted_items[i]\n        item2 = sorted_items[i + 1]\n\n        # Probabilistic swap if feasible\n        if base_solution[item1] != base_solution[item2]:\n            delta_weight = weight_lst[item2] - weight_lst[item1]\n            if current_weight + delta_weight <= capacity and random.random() < 0.4:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight += delta_weight\n\n    # Greedy addition of high-scoring items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This new algorithm uses a hybrid approach combining a greedy selection of high-value items with a probabilistic removal of low-marginal items, guided by adaptive weights that balance the two objectives, while ensuring feasibility through iterative weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    obj_weight1 = 0.7\n    obj_weight2 = 0.3\n    marginal = (obj_weight1 * value1_lst + obj_weight2 * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-marginal)\n\n    # Greedy addition of high-marginal items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Probabilistic removal of low-marginal items\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            remove_prob = 0.2 * (1 - marginal[item] / np.max(marginal))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9243965612302538,
            5.7434883415699005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    obj_weight1 = 0.7\n    obj_weight2 = 0.3\n    marginal = (obj_weight1 * value1_lst + obj_weight2 * value2_lst) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-marginal)\n\n    # Greedy addition of high-marginal items\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Probabilistic removal of low-marginal items\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            remove_prob = 0.2 * (1 - marginal[item] / np.max(marginal))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.49407645699978514,
            8.52945140004158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The algorithm employs a hybrid strategy combining cluster-based item grouping with adaptive dominance-aware perturbations, where items are partitioned into clusters based on their value-weight ratios, and perturbations are applied within clusters to maintain balance between exploration and exploitation while ensuring feasibility through cluster-wise adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Divide items into 3 clusters\n    cluster_size = len(sorted_items) // 3\n    clusters = [\n        sorted_items[:cluster_size],\n        sorted_items[cluster_size:2*cluster_size],\n        sorted_items[2*cluster_size:]\n    ]\n\n    # Select a cluster to perturb\n    cluster_idx = random.randint(0, 2)\n    selected_cluster = clusters[cluster_idx]\n\n    # Perform cluster-based perturbation\n    for item in selected_cluster:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on cluster position\n            flip_prob = 0.2 + (cluster_idx * 0.1)\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistically add based on cluster position and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 - (cluster_idx * 0.1)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Cluster-wise feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for cluster in clusters:\n            for item in cluster:\n                if new_solution[item] == 1 and excess_weight <= 0:\n                    break\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    excess_weight -= weight_lst[item]\n                    if excess_weight <= 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.4304806598454335,
            0.9369748532772064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Divide items into 3 clusters\n    cluster_size = len(sorted_items) // 3\n    clusters = [\n        sorted_items[:cluster_size],\n        sorted_items[cluster_size:2*cluster_size],\n        sorted_items[2*cluster_size:]\n    ]\n\n    # Select a cluster to perturb\n    cluster_idx = random.randint(0, 2)\n    selected_cluster = clusters[cluster_idx]\n\n    # Perform cluster-based perturbation\n    for item in selected_cluster:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on cluster position\n            flip_prob = 0.2 + (cluster_idx * 0.1)\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistically add based on cluster position and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 - (cluster_idx * 0.1)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Cluster-wise feasibility adjustment\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for cluster in clusters:\n            for item in cluster:\n                if new_solution[item] == 1 and excess_weight <= 0:\n                    break\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    excess_weight -= weight_lst[item]\n                    if excess_weight <= 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{The novel local search strategy combines a probabilistic item removal with a targeted addition of items based on their dominance in both objectives, using a dynamic threshold to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for each item\n    dominance_scores = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n\n    # Sort items by dominance score (descending)\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Dynamic threshold for item selection\n    threshold = 0.5 + 0.2 * (current_weight / capacity)\n\n    # Probabilistic removal of low-score items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Targeted addition of high-score items\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if dominance_scores[item] > threshold and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.39033924668710074,
            2.885523647069931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for each item\n    dominance_scores = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n\n    # Sort items by dominance score (descending)\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Dynamic threshold for item selection\n    threshold = 0.5 + 0.2 * (current_weight / capacity)\n\n    # Probabilistic removal of low-score items\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Targeted addition of high-score items\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if dominance_scores[item] > threshold and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{The novel local search strategy combines a diversity-preserving perturbation with a multi-objective greedy insertion, where items are strategically replaced based on their Pareto dominance and marginal utility, ensuring both exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify Pareto-dominant items (non-dominated in both objectives)\n    dominated = np.zeros(len(weight_lst), dtype=bool)\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            continue\n        is_dominated = False\n        for j in range(len(weight_lst)):\n            if i == j or base_solution[j] == 0:\n                continue\n            if (value1_lst[j] >= value1_lst[i] and value2_lst[j] >= value2_lst[i] and\n                (value1_lst[j] > value1_lst[i] or value2_lst[j] > value2_lst[i])):\n                is_dominated = True\n                break\n        dominated[i] = is_dominated\n\n    # Perform multi-objective greedy insertion\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and not dominated[i]:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Perform diversity-preserving perturbation\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_lst):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9560471911036533,
            10.511112719774246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify Pareto-dominant items (non-dominated in both objectives)\n    dominated = np.zeros(len(weight_lst), dtype=bool)\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            continue\n        is_dominated = False\n        for j in range(len(weight_lst)):\n            if i == j or base_solution[j] == 0:\n                continue\n            if (value1_lst[j] >= value1_lst[i] and value2_lst[j] >= value2_lst[i] and\n                (value1_lst[j] > value1_lst[i] or value2_lst[j] > value2_lst[i])):\n                is_dominated = True\n                break\n        dominated[i] = is_dominated\n\n    # Perform multi-objective greedy insertion\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and not dominated[i]:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Perform diversity-preserving perturbation\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1 and random.random() < 0.2:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_lst):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This new algorithm uses a dynamic weighted marginal contribution scoring system that balances both objectives, combined with a simulated annealing-like acceptance criterion to probabilistically explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic weighted marginal contribution score\n    weight_factor = 0.5  # Balance between objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = weight_factor * value1_ratio + (1 - weight_factor) * value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Simulated annealing-like perturbation\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on score\n            if random.random() < np.exp(-combined_ratio[item] * temperature):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible and score is high\n            if current_weight + weight_lst[item] <= capacity and random.random() < combined_ratio[item] * 0.8:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37449379263423044,
            4.248586714267731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic weighted marginal contribution score\n    weight_factor = 0.5  # Balance between objectives\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = weight_factor * value1_ratio + (1 - weight_factor) * value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Simulated annealing-like perturbation\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on score\n            if random.random() < np.exp(-combined_ratio[item] * temperature):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item if feasible and score is high\n            if current_weight + weight_lst[item] <= capacity and random.random() < combined_ratio[item] * 0.8:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{The novel local search strategy employs a dynamic priority-based selection where items are prioritized based on a weighted combination of their marginal contributions to both objectives, combined with a probabilistic flip mechanism to escape local optima while maintaining feasibility through a greedy removal of least valuable items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic priority score: weighted combination of marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    dynamic_weight = 0.6 if random.random() < 0.5 else 0.4\n    combined_ratio = dynamic_weight * value1_ratio + (1 - dynamic_weight) * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Dynamic flip probability based on solution quality\n    flip_prob = 0.5 if random.random() < 0.5 else 0.3\n\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < flip_prob:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Greedy removal of least valuable items if still over capacity\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4877567830304007,
            1.7606931328773499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic priority score: weighted combination of marginal contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    dynamic_weight = 0.6 if random.random() < 0.5 else 0.4\n    combined_ratio = dynamic_weight * value1_ratio + (1 - dynamic_weight) * value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Dynamic flip probability based on solution quality\n    flip_prob = 0.5 if random.random() < 0.5 else 0.3\n\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < flip_prob:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Greedy removal of least valuable items if still over capacity\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The new algorithm combines a diversity-preserving perturbation with a multi-objective hill-climbing strategy, where items are selected based on their adaptive contribution to both objectives while maintaining solution diversity through controlled randomness and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate adaptive item priorities\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    diversity_score = np.abs(value1_ratio - value2_ratio)  # Measure of diversity in contributions\n    combined_score = (value1_ratio + value2_ratio) * diversity_score\n    sorted_items = np.argsort(-combined_score)\n\n    # Multi-objective hill-climbing with controlled randomness\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove with probability based on diversity and contribution\n            remove_prob = 0.2 * (1 - diversity_score[item] / np.max(diversity_score))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on combined score and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_score[item] / np.max(combined_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        # Remove items with lowest diversity score first\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    # Additional diversity-preserving flip\n    if random.random() < 0.3:\n        # Randomly flip one item to maintain diversity\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            flip_item = random.choice(candidate_items)\n            new_solution[flip_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.975782572622374,
            9.935967564582825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate adaptive item priorities\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    diversity_score = np.abs(value1_ratio - value2_ratio)  # Measure of diversity in contributions\n    combined_score = (value1_ratio + value2_ratio) * diversity_score\n    sorted_items = np.argsort(-combined_score)\n\n    # Multi-objective hill-climbing with controlled randomness\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove with probability based on diversity and contribution\n            remove_prob = 0.2 * (1 - diversity_score[item] / np.max(diversity_score))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on combined score and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.8 * (combined_score[item] / np.max(combined_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        # Remove items with lowest diversity score first\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    # Additional diversity-preserving flip\n    if random.random() < 0.3:\n        # Randomly flip one item to maintain diversity\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            flip_item = random.choice(candidate_items)\n            new_solution[flip_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{The novel local search strategy combines a stochastic cluster-based perturbation with an adaptive greedy selection of items, where items are grouped by their similarity in value-to-weight ratios and processed in clusters to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items by similarity in value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Normalize ratios for clustering\n    norm_ratio = (combined_ratio - np.min(combined_ratio)) / (np.max(combined_ratio) - np.min(combined_ratio) + 1e-10)\n\n    # Cluster items into 3 groups based on normalized ratio\n    cluster_assignments = np.digitize(norm_ratio, bins=[0.33, 0.66])\n\n    # Process clusters in random order\n    cluster_order = np.random.permutation(3)\n\n    for cluster in cluster_order:\n        cluster_items = np.where(cluster_assignments == cluster)[0]\n\n        # Adaptive processing based on cluster\n        if cluster == 0:  # Low ratio cluster\n            # Remove items with probability based on their ratio\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.2 * (1 - norm_ratio[item]):\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n        elif cluster == 1:  # Medium ratio cluster\n            # Flip items with moderate probability\n            for item in cluster_items:\n                if random.random() < 0.5:\n                    if base_solution[item] == 1:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n                    else:\n                        if current_weight + weight_lst[item] <= capacity:\n                            new_solution[item] = 1\n                            current_weight += weight_lst[item]\n\n        else:  # High ratio cluster\n            # Add high-ratio items greedily\n            for item in np.argsort(-combined_ratio[cluster_items]):\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(combined_ratio):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7617859488953225,
            1.737510770559311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items by similarity in value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Normalize ratios for clustering\n    norm_ratio = (combined_ratio - np.min(combined_ratio)) / (np.max(combined_ratio) - np.min(combined_ratio) + 1e-10)\n\n    # Cluster items into 3 groups based on normalized ratio\n    cluster_assignments = np.digitize(norm_ratio, bins=[0.33, 0.66])\n\n    # Process clusters in random order\n    cluster_order = np.random.permutation(3)\n\n    for cluster in cluster_order:\n        cluster_items = np.where(cluster_assignments == cluster)[0]\n\n        # Adaptive processing based on cluster\n        if cluster == 0:  # Low ratio cluster\n            # Remove items with probability based on their ratio\n            for item in cluster_items:\n                if base_solution[item] == 1 and random.random() < 0.2 * (1 - norm_ratio[item]):\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n\n        elif cluster == 1:  # Medium ratio cluster\n            # Flip items with moderate probability\n            for item in cluster_items:\n                if random.random() < 0.5:\n                    if base_solution[item] == 1:\n                        new_solution[item] = 0\n                        current_weight -= weight_lst[item]\n                    else:\n                        if current_weight + weight_lst[item] <= capacity:\n                            new_solution[item] = 1\n                            current_weight += weight_lst[item]\n\n        else:  # High ratio cluster\n            # Add high-ratio items greedily\n            for item in np.argsort(-combined_ratio[cluster_items]):\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(combined_ratio):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{The new algorithm employs a hybrid strategy combining a probabilistic item removal phase with a value-driven addition phase, prioritizing items based on their normalized contributions to both objectives while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values for both objectives\n    max_value1 = np.max(value1_lst) if np.max(value1_lst) != 0 else 1\n    max_value2 = np.max(value2_lst) if np.max(value2_lst) != 0 else 1\n    norm_value1 = value1_lst / max_value1\n    norm_value2 = value2_lst / max_value2\n\n    # Calculate importance score (weighted sum of normalized values)\n    importance_score = 0.6 * norm_value1 + 0.4 * norm_value2\n\n    # Remove low-importance items with probability proportional to their score\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1 and random.random() < (1 - importance_score[i]):\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Sort items by importance score (descending)\n    sorted_items = np.argsort(-importance_score)\n\n    # Add high-importance items greedily if feasible\n    for i in sorted_items:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            if random.random() < 0.8:  # 80% chance to add high-importance item\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility by removing lowest-importance items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.31841092406239885,
            2.5715989470481873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values for both objectives\n    max_value1 = np.max(value1_lst) if np.max(value1_lst) != 0 else 1\n    max_value2 = np.max(value2_lst) if np.max(value2_lst) != 0 else 1\n    norm_value1 = value1_lst / max_value1\n    norm_value2 = value2_lst / max_value2\n\n    # Calculate importance score (weighted sum of normalized values)\n    importance_score = 0.6 * norm_value1 + 0.4 * norm_value2\n\n    # Remove low-importance items with probability proportional to their score\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1 and random.random() < (1 - importance_score[i]):\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Sort items by importance score (descending)\n    sorted_items = np.argsort(-importance_score)\n\n    # Add high-importance items greedily if feasible\n    for i in sorted_items:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            if random.random() < 0.8:  # 80% chance to add high-importance item\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility by removing lowest-importance items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{The new algorithm employs a multi-phase local search combining a diversity-preserving perturbation with a Pareto-frontier-aware item selection, where items are prioritized based on their normalized contributions to both objectives, followed by a feasibility-preserving adjustment through a weighted knapsack relaxation technique.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    norm_value1 = value1_lst / np.sum(value1_lst)\n    norm_value2 = value2_lst / np.sum(value2_lst)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Phase 1: Diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low combined score or randomly\n            if combined_score[item] < 0.3 or random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high combined score if feasible\n            if current_weight + weight_lst[item] <= capacity and combined_score[item] > 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 2: Pareto-frontier-aware adjustment\n    # Calculate Pareto frontier scores\n    pareto_scores = []\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Score based on potential improvement and trade-off\n            score = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n            pareto_scores.append((score, item))\n        else:\n            pareto_scores.append((-np.inf, item))\n\n    # Sort by score and add top items\n    pareto_scores.sort(reverse=True, key=lambda x: x[0])\n    for score, item in pareto_scores:\n        if score == -np.inf:\n            break\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Phase 3: Feasibility-preserving adjustment\n    if current_weight > capacity:\n        # Use weighted knapsack relaxation to find minimal removal\n        items = [(weight_lst[i], value1_lst[i] + value2_lst[i], i) for i in range(len(weight_lst)) if new_solution[i] == 1]\n        items.sort(key=lambda x: x[1]/x[0], reverse=True)\n\n        excess_weight = current_weight - capacity\n        for w, v, i in items:\n            if excess_weight <= 0:\n                break\n            new_solution[i] = 0\n            excess_weight -= w\n\n    return new_solution\n\n",
        "score": [
            -0.3088740717841383,
            5.648394793272018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    norm_value1 = value1_lst / np.sum(value1_lst)\n    norm_value2 = value2_lst / np.sum(value2_lst)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Phase 1: Diversity-preserving perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with low combined score or randomly\n            if combined_score[item] < 0.3 or random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high combined score if feasible\n            if current_weight + weight_lst[item] <= capacity and combined_score[item] > 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 2: Pareto-frontier-aware adjustment\n    # Calculate Pareto frontier scores\n    pareto_scores = []\n    for item in range(len(weight_lst)):\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Score based on potential improvement and trade-off\n            score = (value1_lst[item] + value2_lst[item]) / (weight_lst[item] + 1e-10)\n            pareto_scores.append((score, item))\n        else:\n            pareto_scores.append((-np.inf, item))\n\n    # Sort by score and add top items\n    pareto_scores.sort(reverse=True, key=lambda x: x[0])\n    for score, item in pareto_scores:\n        if score == -np.inf:\n            break\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Phase 3: Feasibility-preserving adjustment\n    if current_weight > capacity:\n        # Use weighted knapsack relaxation to find minimal removal\n        items = [(weight_lst[i], value1_lst[i] + value2_lst[i], i) for i in range(len(weight_lst)) if new_solution[i] == 1]\n        items.sort(key=lambda x: x[1]/x[0], reverse=True)\n\n        excess_weight = current_weight - capacity\n        for w, v, i in items:\n            if excess_weight <= 0:\n                break\n            new_solution[i] = 0\n            excess_weight -= w\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a multi-objective regret-based selection strategy, where items are prioritized based on their potential to improve both objectives while maintaining solution diversity through adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    diversity_factor = np.sum(np.abs(archive[selected_idx][0] - s[0]) for s in archive) / len(archive)\n    regret1 = np.max(value1_lst) - value1_lst\n    regret2 = np.max(value2_lst) - value2_lst\n    combined_regret = regret1 + regret2 + diversity_factor * 0.1 * (weight_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-combined_regret)\n\n    # Multi-objective regret-based perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with high regret and low diversity contribution\n            if random.random() < (combined_regret[item] / np.max(combined_regret)) * 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high regret and feasible weight\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (combined_regret[item] / np.max(combined_regret)) * 0.6\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Solution quality improvement through regret minimization\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removing improves at least one regret without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility with minimal regret impact\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3752342420444177,
            10.63509452342987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity-aware marginal contributions\n    diversity_factor = np.sum(np.abs(archive[selected_idx][0] - s[0]) for s in archive) / len(archive)\n    regret1 = np.max(value1_lst) - value1_lst\n    regret2 = np.max(value2_lst) - value2_lst\n    combined_regret = regret1 + regret2 + diversity_factor * 0.1 * (weight_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-combined_regret)\n\n    # Multi-objective regret-based perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with high regret and low diversity contribution\n            if random.random() < (combined_regret[item] / np.max(combined_regret)) * 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high regret and feasible weight\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (combined_regret[item] / np.max(combined_regret)) * 0.6\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Solution quality improvement through regret minimization\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removing improves at least one regret without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility with minimal regret impact\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4848554373494106,
            3.6882646679878235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{The novel local search strategy combines a dynamic item grouping with a hybrid of value-driven swaps and capacity-aware perturbations, where items are clustered based on their value correlations and then optimized through a probabilistic two-phase process that balances objective improvements while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_values = objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Cluster items based on value correlation\n    corr_matrix = np.corrcoef(np.vstack((value1_lst, value2_lst)))\n    corr_values = corr_matrix[0, 1:]  # Correlation with value1\n    cluster_centers = np.argsort(-corr_values)[:max(3, len(weight_lst)//4)]  # Top correlated items\n\n    # Phase 1: Value-driven swaps within clusters\n    for center in cluster_centers:\n        if base_solution[center] == 1 and random.random() < 0.4:\n            # Try to swap with a similar item (high correlation)\n            similar_items = np.argsort(-corr_matrix[center])\n            for item in similar_items[1:]:  # Skip self\n                if base_solution[item] == 0 and (current_weight - weight_lst[center] + weight_lst[item]) <= capacity:\n                    new_solution[center], new_solution[item] = 0, 1\n                    current_weight = current_weight - weight_lst[center] + weight_lst[item]\n                    break\n\n    # Phase 2: Capacity-aware perturbations\n    if random.random() < 0.6:\n        # Add or remove items based on marginal gains\n        marginal_gain1 = (value1_lst / (weight_lst + 1e-10)) * (1 - base_solution)\n        marginal_gain2 = (value2_lst / (weight_lst + 1e-10)) * (1 - base_solution)\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        for item in np.argsort(-combined_gain):\n            if base_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest value-to-weight ratio\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(value_ratios * new_solution)\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1 and np.sum(weight_lst * new_solution) <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8535306707139317,
            5.556525021791458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_values = objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_values)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Cluster items based on value correlation\n    corr_matrix = np.corrcoef(np.vstack((value1_lst, value2_lst)))\n    corr_values = corr_matrix[0, 1:]  # Correlation with value1\n    cluster_centers = np.argsort(-corr_values)[:max(3, len(weight_lst)//4)]  # Top correlated items\n\n    # Phase 1: Value-driven swaps within clusters\n    for center in cluster_centers:\n        if base_solution[center] == 1 and random.random() < 0.4:\n            # Try to swap with a similar item (high correlation)\n            similar_items = np.argsort(-corr_matrix[center])\n            for item in similar_items[1:]:  # Skip self\n                if base_solution[item] == 0 and (current_weight - weight_lst[center] + weight_lst[item]) <= capacity:\n                    new_solution[center], new_solution[item] = 0, 1\n                    current_weight = current_weight - weight_lst[center] + weight_lst[item]\n                    break\n\n    # Phase 2: Capacity-aware perturbations\n    if random.random() < 0.6:\n        # Add or remove items based on marginal gains\n        marginal_gain1 = (value1_lst / (weight_lst + 1e-10)) * (1 - base_solution)\n        marginal_gain2 = (value2_lst / (weight_lst + 1e-10)) * (1 - base_solution)\n        combined_gain = marginal_gain1 + marginal_gain2\n\n        for item in np.argsort(-combined_gain):\n            if base_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n            elif base_solution[item] == 1 and random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest value-to-weight ratio\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(value_ratios * new_solution)\n        for item in sorted_items[::-1]:\n            if new_solution[item] == 1 and np.sum(weight_lst * new_solution) <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{The new algorithm combines a multi-objective greedy insertion with a diversity-preserving perturbation, where items are iteratively added based on their marginal contribution to both objectives while maintaining solution diversity through controlled random flips, ensuring feasibility and high-quality exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Multi-objective greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.6:  # Probabilistic insertion\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Diversity-preserving perturbation\n    diversity_factor = 0.3\n    for item in sorted_items:\n        if new_solution[item] == 1 and random.random() < diversity_factor:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8259186952784153,
            3.2147550880908966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Multi-objective greedy insertion\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            if random.random() < 0.6:  # Probabilistic insertion\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Diversity-preserving perturbation\n    diversity_factor = 0.3\n    for item in sorted_items:\n        if new_solution[item] == 1 and random.random() < diversity_factor:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy insertion, where items are prioritized based on their normalized contributions to both objectives while maintaining feasibility through adaptive capacity allocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [np.sum(base_solution != archive[i][0]) for i, (base_solution, _) in enumerate(archive)]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and normalize objectives\n    current_weight = np.sum(weight_lst * base_solution)\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    combined_score = norm_value1 + norm_value2\n\n    # Sort items by combined normalized score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform adaptive perturbation and insertion\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with probability based on their contribution\n            contribution = (norm_value1[item] + norm_value2[item]) * weight_lst[item]\n            if random.random() < 0.4 * contribution:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Insert items with probability based on normalized score and remaining capacity\n            available_capacity = capacity - current_weight\n            if available_capacity > 0:\n                insertion_prob = min(0.8 * combined_score[item] * (available_capacity / capacity), 1.0)\n                if random.random() < insertion_prob and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items in order of lowest normalized contribution\n        excess_weight = current_weight - capacity\n        for item in np.argsort(combined_score):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6765774274352228,
            5.873777091503143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [np.sum(base_solution != archive[i][0]) for i, (base_solution, _) in enumerate(archive)]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and normalize objectives\n    current_weight = np.sum(weight_lst * base_solution)\n    max_value1 = np.max(value1_lst)\n    max_value2 = np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    combined_score = norm_value1 + norm_value2\n\n    # Sort items by combined normalized score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform adaptive perturbation and insertion\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with probability based on their contribution\n            contribution = (norm_value1[item] + norm_value2[item]) * weight_lst[item]\n            if random.random() < 0.4 * contribution:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Insert items with probability based on normalized score and remaining capacity\n            available_capacity = capacity - current_weight\n            if available_capacity > 0:\n                insertion_prob = min(0.8 * combined_score[item] * (available_capacity / capacity), 1.0)\n                if random.random() < insertion_prob and current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items in order of lowest normalized contribution\n        excess_weight = current_weight - capacity\n        for item in np.argsort(combined_score):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{The new algorithm employs a multi-phase local search combining adaptive item prioritization with a dominance-aware swap mechanism, where solutions are refined by strategically swapping items based on their Pareto-efficient contributions while maintaining feasibility through dynamic weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized Pareto scores for each item\n    pareto_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        pareto_scores[i] = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n    # Phase 1: Adaptive item prioritization\n    sorted_items = np.argsort(-pareto_scores)\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove based on dominance\n            if random.random() < 0.5 and (current_value1 > value1_lst[item] or current_value2 > value2_lst[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items if feasible and Pareto-efficient\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 2: Dominance-aware swap mechanism\n    for _ in range(3):  # Limited number of swaps\n        swap_candidates = [i for i in range(len(weight_lst))\n                          if (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or\n                          (new_solution[i] == 1)]\n\n        if not swap_candidates:\n            break\n\n        item1 = random.choice(swap_candidates)\n        item2 = random.choice(swap_candidates)\n\n        if new_solution[item1] != new_solution[item2]:\n            # Calculate potential new values\n            temp_weight = current_weight\n            if new_solution[item1] == 1:\n                temp_weight -= weight_lst[item1]\n            else:\n                temp_weight += weight_lst[item1]\n\n            if new_solution[item2] == 1:\n                temp_weight -= weight_lst[item2]\n            else:\n                temp_weight += weight_lst[item2]\n\n            if temp_weight <= capacity:\n                # Accept swap if it improves at least one objective\n                new_value1 = current_value1 - value1_lst[item1] + value1_lst[item2] if new_solution[item1] == 1 else current_value1 + value1_lst[item1] - value1_lst[item2]\n                new_value2 = current_value2 - value2_lst[item1] + value2_lst[item2] if new_solution[item1] == 1 else current_value2 + value2_lst[item1] - value2_lst[item2]\n\n                if (new_value1 > current_value1 or new_value2 > current_value2):\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = temp_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3849383572684274,
            8.225304007530212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized Pareto scores for each item\n    pareto_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        pareto_scores[i] = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n    # Phase 1: Adaptive item prioritization\n    sorted_items = np.argsort(-pareto_scores)\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove based on dominance\n            if random.random() < 0.5 and (current_value1 > value1_lst[item] or current_value2 > value2_lst[item]):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items if feasible and Pareto-efficient\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Phase 2: Dominance-aware swap mechanism\n    for _ in range(3):  # Limited number of swaps\n        swap_candidates = [i for i in range(len(weight_lst))\n                          if (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or\n                          (new_solution[i] == 1)]\n\n        if not swap_candidates:\n            break\n\n        item1 = random.choice(swap_candidates)\n        item2 = random.choice(swap_candidates)\n\n        if new_solution[item1] != new_solution[item2]:\n            # Calculate potential new values\n            temp_weight = current_weight\n            if new_solution[item1] == 1:\n                temp_weight -= weight_lst[item1]\n            else:\n                temp_weight += weight_lst[item1]\n\n            if new_solution[item2] == 1:\n                temp_weight -= weight_lst[item2]\n            else:\n                temp_weight += weight_lst[item2]\n\n            if temp_weight <= capacity:\n                # Accept swap if it improves at least one objective\n                new_value1 = current_value1 - value1_lst[item1] + value1_lst[item2] if new_solution[item1] == 1 else current_value1 + value1_lst[item1] - value1_lst[item2]\n                new_value2 = current_value2 - value2_lst[item1] + value2_lst[item2] if new_solution[item1] == 1 else current_value2 + value2_lst[item1] - value2_lst[item2]\n\n                if (new_value1 > current_value1 or new_value2 > current_value2):\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = temp_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{The new algorithm uses a dynamic threshold-based selection strategy that adaptively adjusts item inclusion probabilities based on their marginal contributions to both objectives, combined with a feasibility-preserving perturbation mechanism to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Dynamic threshold for item selection\n    threshold = np.mean(combined_marginal) * (1 + 0.1 * np.random.randn())\n\n    # Apply dynamic threshold-based selection\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            if combined_marginal[i] < threshold and random.random() < 0.4:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if combined_marginal[i] > threshold and current_weight + weight_lst[i] <= capacity and random.random() < 0.6:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(combined_marginal):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.581726163666748,
            3.171682745218277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Dynamic threshold for item selection\n    threshold = np.mean(combined_marginal) * (1 + 0.1 * np.random.randn())\n\n    # Apply dynamic threshold-based selection\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            if combined_marginal[i] < threshold and random.random() < 0.4:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if combined_marginal[i] > threshold and current_weight + weight_lst[i] <= capacity and random.random() < 0.6:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(combined_marginal):\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{The novel algorithm employs a multi-phase approach combining cluster-based exploration with a dominance-aware perturbation, where solutions are first grouped by their objective contributions, then perturbed using a weighted random walk that prioritizes items with high marginal gains in either objective while maintaining feasibility through adaptive capacity adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s for s, _ in archive]\n    archive_values = np.array([v for _, v in archive])\n    selected_idx = np.argmax(np.sum(archive_values, axis=1))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Cluster items based on their value contributions\n    value1_ratios = value1_lst / (weight_lst + 1e-10)\n    value2_ratios = value2_lst / (weight_lst + 1e-10)\n    cluster1 = np.argsort(-value1_ratios)\n    cluster2 = np.argsort(-value2_ratios)\n\n    # Alternate between clusters to balance objectives\n    for i in range(len(weight_lst)):\n        cluster = cluster1 if i % 2 == 0 else cluster2\n        item = cluster[i % len(cluster)]\n\n        if base_solution[item] == 1:\n            # Flip out with probability based on marginal contribution\n            marginal_contribution = (value1_ratios[item] + value2_ratios[item]) / 2\n            if random.random() < 0.2 * marginal_contribution:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Add with probability based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                marginal_contribution = (value1_ratios[item] + value2_ratios[item]) / 2\n                if random.random() < 0.5 * marginal_contribution:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 += value1_lst[item]\n                    current_value2 += value2_lst[item]\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        sorted_items = np.argsort(-(value1_ratios + value2_ratios))\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5325808680581756,
            6.863606691360474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s for s, _ in archive]\n    archive_values = np.array([v for _, v in archive])\n    selected_idx = np.argmax(np.sum(archive_values, axis=1))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Cluster items based on their value contributions\n    value1_ratios = value1_lst / (weight_lst + 1e-10)\n    value2_ratios = value2_lst / (weight_lst + 1e-10)\n    cluster1 = np.argsort(-value1_ratios)\n    cluster2 = np.argsort(-value2_ratios)\n\n    # Alternate between clusters to balance objectives\n    for i in range(len(weight_lst)):\n        cluster = cluster1 if i % 2 == 0 else cluster2\n        item = cluster[i % len(cluster)]\n\n        if base_solution[item] == 1:\n            # Flip out with probability based on marginal contribution\n            marginal_contribution = (value1_ratios[item] + value2_ratios[item]) / 2\n            if random.random() < 0.2 * marginal_contribution:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Add with probability based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                marginal_contribution = (value1_ratios[item] + value2_ratios[item]) / 2\n                if random.random() < 0.5 * marginal_contribution:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 += value1_lst[item]\n                    current_value2 += value2_lst[item]\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        sorted_items = np.argsort(-(value1_ratios + value2_ratios))\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The new algorithm employs a hybrid local search strategy combining greedy dominance-based selection with adaptive neighborhood exploration, where items are prioritized based on their Pareto-efficient trade-offs while dynamically adjusting exploration depth through a temperature-controlled flip mechanism to balance diversification and intensification.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized dominance scores\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Calculate how much removing this item would hurt both objectives\n            dominance_scores[i] = - (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n        else:\n            # Calculate how much adding this item would help both objectives\n            dominance_scores[i] = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n    # Sort items by dominance score (descending for removal, ascending for addition)\n    sorted_items = np.argsort(dominance_scores)\n\n    # Adaptive neighborhood exploration\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on dominance score and temperature\n            remove_prob = temperature * (1 - np.tanh(dominance_scores[item]))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistic addition if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * np.tanh(dominance_scores[item])\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6239869129721547,
            9.224334388971329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized dominance scores\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Calculate how much removing this item would hurt both objectives\n            dominance_scores[i] = - (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n        else:\n            # Calculate how much adding this item would help both objectives\n            dominance_scores[i] = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n    # Sort items by dominance score (descending for removal, ascending for addition)\n    sorted_items = np.argsort(dominance_scores)\n\n    # Adaptive neighborhood exploration\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on dominance score and temperature\n            remove_prob = temperature * (1 - np.tanh(dominance_scores[item]))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistic addition if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * np.tanh(dominance_scores[item])\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a Pareto-frontier-guided selection strategy, where items are prioritized based on their potential to improve both objectives while maintaining solution diversity through controlled randomness and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - np.mean([x[0] for x in archive], axis=0)))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto frontier contributions\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] > obj[0] and other_obj[1] > obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(obj)\n\n    # Identify items that could improve Pareto frontier\n    potential_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            temp_obj = (current_value1 + value1_lst[i], current_value2 + value2_lst[i])\n            dominates = False\n            for po in pareto_front:\n                if temp_obj[0] >= po[0] and temp_obj[1] >= po[1]:\n                    dominates = True\n                    break\n            if dominates:\n                potential_items.append(i)\n\n    # Apply diversity-aware perturbation\n    if potential_items:\n        selected_item = random.choice(potential_items)\n        new_solution[selected_item] = 1\n        current_weight += weight_lst[selected_item]\n    else:\n        # Randomly flip items to maintain diversity\n        for i in range(len(weight_lst)):\n            if random.random() < 0.2 and base_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure feasibility by removing lowest value items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(value1_lst + value2_lst)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9233692043421131,
            7.077116876840591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = np.sum(np.abs(sol - np.mean([x[0] for x in archive], axis=0)))\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto frontier contributions\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] > obj[0] and other_obj[1] > obj[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(obj)\n\n    # Identify items that could improve Pareto frontier\n    potential_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            temp_obj = (current_value1 + value1_lst[i], current_value2 + value2_lst[i])\n            dominates = False\n            for po in pareto_front:\n                if temp_obj[0] >= po[0] and temp_obj[1] >= po[1]:\n                    dominates = True\n                    break\n            if dominates:\n                potential_items.append(i)\n\n    # Apply diversity-aware perturbation\n    if potential_items:\n        selected_item = random.choice(potential_items)\n        new_solution[selected_item] = 1\n        current_weight += weight_lst[selected_item]\n    else:\n        # Randomly flip items to maintain diversity\n        for i in range(len(weight_lst)):\n            if random.random() < 0.2 and base_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure feasibility by removing lowest value items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(value1_lst + value2_lst)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The new algorithm uses an adaptive greedy-perturbation approach where items are prioritized based on their weighted sum of normalized marginal contributions, with a dynamic flip probability that balances exploration and exploitation through a temperature parameter that decreases over iterations, ensuring feasibility while maintaining high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = 0.6 * marginal1 + 0.4 * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive perturbation with decreasing temperature\n    temperature = max(0.3, 0.5 - 0.1 * (len(archive) / 100))\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement step\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8817607971025996,
            9.399876177310944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = 0.6 * marginal1 + 0.4 * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive perturbation with decreasing temperature\n    temperature = max(0.3, 0.5 - 0.1 * (len(archive) / 100))\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement step\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This new algorithm employs a hybrid approach combining adaptive item prioritization with a dominance-preserving flip strategy, where items are selected based on their Pareto-efficient trade-off and flipped probabilistically while ensuring feasibility through a dynamic capacity adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for each item\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            # Potential addition score\n            if current_weight + weight_lst[i] <= capacity:\n                dominance_scores[i] = value1_lst[i] * value2_lst[i] / (weight_lst[i] + 1e-10)\n        else:\n            # Potential removal score (negative for dominated items)\n            dominance_scores[i] = -(value1_lst[i] * value2_lst[i] / (weight_lst[i] + 1e-10))\n\n    # Sort items by dominance scores (highest first)\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Apply adaptive flips based on dominance scores\n    for item in sorted_items:\n        if dominance_scores[item] > 0:  # Potential addition\n            if random.random() < 0.7:  # Higher probability for high-scoring additions\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        elif dominance_scores[item] < 0:  # Potential removal\n            if random.random() < 0.3:  # Lower probability for removals\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing lowest dominance items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7720919292733717,
            2.9090070128440857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance scores for each item\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0:\n            # Potential addition score\n            if current_weight + weight_lst[i] <= capacity:\n                dominance_scores[i] = value1_lst[i] * value2_lst[i] / (weight_lst[i] + 1e-10)\n        else:\n            # Potential removal score (negative for dominated items)\n            dominance_scores[i] = -(value1_lst[i] * value2_lst[i] / (weight_lst[i] + 1e-10))\n\n    # Sort items by dominance scores (highest first)\n    sorted_items = np.argsort(-dominance_scores)\n\n    # Apply adaptive flips based on dominance scores\n    for item in sorted_items:\n        if dominance_scores[item] > 0:  # Potential addition\n            if random.random() < 0.7:  # Higher probability for high-scoring additions\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n        elif dominance_scores[item] < 0:  # Potential removal\n            if random.random() < 0.3:  # Lower probability for removals\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing lowest dominance items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The new algorithm employs a hybrid approach combining greedy marginal contribution analysis with a probabilistic local search that adaptively balances exploration and exploitation, using a temperature-controlled flip mechanism to generate high-quality feasible neighbors while preserving Pareto dominance properties.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature-based local search\n    temperature = 0.7\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Flip out with probability based on temperature and marginal\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on marginal and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy dominance improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing least valuable items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9073609122163633,
            10.712606877088547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature-based local search\n    temperature = 0.7\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Flip out with probability based on temperature and marginal\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on marginal and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy dominance improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing least valuable items\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5236331969696247,
            2.0371233522892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{The new algorithm employs a regret-based diversification strategy with adaptive item prioritization, where solutions are selected based on their underutilized potential, and neighbors are generated through a hybrid of greedy and random flips, balancing exploration and exploitation while maintaining feasibility through dynamic capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    regrets = []\n    for sol, (v1, v2) in archive:\n        potential1 = np.sum(value1_lst * (1 - sol))\n        potential2 = np.sum(value2_lst * (1 - sol))\n        regrets.append(potential1 + potential2)\n    selected_idx = np.argmax(regrets)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate regret-based scores\n    regret_scores = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Regret for removing item\n            regret = (value1_lst[i] + value2_lst[i]) * 0.7\n        else:\n            # Regret for adding item\n            regret = (value1_lst[i] + value2_lst[i]) * 0.3\n        regret_scores.append(regret)\n    sorted_items = np.argsort(-np.array(regret_scores))\n\n    # Hybrid flip strategy\n    flip_prob = 0.4\n    for item in sorted_items:\n        if random.random() < flip_prob:\n            if base_solution[item] == 1:\n                # Try removing\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Try adding\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_v1 = current_v1 - value1_lst[item]\n            temp_v2 = current_v2 - value2_lst[item]\n\n            # Check if removal improves both objectives\n            if (temp_v1 >= current_v1 and temp_v2 > current_v2) or \\\n               (temp_v1 > current_v1 and temp_v2 >= current_v2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_v1 = temp_v1\n                current_v2 = temp_v2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3282830428798087,
            5.324889361858368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    regrets = []\n    for sol, (v1, v2) in archive:\n        potential1 = np.sum(value1_lst * (1 - sol))\n        potential2 = np.sum(value2_lst * (1 - sol))\n        regrets.append(potential1 + potential2)\n    selected_idx = np.argmax(regrets)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate regret-based scores\n    regret_scores = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Regret for removing item\n            regret = (value1_lst[i] + value2_lst[i]) * 0.7\n        else:\n            # Regret for adding item\n            regret = (value1_lst[i] + value2_lst[i]) * 0.3\n        regret_scores.append(regret)\n    sorted_items = np.argsort(-np.array(regret_scores))\n\n    # Hybrid flip strategy\n    flip_prob = 0.4\n    for item in sorted_items:\n        if random.random() < flip_prob:\n            if base_solution[item] == 1:\n                # Try removing\n                if current_weight - weight_lst[item] >= 0:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Try adding\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Greedy improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_v1 = current_v1 - value1_lst[item]\n            temp_v2 = current_v2 - value2_lst[item]\n\n            # Check if removal improves both objectives\n            if (temp_v1 >= current_v1 and temp_v2 > current_v2) or \\\n               (temp_v1 > current_v1 and temp_v2 >= current_v2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_v1 = temp_v1\n                current_v2 = temp_v2\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The new algorithm combines a dynamic programming-inspired partition with a multi-objective hill-climbing strategy, where solutions are iteratively refined by evaluating and replacing subsets of items based on their Pareto-efficient contributions, while maintaining feasibility through adaptive weight balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient scores\n    pareto_scores = (value1_lst / np.max(value1_lst)) + (value2_lst / np.max(value2_lst))\n    sorted_items = np.argsort(-pareto_scores)\n\n    # Dynamic subset replacement\n    subset_size = max(1, len(sorted_items) // 5)\n    for i in range(subset_size):\n        item = sorted_items[i]\n        if base_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective hill-climbing\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Adaptive weight balancing\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3697164544706113,
            2.5582583844661713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient scores\n    pareto_scores = (value1_lst / np.max(value1_lst)) + (value2_lst / np.max(value2_lst))\n    sorted_items = np.argsort(-pareto_scores)\n\n    # Dynamic subset replacement\n    subset_size = max(1, len(sorted_items) // 5)\n    for i in range(subset_size):\n        item = sorted_items[i]\n        if base_solution[item] == 1:\n            # Try removing the item\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Multi-objective hill-climbing\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Adaptive weight balancing\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{The new algorithm employs a dominance-aware adaptive perturbation strategy that combines item prioritization based on their Pareto-optimal contributions with a temperature-controlled flip mechanism, ensuring feasibility while exploring high-quality neighbors through dynamic objective balancing and feasibility repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic objective balancing\n    balance_factor = random.uniform(0.3, 0.7)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = balance_factor * marginal1 + (1 - balance_factor) * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature control\n    temperature = min(0.7, max(0.3, 0.5 * (1 - current_weight / capacity)))\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-aware feasibility repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8913452260408415,
            9.468893438577652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic objective balancing\n    balance_factor = random.uniform(0.3, 0.7)\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = balance_factor * marginal1 + (1 - balance_factor) * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature control\n    temperature = min(0.7, max(0.3, 0.5 * (1 - current_weight / capacity)))\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-aware feasibility repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{The new algorithm employs a diversity-preserving genetic crossover operator combined with a dominance-aware mutation strategy, where solutions are recombined based on their Pareto-front proximity while mutations are guided by objective-specific item rankings to maintain feasibility and explore high-quality regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        idx1, idx2 = random.sample(range(len(archive)), 2)\n    else:\n        idx1 = idx2 = 0\n\n    parent1, _ = archive[idx1]\n    parent2, _ = archive[idx2]\n    new_solution = np.zeros_like(parent1)\n\n    # Uniform crossover with bias toward higher-value items\n    for i in range(len(parent1)):\n        if parent1[i] == parent2[i]:\n            new_solution[i] = parent1[i]\n        else:\n            # Prefer items with higher combined value\n            if (value1_lst[i] + value2_lst[i]) > (value1_lst[(i+1)%len(parent1)] + value2_lst[(i+1)%len(parent1)]):\n                new_solution[i] = parent1[i]\n            else:\n                new_solution[i] = parent2[i]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dominance-aware mutation: prioritize items that improve at least one objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing if it doesn't dominate in either objective\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n\n            if temp_weight <= capacity:\n                # Check if removing improves at least one objective\n                if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                    if random.random() < 0.5:\n                        new_solution[i] = 0\n                        current_weight = temp_weight\n        else:\n            # Consider adding if feasible and improves at least one objective\n            if current_weight + weight_lst[i] <= capacity:\n                if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                    if random.random() < 0.3:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items with lowest combined value-to-weight ratio\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        excess = current_weight - capacity\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.42200544579413724,
            2.8746600449085236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        idx1, idx2 = random.sample(range(len(archive)), 2)\n    else:\n        idx1 = idx2 = 0\n\n    parent1, _ = archive[idx1]\n    parent2, _ = archive[idx2]\n    new_solution = np.zeros_like(parent1)\n\n    # Uniform crossover with bias toward higher-value items\n    for i in range(len(parent1)):\n        if parent1[i] == parent2[i]:\n            new_solution[i] = parent1[i]\n        else:\n            # Prefer items with higher combined value\n            if (value1_lst[i] + value2_lst[i]) > (value1_lst[(i+1)%len(parent1)] + value2_lst[(i+1)%len(parent1)]):\n                new_solution[i] = parent1[i]\n            else:\n                new_solution[i] = parent2[i]\n\n    # Calculate current weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Dominance-aware mutation: prioritize items that improve at least one objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Consider removing if it doesn't dominate in either objective\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n\n            if temp_weight <= capacity:\n                # Check if removing improves at least one objective\n                if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                    if random.random() < 0.5:\n                        new_solution[i] = 0\n                        current_weight = temp_weight\n        else:\n            # Consider adding if feasible and improves at least one objective\n            if current_weight + weight_lst[i] <= capacity:\n                if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                    if random.random() < 0.3:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        # Remove items with lowest combined value-to-weight ratio\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        excess = current_weight - capacity\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3581300526434186,
            1.381683588027954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{The new algorithm uses a hybrid approach combining a diversity-aware perturbation with a Pareto-frontier guided selection, where items are probabilistically flipped based on their position relative to the current Pareto frontier, while ensuring feasibility through a dynamic capacity adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto frontier bounds\n    pareto_frontier1 = max(obj[1][0] for obj in archive)\n    pareto_frontier2 = max(obj[1][1] for obj in archive)\n\n    # Calculate diversity-aware scores\n    value1_score = (value1_lst / (weight_lst + 1e-10)) * (1 - (current_value1 / (pareto_frontier1 + 1e-10)))\n    value2_score = (value2_lst / (weight_lst + 1e-10)) * (1 - (current_value2 / (pareto_frontier2 + 1e-10)))\n    combined_score = value1_score + value2_score\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic capacity adjustment\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity < 0:\n        excess_weight = -remaining_capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                current_weight -= weight_lst[item]\n        remaining_capacity = capacity - current_weight\n\n    # Hybrid perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic flip based on diversity score\n            flip_prob = 0.4 * (1 - combined_score[item] / (np.max(combined_score) + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add if feasible and beneficial\n            if weight_lst[item] <= remaining_capacity and random.random() < 0.6 * (combined_score[item] / (np.max(combined_score) + 1e-10)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8632301414911889,
            3.6763266921043396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto frontier bounds\n    pareto_frontier1 = max(obj[1][0] for obj in archive)\n    pareto_frontier2 = max(obj[1][1] for obj in archive)\n\n    # Calculate diversity-aware scores\n    value1_score = (value1_lst / (weight_lst + 1e-10)) * (1 - (current_value1 / (pareto_frontier1 + 1e-10)))\n    value2_score = (value2_lst / (weight_lst + 1e-10)) * (1 - (current_value2 / (pareto_frontier2 + 1e-10)))\n    combined_score = value1_score + value2_score\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic capacity adjustment\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity < 0:\n        excess_weight = -remaining_capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                current_weight -= weight_lst[item]\n        remaining_capacity = capacity - current_weight\n\n    # Hybrid perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic flip based on diversity score\n            flip_prob = 0.4 * (1 - combined_score[item] / (np.max(combined_score) + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add if feasible and beneficial\n            if weight_lst[item] <= remaining_capacity and random.random() < 0.6 * (combined_score[item] / (np.max(combined_score) + 1e-10)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                remaining_capacity -= weight_lst[item]\n\n    # Final feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic flip with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:  # Higher probability to flip out items\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3964735395963348,
            1.960161030292511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic flip with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:  # Higher probability to flip out items\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The new algorithm employs a hybrid strategy combining greedy marginal contribution sorting with a dynamic neighborhood exploration that adaptively balances between adding high-margin items and removing low-value items, while maintaining feasibility through capacity-aware perturbations guided by a dominance-aware fitness function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, (current_value1, current_value2) = random.choice(archive)\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate dominance-aware fitness scores\n    fitness1 = value1_lst / (weight_lst + 1e-10)\n    fitness2 = value2_lst / (weight_lst + 1e-10)\n    combined_fitness = fitness1 + fitness2\n    sorted_items = np.argsort(-combined_fitness)\n\n    # Dynamic neighborhood exploration\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Remove low-value items with higher probability\n            removal_prob = (1 - fitness1[item] * fitness2[item]) * 0.7\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-value items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                addition_prob = (fitness1[item] * fitness2[item]) * 0.9\n                if random.random() < addition_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Capacity repair if needed\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.36474250314146994,
            2.763777583837509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, (current_value1, current_value2) = random.choice(archive)\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate dominance-aware fitness scores\n    fitness1 = value1_lst / (weight_lst + 1e-10)\n    fitness2 = value2_lst / (weight_lst + 1e-10)\n    combined_fitness = fitness1 + fitness2\n    sorted_items = np.argsort(-combined_fitness)\n\n    # Dynamic neighborhood exploration\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Remove low-value items with higher probability\n            removal_prob = (1 - fitness1[item] * fitness2[item]) * 0.7\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-value items if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                addition_prob = (fitness1[item] * fitness2[item]) * 0.9\n                if random.random() < addition_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Capacity repair if needed\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{The new algorithm uses an adaptive greedy selection strategy that prioritizes items based on their marginal contribution to one objective while considering feasibility and diversity, with probabilistic item swaps to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    sorted_items_value1 = np.argsort(-value1_ratio)\n    sorted_items_value2 = np.argsort(-value2_ratio)\n\n    objective_selector = random.random()\n\n    if objective_selector < 0.5:\n        sorted_items = sorted_items_value1\n    else:\n        sorted_items = sorted_items_value2\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4192922145431048,
            1.652715116739273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    sorted_items_value1 = np.argsort(-value1_ratio)\n    sorted_items_value2 = np.argsort(-value2_ratio)\n\n    objective_selector = random.random()\n\n    if objective_selector < 0.5:\n        sorted_items = sorted_items_value1\n    else:\n        sorted_items = sorted_items_value2\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3904539595105712,
            1.3700207769870758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The novel algorithm combines a dynamic clustering-based perturbation with a Pareto front approximation strategy, where items are grouped by their objective contributions and explored through adaptive cluster-based flips that prioritize Pareto dominance while maintaining feasibility through capacity-aware adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their objective contributions\n    cluster1 = np.argsort(-value1_lst)\n    cluster2 = np.argsort(-value2_lst)\n\n    # Dynamic cluster-based perturbation\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Flip out based on cluster dominance\n            if i in cluster1[:len(cluster1)//2] and i in cluster2[:len(cluster2)//2]:\n                if random.random() < 0.4:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n        else:\n            # Add based on cluster feasibility and dominance\n            if current_weight + weight_lst[i] <= capacity:\n                if (i in cluster1[:len(cluster1)//2] or i in cluster2[:len(cluster2)//2]) and random.random() < 0.6:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Pareto front approximation for cluster-based selection\n    for i in cluster1:\n        if new_solution[i] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n\n            # Check if removal improves Pareto front\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Capacity adjustment through cluster-based removal\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for i in cluster1:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4044004930725573,
            6.175112813711166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their objective contributions\n    cluster1 = np.argsort(-value1_lst)\n    cluster2 = np.argsort(-value2_lst)\n\n    # Dynamic cluster-based perturbation\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            # Flip out based on cluster dominance\n            if i in cluster1[:len(cluster1)//2] and i in cluster2[:len(cluster2)//2]:\n                if random.random() < 0.4:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n        else:\n            # Add based on cluster feasibility and dominance\n            if current_weight + weight_lst[i] <= capacity:\n                if (i in cluster1[:len(cluster1)//2] or i in cluster2[:len(cluster2)//2]) and random.random() < 0.6:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Pareto front approximation for cluster-based selection\n    for i in cluster1:\n        if new_solution[i] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n\n            # Check if removal improves Pareto front\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Capacity adjustment through cluster-based removal\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for i in cluster1:\n            if new_solution[i] == 1 and excess_weight <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This new algorithm employs a hybrid strategy combining greedy marginal contribution prioritization with a probabilistic acceptance mechanism that balances exploration and exploitation, using adaptive temperature scaling to dynamically adjust flip probabilities while maintaining feasibility through dominance-aware item removals.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature scaling\n    temperature = min(0.8, max(0.2, 0.5 + 0.1 * (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))))\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-aware removal\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9144429871975204,
            7.918809175491333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature scaling\n    temperature = min(0.8, max(0.2, 0.5 + 0.1 * (current_value1 + current_value2) / (np.sum(value1_lst) + np.sum(value2_lst))))\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-aware removal\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{The new algorithm combines a probabilistic multi-objective item clustering with a greedy dominance-based selection strategy, where items are grouped by their value-to-weight ratios and then selectively included based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive cluster-based perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Cluster items into high, medium, low based on combined ratio\n    cluster_thresholds = np.percentile(combined_ratio, [33, 66])\n    clusters = np.digitize(combined_ratio, cluster_thresholds)\n\n    # Process each cluster in order of priority\n    for cluster in [2, 1, 0]:  # High to low priority\n        cluster_items = np.where(clusters == cluster)[0]\n        for item in cluster_items:\n            if base_solution[item] == 1:\n                # Probabilistically flip out based on cluster priority\n                flip_prob = 0.1 * (3 - cluster)\n                if random.random() < flip_prob:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Greedily add if feasible and meets dominance criteria\n                if current_weight + weight_lst[item] <= capacity:\n                    # Check if adding improves at least one objective\n                    temp_value1 = current_value1 + value1_lst[item]\n                    temp_value2 = current_value2 + value2_lst[item]\n\n                    # If adding improves at least one objective\n                    if temp_value1 > current_value1 or temp_value2 > current_value2:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        current_value1 = temp_value1\n                        current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest priority items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for cluster in [0, 1, 2]:  # Low to high priority\n            cluster_items = np.where(clusters == cluster)[0]\n            for item in cluster_items:\n                if new_solution[item] == 1 and excess_weight <= 0:\n                    break\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37787753486390274,
            2.4581085443496704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on value-to-weight ratios\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Cluster items into high, medium, low based on combined ratio\n    cluster_thresholds = np.percentile(combined_ratio, [33, 66])\n    clusters = np.digitize(combined_ratio, cluster_thresholds)\n\n    # Process each cluster in order of priority\n    for cluster in [2, 1, 0]:  # High to low priority\n        cluster_items = np.where(clusters == cluster)[0]\n        for item in cluster_items:\n            if base_solution[item] == 1:\n                # Probabilistically flip out based on cluster priority\n                flip_prob = 0.1 * (3 - cluster)\n                if random.random() < flip_prob:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # Greedily add if feasible and meets dominance criteria\n                if current_weight + weight_lst[item] <= capacity:\n                    # Check if adding improves at least one objective\n                    temp_value1 = current_value1 + value1_lst[item]\n                    temp_value2 = current_value2 + value2_lst[item]\n\n                    # If adding improves at least one objective\n                    if temp_value1 > current_value1 or temp_value2 > current_value2:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                        current_value1 = temp_value1\n                        current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest priority items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for cluster in [0, 1, 2]:  # Low to high priority\n            cluster_items = np.where(clusters == cluster)[0]\n            for item in cluster_items:\n                if new_solution[item] == 1 and excess_weight <= 0:\n                    break\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm combines a genetic algorithm-inspired crossover with a dominance-based mutation strategy, where items are prioritized based on their Pareto-efficient contributions to both objectives, ensuring feasibility through adaptive weight-balancing flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Genetic crossover-inspired perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on marginal contribution and weight balance\n            flip_prob = 0.3 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based mutation\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8483924413167234,
            7.5551106333732605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Genetic crossover-inspired perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on marginal contribution and weight balance\n            flip_prob = 0.3 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based mutation\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm employs a dynamic item prioritization strategy that combines objective-specific marginal gains with a probabilistic neighborhood exploration, where high-impact items are selectively swapped or added while maintaining feasibility through a constrained greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(1 - (v1 / (v1 + v2 + 1e-10))) * (1 - (v2 / (v1 + v2 + 1e-10))) for _, (v1, v2) in archive],\n        k=1\n    )[0]\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal gains with a dynamic weight\n    alpha = random.uniform(0.3, 0.7)\n    combined_marginal = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Sort items by combined marginal gain\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform dynamic neighborhood exploration\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-margin items\n            if random.random() < 0.4 * (1 - combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal gain if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * (combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility through constrained greedy removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8927633446680836,
            7.466459184885025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst)\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[(1 - (v1 / (v1 + v2 + 1e-10))) * (1 - (v2 / (v1 + v2 + 1e-10))) for _, (v1, v2) in archive],\n        k=1\n    )[0]\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal gains for each objective\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal gains with a dynamic weight\n    alpha = random.uniform(0.3, 0.7)\n    combined_marginal = alpha * marginal1 + (1 - alpha) * marginal2\n\n    # Sort items by combined marginal gain\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform dynamic neighborhood exploration\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-margin items\n            if random.random() < 0.4 * (1 - combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal gain if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6 * (combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility through constrained greedy removal\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{The new algorithm uses a dynamic priority-based local search that combines a weighted marginal contribution score with a probabilistic item selection to explore the solution space, ensuring feasibility through adaptive weight adjustments and greedy removal of low-priority items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contribution score\n    weight_factor = 0.5\n    value1_score = (value1_lst / (weight_lst + 1e-10)) * (1 + weight_factor * (value2_lst / (weight_lst + 1e-10)))\n    value2_score = (value2_lst / (weight_lst + 1e-10)) * (1 + weight_factor * (value1_lst / (weight_lst + 1e-10)))\n    combined_score = value1_score + value2_score\n\n    sorted_items = np.argsort(-combined_score)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4678304028782531,
            2.0647093057632446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contribution score\n    weight_factor = 0.5\n    value1_score = (value1_lst / (weight_lst + 1e-10)) * (1 + weight_factor * (value2_lst / (weight_lst + 1e-10)))\n    value2_score = (value2_lst / (weight_lst + 1e-10)) * (1 + weight_factor * (value1_lst / (weight_lst + 1e-10)))\n    combined_score = value1_score + value2_score\n\n    sorted_items = np.argsort(-combined_score)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This new algorithm combines a dominance-based selection with a novel hybrid local search that uses adaptive item swapping and probabilistic flipping, guided by Pareto-efficient value ratios, to explore high-quality neighbors while maintaining feasibility through dynamic capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient value ratios\n    ratio1 = value1_lst / (value2_lst + 1e-10)\n    ratio2 = value2_lst / (value1_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Hybrid local search: adaptive swapping and probabilistic flipping\n    for i in range(len(sorted_items) - 1):\n        item1 = sorted_items[i]\n        item2 = sorted_items[i + 1]\n\n        # Swap items if beneficial for both objectives\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1 and new_solution[item2] == 0:\n                if current_weight - weight_lst[item1] + weight_lst[item2] <= capacity:\n                    if (value1_lst[item2] > value1_lst[item1] and value2_lst[item2] >= value2_lst[item1]) or \\\n                       (value1_lst[item2] >= value1_lst[item1] and value2_lst[item2] > value2_lst[item1]):\n                        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                        current_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n        # Probabilistic flip based on value ratios\n        if new_solution[item1] == 1:\n            flip_prob = 0.3 * (1 - combined_ratio[item1] / np.max(combined_ratio))\n            if random.random() < flip_prob:\n                new_solution[item1] = 0\n                current_weight -= weight_lst[item1]\n\n    # Ensure feasibility by removing lowest ratio items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6459104891198224,
            4.472601413726807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient value ratios\n    ratio1 = value1_lst / (value2_lst + 1e-10)\n    ratio2 = value2_lst / (value1_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Hybrid local search: adaptive swapping and probabilistic flipping\n    for i in range(len(sorted_items) - 1):\n        item1 = sorted_items[i]\n        item2 = sorted_items[i + 1]\n\n        # Swap items if beneficial for both objectives\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1 and new_solution[item2] == 0:\n                if current_weight - weight_lst[item1] + weight_lst[item2] <= capacity:\n                    if (value1_lst[item2] > value1_lst[item1] and value2_lst[item2] >= value2_lst[item1]) or \\\n                       (value1_lst[item2] >= value1_lst[item1] and value2_lst[item2] > value2_lst[item1]):\n                        new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                        current_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n        # Probabilistic flip based on value ratios\n        if new_solution[item1] == 1:\n            flip_prob = 0.3 * (1 - combined_ratio[item1] / np.max(combined_ratio))\n            if random.random() < flip_prob:\n                new_solution[item1] = 0\n                current_weight -= weight_lst[item1]\n\n    # Ensure feasibility by removing lowest ratio items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{The new local search strategy employs a dynamic prioritization of items based on their marginal contributions to each objective, combined with a probabilistic flip mechanism that balances exploration and exploitation, while ensuring feasibility through a greedy weight adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    value1_marginal = value1_lst / (weight_lst + 1e-10)\n    value2_marginal = value2_lst / (weight_lst + 1e-10)\n    dynamic_priority = (value1_marginal + value2_marginal) * (1 + 0.5 * (random.random() - 0.5))\n\n    # Probabilistic flip mechanism\n    for item in np.argsort(-dynamic_priority):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Greedy weight adjustment\n    if current_weight > capacity:\n        for item in np.argsort(dynamic_priority):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.5667295793285809,
            1.7520669400691986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    value1_marginal = value1_lst / (weight_lst + 1e-10)\n    value2_marginal = value2_lst / (weight_lst + 1e-10)\n    dynamic_priority = (value1_marginal + value2_marginal) * (1 + 0.5 * (random.random() - 0.5))\n\n    # Probabilistic flip mechanism\n    for item in np.argsort(-dynamic_priority):\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Greedy weight adjustment\n    if current_weight > capacity:\n        for item in np.argsort(dynamic_priority):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm combines a greedy dominance-based selection with a probabilistic flip mechanism that prioritizes items with high marginal contributions to both objectives, using adaptive probabilities to balance exploration and exploitation while maintaining feasibility through weight-constrained perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 * 0.6 + marginal2 * 0.4\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = 0.3 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility correction\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8640596441240043,
            7.908321529626846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 * 0.6 + marginal2 * 0.4\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = 0.3 * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility correction\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{The novel local search strategy combines a dynamic item prioritization based on Pareto-frontier proximity with a targeted swap-and-add mechanism that selectively improves both objectives through a hybrid of probabilistic and deterministic operations while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value-to-weight ratios\n    value1_norm = value1_lst / (weight_lst + 1e-10)\n    value2_norm = value2_lst / (weight_lst + 1e-10)\n\n    # Dynamic prioritization: combine ratios with solution-specific weights\n    alpha = 0.5 if random.random() < 0.5 else 1.5  # Dynamic weighting factor\n    combined_ratio = alpha * value1_norm + (1 - alpha) * value2_norm\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Targeted swap-and-add mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            # Probabilistic removal of low-contribution items\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Deterministic addition of high-value items\n            if (value1_lst[item] > current_value1 * 0.05) or (value2_lst[item] > current_value2 * 0.05):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and correction\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8891994655353572,
            2.7422102987766266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value-to-weight ratios\n    value1_norm = value1_lst / (weight_lst + 1e-10)\n    value2_norm = value2_lst / (weight_lst + 1e-10)\n\n    # Dynamic prioritization: combine ratios with solution-specific weights\n    alpha = 0.5 if random.random() < 0.5 else 1.5  # Dynamic weighting factor\n    combined_ratio = alpha * value1_norm + (1 - alpha) * value2_norm\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Targeted swap-and-add mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            # Probabilistic removal of low-contribution items\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Deterministic addition of high-value items\n            if (value1_lst[item] > current_value1 * 0.05) or (value2_lst[item] > current_value2 * 0.05):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and correction\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its dominance in objectives\n            if random.random() < 0.3 and (marginal_value1[item] < 0.5 * np.max(marginal_value1) or marginal_value2[item] < 0.5 * np.max(marginal_value2)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible and not already in the solution\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7 and not base_solution[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing least critical items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.49875139328096696,
            2.6270526945590973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its dominance in objectives\n            if random.random() < 0.3 and (marginal_value1[item] < 0.5 * np.max(marginal_value1) or marginal_value2[item] < 0.5 * np.max(marginal_value2)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible and not already in the solution\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7 and not base_solution[item]:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing least critical items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{The novel local search strategy combines a diversity-aware clustering-based perturbation with an adaptive greedy selection of items, where items are prioritized based on their contribution to both objectives while considering the solution's diversity in the archive, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate pairwise distances in the objective space\n        distances = []\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                obj1 = archive[i][1][0] - archive[j][1][0]\n                obj2 = archive[i][1][1] - archive[j][1][1]\n                distances.append(np.sqrt(obj1**2 + obj2**2))\n        avg_distance = np.mean(distances) if distances else 0\n\n        # Select a solution that is not too close to others (diversity-aware)\n        selected_idx = -1\n        max_diversity = -1\n        for i in range(len(archive)):\n            diversity = 0\n            for j in range(len(archive)):\n                if i != j:\n                    obj1 = archive[i][1][0] - archive[j][1][0]\n                    obj2 = archive[i][1][1] - archive[j][1][1]\n                    diversity += np.sqrt(obj1**2 + obj2**2)\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive prioritization: balance between value and weight, considering solution's position in objective space\n    # Prioritize items that improve the most in the objective space where the solution is relatively weak\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Adjust ratios based on the solution's position in the objective space\n    if current_value1 < current_value2:\n        combined_ratio = value1_ratio * 1.5 + value2_ratio * 0.5  # More focus on value1\n    else:\n        combined_ratio = value1_ratio * 0.5 + value2_ratio * 1.5  # More focus on value2\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with adaptive greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its contribution to the solution's weakness\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Adaptive greedy: add items that improve the most in the weaker objective\n            if current_weight + weight_lst[item] <= capacity:\n                if (current_value1 < current_value2 and value1_ratio[item] > value2_ratio[item]) or \\\n                   (current_value1 >= current_value2 and value2_ratio[item] > value1_ratio[item]):\n                    if random.random() < 0.8:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                else:\n                    if random.random() < 0.5:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7313232555611588,
            9.055252254009247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate pairwise distances in the objective space\n        distances = []\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                obj1 = archive[i][1][0] - archive[j][1][0]\n                obj2 = archive[i][1][1] - archive[j][1][1]\n                distances.append(np.sqrt(obj1**2 + obj2**2))\n        avg_distance = np.mean(distances) if distances else 0\n\n        # Select a solution that is not too close to others (diversity-aware)\n        selected_idx = -1\n        max_diversity = -1\n        for i in range(len(archive)):\n            diversity = 0\n            for j in range(len(archive)):\n                if i != j:\n                    obj1 = archive[i][1][0] - archive[j][1][0]\n                    obj2 = archive[i][1][1] - archive[j][1][1]\n                    diversity += np.sqrt(obj1**2 + obj2**2)\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive prioritization: balance between value and weight, considering solution's position in objective space\n    # Prioritize items that improve the most in the objective space where the solution is relatively weak\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Adjust ratios based on the solution's position in the objective space\n    if current_value1 < current_value2:\n        combined_ratio = value1_ratio * 1.5 + value2_ratio * 0.5  # More focus on value1\n    else:\n        combined_ratio = value1_ratio * 0.5 + value2_ratio * 1.5  # More focus on value2\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with adaptive greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item based on its contribution to the solution's weakness\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Adaptive greedy: add items that improve the most in the weaker objective\n            if current_weight + weight_lst[item] <= capacity:\n                if (current_value1 < current_value2 and value1_ratio[item] > value2_ratio[item]) or \\\n                   (current_value1 >= current_value2 and value2_ratio[item] > value1_ratio[item]):\n                    if random.random() < 0.8:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n                else:\n                    if random.random() < 0.5:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The new algorithm employs a diversity-preserving local search that combines adaptive item prioritization with a hybrid of greedy dominance checks and probabilistic flips, ensuring both objective improvements while maintaining feasibility through a dynamic weight adjustment strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic item priorities based on both objectives and current solution\n    diversity_factor = 1.0 - (current_weight / capacity)\n    value1_priority = value1_lst * (1 + diversity_factor) / (weight_lst + 1e-10)\n    value2_priority = value2_lst * (1 + diversity_factor) / (weight_lst + 1e-10)\n    combined_priority = value1_priority + value2_priority\n    sorted_items = np.argsort(-combined_priority)\n\n    # Hybrid local search: dominance-aware flips with probabilistic adjustments\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability based on priority and current diversity\n            flip_prob = 0.5 * (1 - combined_priority[item] / np.max(combined_priority)) + 0.5 * diversity_factor\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on priority and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 * (combined_priority[item] / np.max(combined_priority)) + 0.5 * (1 - current_weight / capacity)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dynamic weight adjustment to maintain feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Greedy dominance check for final improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    return new_solution\n\n",
        "score": [
            -0.8921741977649345,
            10.122310549020767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic item priorities based on both objectives and current solution\n    diversity_factor = 1.0 - (current_weight / capacity)\n    value1_priority = value1_lst * (1 + diversity_factor) / (weight_lst + 1e-10)\n    value2_priority = value2_lst * (1 + diversity_factor) / (weight_lst + 1e-10)\n    combined_priority = value1_priority + value2_priority\n    sorted_items = np.argsort(-combined_priority)\n\n    # Hybrid local search: dominance-aware flips with probabilistic adjustments\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out with probability based on priority and current diversity\n            flip_prob = 0.5 * (1 - combined_priority[item] / np.max(combined_priority)) + 0.5 * diversity_factor\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add with probability based on priority and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.5 * (combined_priority[item] / np.max(combined_priority)) + 0.5 * (1 - current_weight / capacity)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dynamic weight adjustment to maintain feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Greedy dominance check for final improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3136581557903235,
            1.9001019895076752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{The new algorithm employs a diversity-aware local search that combines a Pareto-frontier guided perturbation with a value-weighted clustering strategy, where items are grouped based on their normalized contributions to both objectives and perturbed based on their cluster dominance, ensuring both exploration of high-value regions and maintenance of solution diversity while respecting feasibility constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and calculate diversity scores\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    diversity_score = norm_value1 + norm_value2 - 2 * norm_value1 * norm_value2\n\n    # Cluster items based on diversity score\n    sorted_items = np.argsort(-diversity_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items[:len(sorted_items)//2]:\n        if base_solution[item] == 1:\n            # Remove items with low diversity contribution\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-diversity items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Value-weighted refinement\n    value_weight = (norm_value1 + norm_value2) / 2\n    sorted_by_weight = np.argsort(-value_weight)\n\n    for item in sorted_by_weight:\n        if new_solution[item] == 1:\n            # Remove low-value items\n            if random.random() < 0.3 and current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-value items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.4:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_by_weight:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3883197206253396,
            2.702168732881546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and calculate diversity scores\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    diversity_score = norm_value1 + norm_value2 - 2 * norm_value1 * norm_value2\n\n    # Cluster items based on diversity score\n    sorted_items = np.argsort(-diversity_score)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items[:len(sorted_items)//2]:\n        if base_solution[item] == 1:\n            # Remove items with low diversity contribution\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-diversity items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Value-weighted refinement\n    value_weight = (norm_value1 + norm_value2) / 2\n    sorted_by_weight = np.argsort(-value_weight)\n\n    for item in sorted_by_weight:\n        if new_solution[item] == 1:\n            # Remove low-value items\n            if random.random() < 0.3 and current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add high-value items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.4:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_by_weight:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{The new algorithm uses a hybrid of genetic mutation and adaptive dominance-based local search, where items are flipped probabilistically based on their Pareto-efficient contributions, with feasibility maintained through a capacity-aware mutation strategy that prioritizes high-marginal-value items.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Genetic mutation with adaptive probability\n    mutation_rate = 0.3\n    for item in sorted_items:\n        if random.random() < mutation_rate:\n            if base_solution[item] == 1:\n                # Remove item if it's in the solution\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                # Add item if it fits in the knapsack\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Adaptive local search based on dominance\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.47587999158650074,
            2.882655441761017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Genetic mutation with adaptive probability\n    mutation_rate = 0.3\n    for item in sorted_items:\n        if random.random() < mutation_rate:\n            if base_solution[item] == 1:\n                # Remove item if it's in the solution\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n            else:\n                # Add item if it fits in the knapsack\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Adaptive local search based on dominance\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{The novel local search strategy combines a diversity-aware item selection with a gradient-based marginal contribution analysis to prioritize items that show high potential for multi-objective improvement, while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [np.sum(np.abs(sol[0] - archive[0][0])) for sol in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform gradient-based local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with negative marginal contribution\n            if combined_marginal[item] < 0 and current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with positive marginal contribution if feasible\n            if combined_marginal[item] > 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with adaptive weight adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7734300084651748,
            3.1218771934509277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [np.sum(np.abs(sol[0] - archive[0][0])) for sol in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform gradient-based local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove items with negative marginal contribution\n            if combined_marginal[item] < 0 and current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with positive marginal contribution if feasible\n            if combined_marginal[item] > 0 and current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with adaptive weight adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm implements a neighborhood exploration strategy that combines adaptive item prioritization with a dynamic selection mechanism, where items are evaluated based on their marginal contribution to both objectives, and the selection is influenced by a temperature-based probability to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([v1 + v2 for (s, (v1, v2)) in archive]) / sum(v1 + v2 for (s, (v1, v2)) in archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Temperature-based probability for exploration\n    temperature = max(0.1, 1.0 - (current_value1 + current_value2) / (2 * np.sum(value1_lst + value2_lst)))\n\n    # Adaptive prioritization: combine normalized values and weights\n    normalized_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    normalized_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    normalized_weight = weight_lst / (np.max(weight_lst) + 1e-10)\n    combined_score = (normalized_value1 + normalized_value2) / (1 + normalized_weight)\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic selection: flip items with probability based on temperature\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < temperature:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < (1 - temperature):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8680974955415441,
            2.8590413331985474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([v1 + v2 for (s, (v1, v2)) in archive]) / sum(v1 + v2 for (s, (v1, v2)) in archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Temperature-based probability for exploration\n    temperature = max(0.1, 1.0 - (current_value1 + current_value2) / (2 * np.sum(value1_lst + value2_lst)))\n\n    # Adaptive prioritization: combine normalized values and weights\n    normalized_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    normalized_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    normalized_weight = weight_lst / (np.max(weight_lst) + 1e-10)\n    combined_score = (normalized_value1 + normalized_value2) / (1 + normalized_weight)\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Dynamic selection: flip items with probability based on temperature\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < temperature:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < (1 - temperature):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.6018726537046033,
            1.8645526766777039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    sorted_items = np.argsort(-combined_ratio)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.5:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.5:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The new algorithm employs a hybrid strategy combining greedy marginal contribution analysis with a novelty-based perturbation that prioritizes items with high objective-specific diversity, using a diversity-aware temperature mechanism to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate objective-specific novelty scores\n    novelty1 = value1_lst / (weight_lst + 1e-10)\n    novelty2 = value2_lst / (weight_lst + 1e-10)\n    combined_novelty = novelty1 + novelty2\n    sorted_items = np.argsort(-combined_novelty)\n\n    # Diversity-aware temperature mechanism\n    diversity_temp = 0.7 * (1 - np.mean(base_solution))\n\n    # Novelty-based perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on novelty and diversity\n            remove_prob = diversity_temp * (1 - combined_novelty[item] / np.max(combined_novelty))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistic addition based on novelty and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - diversity_temp) * (combined_novelty[item] / np.max(combined_novelty))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Novelty-based dominance check\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check for novelty improvement\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing least novel items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8276209386935914,
            9.721777319908142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate objective-specific novelty scores\n    novelty1 = value1_lst / (weight_lst + 1e-10)\n    novelty2 = value2_lst / (weight_lst + 1e-10)\n    combined_novelty = novelty1 + novelty2\n    sorted_items = np.argsort(-combined_novelty)\n\n    # Diversity-aware temperature mechanism\n    diversity_temp = 0.7 * (1 - np.mean(base_solution))\n\n    # Novelty-based perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on novelty and diversity\n            remove_prob = diversity_temp * (1 - combined_novelty[item] / np.max(combined_novelty))\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Probabilistic addition based on novelty and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - diversity_temp) * (combined_novelty[item] / np.max(combined_novelty))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Novelty-based dominance check\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check for novelty improvement\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing least novel items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{The new algorithm employs a cluster-based perturbation strategy that first groups items into clusters based on their value-to-weight ratios for both objectives, then selectively flips items within clusters to maintain feasibility while exploring diverse neighborhoods through adaptive cluster-wise perturbations, ensuring high-quality solutions are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Cluster items based on combined ratio\n    sorted_indices = np.argsort(combined_ratio)\n    num_clusters = max(3, len(sorted_indices) // 5)\n    cluster_size = len(sorted_indices) // num_clusters\n    clusters = [sorted_indices[i*cluster_size:(i+1)*cluster_size] for i in range(num_clusters)]\n\n    # Selectively perturb clusters\n    for cluster in clusters:\n        if random.random() < 0.5:  # 50% chance to perturb this cluster\n            cluster_weight = np.sum(weight_lst[cluster] * new_solution[cluster])\n            cluster_value1 = np.sum(value1_lst[cluster] * new_solution[cluster])\n            cluster_value2 = np.sum(value2_lst[cluster] * new_solution[cluster])\n\n            # Try to flip a random item in the cluster\n            flip_candidate = random.choice(cluster)\n            if new_solution[flip_candidate] == 1:\n                new_solution[flip_candidate] = 0\n                cluster_weight -= weight_lst[flip_candidate]\n                cluster_value1 -= value1_lst[flip_candidate]\n                cluster_value2 -= value2_lst[flip_candidate]\n            else:\n                if cluster_weight + weight_lst[flip_candidate] <= capacity:\n                    new_solution[flip_candidate] = 1\n                    cluster_weight += weight_lst[flip_candidate]\n                    cluster_value1 += value1_lst[flip_candidate]\n                    cluster_value2 += value2_lst[flip_candidate]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items from clusters with lowest combined ratio\n        for cluster in reversed(clusters):\n            for item in cluster:\n                if new_solution[item] == 1 and excess <= 0:\n                    break\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    excess -= weight_lst[item]\n                    if excess <= 0:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.4283992481749682,
            4.9597766399383545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Cluster items based on combined ratio\n    sorted_indices = np.argsort(combined_ratio)\n    num_clusters = max(3, len(sorted_indices) // 5)\n    cluster_size = len(sorted_indices) // num_clusters\n    clusters = [sorted_indices[i*cluster_size:(i+1)*cluster_size] for i in range(num_clusters)]\n\n    # Selectively perturb clusters\n    for cluster in clusters:\n        if random.random() < 0.5:  # 50% chance to perturb this cluster\n            cluster_weight = np.sum(weight_lst[cluster] * new_solution[cluster])\n            cluster_value1 = np.sum(value1_lst[cluster] * new_solution[cluster])\n            cluster_value2 = np.sum(value2_lst[cluster] * new_solution[cluster])\n\n            # Try to flip a random item in the cluster\n            flip_candidate = random.choice(cluster)\n            if new_solution[flip_candidate] == 1:\n                new_solution[flip_candidate] = 0\n                cluster_weight -= weight_lst[flip_candidate]\n                cluster_value1 -= value1_lst[flip_candidate]\n                cluster_value2 -= value2_lst[flip_candidate]\n            else:\n                if cluster_weight + weight_lst[flip_candidate] <= capacity:\n                    new_solution[flip_candidate] = 1\n                    cluster_weight += weight_lst[flip_candidate]\n                    cluster_value1 += value1_lst[flip_candidate]\n                    cluster_value2 += value2_lst[flip_candidate]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items from clusters with lowest combined ratio\n        for cluster in reversed(clusters):\n            for item in cluster:\n                if new_solution[item] == 1 and excess <= 0:\n                    break\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    excess -= weight_lst[item]\n                    if excess <= 0:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{The new algorithm uses a hybrid approach combining greedy item prioritization with adaptive temperature-based flips, where items are selected based on a weighted score combining normalized marginal contributions and dominance-based improvements, ensuring feasibility through iterative adjustments and excess weight removal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    alpha = 0.7  # Weight for value1 in score calculation\n    beta = 0.3   # Weight for value2 in score calculation\n    score = alpha * (value1_lst / (weight_lst + 1e-10)) + beta * (value2_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-score)\n\n    # Adaptive temperature-based flips\n    temperature = 0.6\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - score[item] / np.max(score))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (score[item] / np.max(score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest score items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8169544870601951,
            9.511547893285751
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate weighted marginal contributions\n    alpha = 0.7  # Weight for value1 in score calculation\n    beta = 0.3   # Weight for value2 in score calculation\n    score = alpha * (value1_lst / (weight_lst + 1e-10)) + beta * (value2_lst / (weight_lst + 1e-10))\n    sorted_items = np.argsort(-score)\n\n    # Adaptive temperature-based flips\n    temperature = 0.6\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - score[item] / np.max(score))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (score[item] / np.max(score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest score items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{The new algorithm employs a hybrid local search combining dominance-based item prioritization with a temperature-controlled flip mechanism, where items are selected based on their normalized objective contributions and probabilistically flipped to balance exploration and exploitation while maintaining feasibility through adaptive weight adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized objective contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Temperature-controlled flip mechanism\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_score[item] / np.max(combined_score))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_score[item] / np.max(combined_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based local improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.459330399660169,
            6.945935547351837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized objective contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = norm_value1 + norm_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Temperature-controlled flip mechanism\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_score[item] / np.max(combined_score))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_score[item] / np.max(combined_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based local improvement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This algorithm employs a hybrid approach combining cluster-based exploration with adaptive dominance-aware swaps, where items are grouped by their objective contributions and swapped based on their potential to improve both objectives while maintaining feasibility through capacity-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their objective contributions\n    cluster1 = np.argsort(-value1_lst / (weight_lst + 1e-10))\n    cluster2 = np.argsort(-value2_lst / (weight_lst + 1e-10))\n\n    # Perform cluster-based swaps\n    for i in range(len(cluster1)):\n        item1 = cluster1[i]\n        item2 = cluster2[i]\n\n        # Swap if it improves at least one objective and maintains feasibility\n        if new_solution[item1] != new_solution[item2]:\n            temp_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 - value1_lst[item1] + value1_lst[item2]\n                temp_value2 = current_value2 - value2_lst[item1] + value2_lst[item2]\n\n                # Accept if at least one objective improves\n                if (temp_value1 > current_value1 or temp_value2 > current_value2):\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(-(value1_lst + value2_lst) / (weight_lst + 1e-10)):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.46192451417586344,
            3.352999746799469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items based on their objective contributions\n    cluster1 = np.argsort(-value1_lst / (weight_lst + 1e-10))\n    cluster2 = np.argsort(-value2_lst / (weight_lst + 1e-10))\n\n    # Perform cluster-based swaps\n    for i in range(len(cluster1)):\n        item1 = cluster1[i]\n        item2 = cluster2[i]\n\n        # Swap if it improves at least one objective and maintains feasibility\n        if new_solution[item1] != new_solution[item2]:\n            temp_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 - value1_lst[item1] + value1_lst[item2]\n                temp_value2 = current_value2 - value2_lst[item1] + value2_lst[item2]\n\n                # Accept if at least one objective improves\n                if (temp_value1 > current_value1 or temp_value2 > current_value2):\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in np.argsort(-(value1_lst + value2_lst) / (weight_lst + 1e-10)):\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{The novel local search strategy combines a Pareto-optimality-aware item clustering with a dynamic objective-weighted knapsack insertion, where items are grouped based on their dominance relationship and inserted in a way that balances both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores (simplified for this example)\n        dominance_scores = np.array([sum(archive[i][1]) for i in range(len(archive))])\n        selected_idx = np.random.choice(len(archive), p=dominance_scores/sum(dominance_scores))\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items into Pareto-optimal groups\n    item_indices = np.arange(len(weight_lst))\n    np.random.shuffle(item_indices)\n    clusters = []\n    current_cluster = []\n\n    for item in item_indices:\n        if base_solution[item] == 1:\n            current_cluster.append(item)\n        else:\n            if current_cluster:\n                clusters.append(current_cluster)\n                current_cluster = []\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Dynamic objective-weighted insertion\n    for cluster in clusters:\n        # Randomly select an objective to prioritize\n        if random.random() < 0.5:\n            # Prioritize value1\n            cluster_sorted = sorted(cluster, key=lambda x: -value1_lst[x] / (weight_lst[x] + 1e-10))\n        else:\n            # Prioritize value2\n            cluster_sorted = sorted(cluster, key=lambda x: -value2_lst[x] / (weight_lst[x] + 1e-10))\n\n        # Try to insert items in the cluster\n        for item in cluster_sorted:\n            if new_solution[item] == 1:\n                if random.random() < 0.2:  # Small chance to remove\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:  # Higher chance to add\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest value density until feasible\n        value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-value_density)\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8582502926897356,
            2.360303431749344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores (simplified for this example)\n        dominance_scores = np.array([sum(archive[i][1]) for i in range(len(archive))])\n        selected_idx = np.random.choice(len(archive), p=dominance_scores/sum(dominance_scores))\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Cluster items into Pareto-optimal groups\n    item_indices = np.arange(len(weight_lst))\n    np.random.shuffle(item_indices)\n    clusters = []\n    current_cluster = []\n\n    for item in item_indices:\n        if base_solution[item] == 1:\n            current_cluster.append(item)\n        else:\n            if current_cluster:\n                clusters.append(current_cluster)\n                current_cluster = []\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Dynamic objective-weighted insertion\n    for cluster in clusters:\n        # Randomly select an objective to prioritize\n        if random.random() < 0.5:\n            # Prioritize value1\n            cluster_sorted = sorted(cluster, key=lambda x: -value1_lst[x] / (weight_lst[x] + 1e-10))\n        else:\n            # Prioritize value2\n            cluster_sorted = sorted(cluster, key=lambda x: -value2_lst[x] / (weight_lst[x] + 1e-10))\n\n        # Try to insert items in the cluster\n        for item in cluster_sorted:\n            if new_solution[item] == 1:\n                if random.random() < 0.2:  # Small chance to remove\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:  # Higher chance to add\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest value density until feasible\n        value_density = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(-value_density)\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{The new algorithm employs a hybrid strategy combining lexicographic ordering with adaptive weight normalization to prioritize items based on their combined objective contributions, followed by a temperature-controlled flip mechanism that balances exploration and exploitation while ensuring feasibility through dominance-based refinement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Lexicographic ordering with adaptive weights\n    alpha = 0.7\n    normalized_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    normalized_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = alpha * normalized_value1 + (1 - alpha) * normalized_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Temperature-controlled flip mechanism\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_score[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * combined_score[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3968907719793469,
            3.800004154443741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Lexicographic ordering with adaptive weights\n    alpha = 0.7\n    normalized_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    normalized_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    combined_score = alpha * normalized_value1 + (1 - alpha) * normalized_value2\n    sorted_items = np.argsort(-combined_score)\n\n    # Temperature-controlled flip mechanism\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_score[item])\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * combined_score[item]\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility check\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.49470845585540946,
            1.7490972876548767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined marginal until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The novel local search strategy uses a weighted marginal contribution score to prioritize items for flipping, combining both objectives with adaptive weights, while ensuring feasibility through a greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate weighted marginal contribution scores\n    weight1 = 0.6\n    weight2 = 0.4\n    marginal_score = (value1_lst * weight1 + value2_lst * weight2) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-marginal_score)\n\n    # Flip items based on marginal score with probability\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4854970642822274,
            1.8386104106903076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate weighted marginal contribution scores\n    weight1 = 0.6\n    weight2 = 0.4\n    marginal_score = (value1_lst * weight1 + value2_lst * weight2) / (weight_lst + 1e-10)\n    sorted_items = np.argsort(-marginal_score)\n\n    # Flip items based on marginal score with probability\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{The new algorithm uses a hybrid approach combining diversity-preserving swaps and objective-aware item prioritization to generate high-quality neighbors by probabilistically flipping items based on their marginal contribution to both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions with diversity factor\n    diversity_factor = 1 / (np.sum(base_solution) + 1e-10)\n    combined_score = (marginal1 + marginal2) * diversity_factor\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform hybrid local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out items with lower score\n            if random.random() < 0.4 and combined_score[item] < np.median(combined_score):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high score if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.35166099175698895,
            10.319006770849228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine marginal contributions with diversity factor\n    diversity_factor = 1 / (np.sum(base_solution) + 1e-10)\n    combined_score = (marginal1 + marginal2) * diversity_factor\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform hybrid local search\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out items with lower score\n            if random.random() < 0.4 and combined_score[item] < np.median(combined_score):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high score if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This new algorithm employs a dominance-aware greedy insertion with adaptive temperature-based exploration, where items are prioritized based on their Pareto-optimal contributions while dynamically adjusting flip probabilities to balance exploitation and exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance-aware scores\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            temp_value1 = current_value1 + value1_lst[i]\n            temp_value2 = current_value2 + value2_lst[i]\n            # Check if adding this item would dominate any existing solution in the archive\n            dominates = True\n            for _, (v1, v2) in archive:\n                if (v1 >= temp_value1 and v2 > temp_value2) or (v1 > temp_value1 and v2 >= temp_value2):\n                    dominates = False\n                    break\n            dominance_scores[i] = dominates * (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n    # Adaptive temperature-based selection\n    temperature = max(0.1, 0.9 ** (len(archive) / 10))\n    sorted_items = np.argsort(-dominance_scores)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and dominance\n            flip_prob = temperature * (1 - dominance_scores[item] / (np.max(dominance_scores) + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on dominance and feasibility\n            if current_weight + weight_lst[item] <= capacity and dominance_scores[item] > 0:\n                add_prob = (1 - temperature) * (dominance_scores[item] / (np.max(dominance_scores) + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8490454541712866,
            4.565793991088867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance-aware scores\n    dominance_scores = np.zeros(len(weight_lst))\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            temp_value1 = current_value1 + value1_lst[i]\n            temp_value2 = current_value2 + value2_lst[i]\n            # Check if adding this item would dominate any existing solution in the archive\n            dominates = True\n            for _, (v1, v2) in archive:\n                if (v1 >= temp_value1 and v2 > temp_value2) or (v1 > temp_value1 and v2 >= temp_value2):\n                    dominates = False\n                    break\n            dominance_scores[i] = dominates * (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-10)\n\n    # Adaptive temperature-based selection\n    temperature = max(0.1, 0.9 ** (len(archive) / 10))\n    sorted_items = np.argsort(-dominance_scores)\n\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and dominance\n            flip_prob = temperature * (1 - dominance_scores[item] / (np.max(dominance_scores) + 1e-10))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on dominance and feasibility\n            if current_weight + weight_lst[item] <= capacity and dominance_scores[item] > 0:\n                add_prob = (1 - temperature) * (dominance_scores[item] / (np.max(dominance_scores) + 1e-10))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The novel local search strategy combines a diversity-aware probabilistic perturbation with a multi-objective greedy selection, where items are prioritized based on their non-dominated contribution to both objectives, ensuring feasibility while fostering exploration of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate non-dominated contribution scores\n    value1_scores = value1_lst / (weight_lst + 1e-10)\n    value2_scores = value2_lst / (weight_lst + 1e-10)\n    combined_scores = (value1_scores + value2_scores) / 2  # Simple average for diversity\n\n    # Sort items by combined scores (descending)\n    sorted_items = np.argsort(-combined_scores)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove with higher chance for lower-scoring items\n            removal_prob = 0.1 + 0.4 * (1 - combined_scores[item] / (combined_scores.max() + 1e-10))\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with higher chance for high-scoring items\n            addition_prob = 0.5 * (combined_scores[item] / (combined_scores.max() + 1e-10))\n            if current_weight + weight_lst[item] <= capacity and random.random() < addition_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        # Remove lowest-scoring items first\n        for item in sorted_items:\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Additional diversification: flip a small number of random bits\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if random.random() < 0.3:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            elif new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9380797630050144,
            6.913666993379593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate non-dominated contribution scores\n    value1_scores = value1_lst / (weight_lst + 1e-10)\n    value2_scores = value2_lst / (weight_lst + 1e-10)\n    combined_scores = (value1_scores + value2_scores) / 2  # Simple average for diversity\n\n    # Sort items by combined scores (descending)\n    sorted_items = np.argsort(-combined_scores)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove with higher chance for lower-scoring items\n            removal_prob = 0.1 + 0.4 * (1 - combined_scores[item] / (combined_scores.max() + 1e-10))\n            if random.random() < removal_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with higher chance for high-scoring items\n            addition_prob = 0.5 * (combined_scores[item] / (combined_scores.max() + 1e-10))\n            if current_weight + weight_lst[item] <= capacity and random.random() < addition_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Feasibility check and repair\n    if current_weight > capacity:\n        # Remove lowest-scoring items first\n        for item in sorted_items:\n            if new_solution[item] == 1 and current_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Additional diversification: flip a small number of random bits\n    flip_indices = np.random.choice(len(new_solution), size=min(2, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if random.random() < 0.3:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            elif new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{The new algorithm employs a diversity-aware local search that combines a random walk with a gradient-based selection of items, where items are prioritized based on their marginal contribution to both objectives, while ensuring feasibility through a dynamic adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a random solution, but with higher probability for solutions with lower diversity\n        diversity_scores = np.array([np.sum(sol[0] != archive[0][0]) for sol in archive])\n        selected_idx = np.random.choice(len(archive), p=diversity_scores / np.sum(diversity_scores))\n    else:\n        selected_idx = 0\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a dynamic local search: random walk with gradient-based selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Randomly flip out items with a bias toward lower marginal contribution\n            if random.random() < 0.2 * (1 - combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with a bias toward higher marginal contribution\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8 * (combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a dynamic adjustment\n    if current_weight > capacity:\n        # Remove items with the lowest marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8392539866117739,
            9.374429732561111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select a random solution, but with higher probability for solutions with lower diversity\n        diversity_scores = np.array([np.sum(sol[0] != archive[0][0]) for sol in archive])\n        selected_idx = np.random.choice(len(archive), p=diversity_scores / np.sum(diversity_scores))\n    else:\n        selected_idx = 0\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a dynamic local search: random walk with gradient-based selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Randomly flip out items with a bias toward lower marginal contribution\n            if random.random() < 0.2 * (1 - combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with a bias toward higher marginal contribution\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8 * (combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a dynamic adjustment\n    if current_weight > capacity:\n        # Remove items with the lowest marginal contribution until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a Pareto-frontier guided item selection, where solutions are prioritized based on their potential to explore underrepresented regions of the objective space while maintaining feasibility through adaptive weight balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity metrics\n    if len(archive) > 1:\n        distances = np.linalg.norm(objectives - objectives[selected_idx], axis=1)\n        diversity_rank = np.argsort(-distances)\n        selected_idx = diversity_rank[0]\n\n    # Identify items on the Pareto frontier\n    pareto_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            temp_solution = base_solution.copy()\n            temp_solution[i] = 0\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n\n            # Check if removing this item makes the solution non-dominated by any other\n            is_pareto = True\n            for (sol, (v1, v2)) in archive:\n                if (v1 >= temp_value1 and v2 >= temp_value2) and (v1 > temp_value1 or v2 > temp_value2):\n                    is_pareto = False\n                    break\n            if is_pareto:\n                pareto_items.append(i)\n\n    # Adaptive weight balancing perturbation\n    alpha = 0.6  # Weight balancing factor\n    for i in range(len(weight_lst)):\n        if i in pareto_items:\n            # More likely to keep Pareto items\n            if random.random() < 0.8:\n                continue\n        else:\n            # Consider adding non-Pareto items with probability based on balanced value\n            balanced_value = alpha * value1_lst[i] + (1 - alpha) * value2_lst[i]\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                if random.random() < balanced_value / np.max(alpha * value1_lst + (1 - alpha) * value2_lst):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n            elif base_solution[i] == 1 and random.random() < 0.3:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with lowest balanced value until feasible\n        sorted_items = np.argsort(alpha * value1_lst + (1 - alpha) * value2_lst)\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.34305221833998684,
            6.869518429040909
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate diversity metrics\n    if len(archive) > 1:\n        distances = np.linalg.norm(objectives - objectives[selected_idx], axis=1)\n        diversity_rank = np.argsort(-distances)\n        selected_idx = diversity_rank[0]\n\n    # Identify items on the Pareto frontier\n    pareto_items = []\n    for i in range(len(weight_lst)):\n        if base_solution[i] == 1:\n            temp_solution = base_solution.copy()\n            temp_solution[i] = 0\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n\n            # Check if removing this item makes the solution non-dominated by any other\n            is_pareto = True\n            for (sol, (v1, v2)) in archive:\n                if (v1 >= temp_value1 and v2 >= temp_value2) and (v1 > temp_value1 or v2 > temp_value2):\n                    is_pareto = False\n                    break\n            if is_pareto:\n                pareto_items.append(i)\n\n    # Adaptive weight balancing perturbation\n    alpha = 0.6  # Weight balancing factor\n    for i in range(len(weight_lst)):\n        if i in pareto_items:\n            # More likely to keep Pareto items\n            if random.random() < 0.8:\n                continue\n        else:\n            # Consider adding non-Pareto items with probability based on balanced value\n            balanced_value = alpha * value1_lst[i] + (1 - alpha) * value2_lst[i]\n            if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                if random.random() < balanced_value / np.max(alpha * value1_lst + (1 - alpha) * value2_lst):\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n            elif base_solution[i] == 1 and random.random() < 0.3:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        # Remove items with lowest balanced value until feasible\n        sorted_items = np.argsort(alpha * value1_lst + (1 - alpha) * value2_lst)\n        for i in sorted_items:\n            if new_solution[i] == 1 and excess <= 0:\n                break\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{The new algorithm employs a dynamic item prioritization scheme that combines objective-specific value-to-weight ratios with a probabilistic flip mechanism, followed by a greedy repair phase to ensure feasibility, creating a balance between exploration and exploitation for enhanced multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective ratios\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Dynamic prioritization: alternate between objectives\n    if random.random() < 0.5:\n        prioritized_items = np.argsort(-value1_ratio)\n    else:\n        prioritized_items = np.argsort(-value2_ratio)\n\n    # Flip items with low contribution to the prioritized objective\n    for item in prioritized_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedily add items not in the solution if feasible\n    for item in prioritized_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest ratio items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in prioritized_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.49606663861191774,
            2.4622082114219666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objective ratios\n    current_weight = np.sum(weight_lst * base_solution)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n    # Dynamic prioritization: alternate between objectives\n    if random.random() < 0.5:\n        prioritized_items = np.argsort(-value1_ratio)\n    else:\n        prioritized_items = np.argsort(-value2_ratio)\n\n    # Flip items with low contribution to the prioritized objective\n    for item in prioritized_items:\n        if base_solution[item] == 1 and random.random() < 0.4:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Greedily add items not in the solution if feasible\n    for item in prioritized_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing lowest ratio items if needed\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in prioritized_items:\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm uses a dynamic weight adjustment mechanism to prioritize items based on their marginal contributions to both objectives, with a probabilistic flip mechanism to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic weight adjustment for marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_weight = 0.5 * marginal_value1 + 0.5 * marginal_value2\n    sorted_items = np.argsort(-dynamic_weight)\n\n    # Probabilistic flip mechanism with dynamic thresholds\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:  # Lower probability to remove items\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:  # Higher probability to add items\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37895446515824244,
            2.5741339921951294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic weight adjustment for marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    dynamic_weight = 0.5 * marginal_value1 + 0.5 * marginal_value2\n    sorted_items = np.argsort(-dynamic_weight)\n\n    # Probabilistic flip mechanism with dynamic thresholds\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.2:  # Lower probability to remove items\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8:  # Higher probability to add items\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{The new algorithm employs a cluster-based perturbation strategy that first groups items into three clusters based on their weight and marginal contributions to both objectives, then applies cluster-specific perturbations to explore high-quality neighbors by selectively flipping items within clusters while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Cluster items based on weight and marginal contributions\n    light_items = np.where((weight_lst <= capacity * 0.3) & (combined_marginal >= np.percentile(combined_marginal, 75)))[0]\n    medium_items = np.where((weight_lst > capacity * 0.3) & (weight_lst <= capacity * 0.6) & (combined_marginal >= np.percentile(combined_marginal, 50)))[0]\n    heavy_items = np.where(weight_lst > capacity * 0.6)[0]\n\n    # Apply cluster-specific perturbations\n    for cluster in [light_items, medium_items, heavy_items]:\n        if len(cluster) == 0:\n            continue\n        cluster_solution = new_solution[cluster]\n        cluster_weight = np.sum(weight_lst[cluster] * cluster_solution)\n        cluster_capacity = capacity if cluster is heavy_items else capacity * 0.5\n\n        # Flip items in the cluster with probability based on cluster type\n        for item in cluster:\n            if cluster is light_items:\n                flip_prob = 0.4 if new_solution[item] == 1 else 0.6\n            elif cluster is medium_items:\n                flip_prob = 0.3 if new_solution[item] == 1 else 0.5\n            else:  # heavy_items\n                flip_prob = 0.2 if new_solution[item] == 1 else 0.3\n\n            if random.random() < flip_prob:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                else:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing excess items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(-combined_marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.42019409208120284,
            4.161169677972794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n\n    # Cluster items based on weight and marginal contributions\n    light_items = np.where((weight_lst <= capacity * 0.3) & (combined_marginal >= np.percentile(combined_marginal, 75)))[0]\n    medium_items = np.where((weight_lst > capacity * 0.3) & (weight_lst <= capacity * 0.6) & (combined_marginal >= np.percentile(combined_marginal, 50)))[0]\n    heavy_items = np.where(weight_lst > capacity * 0.6)[0]\n\n    # Apply cluster-specific perturbations\n    for cluster in [light_items, medium_items, heavy_items]:\n        if len(cluster) == 0:\n            continue\n        cluster_solution = new_solution[cluster]\n        cluster_weight = np.sum(weight_lst[cluster] * cluster_solution)\n        cluster_capacity = capacity if cluster is heavy_items else capacity * 0.5\n\n        # Flip items in the cluster with probability based on cluster type\n        for item in cluster:\n            if cluster is light_items:\n                flip_prob = 0.4 if new_solution[item] == 1 else 0.6\n            elif cluster is medium_items:\n                flip_prob = 0.3 if new_solution[item] == 1 else 0.5\n            else:  # heavy_items\n                flip_prob = 0.2 if new_solution[item] == 1 else 0.3\n\n            if random.random() < flip_prob:\n                if new_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n                else:\n                    if current_weight + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_weight += weight_lst[item]\n\n    # Ensure feasibility by removing excess items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        sorted_items = np.argsort(-combined_marginal)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The new algorithm employs a hybrid approach combining a greedy dominance-aware selection with a probabilistic local search that adaptively balances exploration and exploitation by prioritizing items with high marginal contributions to both objectives while maintaining feasibility through temperature-controlled perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions with different weights for objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature-based perturbation\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection with different criteria\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 >= current_value2) and \\\n               (temp_value1 > current_value1 or temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility check with different approach\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8756471652296892,
            9.492368519306183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions with different weights for objectives\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = 0.7 * marginal1 + 0.3 * marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive temperature-based perturbation\n    temperature = 0.3\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection with different criteria\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 >= current_value1 and temp_value2 >= current_value2) and \\\n               (temp_value1 > current_value1 or temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility check with different approach\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{The new algorithm combines a hybrid evolutionary-inspired perturbation with a Pareto-frontier guided selection strategy, where items are prioritized based on their adaptive trade-off contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through a dynamic combination of marginal gains and dominance-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate adaptive trade-off contributions\n    tradeoff = (value1_lst / (value2_lst + 1e-10)) * (weight_lst + 1e-10)\n    sorted_items = np.argsort(-tradeoff)\n\n    # Hybrid perturbation strategy\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on trade-off and weight\n            remove_prob = 0.3 * (tradeoff[item] / np.max(tradeoff)) + 0.7 * (weight_lst[item] / capacity)\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Conditional addition based on trade-off and capacity\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (tradeoff[item] / np.max(tradeoff)) + 0.3 * (1 - weight_lst[item] / capacity)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Pareto-frontier guided selection\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal moves towards Pareto frontier\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Greedy feasibility repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3069022919858829,
            8.504471868276596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate adaptive trade-off contributions\n    tradeoff = (value1_lst / (value2_lst + 1e-10)) * (weight_lst + 1e-10)\n    sorted_items = np.argsort(-tradeoff)\n\n    # Hybrid perturbation strategy\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistic removal based on trade-off and weight\n            remove_prob = 0.3 * (tradeoff[item] / np.max(tradeoff)) + 0.7 * (weight_lst[item] / capacity)\n            if random.random() < remove_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Conditional addition based on trade-off and capacity\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (tradeoff[item] / np.max(tradeoff)) + 0.3 * (1 - weight_lst[item] / capacity)\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Pareto-frontier guided selection\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # Check if removal moves towards Pareto frontier\n            if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n               (temp_value1 >= current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Greedy feasibility repair\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{The new algorithm combines a Pareto-frontier-guided perturbation with a value-balancing heuristic, where items are selected based on their proximity to the Pareto frontier and their balanced contribution to both objectives, ensuring feasibility through a dynamic weight adjustment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    value_balance = np.abs(norm_value1 - norm_value2)\n\n    # Sort items by value balance (ascending) to prioritize balanced items\n    sorted_items = np.argsort(value_balance)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on value balance\n            flip_prob = 0.5 * value_balance[item]\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on value balance and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (1 - value_balance[item])\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dynamic weight adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest value balance (most balanced)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Final check and adjustment\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still infeasible, remove random items until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3642475528658818,
            2.1080128848552704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized value contributions\n    norm_value1 = value1_lst / (np.max(value1_lst) + 1e-10)\n    norm_value2 = value2_lst / (np.max(value2_lst) + 1e-10)\n    value_balance = np.abs(norm_value1 - norm_value2)\n\n    # Sort items by value balance (ascending) to prioritize balanced items\n    sorted_items = np.argsort(value_balance)\n\n    # Pareto-frontier guided perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on value balance\n            flip_prob = 0.5 * value_balance[item]\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on value balance and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = 0.7 * (1 - value_balance[item])\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dynamic weight adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with lowest value balance (most balanced)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Final check and adjustment\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still infeasible, remove random items until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            item_to_remove = random.choice(items_in)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy insertion, where items are prioritized based on their Pareto-efficient contributions and the solution's current diversity in the archive, ensuring both exploration and exploitation of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for (sol, obj) in archive])\n        objectives = objectives / (np.max(objectives, axis=0) + 1e-10)  # Normalize\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Select solution with minimum crowding (most isolated)\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item with probability inversely proportional to its contribution\n            contrib = combined_ratio[item]\n            if random.random() < (1 - contrib / (np.max(combined_ratio) + 1e-10)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item with probability proportional to its contribution\n            if current_weight + weight_lst[item] <= capacity:\n                contrib = combined_ratio[item]\n                if random.random() < (contrib / (np.max(combined_ratio) + 1e-10)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9466304697440313,
            9.873591631650925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution in the archive\n        objectives = np.array([obj for (sol, obj) in archive])\n        objectives = objectives / (np.max(objectives, axis=0) + 1e-10)  # Normalize\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Select solution with minimum crowding (most isolated)\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient contributions\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform diversity-aware perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Remove item with probability inversely proportional to its contribution\n            contrib = combined_ratio[item]\n            if random.random() < (1 - contrib / (np.max(combined_ratio) + 1e-10)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add item with probability proportional to its contribution\n            if current_weight + weight_lst[item] <= capacity:\n                contrib = combined_ratio[item]\n                if random.random() < (contrib / (np.max(combined_ratio) + 1e-10)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{The new algorithm combines a diversity-driven perturbation with a multi-objective greedy selection strategy, where items are prioritized based on their normalized marginal contributions to both objectives, while maintaining feasibility through adaptive weight balancing and probabilistic item inclusion/exclusion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / 2  # Balanced approach\n\n    # Diversity-driven perturbation\n    diversity_factor = 0.3\n    for i in range(len(base_solution)):\n        if random.random() < diversity_factor:\n            if base_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Multi-objective greedy selection\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Probabilistic addition based on marginal contribution\n            add_prob = combined_marginal[item] / np.max(combined_marginal)\n            if random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive weight balancing\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        temp_weight = np.sum(weight_lst * new_solution)\n        for item in sorted_items:\n            if new_solution[item] == 1 and temp_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                temp_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3860160810756971,
            3.999766618013382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = (marginal1 + marginal2) / 2  # Balanced approach\n\n    # Diversity-driven perturbation\n    diversity_factor = 0.3\n    for i in range(len(base_solution)):\n        if random.random() < diversity_factor:\n            if base_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            elif current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Multi-objective greedy selection\n    sorted_items = np.argsort(-combined_marginal)\n    for item in sorted_items:\n        if new_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Probabilistic addition based on marginal contribution\n            add_prob = combined_marginal[item] / np.max(combined_marginal)\n            if random.random() < add_prob:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Adaptive weight balancing\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    # Final feasibility check\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items with lowest marginal contribution until feasible\n        temp_weight = np.sum(weight_lst * new_solution)\n        for item in sorted_items:\n            if new_solution[item] == 1 and temp_weight <= capacity:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                temp_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm employs a hybrid approach combining greedy marginal contribution prioritization with a dominance-aware simulated annealing process, where items are adaptively flipped based on their Pareto-efficient trade-offs and feasibility constraints, while maintaining solution quality through iterative dominance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance-aware marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 * 0.6 + marginal2 * 0.4  # Weighted combination\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive flip strategy\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # More aggressive removal for items with low marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal)) ** 2\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal)) ** 1.5\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item strictly improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing items with lowest marginal ratio\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8210798967987729,
            9.869972974061966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dominance-aware marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 * 0.6 + marginal2 * 0.4  # Weighted combination\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Adaptive flip strategy\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # More aggressive removal for items with low marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal)) ** 2\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items with high marginal contribution if feasible\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal)) ** 1.5\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item strictly improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            if (temp_value1 > current_value1 and temp_value2 > current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing items with lowest marginal ratio\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm employs a hybrid local search combining a value-weighted random perturbation with a dominance-based greedy selection, where items are prioritized based on their normalized marginal contributions to both objectives, ensuring feasibility while maximizing solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    value1_norm = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    value2_norm = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_score = value1_norm + value2_norm\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform hybrid local search: dominance-based greedy selection with random perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-scoring items\n            if combined_score[item] < 0.5 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-scoring items if feasible and dominant\n            if current_weight + weight_lst[item] <= capacity:\n                if (value1_lst[item] > np.mean(value1_lst[base_solution == 1]) and\n                    value2_lst[item] > np.mean(value2_lst[base_solution == 1])):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal adjustments\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4058025239105738,
            4.932323902845383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions for both objectives\n    value1_norm = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n    value2_norm = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n    combined_score = value1_norm + value2_norm\n\n    # Sort items by combined score (descending)\n    sorted_items = np.argsort(-combined_score)\n\n    # Perform hybrid local search: dominance-based greedy selection with random perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically remove low-scoring items\n            if combined_score[item] < 0.5 and random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-scoring items if feasible and dominant\n            if current_weight + weight_lst[item] <= capacity:\n                if (value1_lst[item] > np.mean(value1_lst[base_solution == 1]) and\n                    value2_lst[item] > np.mean(value2_lst[base_solution == 1])):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Ensure feasibility with minimal adjustments\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{The new algorithm combines a diversity-aware perturbation with a non-dominated sorting-based local search, where solutions are modified by strategically flipping items based on their Pareto-frontier contributions while maintaining feasibility through adaptive weight balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n    weight_norm = weight_lst / (capacity + 1e-10)\n\n    # Sort items by diversity-aware metric\n    diversity_metric = (value1_norm + value2_norm) / (weight_norm + 1e-10)\n    sorted_items = np.argsort(-diversity_metric)\n\n    # Perform non-dominated sorting-based perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out items that are not on the Pareto frontier\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that would improve the Pareto frontier\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item would create a non-dominated solution\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                # Check dominance with all archive solutions\n                is_non_dominated = True\n                for _, (other_value1, other_value2) in archive:\n                    if (other_value1 >= temp_value1 and other_value2 > temp_value2) or \\\n                       (other_value1 > temp_value1 and other_value2 >= temp_value2):\n                        is_non_dominated = False\n                        break\n\n                if is_non_dominated and random.random() < 0.6:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest diversity items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.42648242685007054,
            2.872836321592331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized contributions\n    value1_norm = value1_lst / (np.sum(value1_lst) + 1e-10)\n    value2_norm = value2_lst / (np.sum(value2_lst) + 1e-10)\n    weight_norm = weight_lst / (capacity + 1e-10)\n\n    # Sort items by diversity-aware metric\n    diversity_metric = (value1_norm + value2_norm) / (weight_norm + 1e-10)\n    sorted_items = np.argsort(-diversity_metric)\n\n    # Perform non-dominated sorting-based perturbation\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out items that are not on the Pareto frontier\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add items that would improve the Pareto frontier\n            if current_weight + weight_lst[item] <= capacity:\n                # Check if adding this item would create a non-dominated solution\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = current_value1 + value1_lst[item]\n                temp_value2 = current_value2 + value2_lst[item]\n\n                # Check dominance with all archive solutions\n                is_non_dominated = True\n                for _, (other_value1, other_value2) in archive:\n                    if (other_value1 >= temp_value1 and other_value2 > temp_value2) or \\\n                       (other_value1 > temp_value1 and other_value2 >= temp_value2):\n                        is_non_dominated = False\n                        break\n\n                if is_non_dominated and random.random() < 0.6:\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest diversity items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search with adaptive probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Adaptive probability to remove low-contribution items\n            if random.random() < 0.2 * (1 - combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Adaptive probability to add high-contribution items\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8 * (combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different approach\n    if current_weight > capacity:\n        # Remove items in reverse order until feasible\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8226628824162161,
            7.2359868586063385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal contribution (descending)\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Perform a hybrid local search with adaptive probabilities\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Adaptive probability to remove low-contribution items\n            if random.random() < 0.2 * (1 - combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Adaptive probability to add high-contribution items\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.8 * (combined_marginal[item] / np.max(combined_marginal)):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility with a different approach\n    if current_weight > capacity:\n        # Remove items in reverse order until feasible\n        for item in reversed(sorted_items):\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This new algorithm employs a dynamic threshold-based selection mechanism that adaptively prioritizes items based on their normalized contributions to both objectives, followed by a constrained perturbation phase that either swaps or flips items probabilistically while maintaining feasibility through a greedy adjustment step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and compute dynamic thresholds\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    threshold1 = np.percentile(norm_value1, 75)\n    threshold2 = np.percentile(norm_value2, 75)\n\n    # Identify candidate items based on dynamic thresholds\n    candidates = []\n    for i in range(len(weight_lst)):\n        if (norm_value1[i] >= threshold1 or norm_value2[i] >= threshold2) and base_solution[i] == 1:\n            candidates.append(i)\n\n    # Perform constrained perturbation\n    if candidates:\n        # Swap or flip with probability based on normalized contributions\n        for i in candidates:\n            if random.random() < 0.5 * (norm_value1[i] + norm_value2[i]):\n                if new_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Greedy adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_lst):\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8429845526592403,
            2.806202530860901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Normalize values and compute dynamic thresholds\n    max_value1, max_value2 = np.max(value1_lst), np.max(value2_lst)\n    norm_value1 = value1_lst / (max_value1 + 1e-10)\n    norm_value2 = value2_lst / (max_value2 + 1e-10)\n    threshold1 = np.percentile(norm_value1, 75)\n    threshold2 = np.percentile(norm_value2, 75)\n\n    # Identify candidate items based on dynamic thresholds\n    candidates = []\n    for i in range(len(weight_lst)):\n        if (norm_value1[i] >= threshold1 or norm_value2[i] >= threshold2) and base_solution[i] == 1:\n            candidates.append(i)\n\n    # Perform constrained perturbation\n    if candidates:\n        # Swap or flip with probability based on normalized contributions\n        for i in candidates:\n            if random.random() < 0.5 * (norm_value1[i] + norm_value2[i]):\n                if new_solution[i] == 1:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Greedy adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for i in np.argsort(weight_lst):\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                excess -= weight_lst[i]\n                if excess <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The new algorithm employs a dynamic priority-based selection that combines marginal gains for both objectives with adaptive flipping probabilities, ensuring diverse exploration while maintaining feasibility through a weighted greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic priority scoring: weighted sum of normalized marginal gains\n    value1_marginal = value1_lst / (weight_lst + 1e-10)\n    value2_marginal = value2_lst / (weight_lst + 1e-10)\n    alpha = random.uniform(0.3, 0.7)\n    dynamic_score = alpha * value1_marginal + (1 - alpha) * value2_marginal\n    sorted_items = np.argsort(-dynamic_score)\n\n    # Adaptive flipping with probability based on score rank\n    for i, item in enumerate(sorted_items):\n        flip_prob = 0.5 * (1 - i / len(sorted_items))  # Higher probability for top-ranked items\n        if base_solution[item] == 1 and random.random() < flip_prob:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.6:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Weighted greedy adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                weight_contribution = weight_lst[item] * (dynamic_score[item] / (np.sum(dynamic_score) + 1e-10))\n                if excess >= weight_contribution:\n                    new_solution[item] = 0\n                    excess -= weight_contribution\n\n    return new_solution\n\n",
        "score": [
            -0.42580663206045816,
            2.411705732345581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic priority scoring: weighted sum of normalized marginal gains\n    value1_marginal = value1_lst / (weight_lst + 1e-10)\n    value2_marginal = value2_lst / (weight_lst + 1e-10)\n    alpha = random.uniform(0.3, 0.7)\n    dynamic_score = alpha * value1_marginal + (1 - alpha) * value2_marginal\n    sorted_items = np.argsort(-dynamic_score)\n\n    # Adaptive flipping with probability based on score rank\n    for i, item in enumerate(sorted_items):\n        flip_prob = 0.5 * (1 - i / len(sorted_items))  # Higher probability for top-ranked items\n        if base_solution[item] == 1 and random.random() < flip_prob:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n        elif base_solution[item] == 0 and random.random() < 0.6:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Weighted greedy adjustment to ensure feasibility\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                weight_contribution = weight_lst[item] * (dynamic_score[item] / (np.sum(dynamic_score) + 1e-10))\n                if excess >= weight_contribution:\n                    new_solution[item] = 0\n                    excess -= weight_contribution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This novel local search strategy combines a dynamic value-weighted clustering approach with a probabilistic item reallocation mechanism, where items are grouped based on their combined objective contributions and reallocated to optimize both objectives while ensuring feasibility through adaptive capacity adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic value weights based on current solution\n    value_weights = (value1_lst * (1 - base_solution) + value2_lst * (1 - base_solution)) / (weight_lst + 1e-10)\n\n    # Cluster items into high and low value groups\n    median_value = np.median(value_weights)\n    high_value_items = np.where(value_weights > median_value)[0]\n    low_value_items = np.where(value_weights <= median_value)[0]\n\n    # Perform dynamic reallocation\n    for item in high_value_items:\n        if base_solution[item] == 0 and random.random() < 0.4:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    for item in low_value_items:\n        if base_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Adaptive capacity adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        sorted_items = np.argsort(value_weights)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8718321154562774,
            1.9042481780052185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate dynamic value weights based on current solution\n    value_weights = (value1_lst * (1 - base_solution) + value2_lst * (1 - base_solution)) / (weight_lst + 1e-10)\n\n    # Cluster items into high and low value groups\n    median_value = np.median(value_weights)\n    high_value_items = np.where(value_weights > median_value)[0]\n    low_value_items = np.where(value_weights <= median_value)[0]\n\n    # Perform dynamic reallocation\n    for item in high_value_items:\n        if base_solution[item] == 0 and random.random() < 0.4:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    for item in low_value_items:\n        if base_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Adaptive capacity adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        sorted_items = np.argsort(value_weights)\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n"
    }
]