[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The new algorithm employs a hybrid local search combining Pareto-dominance aware item flips with a probabilistic selection mechanism, where items are prioritized based on their normalized contributions to both objectives, and feasibility is maintained through temperature-controlled perturbations and dominance-based refinement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized scores with different parameters\n    score1 = (value1_lst ** 0.7) / (weight_lst ** 0.3)\n    score2 = (value2_lst ** 0.3) / (weight_lst ** 0.7)\n    combined_score = score1 + score2\n    sorted_items = np.argsort(-combined_score)\n\n    # Probabilistic selection with temperature control\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Higher probability to flip based on score and temperature\n            flip_prob = temperature * (1 - combined_score[item] / np.max(combined_score))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Higher probability to add based on score and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_score[item] / np.max(combined_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement with different thresholds\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # More aggressive dominance check\n            if (temp_value1 >= current_value1 * 0.98 and temp_value2 > current_value2 * 1.02) or \\\n               (temp_value1 > current_value1 * 1.02 and temp_value2 >= current_value2 * 0.98):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair with different strategy\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8292799341072276,
            9.336060017347336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized scores with different parameters\n    score1 = (value1_lst ** 0.7) / (weight_lst ** 0.3)\n    score2 = (value2_lst ** 0.3) / (weight_lst ** 0.7)\n    combined_score = score1 + score2\n    sorted_items = np.argsort(-combined_score)\n\n    # Probabilistic selection with temperature control\n    temperature = 0.7\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Higher probability to flip based on score and temperature\n            flip_prob = temperature * (1 - combined_score[item] / np.max(combined_score))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Higher probability to add based on score and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_score[item] / np.max(combined_score))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based refinement with different thresholds\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # More aggressive dominance check\n            if (temp_value1 >= current_value1 * 0.98 and temp_value2 > current_value2 * 1.02) or \\\n               (temp_value1 > current_value1 * 1.02 and temp_value2 >= current_value2 * 0.98):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Feasibility repair with different strategy\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n                if excess_weight <= 0:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The new algorithm uses an adaptive weight-based prioritization combined with a biased random walk to explore the solution space, where items are selected based on a dynamically adjusted score that balances both objectives while ensuring feasibility through a controlled perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive weight-based prioritization\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n    alpha = 0.5 * (total_value1 / (total_value1 + total_value2 + 1e-10)) if (total_value1 + total_value2) > 0 else 0.5\n    score = alpha * (value1_lst / (weight_lst + 1e-10)) + (1 - alpha) * (value2_lst / (weight_lst + 1e-10))\n\n    # Sort items by score (descending)\n    sorted_items = np.argsort(-score)\n\n    # Biased random walk with controlled perturbations\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on score\n            if random.random() < (0.2 + 0.3 * (1 - score[item] / (np.max(score) + 1e-10))):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-score items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < (0.5 + 0.5 * (score[item] / (np.max(score) + 1e-10))):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4138340719195247,
            6.342355459928513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Adaptive weight-based prioritization\n    total_value1 = np.sum(value1_lst * base_solution)\n    total_value2 = np.sum(value2_lst * base_solution)\n    alpha = 0.5 * (total_value1 / (total_value1 + total_value2 + 1e-10)) if (total_value1 + total_value2) > 0 else 0.5\n    score = alpha * (value1_lst / (weight_lst + 1e-10)) + (1 - alpha) * (value2_lst / (weight_lst + 1e-10))\n\n    # Sort items by score (descending)\n    sorted_items = np.argsort(-score)\n\n    # Biased random walk with controlled perturbations\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out based on score\n            if random.random() < (0.2 + 0.3 * (1 - score[item] / (np.max(score) + 1e-10))):\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-score items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < (0.5 + 0.5 * (score[item] / (np.max(score) + 1e-10))):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest score until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    }
]