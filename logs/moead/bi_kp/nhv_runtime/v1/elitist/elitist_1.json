[
    {
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.45817590907238315,
            5.758057504892349
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n",
        "score": [
            -0.8828980235516555,
            2.424465984106064
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    if np.sum(weight_lst * neighbor) > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            best_item = max(available_items, key=lambda x: value1_lst[x] + value2_lst[x])\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            if np.sum(weight_lst * neighbor) > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    worst_item = min(in_solution, key=lambda x: value1_lst[x] + value2_lst[x])\n                    neighbor[worst_item] = 0\n    return neighbor\n\n",
        "score": [
            -0.8828980235516555,
            2.424465984106064
        ]
    }
]