[
    {
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify critical items (high value-to-weight ratio for both objectives)\n    value1_ratio = value1_lst / (weight_lst + 1e-10)\n    value2_ratio = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = value1_ratio + value2_ratio\n\n    # Sort items by combined ratio (descending)\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-ratio items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        # Remove items with lowest combined ratio until feasible\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.45817590907238315,
            5.758057504892349
        ]
    },
    {
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ]
    },
    {
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ]
    },
    {
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ]
    },
    {
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ]
    },
    {
        "algorithm": "{This novel local search strategy combines a multi-objective greedy insertion with a probabilistic removal of low-contributing items, where items are prioritized based on their Pareto-frontier dominance and marginal contributions to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        selected_idx = random.randint(0, min(2, len(archive)-1))  # Select from top 3 solutions\n    else:\n        selected_idx = 0\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify items not in the current solution (potential candidates for insertion)\n    candidate_items = np.where(base_solution == 0)[0]\n\n    # Sort candidate items by Pareto dominance (simplified: prioritize items that improve both objectives)\n    pareto_scores = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n    sorted_candidates = np.argsort(-pareto_scores[candidate_items])\n\n    # Greedily insert high-priority items that fit\n    for item in sorted_candidates:\n        if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Probabilistically remove low-contributing items\n    for item in np.where(new_solution == 1)[0]:\n        if random.random() < 0.2:  # 20% chance to remove\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility by removing items with lowest combined ratio if needed\n    if current_weight > capacity:\n        combined_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        sorted_items = np.argsort(combined_ratio)\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9588833784599934,
            2.3248770236968994
        ]
    },
    {
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ]
    },
    {
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ]
    },
    {
        "algorithm": "{The new algorithm combines a simulated annealing-inspired perturbation with a dominance-based selection strategy, where items are prioritized based on their Pareto-optimal contributions to both objectives, ensuring feasibility while exploring high-quality neighbors through adaptive temperature-based flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate normalized marginal contributions\n    marginal1 = value1_lst / (weight_lst + 1e-10)\n    marginal2 = value2_lst / (weight_lst + 1e-10)\n    combined_marginal = marginal1 + marginal2\n    sorted_items = np.argsort(-combined_marginal)\n\n    # Simulated annealing-inspired perturbation\n    temperature = 0.5\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Flip out based on temperature and marginal contribution\n            flip_prob = temperature * (1 - combined_marginal[item] / np.max(combined_marginal))\n            if random.random() < flip_prob:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Add based on marginal contribution and feasibility\n            if current_weight + weight_lst[item] <= capacity:\n                add_prob = (1 - temperature) * (combined_marginal[item] / np.max(combined_marginal))\n                if random.random() < add_prob:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    # Dominance-based selection to ensure quality\n    for item in sorted_items:\n        if new_solution[item] == 1:\n            # Check if removing this item improves both objectives\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            temp_weight = current_weight - weight_lst[item]\n            temp_value1 = current_value1 - value1_lst[item]\n            temp_value2 = current_value2 - value2_lst[item]\n\n            # If removing improves at least one objective without hurting the other\n            if (temp_value1 >= current_value1 and temp_value2 > current_value2) or \\\n               (temp_value1 > current_value1 and temp_value2 >= current_value2):\n                new_solution = temp_solution\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Ensure feasibility by removing lowest marginal items\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.9871495630826842,
            10.444509327411652
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines a diversity-aware perturbation with a multi-objective greedy insertion, where items are selected based on their Pareto-efficient marginal contributions, ensuring both solution quality and exploration of the objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (1.0 + i) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate Pareto-efficient marginal contributions\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Sort items by both objectives (lexicographic order)\n    sorted_items = np.lexsort((-marginal_value1, -marginal_value2))\n\n    # Perform multi-objective greedy insertion\n    for item in sorted_items:\n        if base_solution[item] == 0 and current_weight + weight_lst[item] <= capacity:\n            # Probabilistically add items that improve both objectives\n            if random.random() < 0.5 and (marginal_value1[item] > 0 or marginal_value2[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Perform targeted removal of low-contribution items\n    for item in sorted_items:\n        if new_solution[item] == 1 and random.random() < 0.2:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    # Ensure feasibility\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8537454061923645,
            0.7239254117012024
        ]
    },
    {
        "algorithm": "{The novel local search strategy combines a probabilistic swap-based perturbation with a greedy selection of critical items, where items are prioritized based on their marginal contribution to both objectives, ensuring feasibility and high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate marginal contributions for both objectives\n    marginal_value1 = value1_lst - (value1_lst * base_solution)\n    marginal_value2 = value2_lst - (value2_lst * base_solution)\n    marginal_ratio = (marginal_value1 + marginal_value2) / (weight_lst + 1e-10)\n\n    # Sort items by marginal contribution (descending)\n    sorted_items = np.argsort(-marginal_ratio)\n\n    # Perform a hybrid local search: probabilistic swap with greedy selection\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            # Probabilistically flip out an item\n            if random.random() < 0.3:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            # Greedily add high-marginal items if feasible\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.7:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Ensure feasibility (minor adjustment if needed)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess_weight <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8863274204254625,
            1.2014946341514587
        ]
    },
    {
        "algorithm": "{The new algorithm uses a dynamic prioritization of items based on their marginal contributions to both objectives, combined with a probabilistic flip mechanism that balances exploration and exploitation, ensuring feasibility through a constrained greedy adjustment phase.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Dynamic prioritization based on marginal contributions\n    value1_contribution = value1_lst / (weight_lst + 1e-10)\n    value2_contribution = value2_lst / (weight_lst + 1e-10)\n    dynamic_score = (value1_contribution + value2_contribution) * (1 + base_solution * 0.5)\n\n    sorted_items = np.argsort(-dynamic_score)\n\n    # Probabilistic flip mechanism\n    for item in sorted_items:\n        if base_solution[item] == 1:\n            if random.random() < 0.4:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n        else:\n            if current_weight + weight_lst[item] <= capacity and random.random() < 0.6:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Constrained greedy adjustment\n    if current_weight > capacity:\n        excess = current_weight - capacity\n        for item in sorted_items:\n            if new_solution[item] == 1 and excess <= 0:\n                break\n            if new_solution[item] == 1:\n                new_solution[item] = 0\n                excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.42049465801505015,
            0.5469358563423157
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive with a high combined objective score, identifies promising items to swap or flip, and applies a hybrid local search strategy that combines greedy addition of high-value items and removal of low-value items to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Calculate the current total weight\n    current_weight = np.sum(weight_lst * selected_solution)\n\n    # Identify items to potentially swap or flip\n    items_to_consider = np.where(selected_solution == 1)[0]\n    if len(items_to_consider) == 0:\n        items_to_consider = np.arange(len(weight_lst))\n\n    # Randomly select an item to flip or swap\n    item_idx = np.random.choice(items_to_consider)\n\n    # Generate neighbor by flipping the selected item\n    neighbor = selected_solution.copy()\n    neighbor[item_idx] = 1 - neighbor[item_idx]\n\n    # Ensure feasibility by checking weight\n    new_weight = np.sum(weight_lst * neighbor)\n    if new_weight > capacity:\n        # If flipping makes it infeasible, try adding the most valuable item not in the solution\n        available_items = np.where(selected_solution == 0)[0]\n        if len(available_items) > 0:\n            # Calculate the value ratio for each available item\n            value_ratios = (value1_lst[available_items] + value2_lst[available_items]) / weight_lst[available_items]\n            best_item = available_items[np.argmax(value_ratios)]\n            neighbor[best_item] = 1\n            # Ensure the new item doesn't exceed capacity\n            new_weight = np.sum(weight_lst * neighbor)\n            if new_weight > capacity:\n                # If still infeasible, remove the least valuable item in the solution\n                in_solution = np.where(neighbor == 1)[0]\n                if len(in_solution) > 0:\n                    value_ratios_in = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n                    worst_item = in_solution[np.argmin(value_ratios_in)]\n                    neighbor[worst_item] = 0\n\n    return neighbor\n\n",
        "score": [
            -0.927374303446451,
            1.4551216065883636
        ]
    }
]