[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining adaptive item swaps and value-aware perturbations to generate a feasible neighbor solution that balances both objectives while avoiding standard 2-opt approaches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps and value-aware perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Find items to swap: one in the knapsack and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with high value-to-weight ratio\n        in_item = in_items[np.argmax(value1_lst[in_items] / weight_lst[in_items])]\n        out_item = out_items[np.argmax(value2_lst[out_items] / weight_lst[out_items])]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Value-aware perturbations (small random changes)\n    for _ in range(3):\n        # Randomly select an item to flip\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if feasible\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if feasible\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.23825136745419404,
            4.889248162508011
        ]
    },
    {
        "algorithm": "{The algorithm prioritizes solutions with high potential for improvement by selecting the most crowded region in the objective space, then applies a hybrid local search combining adaptive item clustering and objective-balanced perturbations to generate a neighbor solution that explores both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution from the most crowded region in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[1:-1]] += (objectives[sorted_idx[2:], i] - objectives[sorted_idx[:-2], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive clustering and objective-balanced perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item clustering (group similar items)\n    item_groups = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Group items with similar value ratios\n            ratio = value1_lst[i] / (value2_lst[i] + 1e-10)\n            found_group = False\n            for group in item_groups:\n                if abs(ratio - group[0]) < 0.2:  # Threshold for grouping\n                    group.append(i)\n                    found_group = True\n                    break\n            if not found_group:\n                item_groups.append([ratio, i])\n\n    # Step 2: Objective-balanced perturbations\n    for _ in range(5):\n        # Select a random group to perturb\n        if not item_groups:\n            break\n        group = item_groups[np.random.randint(len(item_groups))][1:]\n        if not group:\n            continue\n\n        # Decide whether to remove or add items\n        action = np.random.choice(['remove', 'add'])\n\n        if action == 'remove':\n            # Remove all items in the group if feasible\n            group_weight = np.sum(weight_lst[np.array(group)])\n            if current_weight - group_weight >= 0:\n                new_solution[group] = 0\n                current_weight -= group_weight\n        else:\n            # Add complementary items (not in knapsack) with balanced values\n            out_items = np.where(new_solution == 0)[0]\n            if len(out_items) == 0:\n                continue\n\n            # Select items that balance both objectives\n            balanced_scores = (value1_lst[out_items] / np.sum(value1_lst)) + (value2_lst[out_items] / np.sum(value2_lst))\n            candidate = out_items[np.argmax(balanced_scores)]\n\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.7536478643965815,
            6.416107684373856
        ]
    }
]