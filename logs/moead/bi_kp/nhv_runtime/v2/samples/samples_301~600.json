[
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining adaptive item swaps and value-aware perturbations to generate a feasible neighbor solution that balances both objectives while avoiding standard 2-opt approaches.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps and value-aware perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Find items to swap: one in the knapsack and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with high value-to-weight ratio\n        in_item = in_items[np.argmax(value1_lst[in_items] / weight_lst[in_items])]\n        out_item = out_items[np.argmax(value2_lst[out_items] / weight_lst[out_items])]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Value-aware perturbations (small random changes)\n    for _ in range(3):\n        # Randomly select an item to flip\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if feasible\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if feasible\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high diversity in objective values, then applies a novel local search combining objective-aware clustering and adaptive item perturbations to generate a neighbor solution that explores the Pareto front by balancing both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective values\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by combined objective dominance\n        combined_dominance = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(combined_dominance)[-min(2, len(in_items)):]]\n\n        # Cluster out-items by complementary objective dominance\n        out_dominance1 = value1_lst[out_items] / weight_lst[out_items]\n        out_dominance2 = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance1 + out_dominance2)[-min(2, len(out_items)):]]\n\n        # Perform adaptive perturbations\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Value-aware diversification\n    for _ in range(3):\n        # Select items to flip based on objective balance\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if it improves objective balance\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if it improves objective balance\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8252012812308716,
            2.3035900592803955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objective values\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by combined objective dominance\n        combined_dominance = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(combined_dominance)[-min(2, len(in_items)):]]\n\n        # Cluster out-items by complementary objective dominance\n        out_dominance1 = value1_lst[out_items] / weight_lst[out_items]\n        out_dominance2 = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance1 + out_dominance2)[-min(2, len(out_items)):]]\n\n        # Perform adaptive perturbations\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Value-aware diversification\n    for _ in range(3):\n        # Select items to flip based on objective balance\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if it improves objective balance\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if it improves objective balance\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining adaptive item swaps and value-aware perturbations to generate a feasible neighbor solution that balances both objectives while avoiding standard 2-opt approaches.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps and value-aware perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Find items to swap: one in the knapsack and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with high value-to-weight ratio\n        in_item = in_items[np.argmax(value1_lst[in_items] / weight_lst[in_items])]\n        out_item = out_items[np.argmax(value2_lst[out_items] / weight_lst[out_items])]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Value-aware perturbations (small random changes)\n    for _ in range(3):\n        # Randomly select an item to flip\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if feasible\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if feasible\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement in both objectives, then applies a novel local search combining objective-balanced clustering and dynamic item reallocation to generate a neighbor solution that explores the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement in both objectives\n    potential_scores = [np.sum(sol[0]) * (obj[0] + obj[1]) for sol, obj in archive]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-balanced clustering and dynamic reallocation\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective balance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective balance\n        in_balance = np.abs(value1_lst[in_items] - value2_lst[in_items])\n        in_cluster = in_items[np.argsort(in_balance)[:min(3, len(in_items))]]\n\n        # Cluster out-items by objective potential\n        out_potential = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_potential)[-min(3, len(out_items)):]]\n\n        # Perform dynamic reallocation\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Dynamic item reallocation with objective awareness\n    for _ in range(3):\n        # Find items to potentially remove\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Select items with least balanced objectives\n            item_balance = np.abs(value1_lst[candidate_items] - value2_lst[candidate_items])\n            item_to_remove = candidate_items[np.argmax(item_balance)]\n\n            if current_weight - weight_lst[item_to_remove] <= capacity:\n                new_solution[item_to_remove] = 0\n                current_weight -= weight_lst[item_to_remove]\n\n                # Find items to add with complementary objectives\n                potential_adds = np.where((new_solution == 0) &\n                                         (weight_lst <= (capacity - current_weight)))[0]\n                if len(potential_adds) > 0:\n                    # Select items that complement the removed item's objectives\n                    removed_balance = abs(value1_lst[item_to_remove] - value2_lst[item_to_remove])\n                    complement_score = np.abs((value1_lst[potential_adds] - value2_lst[potential_adds]) - removed_balance)\n                    add_candidates = potential_adds[np.argsort(complement_score)[:min(2, len(potential_adds))]]\n                    if len(add_candidates) > 0:\n                        new_item = np.random.choice(add_candidates)\n                        new_solution[new_item] = 1\n                        current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.7931924544824495,
            8.985797822475433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement in both objectives\n    potential_scores = [np.sum(sol[0]) * (obj[0] + obj[1]) for sol, obj in archive]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-balanced clustering and dynamic reallocation\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective balance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective balance\n        in_balance = np.abs(value1_lst[in_items] - value2_lst[in_items])\n        in_cluster = in_items[np.argsort(in_balance)[:min(3, len(in_items))]]\n\n        # Cluster out-items by objective potential\n        out_potential = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_potential)[-min(3, len(out_items)):]]\n\n        # Perform dynamic reallocation\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Dynamic item reallocation with objective awareness\n    for _ in range(3):\n        # Find items to potentially remove\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Select items with least balanced objectives\n            item_balance = np.abs(value1_lst[candidate_items] - value2_lst[candidate_items])\n            item_to_remove = candidate_items[np.argmax(item_balance)]\n\n            if current_weight - weight_lst[item_to_remove] <= capacity:\n                new_solution[item_to_remove] = 0\n                current_weight -= weight_lst[item_to_remove]\n\n                # Find items to add with complementary objectives\n                potential_adds = np.where((new_solution == 0) &\n                                         (weight_lst <= (capacity - current_weight)))[0]\n                if len(potential_adds) > 0:\n                    # Select items that complement the removed item's objectives\n                    removed_balance = abs(value1_lst[item_to_remove] - value2_lst[item_to_remove])\n                    complement_score = np.abs((value1_lst[potential_adds] - value2_lst[potential_adds]) - removed_balance)\n                    add_candidates = potential_adds[np.argsort(complement_score)[:min(2, len(potential_adds))]]\n                    if len(add_candidates) > 0:\n                        new_item = np.random.choice(add_candidates)\n                        new_solution[new_item] = 1\n                        current_weight += weight_lst[new_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with extreme objective values, then applies a novel local search combining objective-biased item swaps and adaptive diversification to generate a neighbor solution that explores the Pareto front's extremes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with extreme objective values\n    selected_idx = np.argmax([max(obj[0], obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Extreme objective bias swaps\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Find items with highest value1\n        high_value1_items = in_items[np.argsort(value1_lst[in_items])[-min(2, len(in_items)):]]\n        # Find items with highest value2\n        high_value2_items = in_items[np.argsort(value2_lst[in_items])[-min(2, len(in_items)):]]\n\n        # Swap items based on extreme objectives\n        for item in high_value1_items:\n            potential_replacements = out_items[(weight_lst[out_items] <= weight_lst[item]) &\n                                             (value2_lst[out_items] > value2_lst[item])]\n            if len(potential_replacements) > 0:\n                replacement = potential_replacements[np.argmax(value2_lst[potential_replacements])]\n                new_weight = current_weight - weight_lst[item] + weight_lst[replacement]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    new_solution[replacement] = 1\n                    current_weight = new_weight\n\n        for item in high_value2_items:\n            potential_replacements = out_items[(weight_lst[out_items] <= weight_lst[item]) &\n                                             (value1_lst[out_items] > value1_lst[item])]\n            if len(potential_replacements) > 0:\n                replacement = potential_replacements[np.argmax(value1_lst[potential_replacements])]\n                new_weight = current_weight - weight_lst[item] + weight_lst[replacement]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    new_solution[replacement] = 1\n                    current_weight = new_weight\n\n    # Step 2: Adaptive diversification\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            # Remove items with low marginal contribution\n            in_items = np.where(new_solution == 1)[0]\n            if len(in_items) > 1:\n                marginal_contribution = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n                item_to_remove = in_items[np.argmin(marginal_contribution)]\n                new_solution[item_to_remove] = 0\n                current_weight -= weight_lst[item_to_remove]\n\n                # Add items with complementary objective profile\n                potential_adds = np.where((new_solution == 0) &\n                                        (weight_lst <= (capacity - current_weight)))[0]\n                if len(potential_adds) > 0:\n                    add_candidates = potential_adds[np.argsort(\n                        (value1_lst[potential_adds] * value2_lst[potential_adds]) /\n                        (weight_lst[potential_adds] ** 2))[-min(2, len(potential_adds)):]]\n                    if len(add_candidates) > 0:\n                        new_item = np.random.choice(add_candidates)\n                        new_solution[new_item] = 1\n                        current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.4032663107124298,
            8.678346961736679
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with extreme objective values\n    selected_idx = np.argmax([max(obj[0], obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Extreme objective bias swaps\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Find items with highest value1\n        high_value1_items = in_items[np.argsort(value1_lst[in_items])[-min(2, len(in_items)):]]\n        # Find items with highest value2\n        high_value2_items = in_items[np.argsort(value2_lst[in_items])[-min(2, len(in_items)):]]\n\n        # Swap items based on extreme objectives\n        for item in high_value1_items:\n            potential_replacements = out_items[(weight_lst[out_items] <= weight_lst[item]) &\n                                             (value2_lst[out_items] > value2_lst[item])]\n            if len(potential_replacements) > 0:\n                replacement = potential_replacements[np.argmax(value2_lst[potential_replacements])]\n                new_weight = current_weight - weight_lst[item] + weight_lst[replacement]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    new_solution[replacement] = 1\n                    current_weight = new_weight\n\n        for item in high_value2_items:\n            potential_replacements = out_items[(weight_lst[out_items] <= weight_lst[item]) &\n                                             (value1_lst[out_items] > value1_lst[item])]\n            if len(potential_replacements) > 0:\n                replacement = potential_replacements[np.argmax(value1_lst[potential_replacements])]\n                new_weight = current_weight - weight_lst[item] + weight_lst[replacement]\n                if new_weight <= capacity:\n                    new_solution[item] = 0\n                    new_solution[replacement] = 1\n                    current_weight = new_weight\n\n    # Step 2: Adaptive diversification\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            # Remove items with low marginal contribution\n            in_items = np.where(new_solution == 1)[0]\n            if len(in_items) > 1:\n                marginal_contribution = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n                item_to_remove = in_items[np.argmin(marginal_contribution)]\n                new_solution[item_to_remove] = 0\n                current_weight -= weight_lst[item_to_remove]\n\n                # Add items with complementary objective profile\n                potential_adds = np.where((new_solution == 0) &\n                                        (weight_lst <= (capacity - current_weight)))[0]\n                if len(potential_adds) > 0:\n                    add_candidates = potential_adds[np.argsort(\n                        (value1_lst[potential_adds] * value2_lst[potential_adds]) /\n                        (weight_lst[potential_adds] ** 2))[-min(2, len(potential_adds)):]]\n                    if len(add_candidates) > 0:\n                        new_item = np.random.choice(add_candidates)\n                        new_solution[new_item] = 1\n                        current_weight += weight_lst[new_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining adaptive item swaps and value-aware perturbations to generate a feasible neighbor solution that balances both objectives while avoiding standard 2-opt approaches.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps and value-aware perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Find items to swap: one in the knapsack and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with high value-to-weight ratio\n        in_item = in_items[np.argmax(value1_lst[in_items] / weight_lst[in_items])]\n        out_item = out_items[np.argmax(value2_lst[out_items] / weight_lst[out_items])]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Value-aware perturbations (small random changes)\n    for _ in range(3):\n        # Randomly select an item to flip\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if feasible\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if feasible\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining dominance-aware swaps and objective-balanced perturbations to generate a feasible neighbor solution that balances both objectives while avoiding standard 2-opt approaches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (dominance-aware)\n    selected_idx = np.argmax([np.sum(np.maximum(value1_lst[sol[0] == 1], value2_lst[sol[0] == 1])) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Dominance-aware swaps (prioritize items that improve both objectives)\n    for _ in range(5):\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items that improve both objectives when swapped\n        in_scores = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        out_scores = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        in_item = in_items[np.argmax(in_scores)]\n        out_item = out_items[np.argmax(out_scores)]\n\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Objective-balanced perturbations (small random changes)\n    for _ in range(3):\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38314649617251906,
            9.377206921577454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (dominance-aware)\n    selected_idx = np.argmax([np.sum(np.maximum(value1_lst[sol[0] == 1], value2_lst[sol[0] == 1])) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Dominance-aware swaps (prioritize items that improve both objectives)\n    for _ in range(5):\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items that improve both objectives when swapped\n        in_scores = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        out_scores = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        in_item = in_items[np.argmax(in_scores)]\n        out_item = out_items[np.argmax(out_scores)]\n\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Objective-balanced perturbations (small random changes)\n    for _ in range(3):\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n"
    }
]