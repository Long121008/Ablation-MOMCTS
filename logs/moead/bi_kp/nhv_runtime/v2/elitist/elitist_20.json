[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining adaptive item swaps and value-aware perturbations to generate a feasible neighbor solution that balances both objectives while avoiding standard 2-opt approaches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps and value-aware perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Find items to swap: one in the knapsack and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with high value-to-weight ratio\n        in_item = in_items[np.argmax(value1_lst[in_items] / weight_lst[in_items])]\n        out_item = out_items[np.argmax(value2_lst[out_items] / weight_lst[out_items])]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Value-aware perturbations (small random changes)\n    for _ in range(3):\n        # Randomly select an item to flip\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if feasible\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if feasible\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.23825136745419404,
            4.889248162508011
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the lowest total value in either objective, then applies a novel local search combining objective-aware clustering and adaptive item replacements to generate a neighbor solution that explores the Pareto front's less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest value in either objective\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    if min_obj1 <= min_obj2:\n        selected_idx = next(i for i, (_, obj) in enumerate(archive) if obj[0] == min_obj1)\n    else:\n        selected_idx = next(i for i, (_, obj) in enumerate(archive) if obj[1] == min_obj2)\n\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Objective-aware clustering and adaptive replacements\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance (lowest first)\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[:min(2, len(in_items))]]\n\n        # Cluster out-items by objective 2 dominance (highest first)\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(2, len(out_items)):]]\n\n        # Perform adaptive replacements\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Exploratory perturbations (small random changes)\n    for _ in range(3):\n        # Randomly select an item to flip\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if feasible\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if feasible\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8055403945603942,
            1.1238300502300262
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel local search combining objective-aware clustering and adaptive item exchanges to generate a neighbor solution that explores diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values\n    selected_idx = np.argmin([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Objective-aware clustering and adaptive exchanges\n    new_solution = base_solution.copy()\n\n    # Step 1: Cluster items by objective dominance\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Cluster in-items by objective 1 dominance\n        in_dominance = value1_lst[in_items] / weight_lst[in_items]\n        in_cluster = in_items[np.argsort(in_dominance)[-min(3, len(in_items)):]]\n\n        # Cluster out-items by objective 2 dominance\n        out_dominance = value2_lst[out_items] / weight_lst[out_items]\n        out_cluster = out_items[np.argsort(out_dominance)[-min(3, len(out_items)):]]\n\n        # Perform adaptive exchanges\n        for in_item in in_cluster:\n            for out_item in out_cluster:\n                new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n                if new_weight <= capacity:\n                    new_solution[in_item] = 0\n                    new_solution[out_item] = 1\n                    current_weight = new_weight\n                    break\n\n    # Step 2: Diversification through random exchanges\n    for _ in range(2):\n        if np.random.rand() < 0.7:  # Higher probability for diversification\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_to_remove = np.random.choice(candidate_items)\n                if current_weight - weight_lst[item_to_remove] <= capacity:\n                    new_solution[item_to_remove] = 0\n                    current_weight -= weight_lst[item_to_remove]\n\n                    # Find a new item to add with complementary objective profile\n                    potential_adds = np.where((new_solution == 0) &\n                                            (weight_lst <= (capacity - current_weight)))[0]\n                    if len(potential_adds) > 0:\n                        add_candidates = potential_adds[np.argsort(\n                            (value1_lst[potential_adds] + value2_lst[potential_adds]) /\n                            weight_lst[potential_adds])[-min(3, len(potential_adds)):]]\n                        if len(add_candidates) > 0:\n                            new_item = np.random.choice(add_candidates)\n                            new_solution[new_item] = 1\n                            current_weight += weight_lst[new_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9557552178553669,
            1.2386573553085327
        ]
    }
]