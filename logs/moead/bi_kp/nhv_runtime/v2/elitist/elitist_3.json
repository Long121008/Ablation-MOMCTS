[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining adaptive item swaps and value-aware perturbations to generate a feasible neighbor solution that balances both objectives while avoiding standard 2-opt approaches.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search: adaptive swaps and value-aware perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Adaptive item swaps (prioritize high-value items)\n    for _ in range(5):  # Limit iterations to prevent excessive computation\n        # Find items to swap: one in the knapsack and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items with high value-to-weight ratio\n        in_item = in_items[np.argmax(value1_lst[in_items] / weight_lst[in_items])]\n        out_item = out_items[np.argmax(value2_lst[out_items] / weight_lst[out_items])]\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Value-aware perturbations (small random changes)\n    for _ in range(3):\n        # Randomly select an item to flip\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            # Try removing if feasible\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding if feasible\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.23825136745419404,
            4.889248162508011
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on both objective values and their trade-off, then applies a novel multi-objective aware perturbation strategy that combines value-based flips with objective-balancing swaps to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Multi-objective aware perturbation\n    for _ in range(10):\n        # Select items to consider based on objective dominance\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Calculate dominance scores\n        in_scores = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        out_scores = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        # Select items with highest potential improvement\n        in_item = in_items[np.argmax(in_scores)]\n        out_item = out_items[np.argmax(out_scores)]\n\n        # Check feasibility and apply swap\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Objective-balancing flips\n    for _ in range(5):\n        # Calculate balance factor\n        total_value1 = np.sum(value1_lst[new_solution == 1])\n        total_value2 = np.sum(value2_lst[new_solution == 1])\n        balance = total_value1 / (total_value2 + 1e-8)\n\n        # Select items to flip based on balance\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n\n        if balance > 1.2:\n            # Reduce value1 dominance\n            item = candidates[np.argmax(value1_lst[candidates] / weight_lst[candidates])]\n        elif balance < 0.8:\n            # Increase value2 dominance\n            item = candidates[np.argmax(value2_lst[candidates] / weight_lst[candidates])]\n        else:\n            # Random selection for balanced solutions\n            item = np.random.choice(candidates)\n\n        # Try removing the selected item\n        if current_weight - weight_lst[item] <= capacity:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7701781560181151,
            6.009145766496658
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on diversity and potential improvement, then applies a novel local search combining objective-aware item grouping and adaptive perturbations to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential improvement\n    selected_idx = np.argmax([np.sum(np.abs(sol[0] - archive[0][0])) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Objective-aware item grouping\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    if len(in_items) > 0 and len(out_items) > 0:\n        # Group items by objective dominance\n        obj1_dominant = in_items[np.argsort(-value1_lst[in_items])]\n        obj2_dominant = in_items[np.argsort(-value2_lst[in_items])]\n\n        # Swap items between groups\n        for _ in range(3):\n            if len(obj1_dominant) > 0 and len(obj2_dominant) > 0:\n                swap_in = obj1_dominant[0]\n                swap_out = obj2_dominant[0]\n\n                new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n                if new_weight <= capacity:\n                    new_solution[swap_in] = 0\n                    new_solution[swap_out] = 1\n                    current_weight = new_weight\n                    obj1_dominant = obj1_dominant[1:]\n                    obj2_dominant = obj2_dominant[1:]\n\n    # Adaptive perturbations based on objective gaps\n    for _ in range(5):\n        item_idx = np.random.choice(len(new_solution))\n        if new_solution[item_idx] == 1:\n            if current_weight - weight_lst[item_idx] <= capacity:\n                # Remove if it's not a strong contributor to both objectives\n                if (value1_lst[item_idx] < 0.7 * np.mean(value1_lst[in_items])) or \\\n                   (value2_lst[item_idx] < 0.7 * np.mean(value2_lst[in_items])):\n                    new_solution[item_idx] = 0\n                    current_weight -= weight_lst[item_idx]\n        else:\n            if current_weight + weight_lst[item_idx] <= capacity:\n                # Add if it shows potential for both objectives\n                if (value1_lst[item_idx] > 0.7 * np.mean(value1_lst)) or \\\n                   (value2_lst[item_idx] > 0.7 * np.mean(value2_lst)):\n                    new_solution[item_idx] = 1\n                    current_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7286788683525873,
            4.009450048208237
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on both objective values and their trade-off, then applies a novel multi-objective aware perturbation strategy that combines value-based flips with objective-balancing swaps to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    new_solution = base_solution.copy()\n\n    # Multi-objective aware perturbation\n    for _ in range(10):\n        # Select items to consider based on objective dominance\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Calculate dominance scores\n        in_scores = (value1_lst[in_items] + value2_lst[in_items]) / weight_lst[in_items]\n        out_scores = (value1_lst[out_items] + value2_lst[out_items]) / weight_lst[out_items]\n\n        # Select items with highest potential improvement\n        in_item = in_items[np.argmax(in_scores)]\n        out_item = out_items[np.argmax(out_scores)]\n\n        # Check feasibility and apply swap\n        new_weight = current_weight - weight_lst[in_item] + weight_lst[out_item]\n        if new_weight <= capacity:\n            new_solution[in_item] = 0\n            new_solution[out_item] = 1\n            current_weight = new_weight\n\n    # Objective-balancing flips\n    for _ in range(5):\n        # Calculate balance factor\n        total_value1 = np.sum(value1_lst[new_solution == 1])\n        total_value2 = np.sum(value2_lst[new_solution == 1])\n        balance = total_value1 / (total_value2 + 1e-8)\n\n        # Select items to flip based on balance\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n\n        if balance > 1.2:\n            # Reduce value1 dominance\n            item = candidates[np.argmax(value1_lst[candidates] / weight_lst[candidates])]\n        elif balance < 0.8:\n            # Increase value2 dominance\n            item = candidates[np.argmax(value2_lst[candidates] / weight_lst[candidates])]\n        else:\n            # Random selection for balanced solutions\n            item = np.random.choice(candidates)\n\n        # Try removing the selected item\n        if current_weight - weight_lst[item] <= capacity:\n            new_solution[item] = 0\n            current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.7701781560181151,
            6.009145766496658
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive by evaluating the potential for local improvement based on the objective values and weights, then applies a novel hybrid local search strategy that combines item swaps, flips, and weighted random perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Determine candidate items for modification\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Number of perturbations\n        # Randomly select a modification type\n        mod_type = random.choice(['swap', 'flip', 'weighted_flip'])\n\n        if mod_type == 'swap' and len(candidate_items) >= 2:\n            # Swap two items\n            i, j = random.sample(list(candidate_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif mod_type == 'flip':\n            # Flip a random item\n            i = random.choice(candidate_items)\n            if new_solution[i] == 1:\n                # Check if removing the item keeps solution feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                # Check if adding the item keeps solution feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n        elif mod_type == 'weighted_flip':\n            # Weighted random flip based on value-to-weight ratio\n            ratios = (value1_lst + value2_lst) / weight_lst\n            probs = ratios / np.sum(ratios)\n            i = np.random.choice(len(weight_lst), p=probs)\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4924781366189838,
            2.398270905017853
        ]
    },
    {
        "algorithm": "{The heuristic function selects a solution from the archive with the highest combined value-to-weight ratio for both objectives, then applies a novel hybrid local search strategy that combines adaptive item swaps, value-biased flips, and capacity-aware perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select the solution with the highest combined value-to-weight ratio for both objectives\n    best_ratio = -1\n    selected_idx = 0\n    for i, (solution, (v1, v2)) in enumerate(archive):\n        total_weight = np.sum(weight_lst[solution == 1])\n        if total_weight == 0:\n            continue\n        ratio = (v1 + v2) / total_weight\n        if ratio > best_ratio:\n            best_ratio = ratio\n            selected_idx = i\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Hybrid local search strategy\n    for _ in range(5):\n        # Adaptive selection of modification type\n        if current_weight < capacity * 0.7:\n            mod_type = random.choice(['swap', 'add'])\n        else:\n            mod_type = random.choice(['swap', 'remove'])\n\n        if mod_type == 'swap':\n            # Swap two items with complementary value profiles\n            included = np.where(new_solution == 1)[0]\n            excluded = np.where(new_solution == 0)[0]\n            if len(included) > 0 and len(excluded) > 0:\n                i = random.choice(included)\n                # Find excluded item with similar value-to-weight ratio\n                target_ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n                diffs = np.abs(ratios - target_ratio)\n                j = excluded[np.argmin(diffs)]\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i] = 0\n                    new_solution[j] = 1\n\n        elif mod_type == 'add':\n            # Add item with highest value-to-weight ratio\n            excluded = np.where(new_solution == 0)[0]\n            if len(excluded) > 0:\n                ratios = (value1_lst[excluded] + value2_lst[excluded]) / weight_lst[excluded]\n                j = excluded[np.argmax(ratios)]\n                if current_weight + weight_lst[j] <= capacity:\n                    new_solution[j] = 1\n\n        elif mod_type == 'remove':\n            # Remove item with lowest value-to-weight ratio\n            included = np.where(new_solution == 1)[0]\n            if len(included) > 0:\n                ratios = (value1_lst[included] + value2_lst[included]) / weight_lst[included]\n                i = included[np.argmin(ratios)]\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5866382720338202,
            2.6069660782814026
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive by evaluating the potential for local improvement based on the objective values and weights, then applies a novel hybrid local search strategy that combines item swaps, flips, and weighted random perturbations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Determine candidate items for modification\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Number of perturbations\n        # Randomly select a modification type\n        mod_type = random.choice(['swap', 'flip', 'weighted_flip'])\n\n        if mod_type == 'swap' and len(candidate_items) >= 2:\n            # Swap two items\n            i, j = random.sample(list(candidate_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif mod_type == 'flip':\n            # Flip a random item\n            i = random.choice(candidate_items)\n            if new_solution[i] == 1:\n                # Check if removing the item keeps solution feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                # Check if adding the item keeps solution feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n        elif mod_type == 'weighted_flip':\n            # Weighted random flip based on value-to-weight ratio\n            ratios = (value1_lst + value2_lst) / weight_lst\n            probs = ratios / np.sum(ratios)\n            i = np.random.choice(len(weight_lst), p=probs)\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n                    current_value1 -= value1_lst[i]\n                    current_value2 -= value2_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    current_value1 += value1_lst[i]\n                    current_value2 += value2_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4924781366189838,
            2.398270905017853
        ]
    }
]