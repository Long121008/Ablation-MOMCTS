[
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective balancing approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 2, but with a novel neighborhood exploration strategy that uses item clustering and adaptive perturbation probabilities based on item similarity and objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [10, 50, 90], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.3, 0.7])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            item_scores = (value1_lst - np.min(value1_lst)) * 0.4 + (value2_lst - np.min(value2_lst)) * 0.6\n            cluster_centers = np.array([np.mean(item_scores[items_in]), np.mean(item_scores[items_out])])\n            weights_in = np.exp(-np.abs(item_scores[items_in] - cluster_centers[0])**2 / 0.1)\n            weights_out = np.exp(-np.abs(item_scores[items_out] - cluster_centers[1])**2 / 0.1)\n\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight = new_weight\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                item_scores = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                weights_add = np.exp(-np.abs(item_scores - np.max(item_scores))**2 / 0.1)\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if current_weight + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                item_scores = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                weights_remove = np.exp(-np.abs(item_scores - np.min(item_scores))**2 / 0.1)\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n                current_weight -= weight_lst[remove_item]\n\n    return new_solution\n\n",
        "score": [
            -17.415914770080253,
            -19.65684568629146
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective balancing approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [10, 50, 90], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.7, 0.3])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.6 + (value2_lst[items_in] - np.min(value2_lst)) * 0.4\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.4 + (value2_lst[items_out] - np.min(value2_lst)) * 0.6\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -20.037217174114247,
            -16.74669290484868
        ]
    }
]