[
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective balancing approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 2.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [10, 50, 90], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.3, 0.7])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.4 + (value2_lst[items_in] - np.min(value2_lst)) * 0.6\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.6 + (value2_lst[items_out] - np.min(value2_lst)) * 0.4\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.505691323686307,
            -19.53825377475745
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective balancing approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [10, 50, 90], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.7, 0.3])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.6 + (value2_lst[items_in] - np.min(value2_lst)) * 0.4\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.4 + (value2_lst[items_out] - np.min(value2_lst)) * 0.6\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -20.020749057024922,
            -17.001406906542197
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective balancing approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 2.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [10, 50, 90], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.3, 0.7])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.4 + (value2_lst[items_in] - np.min(value2_lst)) * 0.6\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.6 + (value2_lst[items_out] - np.min(value2_lst)) * 0.4\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.505691323686307,
            -19.53825377475745
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive weighted sum based on objective percentiles, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [25, 50, 75], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.6, 0.4])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.7 + (value2_lst[items_in] - np.min(value2_lst)) * 0.3\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.5 + (value2_lst[items_out] - np.min(value2_lst)) * 0.5\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.6:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.7 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.3 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.711234396808436,
            -17.439658458061523
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dominance-based selection with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.sum(objectives[:, 0] > objectives[:, 1]) + np.sum(objectives[:, 1] > objectives[:, 0])\n    weights = np.array([0.7, 0.3])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.6 + (value2_lst[items_in] - np.min(value2_lst)) * 0.4\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.4 + (value2_lst[items_out] - np.min(value2_lst)) * 0.6\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.6:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.706342600074578,
            -17.559586405643167
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive weighted sum based on objective percentiles, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Adaptive selection based on objective percentiles and weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [25, 50, 75], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.6, 0.4])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive operations\n    for _ in range(5):\n        # Biased swap operation\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Weighted selection for swap candidates\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.7 + (value2_lst[items_in] - np.min(value2_lst)) * 0.3\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.5 + (value2_lst[items_out] - np.min(value2_lst)) * 0.5\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Probabilistic addition operation\n        if random.random() < 0.6:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.7 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        # Probabilistic removal operation\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.3 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.694225841256536,
            -17.63057676510328
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective balancing approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [10, 50, 90], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.7, 0.3])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.6 + (value2_lst[items_in] - np.min(value2_lst)) * 0.4\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.4 + (value2_lst[items_out] - np.min(value2_lst)) * 0.6\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -20.020749057024922,
            -17.001406906542197
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a diversity-aware selection with adaptive objective weights, then applies a hybrid local search combining biased item swaps with probabilistic operations, emphasizing objective 2, while ensuring feasibility through capacity-aware random walks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores) if np.sum(diversity_scores) > 0 else np.array([0.5, 0.5])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for _ in range(3):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value2_lst[items_in] - np.min(value2_lst)) * 0.8 + (value1_lst[items_in] - np.min(value1_lst)) * 0.2\n            weights_out = (value2_lst[items_out] - np.min(value2_lst)) * 0.7 + (value1_lst[items_out] - np.min(value1_lst)) * 0.3\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight = new_weight\n\n        if random.random() < 0.6:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value2_lst[candidate_items] - np.min(value2_lst)) * 0.9 + (value1_lst[candidate_items] - np.min(value1_lst)) * 0.1\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if current_weight + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6 + (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n                current_weight -= weight_lst[remove_item]\n\n    return new_solution\n\n",
        "score": [
            -19.35785680146091,
            -18.164351309393115
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive using a dynamic weighted sum based on objective ranges, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic normalization and weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    normalized = (objectives - np.min(objectives, axis=0)) / (ranges + 1e-8)\n    weights = np.array([0.4, 0.6])  # Emphasis on objective 2\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive probabilities\n    for _ in range(5):  # More iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Range-based weighted selection\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.5 + (value2_lst[items_in] - np.min(value2_lst)) * 0.5\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.3 + (value2_lst[items_out] - np.min(value2_lst)) * 0.7\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Adaptive probabilistic operations\n        if random.random() < 0.5:  # More aggressive addition\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # More frequent removal\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.79205759190698,
            -19.50542184883585
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive weighted sum based on objective percentiles, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [25, 50, 75], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.6, 0.4])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.7 + (value2_lst[items_in] - np.min(value2_lst)) * 0.3\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.5 + (value2_lst[items_out] - np.min(value2_lst)) * 0.5\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.6:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.7 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.3 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.711234396808436,
            -17.439658458061523
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective balancing approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 2.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [10, 50, 90], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.3, 0.7])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.4 + (value2_lst[items_in] - np.min(value2_lst)) * 0.6\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.6 + (value2_lst[items_out] - np.min(value2_lst)) * 0.4\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.505691323686307,
            -19.53825377475745
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive using a dynamic weighted sum based on objective ranges, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic normalization and weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    normalized = (objectives - np.min(objectives, axis=0)) / (ranges + 1e-8)\n    weights = np.array([0.4, 0.6])  # Emphasis on objective 2\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive probabilities\n    for _ in range(5):  # More iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Range-based weighted selection\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.5 + (value2_lst[items_in] - np.min(value2_lst)) * 0.5\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.3 + (value2_lst[items_out] - np.min(value2_lst)) * 0.7\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Adaptive probabilistic operations\n        if random.random() < 0.5:  # More aggressive addition\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # More frequent removal\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.79205759190698,
            -19.50542184883585
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive weighted sum based on objective percentiles, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [25, 50, 75], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.6, 0.4])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.7 + (value2_lst[items_in] - np.min(value2_lst)) * 0.3\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.5 + (value2_lst[items_out] - np.min(value2_lst)) * 0.5\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.6:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.7 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.3 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.711234396808436,
            -17.439658458061523
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective weighting scheme that adapts based on solution diversity, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 2.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = np.array([0.3, 0.7]) if diversity[1] > diversity[0] else np.array([0.4, 0.6])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.3 + (value2_lst[items_in] - np.min(value2_lst)) * 0.7\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.4 + (value2_lst[items_out] - np.min(value2_lst)) * 0.6\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.7:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.4:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -18.411947663356386,
            -18.884563282571037
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive using a dynamic weighted sum based on objective ranges, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic normalization and weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    normalized = (objectives - np.min(objectives, axis=0)) / (ranges + 1e-8)\n    weights = np.array([0.4, 0.6])  # Emphasis on objective 2\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive probabilities\n    for _ in range(5):  # More iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Range-based weighted selection\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.5 + (value2_lst[items_in] - np.min(value2_lst)) * 0.5\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.3 + (value2_lst[items_out] - np.min(value2_lst)) * 0.7\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Adaptive probabilistic operations\n        if random.random() < 0.5:  # More aggressive addition\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # More frequent removal\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.79205759190698,
            -19.50542184883585
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive weighted sum based on objective percentiles, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 1.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    percentiles = np.percentile(objectives, [25, 50, 75], axis=0)\n    normalized = (objectives - percentiles[0]) / (percentiles[2] - percentiles[0] + 1e-8)\n    weights = np.array([0.6, 0.4])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.7 + (value2_lst[items_in] - np.min(value2_lst)) * 0.3\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.5 + (value2_lst[items_out] - np.min(value2_lst)) * 0.5\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.6:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.7 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.3 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.711234396808436,
            -17.439658458061523
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dominance-based selection mechanism, then applies a hybrid local search combining adaptive item swaps with probabilistic item additions/removals, emphasizing high-value items for both objectives while dynamically adjusting exploration intensity based on solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with highest combined value\n    objectives = np.array([obj for _, obj in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_values)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Adaptive local search with multiple operations\n    for _ in range(5):\n        # Calculate exploration probability based on current solution quality\n        exploration_prob = 0.5 + 0.5 * (np.sum(value1_lst[new_solution == 1]) / np.sum(value1_lst))\n\n        # Biased item swap operation\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Calculate swap value ratios\n            in_values = (value1_lst[items_in] + value2_lst[items_in]) / weight_lst[items_in]\n            out_values = (value1_lst[items_out] + value2_lst[items_out]) / weight_lst[items_out]\n\n            # Select items with probability proportional to value/weight ratio\n            swap_in = random.choices(items_in, weights=in_values, k=1)[0]\n            swap_out = random.choices(items_out, weights=out_values, k=1)[0]\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight = new_weight\n\n        # Probabilistic item addition\n        if random.random() < exploration_prob:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                # Prefer items with high combined value\n                item_scores = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n                add_item = random.choices(candidate_items, weights=item_scores, k=1)[0]\n                if current_weight + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n\n        # Probabilistic item removal\n        if random.random() < 0.3 and len(items_in) > 1:\n            # Prefer items with low combined value\n            item_scores = 1 / ((value1_lst[items_in] + value2_lst[items_in]) / weight_lst[items_in] + 1e-8)\n            remove_item = random.choices(items_in, weights=item_scores, k=1)[0]\n            new_solution[remove_item] = 0\n            current_weight -= weight_lst[remove_item]\n\n    return new_solution\n\n",
        "score": [
            -19.22712577925948,
            -18.563011903615198
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive using a dynamic weighted sum based on objective ranges, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic normalization and weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    normalized = (objectives - np.min(objectives, axis=0)) / (ranges + 1e-8)\n    weights = np.array([0.4, 0.6])  # Emphasis on objective 2\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive probabilities\n    for _ in range(5):  # More iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Range-based weighted selection\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.5 + (value2_lst[items_in] - np.min(value2_lst)) * 0.5\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.3 + (value2_lst[items_out] - np.min(value2_lst)) * 0.7\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Adaptive probabilistic operations\n        if random.random() < 0.5:  # More aggressive addition\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # More frequent removal\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.79205759190698,
            -19.50542184883585
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a dynamic adaptive weighting of objectives, then applies a hybrid local search combining item swaps with a value-to-weight ratio biased probabilistic replacement strategy to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic adaptive weighting\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / max_values\n    diversity = np.std(normalized, axis=0)\n    weights = diversity / np.sum(diversity)  # Dynamic weights based on diversity\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with value-to-weight ratio bias\n    for _ in range(5):  # Increased iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Value-to-weight ratio biased selection\n            ratio_in = (value1_lst[items_in] + value2_lst[items_in]) / weight_lst[items_in]\n            ratio_out = (value1_lst[items_out] + value2_lst[items_out]) / weight_lst[items_out]\n            swap_in = random.choices(items_in, weights=ratio_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=ratio_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Probabilistic operations with ratio bias\n        if random.random() < 0.5:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                ratio_add = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n                add_item = random.choices(candidate_items, weights=ratio_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.3:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                ratio_remove = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n                remove_item = random.choices(candidate_items, weights=1/ratio_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.272720712653054,
            -18.507379693660422
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic objective scaling approach with adaptive weights, then applies a hybrid local search combining biased item swaps with probabilistic operations to explore high-potential neighbors while maintaining feasibility and emphasizing objective 2.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / (max_values + 1e-8)\n    weights = np.array([0.3, 0.7])\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    for _ in range(5):\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.3 + (value2_lst[items_in] - np.min(value2_lst)) * 0.7\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.4 + (value2_lst[items_out] - np.min(value2_lst)) * 0.6\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        if random.random() < 0.5:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.4:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.96464725990515,
            -19.191733611731443
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive using a dynamic weighted sum based on objective ranges, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic normalization and weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    normalized = (objectives - np.min(objectives, axis=0)) / (ranges + 1e-8)\n    weights = np.array([0.4, 0.6])  # Emphasis on objective 2\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive probabilities\n    for _ in range(5):  # More iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Range-based weighted selection\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.5 + (value2_lst[items_in] - np.min(value2_lst)) * 0.5\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.3 + (value2_lst[items_out] - np.min(value2_lst)) * 0.7\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Adaptive probabilistic operations\n        if random.random() < 0.5:  # More aggressive addition\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # More frequent removal\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.79205759190698,
            -19.50542184883585
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining item swaps with a biased probabilistic replacement strategy to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and compute weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / max_values\n    weights = np.array([0.6, 0.4])  # Higher weight for objective 1\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with biased probabilities\n    for _ in range(4):  # Increased iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Weighted random selection for swap\n            weights_in = value1_lst[items_in] + value2_lst[items_in]\n            weights_out = value1_lst[items_out] + value2_lst[items_out]\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Biased probabilistic operations\n        if random.random() < 0.4:  # Higher probability to add\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = value1_lst[candidate_items] * 0.7 + value2_lst[candidate_items] * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.15:  # Lower probability to remove\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = value1_lst[candidate_items] * 0.3 + value2_lst[candidate_items] * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.454846407496873,
            -18.03891502255262
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining item swaps with a biased probabilistic replacement strategy to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and compute weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / max_values\n    weights = np.array([0.6, 0.4])  # Higher weight for objective 1\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with biased probabilities\n    for _ in range(4):  # Increased iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Weighted random selection for swap\n            weights_in = value1_lst[items_in] + value2_lst[items_in]\n            weights_out = value1_lst[items_out] + value2_lst[items_out]\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Biased probabilistic operations\n        if random.random() < 0.4:  # Higher probability to add\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = value1_lst[candidate_items] * 0.7 + value2_lst[candidate_items] * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.15:  # Lower probability to remove\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = value1_lst[candidate_items] * 0.3 + value2_lst[candidate_items] * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.454846407496873,
            -18.03891502255262
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive using a dynamic weighted sum based on objective ranges, then applies a hybrid local search combining biased item swaps with adaptive probabilistic operations to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Dynamic normalization and weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    normalized = (objectives - np.min(objectives, axis=0)) / (ranges + 1e-8)\n    weights = np.array([0.4, 0.6])  # Emphasis on objective 2\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive probabilities\n    for _ in range(5):  # More iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Range-based weighted selection\n            weights_in = (value1_lst[items_in] - np.min(value1_lst)) * 0.5 + (value2_lst[items_in] - np.min(value2_lst)) * 0.5\n            weights_out = (value1_lst[items_out] - np.min(value1_lst)) * 0.3 + (value2_lst[items_out] - np.min(value2_lst)) * 0.7\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Adaptive probabilistic operations\n        if random.random() < 0.5:  # More aggressive addition\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.4 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.6\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # More frequent removal\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = (value1_lst[candidate_items] - np.min(value1_lst)) * 0.6 + (value2_lst[candidate_items] - np.min(value2_lst)) * 0.4\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -17.79205759190698,
            -19.50542184883585
        ]
    },
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest sum of normalized objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of normalized objectives)\n    archive_objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(archive_objectives, axis=0)\n    normalized_objectives = archive_objectives / max_values\n    sum_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(sum_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(5):\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.5:\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.05824155496723,
            -18.736529017704896
        ]
    },
    {
        "algorithm": "{This new heuristic selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining item swaps with a biased probabilistic replacement strategy to explore high-potential neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives and compute weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    max_values = np.max(objectives, axis=0)\n    normalized = objectives / max_values\n    weights = np.array([0.6, 0.4])  # Higher weight for objective 1\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with biased probabilities\n    for _ in range(4):  # Increased iterations\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Weighted random selection for swap\n            weights_in = value1_lst[items_in] + value2_lst[items_in]\n            weights_out = value1_lst[items_out] + value2_lst[items_out]\n            swap_in = random.choices(items_in, weights=weights_in, k=1)[0]\n            swap_out = random.choices(items_out, weights=weights_out, k=1)[0]\n\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Biased probabilistic operations\n        if random.random() < 0.4:  # Higher probability to add\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                weights_add = value1_lst[candidate_items] * 0.7 + value2_lst[candidate_items] * 0.3\n                add_item = random.choices(candidate_items, weights=weights_add, k=1)[0]\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.15:  # Lower probability to remove\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                weights_remove = value1_lst[candidate_items] * 0.3 + value2_lst[candidate_items] * 0.7\n                remove_item = random.choices(candidate_items, weights=weights_remove, k=1)[0]\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.454846407496873,
            -18.03891502255262
        ]
    },
    {
        "algorithm": "{This heuristic selects a promising solution from the archive by prioritizing those with the highest combined objective values, then applies a novel hybrid local search that combines item swaps with a probabilistic replacement strategy to explore diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic item swaps and replacements\n    for _ in range(3):  # Number of iterations\n        # Step 1: Randomly select items to swap or replace\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Swap one item in with one item out\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Check feasibility after swap\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n\n            if new_weight <= capacity:\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n\n        # Step 2: Probabilistic replacement (add or remove with probability)\n        if random.random() < 0.3:  # 30% chance to add an item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                add_item = random.choice(candidate_items)\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[add_item] <= capacity:\n                    new_solution[add_item] = 1\n\n        if random.random() < 0.2:  # 20% chance to remove an item\n            candidate_items = np.where(new_solution == 1)[0]\n            if len(candidate_items) > 0:\n                remove_item = random.choice(candidate_items)\n                new_solution[remove_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -19.097484262240137,
            -18.630009621331194
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel local search strategy that combines item swaps with a dynamic threshold-based selection to explore neighbors while ensuring feasibility and balancing exploration of both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (highest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmax(archive_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    # Dynamic threshold-based local search\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Calculate dynamic thresholds for each objective\n    threshold1 = current_value1 * 0.9  # 10% improvement threshold for objective 1\n    threshold2 = current_value2 * 0.9  # 10% improvement threshold for objective 2\n\n    # Iteratively explore neighbors\n    for _ in range(5):  # Number of iterations\n        # Randomly select items to consider\n        items_in = np.where(new_solution == 1)[0]\n        items_out = np.where(new_solution == 0)[0]\n\n        if len(items_in) > 0 and len(items_out) > 0:\n            # Try swapping items\n            swap_in = random.choice(items_in)\n            swap_out = random.choice(items_out)\n\n            # Calculate new values and weight\n            new_weight = current_weight - weight_lst[swap_in] + weight_lst[swap_out]\n            new_value1 = current_value1 - value1_lst[swap_in] + value1_lst[swap_out]\n            new_value2 = current_value2 - value2_lst[swap_in] + value2_lst[swap_out]\n\n            # Check feasibility and improvement\n            if new_weight <= capacity and (new_value1 > threshold1 or new_value2 > threshold2):\n                new_solution[swap_in] = 0\n                new_solution[swap_out] = 1\n                current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n                threshold1 = current_value1 * 0.9\n                threshold2 = current_value2 * 0.9\n\n        # Probabilistic addition of items\n        if random.random() < 0.4 and len(items_out) > 0:\n            add_item = random.choice(items_out)\n            if current_weight + weight_lst[add_item] <= capacity:\n                new_value1 = current_value1 + value1_lst[add_item]\n                new_value2 = current_value2 + value2_lst[add_item]\n                if new_value1 > threshold1 or new_value2 > threshold2:\n                    new_solution[add_item] = 1\n                    current_weight += weight_lst[add_item]\n                    current_value1, current_value2 = new_value1, new_value2\n                    threshold1 = current_value1 * 0.9\n                    threshold2 = current_value2 * 0.9\n\n        # Probabilistic removal of items\n        if random.random() < 0.3 and len(items_in) > 0:\n            remove_item = random.choice(items_in)\n            new_value1 = current_value1 - value1_lst[remove_item]\n            new_value2 = current_value2 - value2_lst[remove_item]\n            if new_value1 > threshold1 or new_value2 > threshold2:\n                new_solution[remove_item] = 0\n                current_weight -= weight_lst[remove_item]\n                current_value1, current_value2 = new_value1, new_value2\n                threshold1 = current_value1 * 0.9\n                threshold2 = current_value2 * 0.9\n\n    return new_solution\n\n",
        "score": [
            -19.11770475647412,
            -18.582942881749123
        ]
    }
]